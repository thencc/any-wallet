var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a2, _b, _c, _d, _e, _f, _g, _h, _i2;
function _mergeNamespaces(n, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e = m2[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k2 in e) {
        if (k2 !== "default" && !(k2 in n)) {
          const d2 = Object.getOwnPropertyDescriptor(e, k2);
          if (d2) {
            Object.defineProperty(n, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el2) => {
  const i = arr.indexOf(el2);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction$2 = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$2(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str) => str ? `on${capitalize(str)}` : ``
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b2) {
  if (a.length !== b2.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b2[i]);
  }
  return equal;
}
function looseEqual(a, b2) {
  if (a === b2)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b2);
  if (aValidType || bValidType) {
    return a === b2;
  }
  aValidType = isArray(a);
  bValidType = isArray(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b2) : false;
  }
  aValidType = isObject$2(a);
  bValidType = isObject$2(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l2;
      for (i = 0, l2 = this.effects.length; i < l2; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l2 = this.scopes.length; i < l2; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l2 = this.length; i < l2; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get22(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set22(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$1(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys: ownKeys$1
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has22 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has22.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has22.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has22, get: get22 } = getProto(target);
  let hadKey = has22.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has22.call(target, key);
  }
  const oldValue = get22.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has22, get: get22 } = getProto(target);
  let hadKey = has22.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has22.call(target, key);
  }
  get22 ? get22.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$2(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b2) => getId(a) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b2) => {
  const diff = getId(a) - getId(b2);
  if (diff === 0) {
    if (a.pre && !b2.pre)
      return -1;
    if (b2.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a3;
  const instance = getCurrentScope() === ((_a3 = currentInstance) == null ? void 0 : _a3.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$2(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v, i) => hasChanged(v, oldValue[i])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    );
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen2);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function defineComponent(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l2 = source.length; i < l2; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l2 = keys.length; i < l2; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get4 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set5 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed$1({
        get: get4,
        set: set5
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$2(to) ? to.call(this, this) : to,
      isFunction$2(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b2) {
  return getType(a) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (hasOwn(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (hasOwn(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el2 = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el2, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el2 = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el2, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el2,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el2,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el2, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el2, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el2,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el2,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el2,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el2,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el2,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el2, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el2,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el2,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el2,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props } = initialVNode;
        const { bm: bm2, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm2) {
          invokeArrayFns(bm2);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el2,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu: bu2, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu2) {
          invokeArrayFns(bu2);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el2, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove3(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove3 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el2, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um: um2 } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um2) {
      queuePostRenderEffect(um2, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove3,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j2, u2, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i] = j2;
        result.push(i);
        continue;
      }
      u2 = 0;
      v = result.length - 1;
      while (u2 < v) {
        c = u2 + v >> 1;
        if (arr[result[c]] < arrI) {
          u2 = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i] = result[u2 - 1];
        }
        result[u2] = i;
      }
    }
  }
  u2 = result.length;
  v = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString(ref) || isRef(ref) || isFunction$2(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style2)) {
      if (isProxy(style2) && !isArray(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed$1 = (getterOrOptions, debugOptions) => {
  return computed$2(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is2, props) => {
    const el2 = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el2, text) => {
    el2.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el2, id2) {
    el2.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
function patchStyle(el2, prev, next) {
  const style2 = el2.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if ("_vod" in el2) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style2, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  const tag = el2.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el2._value = value;
    const oldValue = tag === "OPTION" ? el2.getAttribute("value") : el2.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e) {
  }
  needRemove && el2.removeAttribute(key);
}
function addEventListener(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2._vei || (el2._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el2, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el2, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(
      el2,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el2;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el2, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el2, "change", () => {
      const selectedVal = Array.prototype.filter.call(el2.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el2._assign(
        el2.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
    });
    el2._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el2, { value }) {
    setSelected(el2, value);
  },
  beforeUpdate(el2, _binding, vnode) {
    el2._assign = getModelAssigner(vnode);
  },
  updated(el2, { value }) {
    setSelected(el2, value);
  }
};
function setSelected(el2, value) {
  const isMultiple = el2.multiple;
  if (isMultiple && !isArray(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l2 = el2.options.length; i < l2; i++) {
    const option = el2.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el2.selectedIndex !== i)
          el2.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el2.selectedIndex !== -1) {
    el2.selectedIndex = -1;
  }
}
function getValue(el2) {
  return "_value" in el2 ? el2._value : el2.value;
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link2 = links[i];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a;
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d2;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array2) {
    const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array2[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array2);
    } else if (length === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2)
      return 0;
    let x2 = a.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x2 = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n, m2) {
    const i = b2[n];
    b2[n] = b2[m2];
    b2[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 6] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 5] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 4] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi2, lo2;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo2 = c % 256;
      byteArray.push(lo2);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const index = /* @__PURE__ */ getDefaultExportFromCjs(buffer);
const index$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [buffer]);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module) {
  (function(nacl2) {
    var gf2 = function(init) {
      var i, r = new Float64Array(16);
      if (init)
        for (i = 0; i < init.length; i++)
          r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _02 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf2(), gf1 = gf2([1]), _121665 = gf2([56129, 1]), D2 = gf2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x2, i, h2, l2) {
      x2[i] = h2 >> 24 & 255;
      x2[i + 1] = h2 >> 16 & 255;
      x2[i + 2] = h2 >> 8 & 255;
      x2[i + 3] = h2 & 255;
      x2[i + 4] = l2 >> 24 & 255;
      x2[i + 5] = l2 >> 16 & 255;
      x2[i + 6] = l2 >> 8 & 255;
      x2[i + 7] = l2 & 255;
    }
    function vn2(x2, xi2, y2, yi2, n) {
      var i, d2 = 0;
      for (i = 0; i < n; i++)
        d2 |= x2[xi2 + i] ^ y2[yi2 + i];
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x2, xi2, y2, yi2) {
      return vn2(x2, xi2, y2, yi2, 16);
    }
    function crypto_verify_32(x2, xi2, y2, yi2) {
      return vn2(x2, xi2, y2, yi2, 32);
    }
    function core_salsa20(o, p2, k2, c) {
      var j02 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x02 = j02, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i = 0; i < 20; i += 2) {
        u2 = x02 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x02 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x02 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x02 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x02 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x02 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      x02 = x02 + j02 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x02 >>> 0 & 255;
      o[1] = x02 >>> 8 & 255;
      o[2] = x02 >>> 16 & 255;
      o[3] = x02 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p2, k2, c) {
      var j02 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x02 = j02, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i = 0; i < 20; i += 2) {
        u2 = x02 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x02 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x02 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x02 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x02 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x02 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      o[0] = x02 >>> 0 & 255;
      o[1] = x02 >>> 8 & 255;
      o[2] = x02 >>> 16 & 255;
      o[3] = x02 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c) {
      core_salsa20(out, inp, k2, c);
    }
    function crypto_core_hsalsa20(out, inp, k2, c) {
      core_hsalsa20(out, inp, k2, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m2, mpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u2, i;
      for (i = 0; i < 16; i++)
        z2[i] = 0;
      for (i = 0; i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = m2[mpos + i] ^ x2[i];
        u2 = 1;
        for (i = 8; i < 16; i++) {
          u2 = u2 + (z2[i] & 255) | 0;
          z2[i] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < b2; i++)
          c[cpos + i] = m2[mpos + i] ^ x2[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u2, i;
      for (i = 0; i < 16; i++)
        z2[i] = 0;
      for (i = 0; i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = x2[i];
        u2 = 1;
        for (i = 8; i < 16; i++) {
          u2 = u2 + (z2[i] & 255) | 0;
          z2[i] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < b2; i++)
          c[cpos + i] = x2[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d2, n, k2) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k2, sigma);
      var sn2 = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn2[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d2, sn2, s);
    }
    function crypto_stream_xor(c, cpos, m2, mpos, d2, n, k2) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k2, sigma);
      var sn2 = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn2[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m2, mpos, d2, sn2, s);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m2, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d02, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h02 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r02 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
        h02 += t0 & 8191;
        t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d02 = c;
        d02 += h02 * r02;
        d02 += h1 * (5 * r9);
        d02 += h2 * (5 * r8);
        d02 += h3 * (5 * r7);
        d02 += h4 * (5 * r6);
        c = d02 >>> 13;
        d02 &= 8191;
        d02 += h5 * (5 * r5);
        d02 += h6 * (5 * r4);
        d02 += h7 * (5 * r3);
        d02 += h8 * (5 * r2);
        d02 += h9 * (5 * r1);
        c += d02 >>> 13;
        d02 &= 8191;
        d1 = c;
        d1 += h02 * r1;
        d1 += h1 * r02;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h02 * r2;
        d2 += h1 * r1;
        d2 += h2 * r02;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h02 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r02;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h02 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r02;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h02 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r02;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h02 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r02;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h02 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r02;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h02 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r02;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h02 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r02;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d02 | 0;
        d02 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h02 = d02;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h02;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f2, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f2 = this.h[0] + this.pad[0];
      this.h[0] = f2 & 65535;
      for (i = 1; i < 8; i++) {
        f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
        this.h[i] = f2 & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m2, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m2, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m2, mpos, n, k2) {
      var s = new poly1305(k2);
      s.update(m2, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n, k2) {
      var x2 = new Uint8Array(16);
      crypto_onetimeauth(x2, 0, m2, mpos, n, k2);
      return crypto_verify_16(h2, hpos, x2, 0);
    }
    function crypto_secretbox(c, m2, d2, n, k2) {
      var i;
      if (d2 < 32)
        return -1;
      crypto_stream_xor(c, 0, m2, 0, d2, n, k2);
      crypto_onetimeauth(c, 16, c, 32, d2 - 32, c);
      for (i = 0; i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m2, c, d2, n, k2) {
      var i;
      var x2 = new Uint8Array(32);
      if (d2 < 32)
        return -1;
      crypto_stream(x2, 0, 32, n, k2);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d2 - 32, x2) !== 0)
        return -1;
      crypto_stream_xor(m2, 0, c, 0, d2, n, k2);
      for (i = 0; i < 32; i++)
        m2[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p2, q, b2) {
      var t, c = ~(b2 - 1);
      for (var i = 0; i < 16; i++) {
        t = c & (p2[i] ^ q[i]);
        p2[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j2, b2;
      var m2 = gf2(), t = gf2();
      for (i = 0; i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j2 = 0; j2 < 2; j2++) {
        m2[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m2[i] = t[i] - 65535 - (m2[i - 1] >> 16 & 1);
          m2[i - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b2);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b2) {
      var c = new Uint8Array(32), d2 = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d2, b2);
      return crypto_verify_32(c, 0, d2, 0);
    }
    function par25519(a) {
      var d2 = new Uint8Array(32);
      pack25519(d2, a);
      return d2[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b2) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] + b2[i];
    }
    function Z(o, a, b2) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] - b2[i];
    }
    function M(o, a, b2) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b02 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v = a[0];
      t0 += v * b02;
      t1 += v * b1;
      t2 += v * b22;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b02;
      t2 += v * b1;
      t3 += v * b22;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b02;
      t3 += v * b1;
      t4 += v * b22;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b02;
      t4 += v * b1;
      t5 += v * b22;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b02;
      t5 += v * b1;
      t6 += v * b22;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b02;
      t6 += v * b1;
      t7 += v * b22;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b02;
      t7 += v * b1;
      t8 += v * b22;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b02;
      t8 += v * b1;
      t9 += v * b22;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b02;
      t9 += v * b1;
      t10 += v * b22;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b02;
      t10 += v * b1;
      t11 += v * b22;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b02;
      t11 += v * b1;
      t12 += v * b22;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b02;
      t12 += v * b1;
      t13 += v * b22;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b02;
      t13 += v * b1;
      t14 += v * b22;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b02;
      t14 += v * b1;
      t15 += v * b22;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b02;
      t15 += v * b1;
      t16 += v * b22;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b02;
      t16 += v * b1;
      t17 += v * b22;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S2(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf2();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S2(c, c);
        if (a !== 2 && a !== 4)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf2();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S2(c, c);
        if (a !== 1)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function crypto_scalarmult(q, n, p2) {
      var z2 = new Uint8Array(32);
      var x2 = new Float64Array(80), r, i;
      var a = gf2(), b2 = gf2(), c = gf2(), d2 = gf2(), e = gf2(), f2 = gf2();
      for (i = 0; i < 31; i++)
        z2[i] = n[i];
      z2[31] = n[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x2, p2);
      for (i = 0; i < 16; i++) {
        b2[i] = x2[i];
        d2[i] = a[i] = c[i] = 0;
      }
      a[0] = d2[0] = 1;
      for (i = 254; i >= 0; --i) {
        r = z2[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b2, r);
        sel25519(c, d2, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b2, d2);
        Z(b2, b2, d2);
        S2(d2, e);
        S2(f2, a);
        M(a, c, a);
        M(c, b2, e);
        A(e, a, c);
        Z(a, a, c);
        S2(b2, a);
        Z(c, d2, f2);
        M(a, c, _121665);
        A(a, a, d2);
        M(c, c, a);
        M(a, d2, f2);
        M(d2, b2, x2);
        S2(b2, e);
        sel25519(a, b2, r);
        sel25519(c, d2, r);
      }
      for (i = 0; i < 16; i++) {
        x2[i + 16] = a[i];
        x2[i + 32] = c[i];
        x2[i + 48] = b2[i];
        x2[i + 64] = d2[i];
      }
      var x32 = x2.subarray(32);
      var x16 = x2.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q, x16);
      return 0;
    }
    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y2, x2) {
      randombytes(x2, 32);
      return crypto_scalarmult_base(y2, x2);
    }
    function crypto_box_beforenm(k2, y2, x2) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x2, y2);
      return crypto_core_hsalsa20(k2, _02, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m2, d2, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_afternm(c, m2, d2, n, k2);
    }
    function crypto_box_open(m2, c, d2, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_open_afternm(m2, c, d2, n, k2);
    }
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh2, hl2, m2, n) {
      var wh2 = new Int32Array(16), wl2 = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th2, tl2, i, j2, h2, l2, a, b2, c, d2;
      var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j2 = 8 * i + pos;
          wh2[i] = m2[j2 + 0] << 24 | m2[j2 + 1] << 16 | m2[j2 + 2] << 8 | m2[j2 + 3];
          wl2[i] = m2[j2 + 4] << 24 | m2[j2 + 5] << 16 | m2[j2 + 6] << 8 | m2[j2 + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l2 = al7;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = K2[i * 2];
          l2 = K2[i * 2 + 1];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = wh2[i % 16];
          l2 = wl2[i % 16];
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c += b2 >>> 16;
          d2 += c >>> 16;
          th2 = c & 65535 | d2 << 16;
          tl2 = a & 65535 | b2 << 16;
          h2 = th2;
          l2 = tl2;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c += b2 >>> 16;
          d2 += c >>> 16;
          bh7 = c & 65535 | d2 << 16;
          bl7 = a & 65535 | b2 << 16;
          h2 = bh3;
          l2 = bl3;
          a = l2 & 65535;
          b2 = l2 >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = th2;
          l2 = tl2;
          a += l2 & 65535;
          b2 += l2 >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c += b2 >>> 16;
          d2 += c >>> 16;
          bh3 = c & 65535 | d2 << 16;
          bl3 = a & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j2 = 0; j2 < 16; j2++) {
              h2 = wh2[j2];
              l2 = wl2[j2];
              a = l2 & 65535;
              b2 = l2 >>> 16;
              c = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = wh2[(j2 + 9) % 16];
              l2 = wl2[(j2 + 9) % 16];
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j2 + 1) % 16];
              tl2 = wl2[(j2 + 1) % 16];
              h2 = (th2 >>> 1 | tl2 << 32 - 1) ^ (th2 >>> 8 | tl2 << 32 - 8) ^ th2 >>> 7;
              l2 = (tl2 >>> 1 | th2 << 32 - 1) ^ (tl2 >>> 8 | th2 << 32 - 8) ^ (tl2 >>> 7 | th2 << 32 - 7);
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j2 + 14) % 16];
              tl2 = wl2[(j2 + 14) % 16];
              h2 = (th2 >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th2 << 32 - (61 - 32)) ^ th2 >>> 6;
              l2 = (tl2 >>> 19 | th2 << 32 - 19) ^ (th2 >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th2 << 32 - 6);
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a >>> 16;
              c += b2 >>> 16;
              d2 += c >>> 16;
              wh2[j2] = c & 65535 | d2 << 16;
              wl2[j2] = a & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l2 = al0;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[0];
        l2 = hl2[0];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[0] = ah0 = c & 65535 | d2 << 16;
        hl2[0] = al0 = a & 65535 | b2 << 16;
        h2 = ah1;
        l2 = al1;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[1];
        l2 = hl2[1];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[1] = ah1 = c & 65535 | d2 << 16;
        hl2[1] = al1 = a & 65535 | b2 << 16;
        h2 = ah2;
        l2 = al2;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[2];
        l2 = hl2[2];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[2] = ah2 = c & 65535 | d2 << 16;
        hl2[2] = al2 = a & 65535 | b2 << 16;
        h2 = ah3;
        l2 = al3;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[3];
        l2 = hl2[3];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[3] = ah3 = c & 65535 | d2 << 16;
        hl2[3] = al3 = a & 65535 | b2 << 16;
        h2 = ah4;
        l2 = al4;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[4];
        l2 = hl2[4];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[4] = ah4 = c & 65535 | d2 << 16;
        hl2[4] = al4 = a & 65535 | b2 << 16;
        h2 = ah5;
        l2 = al5;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[5];
        l2 = hl2[5];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[5] = ah5 = c & 65535 | d2 << 16;
        hl2[5] = al5 = a & 65535 | b2 << 16;
        h2 = ah6;
        l2 = al6;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[6];
        l2 = hl2[6];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[6] = ah6 = c & 65535 | d2 << 16;
        hl2[6] = al6 = a & 65535 | b2 << 16;
        h2 = ah7;
        l2 = al7;
        a = l2 & 65535;
        b2 = l2 >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[7];
        l2 = hl2[7];
        a += l2 & 65535;
        b2 += l2 >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[7] = ah7 = c & 65535 | d2 << 16;
        hl2[7] = al7 = a & 65535 | b2 << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m2, n) {
      var hh2 = new Int32Array(8), hl2 = new Int32Array(8), x2 = new Uint8Array(256), i, b2 = n;
      hh2[0] = 1779033703;
      hh2[1] = 3144134277;
      hh2[2] = 1013904242;
      hh2[3] = 2773480762;
      hh2[4] = 1359893119;
      hh2[5] = 2600822924;
      hh2[6] = 528734635;
      hh2[7] = 1541459225;
      hl2[0] = 4089235720;
      hl2[1] = 2227873595;
      hl2[2] = 4271175723;
      hl2[3] = 1595750129;
      hl2[4] = 2917565137;
      hl2[5] = 725511199;
      hl2[6] = 4215389547;
      hl2[7] = 327033209;
      crypto_hashblocks_hl(hh2, hl2, m2, n);
      n %= 128;
      for (i = 0; i < n; i++)
        x2[i] = m2[b2 - n + i];
      x2[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x2[n - 9] = 0;
      ts64(x2, n - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh2, hl2, x2, n);
      for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh2[i], hl2[i]);
      return 0;
    }
    function add2(p2, q) {
      var a = gf2(), b2 = gf2(), c = gf2(), d2 = gf2(), e = gf2(), f2 = gf2(), g = gf2(), h2 = gf2(), t = gf2();
      Z(a, p2[1], p2[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b2, p2[0], p2[1]);
      A(t, q[0], q[1]);
      M(b2, b2, t);
      M(c, p2[3], q[3]);
      M(c, c, D22);
      M(d2, p2[2], q[2]);
      A(d2, d2, d2);
      Z(e, b2, a);
      Z(f2, d2, c);
      A(g, d2, c);
      A(h2, b2, a);
      M(p2[0], e, f2);
      M(p2[1], h2, g);
      M(p2[2], g, f2);
      M(p2[3], e, h2);
    }
    function cswap(p2, q, b2) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p2[i], q[i], b2);
      }
    }
    function pack(r, p2) {
      var tx2 = gf2(), ty2 = gf2(), zi2 = gf2();
      inv25519(zi2, p2[2]);
      M(tx2, p2[0], zi2);
      M(ty2, p2[1], zi2);
      pack25519(r, ty2);
      r[31] ^= par25519(tx2) << 7;
    }
    function scalarmult(p2, q, s) {
      var b2, i;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i = 255; i >= 0; --i) {
        b2 = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p2, q, b2);
        add2(q, p2);
        add2(p2, p2);
        cswap(p2, q, b2);
      }
    }
    function scalarbase(p2, s) {
      var q = [gf2(), gf2(), gf2(), gf2()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p2, q, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d2, sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk, p2);
      for (i = 0; i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x2) {
      var carry, i, j2, k2;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j2 = i - 32, k2 = i - 12; j2 < k2; ++j2) {
          x2[j2] += carry - 16 * x2[i] * L2[j2 - (i - 32)];
          carry = Math.floor((x2[j2] + 128) / 256);
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; j2++) {
        x2[j2] += carry - (x2[31] >> 4) * L2[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; j2++)
        x2[j2] -= carry * L2[j2];
      for (i = 0; i < 32; i++) {
        x2[i + 1] += x2[i] >> 8;
        r[i] = x2[i] & 255;
      }
    }
    function reduce(r) {
      var x2 = new Float64Array(64), i;
      for (i = 0; i < 64; i++)
        x2[i] = r[i];
      for (i = 0; i < 64; i++)
        r[i] = 0;
      modL(r, x2);
    }
    function crypto_sign(sm2, m2, n, sk) {
      var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
      var i, j2, x2 = new Float64Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      crypto_hash(d2, sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++)
        sm2[64 + i] = m2[i];
      for (i = 0; i < 32; i++)
        sm2[32 + i] = d2[32 + i];
      crypto_hash(r, sm2.subarray(32), n + 32);
      reduce(r);
      scalarbase(p2, r);
      pack(sm2, p2);
      for (i = 32; i < 64; i++)
        sm2[i] = sk[i];
      crypto_hash(h2, sm2, n + 64);
      reduce(h2);
      for (i = 0; i < 64; i++)
        x2[i] = 0;
      for (i = 0; i < 32; i++)
        x2[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j2 = 0; j2 < 32; j2++) {
          x2[i + j2] += h2[i] * d2[j2];
        }
      }
      modL(sm2.subarray(32), x2);
      return smlen;
    }
    function unpackneg(r, p2) {
      var t = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r[2], gf1);
      unpack25519(r[1], p2);
      S2(num, r[1]);
      M(den, num, D2);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S2(den2, den);
      S2(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S2(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r[0], r[0], I);
      S2(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p2[31] >> 7)
        Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m2, sm2, n, pk) {
      var i;
      var t = new Uint8Array(32), h2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()], q = [gf2(), gf2(), gf2(), gf2()];
      if (n < 64)
        return -1;
      if (unpackneg(q, pk))
        return -1;
      for (i = 0; i < n; i++)
        m2[i] = sm2[i];
      for (i = 0; i < 32; i++)
        m2[i + 32] = pk[i];
      crypto_hash(h2, m2, n);
      reduce(h2);
      scalarmult(p2, q, h2);
      scalarbase(q, sm2.subarray(32));
      add2(p2, q);
      pack(t, p2);
      n -= 64;
      if (crypto_verify_32(sm2, 0, t, 0)) {
        for (i = 0; i < n; i++)
          m2[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++)
        m2[i] = sm2[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl2.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf: gf2,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M,
      A,
      S: S2,
      Z,
      pow2523,
      add: add2,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++)
        arr[i] = 0;
    }
    nacl2.randomBytes = function(n) {
      var b2 = new Uint8Array(n);
      randombytes(b2, n);
      return b2;
    };
    nacl2.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m2.length);
      for (var i = 0; i < msg.length; i++)
        m2[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m2, m2.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl2.secretbox.open = function(box2, nonce, key) {
      checkArrayTypes(box2, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box2.length);
      var m2 = new Uint8Array(c.length);
      for (var i = 0; i < box2.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box2[i];
      if (c.length < 32)
        return null;
      if (crypto_secretbox_open(m2, c, c.length, nonce, key) !== 0)
        return null;
      return m2.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl2.scalarMult = function(n, p2) {
      checkArrayTypes(n, p2);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p2.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p2);
      return q;
    };
    nacl2.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };
    nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl2.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl2.box.before(publicKey, secretKey);
      return nacl2.secretbox(msg, nonce, k2);
    };
    nacl2.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl2.box.after = nacl2.secretbox;
    nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl2.box.before(publicKey, secretKey);
      return nacl2.secretbox.open(msg, nonce, k2);
    };
    nacl2.box.open.after = nacl2.secretbox.open;
    nacl2.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl2.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl2.box.nonceLength = crypto_box_NONCEBYTES;
    nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
    nacl2.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl2.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m2 = new Uint8Array(mlen);
      for (var i = 0; i < m2.length; i++)
        m2[i] = tmp[i];
      return m2;
    };
    nacl2.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl2.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl2.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm2 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++)
        sm2[i] = sig[i];
      for (i = 0; i < msg.length; i++)
        sm2[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m2, sm2, sm2.length, publicKey) >= 0;
    };
    nacl2.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl2.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl2.sign.signatureLength = crypto_sign_BYTES;
    nacl2.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl2.hash.hashLength = crypto_hash_BYTES;
    nacl2.verify = function(x2, y2) {
      checkArrayTypes(x2, y2);
      if (x2.length === 0 || y2.length === 0)
        return false;
      if (x2.length !== y2.length)
        return false;
      return vn2(x2, 0, y2, 0, x2.length) === 0 ? true : false;
    };
    nacl2.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl2.setPRNG(function(x2, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++)
            x2[i] = v[i];
          cleanup(v);
        });
      } else if (typeof commonjsRequire !== "undefined") {
        crypto2 = require$$0;
        if (crypto2 && crypto2.randomBytes) {
          nacl2.setPRNG(function(x2, n) {
            var i, v = crypto2.randomBytes(n);
            for (i = 0; i < n; i++)
              x2[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(module.exports ? module.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
const nacl = /* @__PURE__ */ getDefaultExportFromCjs(naclFastExports);
var sha512$1 = { exports: {} };
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA512_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, bits) {
      return function(message) {
        return new Sha512(bits, true).update(message)[outputType]();
      };
    };
    var createMethod = function(bits) {
      var method = createOutputMethod("hex", bits);
      method.create = function() {
        return new Sha512(bits);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type, bits);
      }
      return method;
    };
    var createHmacOutputMethod = function(outputType, bits) {
      return function(key, message) {
        return new HmacSha512(key, bits, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(bits) {
      var method = createHmacOutputMethod("hex", bits);
      method.create = function(key) {
        return new HmacSha512(key, bits);
      };
      method.update = function(key, message) {
        return method.create(key).update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createHmacOutputMethod(type, bits);
      }
      return method;
    };
    function Sha512(bits, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (bits == 384) {
        this.h0h = 3418070365;
        this.h0l = 3238371032;
        this.h1h = 1654270250;
        this.h1l = 914150663;
        this.h2h = 2438529370;
        this.h2l = 812702999;
        this.h3h = 355462360;
        this.h3l = 4144912697;
        this.h4h = 1731405415;
        this.h4l = 4290775857;
        this.h5h = 2394180231;
        this.h5l = 1750603025;
        this.h6h = 3675008525;
        this.h6l = 1694076839;
        this.h7h = 1203062813;
        this.h7l = 3204075428;
      } else if (bits == 256) {
        this.h0h = 573645204;
        this.h0l = 4230739756;
        this.h1h = 2673172387;
        this.h1l = 3360449730;
        this.h2h = 596883563;
        this.h2l = 1867755857;
        this.h3h = 2520282905;
        this.h3l = 1497426621;
        this.h4h = 2519219938;
        this.h4l = 2827943907;
        this.h5h = 3193839141;
        this.h5l = 1401305490;
        this.h6h = 721525244;
        this.h6l = 746961066;
        this.h7h = 246885852;
        this.h7l = 2177182882;
      } else if (bits == 224) {
        this.h0h = 2352822216;
        this.h0l = 424955298;
        this.h1h = 1944164710;
        this.h1l = 2312950998;
        this.h2h = 502970286;
        this.h2l = 855612546;
        this.h3h = 1738396948;
        this.h3l = 1479516111;
        this.h4h = 258812777;
        this.h4l = 2077511080;
        this.h5h = 2011393907;
        this.h5l = 79989058;
        this.h6h = 1067287976;
        this.h6l = 1780299464;
        this.h7h = 286451373;
        this.h7l = 2446758561;
      } else {
        this.h0h = 1779033703;
        this.h0l = 4089235720;
        this.h1h = 3144134277;
        this.h1l = 2227873595;
        this.h2h = 1013904242;
        this.h2l = 4271175723;
        this.h3h = 2773480762;
        this.h3l = 1595750129;
        this.h4h = 1359893119;
        this.h4l = 2917565137;
        this.h5h = 2600822924;
        this.h5l = 725511199;
        this.h6h = 528734635;
        this.h6l = 4215389547;
        this.h7h = 1541459225;
        this.h7l = 327033209;
      }
      this.bits = bits;
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
    }
    Sha512.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var code2, index2 = 0, i, length = message.length, blocks2 = this.blocks;
      while (index2 < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        if (notString) {
          for (i = this.start; index2 < length && i < 128; ++index2) {
            blocks2[i >> 2] |= message[index2] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start; index2 < length && i < 128; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks2[i >> 2] |= code2 << SHIFT[i++ & 3];
            } else if (code2 < 2048) {
              blocks2[i >> 2] |= (192 | code2 >> 6) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks2[i >> 2] |= (224 | code2 >> 12) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i >> 2] |= (240 | code2 >> 18) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 128) {
          this.block = blocks2[32];
          this.start = i - 128;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha512.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i = this.lastByteIndex;
      blocks2[32] = this.block;
      blocks2[i >> 2] |= EXTRA[i & 3];
      this.block = blocks2[32];
      if (i >= 112) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
      }
      blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[31] = this.bytes << 3;
      this.hash();
    };
    Sha512.prototype.hash = function() {
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j2, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
      for (j2 = 32; j2 < 160; j2 += 2) {
        t1h = blocks2[j2 - 30];
        t1l = blocks2[j2 - 29];
        s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
        s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
        t1h = blocks2[j2 - 4];
        t1l = blocks2[j2 - 3];
        s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
        s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
        t1h = blocks2[j2 - 32];
        t1l = blocks2[j2 - 31];
        t2h = blocks2[j2 - 14];
        t2l = blocks2[j2 - 13];
        c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
        blocks2[j2] = c4 << 16 | c3 & 65535;
        blocks2[j2 + 1] = c2 << 16 | c1 & 65535;
      }
      var ah2 = h0h, al2 = h0l, bh = h1h, bl = h1l, ch2 = h2h, cl2 = h2l, dh2 = h3h, dl = h3l, eh2 = h4h, el2 = h4l, fh2 = h5h, fl2 = h5l, gh2 = h6h, gl2 = h6l, hh2 = h7h, hl2 = h7l;
      bch = bh & ch2;
      bcl = bl & cl2;
      for (j2 = 0; j2 < 160; j2 += 8) {
        s0h = (ah2 >>> 28 | al2 << 4) ^ (al2 >>> 2 | ah2 << 30) ^ (al2 >>> 7 | ah2 << 25);
        s0l = (al2 >>> 28 | ah2 << 4) ^ (ah2 >>> 2 | al2 << 30) ^ (ah2 >>> 7 | al2 << 25);
        s1h = (eh2 >>> 14 | el2 << 18) ^ (eh2 >>> 18 | el2 << 14) ^ (el2 >>> 9 | eh2 << 23);
        s1l = (el2 >>> 14 | eh2 << 18) ^ (el2 >>> 18 | eh2 << 14) ^ (eh2 >>> 9 | el2 << 23);
        abh = ah2 & bh;
        abl = al2 & bl;
        majh = abh ^ ah2 & ch2 ^ bch;
        majl = abl ^ al2 & cl2 ^ bcl;
        chh = eh2 & fh2 ^ ~eh2 & gh2;
        chl = el2 & fl2 ^ ~el2 & gl2;
        t1h = blocks2[j2];
        t1l = blocks2[j2 + 1];
        t2h = K2[j2];
        t2l = K2[j2 + 1];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl2 & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl2 >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh2 & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh2 >>> 16) + (c3 >>> 16);
        t1h = c4 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c4 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (dl & 65535) + (t1l & 65535);
        c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (dh2 & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (dh2 >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        hh2 = c4 << 16 | c3 & 65535;
        hl2 = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        dh2 = c4 << 16 | c3 & 65535;
        dl = c2 << 16 | c1 & 65535;
        s0h = (dh2 >>> 28 | dl << 4) ^ (dl >>> 2 | dh2 << 30) ^ (dl >>> 7 | dh2 << 25);
        s0l = (dl >>> 28 | dh2 << 4) ^ (dh2 >>> 2 | dl << 30) ^ (dh2 >>> 7 | dl << 25);
        s1h = (hh2 >>> 14 | hl2 << 18) ^ (hh2 >>> 18 | hl2 << 14) ^ (hl2 >>> 9 | hh2 << 23);
        s1l = (hl2 >>> 14 | hh2 << 18) ^ (hl2 >>> 18 | hh2 << 14) ^ (hh2 >>> 9 | hl2 << 23);
        dah = dh2 & ah2;
        dal = dl & al2;
        majh = dah ^ dh2 & bh ^ abh;
        majl = dal ^ dl & bl ^ abl;
        chh = hh2 & eh2 ^ ~hh2 & fh2;
        chl = hl2 & el2 ^ ~hl2 & fl2;
        t1h = blocks2[j2 + 2];
        t1l = blocks2[j2 + 3];
        t2h = K2[j2 + 2];
        t2l = K2[j2 + 3];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl2 & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl2 >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh2 & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh2 >>> 16) + (c3 >>> 16);
        t1h = c4 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c4 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (cl2 & 65535) + (t1l & 65535);
        c2 = (cl2 >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (ch2 & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (ch2 >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        gh2 = c4 << 16 | c3 & 65535;
        gl2 = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        ch2 = c4 << 16 | c3 & 65535;
        cl2 = c2 << 16 | c1 & 65535;
        s0h = (ch2 >>> 28 | cl2 << 4) ^ (cl2 >>> 2 | ch2 << 30) ^ (cl2 >>> 7 | ch2 << 25);
        s0l = (cl2 >>> 28 | ch2 << 4) ^ (ch2 >>> 2 | cl2 << 30) ^ (ch2 >>> 7 | cl2 << 25);
        s1h = (gh2 >>> 14 | gl2 << 18) ^ (gh2 >>> 18 | gl2 << 14) ^ (gl2 >>> 9 | gh2 << 23);
        s1l = (gl2 >>> 14 | gh2 << 18) ^ (gl2 >>> 18 | gh2 << 14) ^ (gh2 >>> 9 | gl2 << 23);
        cdh = ch2 & dh2;
        cdl = cl2 & dl;
        majh = cdh ^ ch2 & ah2 ^ dah;
        majl = cdl ^ cl2 & al2 ^ dal;
        chh = gh2 & hh2 ^ ~gh2 & eh2;
        chl = gl2 & hl2 ^ ~gl2 & el2;
        t1h = blocks2[j2 + 4];
        t1l = blocks2[j2 + 5];
        t2h = K2[j2 + 4];
        t2l = K2[j2 + 5];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl2 & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl2 >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh2 & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh2 >>> 16) + (c3 >>> 16);
        t1h = c4 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c4 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (bl & 65535) + (t1l & 65535);
        c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        fh2 = c4 << 16 | c3 & 65535;
        fl2 = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        bh = c4 << 16 | c3 & 65535;
        bl = c2 << 16 | c1 & 65535;
        s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
        s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
        s1h = (fh2 >>> 14 | fl2 << 18) ^ (fh2 >>> 18 | fl2 << 14) ^ (fl2 >>> 9 | fh2 << 23);
        s1l = (fl2 >>> 14 | fh2 << 18) ^ (fl2 >>> 18 | fh2 << 14) ^ (fh2 >>> 9 | fl2 << 23);
        bch = bh & ch2;
        bcl = bl & cl2;
        majh = bch ^ bh & dh2 ^ cdh;
        majl = bcl ^ bl & dl ^ cdl;
        chh = fh2 & gh2 ^ ~fh2 & hh2;
        chl = fl2 & gl2 ^ ~fl2 & hl2;
        t1h = blocks2[j2 + 6];
        t1l = blocks2[j2 + 7];
        t2h = K2[j2 + 6];
        t2l = K2[j2 + 7];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el2 & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el2 >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh2 & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh2 >>> 16) + (c3 >>> 16);
        t1h = c4 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c4 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (al2 & 65535) + (t1l & 65535);
        c2 = (al2 >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (ah2 & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (ah2 >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        eh2 = c4 << 16 | c3 & 65535;
        el2 = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        ah2 = c4 << 16 | c3 & 65535;
        al2 = c2 << 16 | c1 & 65535;
      }
      c1 = (h0l & 65535) + (al2 & 65535);
      c2 = (h0l >>> 16) + (al2 >>> 16) + (c1 >>> 16);
      c3 = (h0h & 65535) + (ah2 & 65535) + (c2 >>> 16);
      c4 = (h0h >>> 16) + (ah2 >>> 16) + (c3 >>> 16);
      this.h0h = c4 << 16 | c3 & 65535;
      this.h0l = c2 << 16 | c1 & 65535;
      c1 = (h1l & 65535) + (bl & 65535);
      c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
      c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
      c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
      this.h1h = c4 << 16 | c3 & 65535;
      this.h1l = c2 << 16 | c1 & 65535;
      c1 = (h2l & 65535) + (cl2 & 65535);
      c2 = (h2l >>> 16) + (cl2 >>> 16) + (c1 >>> 16);
      c3 = (h2h & 65535) + (ch2 & 65535) + (c2 >>> 16);
      c4 = (h2h >>> 16) + (ch2 >>> 16) + (c3 >>> 16);
      this.h2h = c4 << 16 | c3 & 65535;
      this.h2l = c2 << 16 | c1 & 65535;
      c1 = (h3l & 65535) + (dl & 65535);
      c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
      c3 = (h3h & 65535) + (dh2 & 65535) + (c2 >>> 16);
      c4 = (h3h >>> 16) + (dh2 >>> 16) + (c3 >>> 16);
      this.h3h = c4 << 16 | c3 & 65535;
      this.h3l = c2 << 16 | c1 & 65535;
      c1 = (h4l & 65535) + (el2 & 65535);
      c2 = (h4l >>> 16) + (el2 >>> 16) + (c1 >>> 16);
      c3 = (h4h & 65535) + (eh2 & 65535) + (c2 >>> 16);
      c4 = (h4h >>> 16) + (eh2 >>> 16) + (c3 >>> 16);
      this.h4h = c4 << 16 | c3 & 65535;
      this.h4l = c2 << 16 | c1 & 65535;
      c1 = (h5l & 65535) + (fl2 & 65535);
      c2 = (h5l >>> 16) + (fl2 >>> 16) + (c1 >>> 16);
      c3 = (h5h & 65535) + (fh2 & 65535) + (c2 >>> 16);
      c4 = (h5h >>> 16) + (fh2 >>> 16) + (c3 >>> 16);
      this.h5h = c4 << 16 | c3 & 65535;
      this.h5l = c2 << 16 | c1 & 65535;
      c1 = (h6l & 65535) + (gl2 & 65535);
      c2 = (h6l >>> 16) + (gl2 >>> 16) + (c1 >>> 16);
      c3 = (h6h & 65535) + (gh2 & 65535) + (c2 >>> 16);
      c4 = (h6h >>> 16) + (gh2 >>> 16) + (c3 >>> 16);
      this.h6h = c4 << 16 | c3 & 65535;
      this.h6l = c2 << 16 | c1 & 65535;
      c1 = (h7l & 65535) + (hl2 & 65535);
      c2 = (h7l >>> 16) + (hl2 >>> 16) + (c1 >>> 16);
      c3 = (h7h & 65535) + (hh2 & 65535) + (c2 >>> 16);
      c4 = (h7h >>> 16) + (hh2 >>> 16) + (c3 >>> 16);
      this.h7h = c4 << 16 | c3 & 65535;
      this.h7l = c2 << 16 | c1 & 65535;
    };
    Sha512.prototype.hex = function() {
      this.finalize();
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
      var hex = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
      if (bits >= 256) {
        hex += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
      }
      if (bits >= 384) {
        hex += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
      }
      if (bits == 512) {
        hex += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
      }
      return hex;
    };
    Sha512.prototype.toString = Sha512.prototype.hex;
    Sha512.prototype.digest = function() {
      this.finalize();
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
      var arr = [
        h0h >> 24 & 255,
        h0h >> 16 & 255,
        h0h >> 8 & 255,
        h0h & 255,
        h0l >> 24 & 255,
        h0l >> 16 & 255,
        h0l >> 8 & 255,
        h0l & 255,
        h1h >> 24 & 255,
        h1h >> 16 & 255,
        h1h >> 8 & 255,
        h1h & 255,
        h1l >> 24 & 255,
        h1l >> 16 & 255,
        h1l >> 8 & 255,
        h1l & 255,
        h2h >> 24 & 255,
        h2h >> 16 & 255,
        h2h >> 8 & 255,
        h2h & 255,
        h2l >> 24 & 255,
        h2l >> 16 & 255,
        h2l >> 8 & 255,
        h2l & 255,
        h3h >> 24 & 255,
        h3h >> 16 & 255,
        h3h >> 8 & 255,
        h3h & 255
      ];
      if (bits >= 256) {
        arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
      }
      if (bits >= 384) {
        arr.push(
          h4h >> 24 & 255,
          h4h >> 16 & 255,
          h4h >> 8 & 255,
          h4h & 255,
          h4l >> 24 & 255,
          h4l >> 16 & 255,
          h4l >> 8 & 255,
          h4l & 255,
          h5h >> 24 & 255,
          h5h >> 16 & 255,
          h5h >> 8 & 255,
          h5h & 255,
          h5l >> 24 & 255,
          h5l >> 16 & 255,
          h5l >> 8 & 255,
          h5l & 255
        );
      }
      if (bits == 512) {
        arr.push(
          h6h >> 24 & 255,
          h6h >> 16 & 255,
          h6h >> 8 & 255,
          h6h & 255,
          h6l >> 24 & 255,
          h6l >> 16 & 255,
          h6l >> 8 & 255,
          h6l & 255,
          h7h >> 24 & 255,
          h7h >> 16 & 255,
          h7h >> 8 & 255,
          h7h & 255,
          h7l >> 24 & 255,
          h7l >> 16 & 255,
          h7l >> 8 & 255,
          h7l & 255
        );
      }
      return arr;
    };
    Sha512.prototype.array = Sha512.prototype.digest;
    Sha512.prototype.arrayBuffer = function() {
      this.finalize();
      var bits = this.bits;
      var buffer2 = new ArrayBuffer(bits / 8);
      var dataView = new DataView(buffer2);
      dataView.setUint32(0, this.h0h);
      dataView.setUint32(4, this.h0l);
      dataView.setUint32(8, this.h1h);
      dataView.setUint32(12, this.h1l);
      dataView.setUint32(16, this.h2h);
      dataView.setUint32(20, this.h2l);
      dataView.setUint32(24, this.h3h);
      if (bits >= 256) {
        dataView.setUint32(28, this.h3l);
      }
      if (bits >= 384) {
        dataView.setUint32(32, this.h4h);
        dataView.setUint32(36, this.h4l);
        dataView.setUint32(40, this.h5h);
        dataView.setUint32(44, this.h5l);
      }
      if (bits == 512) {
        dataView.setUint32(48, this.h6h);
        dataView.setUint32(52, this.h6l);
        dataView.setUint32(56, this.h7h);
        dataView.setUint32(60, this.h7l);
      }
      return buffer2;
    };
    Sha512.prototype.clone = function() {
      var hash = new Sha512(this.bits, false);
      this.copyTo(hash);
      return hash;
    };
    Sha512.prototype.copyTo = function(hash) {
      var i = 0, attrs = [
        "h0h",
        "h0l",
        "h1h",
        "h1l",
        "h2h",
        "h2l",
        "h3h",
        "h3l",
        "h4h",
        "h4l",
        "h5h",
        "h5l",
        "h6h",
        "h6l",
        "h7h",
        "h7l",
        "start",
        "bytes",
        "hBytes",
        "finalized",
        "hashed",
        "lastByteIndex"
      ];
      for (i = 0; i < attrs.length; ++i) {
        hash[attrs[i]] = this[attrs[i]];
      }
      for (i = 0; i < this.blocks.length; ++i) {
        hash.blocks[i] = this.blocks[i];
      }
    };
    function HmacSha512(key, bits, sharedMemory) {
      var notString, type = typeof key;
      if (type !== "string") {
        if (type === "object") {
          if (key === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
            key = new Uint8Array(key);
          } else if (!Array.isArray(key)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var length = key.length;
      if (!notString) {
        var bytes = [], length = key.length, index2 = 0, code2;
        for (var i = 0; i < length; ++i) {
          code2 = key.charCodeAt(i);
          if (code2 < 128) {
            bytes[index2++] = code2;
          } else if (code2 < 2048) {
            bytes[index2++] = 192 | code2 >> 6;
            bytes[index2++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes[index2++] = 224 | code2 >> 12;
            bytes[index2++] = 128 | code2 >> 6 & 63;
            bytes[index2++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i) & 1023);
            bytes[index2++] = 240 | code2 >> 18;
            bytes[index2++] = 128 | code2 >> 12 & 63;
            bytes[index2++] = 128 | code2 >> 6 & 63;
            bytes[index2++] = 128 | code2 & 63;
          }
        }
        key = bytes;
      }
      if (key.length > 128) {
        key = new Sha512(bits, true).update(key).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (var i = 0; i < 128; ++i) {
        var b2 = key[i] || 0;
        oKeyPad[i] = 92 ^ b2;
        iKeyPad[i] = 54 ^ b2;
      }
      Sha512.call(this, bits, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha512.prototype = new Sha512();
    HmacSha512.prototype.finalize = function() {
      Sha512.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha512.call(this, this.bits, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha512.prototype.finalize.call(this);
      }
    };
    HmacSha512.prototype.clone = function() {
      var hash = new HmacSha512([], this.bits, false);
      this.copyTo(hash);
      hash.inner = this.inner;
      for (var i = 0; i < this.oKeyPad.length; ++i) {
        hash.oKeyPad[i] = this.oKeyPad[i];
      }
      return hash;
    };
    var exports = createMethod(512);
    exports.sha512 = exports;
    exports.sha384 = createMethod(384);
    exports.sha512_256 = createMethod(256);
    exports.sha512_224 = createMethod(224);
    exports.sha512.hmac = createHmacMethod(512);
    exports.sha384.hmac = createHmacMethod(384);
    exports.sha512_256.hmac = createHmacMethod(256);
    exports.sha512_224.hmac = createHmacMethod(224);
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.sha512 = exports.sha512;
      root.sha384 = exports.sha384;
      root.sha512_256 = exports.sha512_256;
      root.sha512_224 = exports.sha512_224;
    }
  })();
})(sha512$1);
var sha512Exports = sha512$1.exports;
const sha512 = /* @__PURE__ */ getDefaultExportFromCjs(sha512Exports);
function genericHash(arr) {
  return sha512.sha512_256.array(arr);
}
function randomBytes(length) {
  return nacl.randomBytes(length);
}
function keyPairFromSeed(seed) {
  return nacl.sign.keyPair.fromSeed(seed);
}
function keyPair() {
  const seed = randomBytes(nacl.box.secretKeyLength);
  return keyPairFromSeed(seed);
}
function isValidSignatureLength(len) {
  return len === nacl.sign.signatureLength;
}
function keyPairFromSecretKey(sk) {
  return nacl.sign.keyPair.fromSecretKey(sk);
}
function sign(msg, secretKey) {
  return nacl.sign.detached(msg, secretKey);
}
function bytesEqual(a, b2) {
  return nacl.verify(a, b2);
}
function verify(message, signature, verifyKey) {
  return nacl.sign.detached.verify(message, signature, verifyKey);
}
const PUBLIC_KEY_LENGTH = nacl.sign.publicKeyLength;
nacl.sign.secretKeyLength;
const HASH_BYTES_LENGTH = 32;
const SEED_BTYES_LENGTH = 32;
var base32$1 = { exports: {} };
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var root = typeof window === "object" ? window : {};
    var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    }
    var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && true && module.exports;
    var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
    var BASE32_DECODE_CHAR = {
      "A": 0,
      "B": 1,
      "C": 2,
      "D": 3,
      "E": 4,
      "F": 5,
      "G": 6,
      "H": 7,
      "I": 8,
      "J": 9,
      "K": 10,
      "L": 11,
      "M": 12,
      "N": 13,
      "O": 14,
      "P": 15,
      "Q": 16,
      "R": 17,
      "S": 18,
      "T": 19,
      "U": 20,
      "V": 21,
      "W": 22,
      "X": 23,
      "Y": 24,
      "Z": 25,
      "2": 26,
      "3": 27,
      "4": 28,
      "5": 29,
      "6": 30,
      "7": 31
    };
    var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
    var throwInvalidUtf8 = function(position, partial) {
      if (partial.length > 10) {
        partial = "..." + partial.substr(-10);
      }
      var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
      err.position = position;
      throw err;
    };
    var toUtf8String = function(bytes) {
      var str = "", length = bytes.length, i = 0, followingChars = 0, b2, c;
      while (i < length) {
        b2 = bytes[i++];
        if (b2 <= 127) {
          str += String.fromCharCode(b2);
          continue;
        } else if (b2 > 191 && b2 <= 223) {
          c = b2 & 31;
          followingChars = 1;
        } else if (b2 <= 239) {
          c = b2 & 15;
          followingChars = 2;
        } else if (b2 <= 247) {
          c = b2 & 7;
          followingChars = 3;
        } else {
          throwInvalidUtf8(i, str);
        }
        for (var j2 = 0; j2 < followingChars; ++j2) {
          b2 = bytes[i++];
          if (b2 < 128 || b2 > 191) {
            throwInvalidUtf8(i, str);
          }
          c <<= 6;
          c += b2 & 63;
        }
        if (c >= 55296 && c <= 57343) {
          throwInvalidUtf8(i, str);
        }
        if (c > 1114111) {
          throwInvalidUtf8(i, str);
        }
        if (c <= 65535) {
          str += String.fromCharCode(c);
        } else {
          c -= 65536;
          str += String.fromCharCode((c >> 10) + 55296);
          str += String.fromCharCode((c & 1023) + 56320);
        }
      }
      return str;
    };
    var decodeAsBytes = function(base32Str) {
      if (base32Str === "") {
        return [];
      } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
        throw new Error("Invalid base32 characters");
      }
      base32Str = base32Str.replace(/=/g, "");
      var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index2 = 0, length = base32Str.length;
      for (var i = 0, count = length >> 3 << 3; i < count; ) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        bytes[index2++] = (v4 << 4 | v5 >>> 1) & 255;
        bytes[index2++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
        bytes[index2++] = (v7 << 5 | v8) & 255;
      }
      var remain = length - count;
      if (remain === 2) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
      } else if (remain === 4) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
      } else if (remain === 5) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        bytes[index2++] = (v4 << 4 | v5 >>> 1) & 255;
      } else if (remain === 7) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        bytes[index2++] = (v4 << 4 | v5 >>> 1) & 255;
        bytes[index2++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
      }
      return bytes;
    };
    var encodeAscii = function(str) {
      var v1, v2, v3, v4, v5, base32Str = "", length = str.length;
      for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v3 = str.charCodeAt(i++);
        v4 = str.charCodeAt(i++);
        v5 = str.charCodeAt(i++);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
      }
      var remain = length - count;
      if (remain === 1) {
        v1 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
      } else if (remain === 2) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
      } else if (remain === 3) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v3 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
      } else if (remain === 4) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v3 = str.charCodeAt(i++);
        v4 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
      }
      return base32Str;
    };
    var encodeUtf8 = function(str) {
      var v1, v2, v3, v4, v5, code2, end = false, base32Str = "", index2 = 0, i, start = 0, length = str.length;
      if (str === "") {
        return base32Str;
      }
      do {
        blocks[0] = blocks[5];
        blocks[1] = blocks[6];
        blocks[2] = blocks[7];
        for (i = start; index2 < length && i < 5; ++index2) {
          code2 = str.charCodeAt(index2);
          if (code2 < 128) {
            blocks[i++] = code2;
          } else if (code2 < 2048) {
            blocks[i++] = 192 | code2 >> 6;
            blocks[i++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            blocks[i++] = 224 | code2 >> 12;
            blocks[i++] = 128 | code2 >> 6 & 63;
            blocks[i++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++index2) & 1023);
            blocks[i++] = 240 | code2 >> 18;
            blocks[i++] = 128 | code2 >> 12 & 63;
            blocks[i++] = 128 | code2 >> 6 & 63;
            blocks[i++] = 128 | code2 & 63;
          }
        }
        start = i - 5;
        if (index2 === length) {
          ++index2;
        }
        if (index2 > length && i < 6) {
          end = true;
        }
        v1 = blocks[0];
        if (i > 4) {
          v2 = blocks[1];
          v3 = blocks[2];
          v4 = blocks[3];
          v5 = blocks[4];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        } else if (i === 1) {
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (i === 2) {
          v2 = blocks[1];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (i === 3) {
          v2 = blocks[1];
          v3 = blocks[2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else {
          v2 = blocks[1];
          v3 = blocks[2];
          v4 = blocks[3];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
      } while (!end);
      return base32Str;
    };
    var encodeBytes = function(bytes) {
      var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length;
      for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v3 = bytes[i++];
        v4 = bytes[i++];
        v5 = bytes[i++];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
      }
      var remain = length - count;
      if (remain === 1) {
        v1 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
      } else if (remain === 2) {
        v1 = bytes[i++];
        v2 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
      } else if (remain === 3) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v3 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
      } else if (remain === 4) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v3 = bytes[i++];
        v4 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
      }
      return base32Str;
    };
    var encode2 = function(input, asciiOnly) {
      var notString = typeof input !== "string";
      if (notString && input.constructor === ArrayBuffer) {
        input = new Uint8Array(input);
      }
      if (notString) {
        return encodeBytes(input);
      } else if (asciiOnly) {
        return encodeAscii(input);
      } else {
        return encodeUtf8(input);
      }
    };
    var decode2 = function(base32Str, asciiOnly) {
      if (!asciiOnly) {
        return toUtf8String(decodeAsBytes(base32Str));
      }
      if (base32Str === "") {
        return "";
      } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
        throw new Error("Invalid base32 characters");
      }
      var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
      if (length === -1) {
        length = base32Str.length;
      }
      for (var i = 0, count = length >> 3 << 3; i < count; ) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
      }
      var remain = length - count;
      if (remain === 2) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
      } else if (remain === 4) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
      } else if (remain === 5) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
      } else if (remain === 7) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
      }
      return str;
    };
    var exports = {
      encode: encode2,
      decode: decode2
    };
    decode2.asBytes = decodeAsBytes;
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.base32 = exports;
    }
  })();
})(base32$1);
var base32Exports = base32$1.exports;
const base32 = /* @__PURE__ */ getDefaultExportFromCjs(base32Exports);
var jsonBigint = { exports: {} };
var stringify = { exports: {} };
var bignumber = { exports: {} };
(function(module) {
  (function(globalObject) {
    var BigNumber2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P2 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber3(v, b2) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x2 = this;
        if (!(x2 instanceof BigNumber3))
          return new BigNumber3(v, b2);
        if (b2 == null) {
          if (v && v._isBigNumber === true) {
            x2.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (v.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = v.e;
              x2.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x2.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x2.c = x2.e = null;
              } else {
                x2.e = e;
                x2.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x2, str, isNum);
            x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b2, 2, ALPHABET.length, "Base");
          if (b2 == 10 && alphabetHasNormalDecimalDigits) {
            x2 = new BigNumber3(v);
            return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x2, str, isNum, b2);
            x2.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b2);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x2, String(v), isNum, b2);
            }
          }
          isNum = false;
          str = convertBase(str, b2, 10, x2.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x2.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (e < MIN_EXP) {
            x2.c = [x2.e = 0];
          } else {
            x2.e = e;
            x2.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x2.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x2.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0")
              ;
            x2.c.push(+str);
          }
        } else {
          x2.c = [x2.e = 0];
        }
      }
      BigNumber3.clone = clone;
      BigNumber3.ROUND_UP = 0;
      BigNumber3.ROUND_DOWN = 1;
      BigNumber3.ROUND_CEIL = 2;
      BigNumber3.ROUND_FLOOR = 3;
      BigNumber3.ROUND_HALF_UP = 4;
      BigNumber3.ROUND_HALF_DOWN = 5;
      BigNumber3.ROUND_HALF_EVEN = 6;
      BigNumber3.ROUND_HALF_CEIL = 7;
      BigNumber3.ROUND_HALF_FLOOR = 8;
      BigNumber3.EUCLID = 9;
      BigNumber3.config = BigNumber3.set = function(obj) {
        var p2, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
              v = obj[p2];
              intCheck(v, 0, MAX, p2);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
              v = obj[p2];
              intCheck(v, 0, 8, p2);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
              v = obj[p2];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p2);
                intCheck(v[1], 0, MAX, p2);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p2);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p2 = "RANGE")) {
              v = obj[p2];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p2);
                intCheck(v[1], 1, MAX, p2);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p2);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p2 + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p2 = "CRYPTO")) {
              v = obj[p2];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p2 + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
              v = obj[p2];
              intCheck(v, 0, 9, p2);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
              v = obj[p2];
              intCheck(v, 0, MAX, p2);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p2 = "FORMAT")) {
              v = obj[p2];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p2 + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p2 = "ALPHABET")) {
              v = obj[p2];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p2 + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber3.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber3.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber3.maximum = BigNumber3.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber3.minimum = BigNumber3.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber3.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp2) {
          var a, b2, e, k2, v, i = 0, c = [], rand = new BigNumber3(ONE);
          if (dp2 == null)
            dp2 = DECIMAL_PLACES;
          else
            intCheck(dp2, 0, MAX);
          k2 = mathceil(dp2 / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k2 *= 2));
              for (; i < k2; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9e15) {
                  b2 = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b2[0];
                  a[i + 1] = b2[1];
                } else {
                  c.push(v % 1e14);
                  i += 2;
                }
              }
              i = k2 / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k2 *= 7);
              for (; i < k2; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 1e14);
                  i += 7;
                }
              }
              i = k2 / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k2; ) {
              v = random53bitInt();
              if (v < 9e15)
                c[i++] = v % 1e14;
            }
          }
          k2 = c[--i];
          dp2 %= LOG_BASE;
          if (k2 && dp2) {
            v = POWS_TEN[LOG_BASE - dp2];
            c[i] = mathfloor(k2 / v) * v;
          }
          for (; c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber3.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber3(args[0]);
        for (; i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j2, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j2 = 0; j2 < arr.length; j2++) {
              if (arr[j2] > baseOut - 1) {
                if (arr[j2 + 1] == null)
                  arr[j2 + 1] = 0;
                arr[j2 + 1] += arr[j2] / baseOut | 0;
                arr[j2] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign2, callerIsToString) {
          var alphabet, d2, e, k2, r, x2, xc2, y2, i = str.indexOf("."), dp2 = DECIMAL_PLACES, rm2 = ROUNDING_MODE;
          if (i >= 0) {
            k2 = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y2 = new BigNumber3(baseIn);
            x2 = y2.pow(str.length - i);
            POW_PRECISION = k2;
            y2.c = toBaseOut(
              toFixedPoint(coeffToString(x2.c), x2.e, "0"),
              10,
              baseOut,
              decimal
            );
            y2.e = y2.c.length;
          }
          xc2 = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k2 = xc2.length;
          for (; xc2[--k2] == 0; xc2.pop())
            ;
          if (!xc2[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x2.c = xc2;
            x2.e = e;
            x2.s = sign2;
            x2 = div(x2, y2, dp2, rm2, baseOut);
            xc2 = x2.c;
            r = x2.r;
            e = x2.e;
          }
          d2 = e + dp2 + 1;
          i = xc2[d2];
          k2 = baseOut / 2;
          r = r || d2 < 0 || xc2[d2 + 1] != null;
          r = rm2 < 4 ? (i != null || r) && (rm2 == 0 || rm2 == (x2.s < 0 ? 3 : 2)) : i > k2 || i == k2 && (rm2 == 4 || r || rm2 == 6 && xc2[d2 - 1] & 1 || rm2 == (x2.s < 0 ? 8 : 7));
          if (d2 < 1 || !xc2[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp2, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc2.length = d2;
            if (r) {
              for (--baseOut; ++xc2[--d2] > baseOut; ) {
                xc2[d2] = 0;
                if (!d2) {
                  ++e;
                  xc2 = [1].concat(xc2);
                }
              }
            }
            for (k2 = xc2.length; !xc2[--k2]; )
              ;
            for (i = 0, str = ""; i <= k2; str += alphabet.charAt(xc2[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x2, k2, base) {
          var m2, temp, xlo, xhi, carry = 0, i = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
          for (x2 = x2.slice(); i--; ) {
            xlo = x2[i] % SQRT_BASE;
            xhi = x2[i] / SQRT_BASE | 0;
            m2 = khi * xlo + xhi * klo;
            temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
            x2[i] = temp % base;
          }
          if (carry)
            x2 = [carry].concat(x2);
          return x2;
        }
        function compare2(a, b2, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b2[i]) {
                cmp = a[i] > b2[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b2, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b2[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b2[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x2, y2, dp2, rm2, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc2, rem, remL, rem0, xi2, xL, yc0, yL, yz, s = x2.s == y2.s ? 1 : -1, xc2 = x2.c, yc2 = y2.c;
          if (!xc2 || !xc2[0] || !yc2 || !yc2[0]) {
            return new BigNumber3(
              // Return NaN if either NaN, or both Infinity or 0.
              !x2.s || !y2.s || (xc2 ? yc2 && xc2[0] == yc2[0] : !yc2) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc2 && xc2[0] == 0 || !yc2 ? s * 0 : s / 0
              )
            );
          }
          q = new BigNumber3(s);
          qc2 = q.c = [];
          e = x2.e - y2.e;
          s = dp2 + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0; yc2[i] == (xc2[i] || 0); i++)
            ;
          if (yc2[i] > (xc2[i] || 0))
            e--;
          if (s < 0) {
            qc2.push(1);
            more = true;
          } else {
            xL = xc2.length;
            yL = yc2.length;
            i = 0;
            s += 2;
            n = mathfloor(base / (yc2[0] + 1));
            if (n > 1) {
              yc2 = multiply(yc2, n, base);
              xc2 = multiply(xc2, n, base);
              yL = yc2.length;
              xL = xc2.length;
            }
            xi2 = yL;
            rem = xc2.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc2.slice();
            yz = [0].concat(yz);
            yc0 = yc2[0];
            if (yc2[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare2(yc2, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc2, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc2, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc2.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc2, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc2, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc2[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc2[xi2] || 0;
              } else {
                rem = [xc2[xi2]];
                remL = 1;
              }
            } while ((xi2++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc2[0])
              qc2.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s = qc2[0]; s >= 10; s /= 10, i++)
              ;
            round(q, dp2 + (q.e = i + e * LOG_BASE - 1) + 1, rm2, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm2, id2) {
        var c02, e, ne, len, str;
        if (rm2 == null)
          rm2 = ROUNDING_MODE;
        else
          intCheck(rm2, 0, 8);
        if (!n.c)
          return n.toString();
        c02 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id2 == 1 || id2 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber3(n), i, rm2);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id2 == 1 || id2 == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += "."; i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (; i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c02 ? "-" + str : str;
      }
      function maxOrMin(args, n) {
        var k2, y2, i = 1, x2 = new BigNumber3(args[0]);
        for (; i < args.length; i++) {
          y2 = new BigNumber3(args[i]);
          if (!y2.s || (k2 = compare(x2, y2)) === n || k2 === 0 && x2.s === n) {
            x2 = y2;
          }
        }
        return x2;
      }
      function normalise(n, c, e) {
        var i = 1, j2 = c.length;
        for (; !c[--j2]; c.pop())
          ;
        for (j2 = c[0]; j2 >= 10; j2 /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x2, str, isNum, b2) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x2.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m2, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b2 || b2 == base ? p1 : m2;
              });
              if (b2) {
                base = b2;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s)
                return new BigNumber3(s, base);
            }
            if (BigNumber3.DEBUG) {
              throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
            }
            x2.s = null;
          }
          x2.c = x2.e = null;
        };
      }();
      function round(x2, sd2, rm2, r) {
        var d2, i, j2, k2, n, ni2, rd2, xc2 = x2.c, pows10 = POWS_TEN;
        if (xc2) {
          out: {
            for (d2 = 1, k2 = xc2[0]; k2 >= 10; k2 /= 10, d2++)
              ;
            i = sd2 - d2;
            if (i < 0) {
              i += LOG_BASE;
              j2 = sd2;
              n = xc2[ni2 = 0];
              rd2 = mathfloor(n / pows10[d2 - j2 - 1] % 10);
            } else {
              ni2 = mathceil((i + 1) / LOG_BASE);
              if (ni2 >= xc2.length) {
                if (r) {
                  for (; xc2.length <= ni2; xc2.push(0))
                    ;
                  n = rd2 = 0;
                  d2 = 1;
                  i %= LOG_BASE;
                  j2 = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k2 = xc2[ni2];
                for (d2 = 1; k2 >= 10; k2 /= 10, d2++)
                  ;
                i %= LOG_BASE;
                j2 = i - LOG_BASE + d2;
                rd2 = j2 < 0 ? 0 : mathfloor(n / pows10[d2 - j2 - 1] % 10);
              }
            }
            r = r || sd2 < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            xc2[ni2 + 1] != null || (j2 < 0 ? n : n % pows10[d2 - j2 - 1]);
            r = rm2 < 4 ? (rd2 || r) && (rm2 == 0 || rm2 == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm2 == 4 || r || rm2 == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j2 > 0 ? n / pows10[d2 - j2] : 0 : xc2[ni2 - 1]) % 10 & 1 || rm2 == (x2.s < 0 ? 8 : 7));
            if (sd2 < 1 || !xc2[0]) {
              xc2.length = 0;
              if (r) {
                sd2 -= x2.e + 1;
                xc2[0] = pows10[(LOG_BASE - sd2 % LOG_BASE) % LOG_BASE];
                x2.e = -sd2 || 0;
              } else {
                xc2[0] = x2.e = 0;
              }
              return x2;
            }
            if (i == 0) {
              xc2.length = ni2;
              k2 = 1;
              ni2--;
            } else {
              xc2.length = ni2 + 1;
              k2 = pows10[LOG_BASE - i];
              xc2[ni2] = j2 > 0 ? mathfloor(n / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
            }
            if (r) {
              for (; ; ) {
                if (ni2 == 0) {
                  for (i = 1, j2 = xc2[0]; j2 >= 10; j2 /= 10, i++)
                    ;
                  j2 = xc2[0] += k2;
                  for (k2 = 1; j2 >= 10; j2 /= 10, k2++)
                    ;
                  if (i != k2) {
                    x2.e++;
                    if (xc2[0] == BASE)
                      xc2[0] = 1;
                  }
                  break;
                } else {
                  xc2[ni2] += k2;
                  if (xc2[ni2] != BASE)
                    break;
                  xc2[ni2--] = 0;
                  k2 = 1;
                }
              }
            }
            for (i = xc2.length; xc2[--i] === 0; xc2.pop())
              ;
          }
          if (x2.e > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (x2.e < MIN_EXP) {
            x2.c = [x2.e = 0];
          }
        }
        return x2;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P2.absoluteValue = P2.abs = function() {
        var x2 = new BigNumber3(this);
        if (x2.s < 0)
          x2.s = 1;
        return x2;
      };
      P2.comparedTo = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2));
      };
      P2.decimalPlaces = P2.dp = function(dp2, rm2) {
        var c, n, v, x2 = this;
        if (dp2 != null) {
          intCheck(dp2, 0, MAX);
          if (rm2 == null)
            rm2 = ROUNDING_MODE;
          else
            intCheck(rm2, 0, 8);
          return round(new BigNumber3(x2), dp2 + x2.e + 1, rm2);
        }
        if (!(c = x2.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (; v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P2.dividedBy = P2.div = function(y2, b2) {
        return div(this, new BigNumber3(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
        return div(this, new BigNumber3(y2, b2), 0, 1);
      };
      P2.exponentiatedBy = P2.pow = function(n, m2) {
        var half, isModExp, i, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
        n = new BigNumber3(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m2 != null)
          m2 = new BigNumber3(m2);
        nIsBig = n.e > 14;
        if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n.c || !n.c[0]) {
          y2 = new BigNumber3(Math.pow(+valueOf(x2), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m2 ? y2.mod(m2) : y2;
        }
        nIsNeg = n.s < 0;
        if (m2) {
          if (m2.c ? !m2.c[0] : !m2.s)
            return new BigNumber3(NaN);
          isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
          if (isModExp)
            x2 = x2.mod(m2);
        } else if (n.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
          k2 = x2.s < 0 && isOdd(n) ? -0 : 0;
          if (x2.e > -1)
            k2 = 1 / k2;
          return new BigNumber3(nIsNeg ? 1 / k2 : k2);
        } else if (POW_PRECISION) {
          k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber3(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y2 = new BigNumber3(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y2 = y2.times(x2);
            if (!y2.c)
              break;
            if (k2) {
              if (y2.c.length > k2)
                y2.c.length = k2;
            } else if (isModExp) {
              y2 = y2.mod(m2);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x2 = x2.times(x2);
          if (k2) {
            if (x2.c && x2.c.length > k2)
              x2.c.length = k2;
          } else if (isModExp) {
            x2 = x2.mod(m2);
          }
        }
        if (isModExp)
          return y2;
        if (nIsNeg)
          y2 = ONE.div(y2);
        return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
      };
      P2.integerValue = function(rm2) {
        var n = new BigNumber3(this);
        if (rm2 == null)
          rm2 = ROUNDING_MODE;
        else
          intCheck(rm2, 0, 8);
        return round(n, n.e + 1, rm2);
      };
      P2.isEqualTo = P2.eq = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) === 0;
      };
      P2.isFinite = function() {
        return !!this.c;
      };
      P2.isGreaterThan = P2.gt = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) > 0;
      };
      P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
        return (b2 = compare(this, new BigNumber3(y2, b2))) === 1 || b2 === 0;
      };
      P2.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P2.isLessThan = P2.lt = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) < 0;
      };
      P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
        return (b2 = compare(this, new BigNumber3(y2, b2))) === -1 || b2 === 0;
      };
      P2.isNaN = function() {
        return !this.s;
      };
      P2.isNegative = function() {
        return this.s < 0;
      };
      P2.isPositive = function() {
        return this.s > 0;
      };
      P2.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P2.minus = function(y2, b2) {
        var i, j2, t, xLTy, x2 = this, a = x2.s;
        y2 = new BigNumber3(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber3(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x2.plus(y2);
        }
        var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
        if (!xe2 || !ye2) {
          if (!xc2 || !yc2)
            return xc2 ? (y2.s = -b2, y2) : new BigNumber3(yc2 ? x2 : NaN);
          if (!xc2[0] || !yc2[0]) {
            return yc2[0] ? (y2.s = -b2, y2) : new BigNumber3(xc2[0] ? x2 : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0
            ));
          }
        }
        xe2 = bitFloor(xe2);
        ye2 = bitFloor(ye2);
        xc2 = xc2.slice();
        if (a = xe2 - ye2) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc2;
          } else {
            ye2 = xe2;
            t = yc2;
          }
          t.reverse();
          for (b2 = a; b2--; t.push(0))
            ;
          t.reverse();
        } else {
          j2 = (xLTy = (a = xc2.length) < (b2 = yc2.length)) ? a : b2;
          for (a = b2 = 0; b2 < j2; b2++) {
            if (xc2[b2] != yc2[b2]) {
              xLTy = xc2[b2] < yc2[b2];
              break;
            }
          }
        }
        if (xLTy) {
          t = xc2;
          xc2 = yc2;
          yc2 = t;
          y2.s = -y2.s;
        }
        b2 = (j2 = yc2.length) - (i = xc2.length);
        if (b2 > 0)
          for (; b2--; xc2[i++] = 0)
            ;
        b2 = BASE - 1;
        for (; j2 > a; ) {
          if (xc2[--j2] < yc2[j2]) {
            for (i = j2; i && !xc2[--i]; xc2[i] = b2)
              ;
            --xc2[i];
            xc2[j2] += BASE;
          }
          xc2[j2] -= yc2[j2];
        }
        for (; xc2[0] == 0; xc2.splice(0, 1), --ye2)
          ;
        if (!xc2[0]) {
          y2.s = ROUNDING_MODE == 3 ? -1 : 1;
          y2.c = [y2.e = 0];
          return y2;
        }
        return normalise(y2, xc2, ye2);
      };
      P2.modulo = P2.mod = function(y2, b2) {
        var q, s, x2 = this;
        y2 = new BigNumber3(y2, b2);
        if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
          return new BigNumber3(NaN);
        } else if (!y2.c || x2.c && !x2.c[0]) {
          return new BigNumber3(x2);
        }
        if (MODULO_MODE == 9) {
          s = y2.s;
          y2.s = 1;
          q = div(x2, y2, 0, 3);
          y2.s = s;
          q.s *= s;
        } else {
          q = div(x2, y2, 0, MODULO_MODE);
        }
        y2 = x2.minus(q.times(y2));
        if (!y2.c[0] && MODULO_MODE == 1)
          y2.s = x2.s;
        return y2;
      };
      P2.multipliedBy = P2.times = function(y2, b2) {
        var c, e, i, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base, sqrtBase, x2 = this, xc2 = x2.c, yc2 = (y2 = new BigNumber3(y2, b2)).c;
        if (!xc2 || !yc2 || !xc2[0] || !yc2[0]) {
          if (!x2.s || !y2.s || xc2 && !xc2[0] && !yc2 || yc2 && !yc2[0] && !xc2) {
            y2.c = y2.e = y2.s = null;
          } else {
            y2.s *= x2.s;
            if (!xc2 || !yc2) {
              y2.c = y2.e = null;
            } else {
              y2.c = [0];
              y2.e = 0;
            }
          }
          return y2;
        }
        e = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
        y2.s *= x2.s;
        xcL = xc2.length;
        ycL = yc2.length;
        if (xcL < ycL) {
          zc2 = xc2;
          xc2 = yc2;
          yc2 = zc2;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc2 = []; i--; zc2.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc2[i] % sqrtBase;
          yhi = yc2[i] / sqrtBase | 0;
          for (k2 = xcL, j2 = i + k2; j2 > i; ) {
            xlo = xc2[--k2] % sqrtBase;
            xhi = xc2[k2] / sqrtBase | 0;
            m2 = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc2[j2] + c;
            c = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
            zc2[j2--] = xlo % base;
          }
          zc2[j2] = c;
        }
        if (c) {
          ++e;
        } else {
          zc2.splice(0, 1);
        }
        return normalise(y2, zc2, e);
      };
      P2.negated = function() {
        var x2 = new BigNumber3(this);
        x2.s = -x2.s || null;
        return x2;
      };
      P2.plus = function(y2, b2) {
        var t, x2 = this, a = x2.s;
        y2 = new BigNumber3(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber3(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x2.minus(y2);
        }
        var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
        if (!xe2 || !ye2) {
          if (!xc2 || !yc2)
            return new BigNumber3(a / 0);
          if (!xc2[0] || !yc2[0])
            return yc2[0] ? y2 : new BigNumber3(xc2[0] ? x2 : a * 0);
        }
        xe2 = bitFloor(xe2);
        ye2 = bitFloor(ye2);
        xc2 = xc2.slice();
        if (a = xe2 - ye2) {
          if (a > 0) {
            ye2 = xe2;
            t = yc2;
          } else {
            a = -a;
            t = xc2;
          }
          t.reverse();
          for (; a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc2.length;
        b2 = yc2.length;
        if (a - b2 < 0) {
          t = yc2;
          yc2 = xc2;
          xc2 = t;
          b2 = a;
        }
        for (a = 0; b2; ) {
          a = (xc2[--b2] = xc2[b2] + yc2[b2] + a) / BASE | 0;
          xc2[b2] = BASE === xc2[b2] ? 0 : xc2[b2] % BASE;
        }
        if (a) {
          xc2 = [a].concat(xc2);
          ++ye2;
        }
        return normalise(y2, xc2, ye2);
      };
      P2.precision = P2.sd = function(sd2, rm2) {
        var c, n, v, x2 = this;
        if (sd2 != null && sd2 !== !!sd2) {
          intCheck(sd2, 1, MAX);
          if (rm2 == null)
            rm2 = ROUNDING_MODE;
          else
            intCheck(rm2, 0, 8);
          return round(new BigNumber3(x2), sd2, rm2);
        }
        if (!(c = x2.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (; v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0]; v >= 10; v /= 10, n++)
            ;
        }
        if (sd2 && x2.e + 1 > n)
          n = x2.e + 1;
        return n;
      };
      P2.shiftedBy = function(k2) {
        intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k2);
      };
      P2.squareRoot = P2.sqrt = function() {
        var m2, n, r, rep, t, x2 = this, c = x2.c, s = x2.s, e = x2.e, dp2 = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
        if (s !== 1 || !c || !c[0]) {
          return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x2 : 1 / 0);
        }
        s = Math.sqrt(+valueOf(x2));
        if (s == 0 || s == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber3(n);
        } else {
          r = new BigNumber3(s + "");
        }
        if (r.c[0]) {
          e = r.e;
          s = e + dp2;
          if (s < 3)
            s = 0;
          for (; ; ) {
            t = r;
            r = half.times(t.plus(div(x2, t, dp2, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
              if (r.e < e)
                --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x2)) {
                    r = t;
                    break;
                  }
                }
                dp2 += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m2 = !r.times(r).eq(x2);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
      };
      P2.toExponential = function(dp2, rm2) {
        if (dp2 != null) {
          intCheck(dp2, 0, MAX);
          dp2++;
        }
        return format(this, dp2, rm2, 1);
      };
      P2.toFixed = function(dp2, rm2) {
        if (dp2 != null) {
          intCheck(dp2, 0, MAX);
          dp2 = dp2 + this.e + 1;
        }
        return format(this, dp2, rm2);
      };
      P2.toFormat = function(dp2, rm2, format2) {
        var str, x2 = this;
        if (format2 == null) {
          if (dp2 != null && rm2 && typeof rm2 == "object") {
            format2 = rm2;
            rm2 = null;
          } else if (dp2 && typeof dp2 == "object") {
            format2 = dp2;
            dp2 = rm2 = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x2.toFixed(dp2, rm2);
        if (x2.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
            new RegExp("\\d{" + g2 + "}\\B", "g"),
            "$&" + (format2.fractionGroupSeparator || "")
          ) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P2.toFraction = function(md2) {
        var d2, d02, d1, d22, e, exp, n, n02, n1, q, r, s, x2 = this, xc2 = x2.c;
        if (md2 != null) {
          n = new BigNumber3(md2);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc2)
          return new BigNumber3(x2);
        d2 = new BigNumber3(ONE);
        n1 = d02 = new BigNumber3(ONE);
        d1 = n02 = new BigNumber3(ONE);
        s = coeffToString(xc2);
        e = d2.e = s.length - x2.e - 1;
        d2.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md2 = !md2 || n.comparedTo(d2) > 0 ? e > 0 ? d2 : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber3(s);
        n02.c[0] = 0;
        for (; ; ) {
          q = div(n, d2, 0, 1);
          d22 = d02.plus(q.times(d1));
          if (d22.comparedTo(md2) == 1)
            break;
          d02 = d1;
          d1 = d22;
          n1 = n02.plus(q.times(d22 = n1));
          n02 = d22;
          d2 = n.minus(q.times(d22 = d2));
          n = d22;
        }
        d22 = div(md2.minus(d02), d1, 0, 1);
        n02 = n02.plus(d22.times(n1));
        d02 = d02.plus(d22.times(d1));
        n02.s = n1.s = x2.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x2).abs().comparedTo(
          div(n02, d02, e, ROUNDING_MODE).minus(x2).abs()
        ) < 1 ? [n1, d1] : [n02, d02];
        MAX_EXP = exp;
        return r;
      };
      P2.toNumber = function() {
        return +valueOf(this);
      };
      P2.toPrecision = function(sd2, rm2) {
        if (sd2 != null)
          intCheck(sd2, 1, MAX);
        return format(this, sd2, rm2, 2);
      };
      P2.toString = function(b2) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) {
          if (s) {
            str = "Infinity";
            if (s < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b2 == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b2, s, true);
          }
          if (s < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P2.valueOf = P2.toJSON = function() {
        return valueOf(this);
      };
      P2._isBigNumber = true;
      if (configObject != null)
        BigNumber3.set(configObject);
      return BigNumber3;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z2, i = 1, j2 = a.length, r = a[0] + "";
      for (; i < j2; ) {
        s = a[i++] + "";
        z2 = LOG_BASE - s.length;
        for (; z2--; s = "0" + s)
          ;
        r += s;
      }
      for (j2 = r.length; r.charCodeAt(--j2) === 48; )
        ;
      return r.slice(0, j2 + 1 || 1);
    }
    function compare(x2, y2) {
      var a, b2, xc2 = x2.c, yc2 = y2.c, i = x2.s, j2 = y2.s, k2 = x2.e, l2 = y2.e;
      if (!i || !j2)
        return null;
      a = xc2 && !xc2[0];
      b2 = yc2 && !yc2[0];
      if (a || b2)
        return a ? b2 ? 0 : -j2 : i;
      if (i != j2)
        return i;
      a = i < 0;
      b2 = k2 == l2;
      if (!xc2 || !yc2)
        return b2 ? 0 : !xc2 ^ a ? 1 : -1;
      if (!b2)
        return k2 > l2 ^ a ? 1 : -1;
      j2 = (k2 = xc2.length) < (l2 = yc2.length) ? k2 : l2;
      for (i = 0; i < j2; i++)
        if (xc2[i] != yc2[i])
          return xc2[i] > yc2[i] ^ a ? 1 : -1;
      return k2 == l2 ? 0 : k2 > l2 ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k2 = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k2 && n.c[k2] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z2) {
      var len, zs2;
      if (e < 0) {
        for (zs2 = z2 + "."; ++e; zs2 += z2)
          ;
        str = zs2 + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs2 = z2, e -= len; --e; zs2 += z2)
            ;
          str += zs2;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber2 = clone();
    BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
    if (module.exports) {
      module.exports = BigNumber2;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber2;
    }
  })(commonjsGlobal);
})(bignumber);
var bignumberExports = bignumber.exports;
(function(module) {
  var BigNumber2 = bignumberExports;
  var JSON2 = module.exports;
  (function() {
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c = meta[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i, k2, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber2 || BigNumber2.isBigNumber(value));
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          if (isBigNumber) {
            return value;
          } else {
            return quote(value);
          }
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              if (typeof rep[i] === "string") {
                k2 = rep[i];
                v = str(k2, value);
                if (v) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            Object.keys(value).forEach(function(k3) {
              var v2 = str(k3, value);
              if (v2) {
                partial.push(quote(k3) + (gap ? ": " : ":") + v2);
              }
            });
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
      }
    }
    if (typeof JSON2.stringify !== "function") {
      JSON2.stringify = function(value, replacer2, space) {
        var i;
        gap = "";
        indent = "";
        if (typeof space === "number") {
          for (i = 0; i < space; i += 1) {
            indent += " ";
          }
        } else if (typeof space === "string") {
          indent = space;
        }
        rep = replacer2;
        if (replacer2 && typeof replacer2 !== "function" && (typeof replacer2 !== "object" || typeof replacer2.length !== "number")) {
          throw new Error("JSON.stringify");
        }
        return str("", { "": value });
      };
    }
  })();
})(stringify);
var stringifyExports = stringify.exports;
var BigNumber = null;
const suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
const suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
var json_parse$1 = function(options) {
  var _options = {
    strict: false,
    // not being strict means do not generate syntax errors for "duplicate key"
    storeAsString: false,
    // toggles whether the values should be stored as BigNumber (default) or a string
    alwaysParseAsBig: false,
    // toggles whether all numbers should be Big
    useNativeBigInt: false,
    // toggles whether to use native BigInt instead of bignumber.js
    protoAction: "error",
    constructorAction: "error"
  };
  if (options !== void 0 && options !== null) {
    if (options.strict === true) {
      _options.strict = true;
    }
    if (options.storeAsString === true) {
      _options.storeAsString = true;
    }
    _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
    _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
    if (typeof options.constructorAction !== "undefined") {
      if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
        _options.constructorAction = options.constructorAction;
      } else {
        throw new Error(
          `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
        );
      }
    }
    if (typeof options.protoAction !== "undefined") {
      if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
        _options.protoAction = options.protoAction;
      } else {
        throw new Error(
          `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
        );
      }
    }
  }
  var at2, ch2, escapee = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	"
  }, text, error = function(m2) {
    throw {
      name: "SyntaxError",
      message: m2,
      at: at2,
      text
    };
  }, next = function(c) {
    if (c && c !== ch2) {
      error("Expected '" + c + "' instead of '" + ch2 + "'");
    }
    ch2 = text.charAt(at2);
    at2 += 1;
    return ch2;
  }, number = function() {
    var number2, string2 = "";
    if (ch2 === "-") {
      string2 = "-";
      next("-");
    }
    while (ch2 >= "0" && ch2 <= "9") {
      string2 += ch2;
      next();
    }
    if (ch2 === ".") {
      string2 += ".";
      while (next() && ch2 >= "0" && ch2 <= "9") {
        string2 += ch2;
      }
    }
    if (ch2 === "e" || ch2 === "E") {
      string2 += ch2;
      next();
      if (ch2 === "-" || ch2 === "+") {
        string2 += ch2;
        next();
      }
      while (ch2 >= "0" && ch2 <= "9") {
        string2 += ch2;
        next();
      }
    }
    number2 = +string2;
    if (!isFinite(number2)) {
      error("Bad number");
    } else {
      if (BigNumber == null)
        BigNumber = bignumberExports;
      if (string2.length > 15)
        return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
      else
        return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
    }
  }, string = function() {
    var hex, i, string2 = "", uffff;
    if (ch2 === '"') {
      var startAt = at2;
      while (next()) {
        if (ch2 === '"') {
          if (at2 - 1 > startAt)
            string2 += text.substring(startAt, at2 - 1);
          next();
          return string2;
        }
        if (ch2 === "\\") {
          if (at2 - 1 > startAt)
            string2 += text.substring(startAt, at2 - 1);
          next();
          if (ch2 === "u") {
            uffff = 0;
            for (i = 0; i < 4; i += 1) {
              hex = parseInt(next(), 16);
              if (!isFinite(hex)) {
                break;
              }
              uffff = uffff * 16 + hex;
            }
            string2 += String.fromCharCode(uffff);
          } else if (typeof escapee[ch2] === "string") {
            string2 += escapee[ch2];
          } else {
            break;
          }
          startAt = at2;
        }
      }
    }
    error("Bad string");
  }, white = function() {
    while (ch2 && ch2 <= " ") {
      next();
    }
  }, word = function() {
    switch (ch2) {
      case "t":
        next("t");
        next("r");
        next("u");
        next("e");
        return true;
      case "f":
        next("f");
        next("a");
        next("l");
        next("s");
        next("e");
        return false;
      case "n":
        next("n");
        next("u");
        next("l");
        next("l");
        return null;
    }
    error("Unexpected '" + ch2 + "'");
  }, value, array2 = function() {
    var array3 = [];
    if (ch2 === "[") {
      next("[");
      white();
      if (ch2 === "]") {
        next("]");
        return array3;
      }
      while (ch2) {
        array3.push(value());
        white();
        if (ch2 === "]") {
          next("]");
          return array3;
        }
        next(",");
        white();
      }
    }
    error("Bad array");
  }, object2 = function() {
    var key, object3 = /* @__PURE__ */ Object.create(null);
    if (ch2 === "{") {
      next("{");
      white();
      if (ch2 === "}") {
        next("}");
        return object3;
      }
      while (ch2) {
        key = string();
        white();
        next(":");
        if (_options.strict === true && Object.hasOwnProperty.call(object3, key)) {
          error('Duplicate key "' + key + '"');
        }
        if (suspectProtoRx.test(key) === true) {
          if (_options.protoAction === "error") {
            error("Object contains forbidden prototype property");
          } else if (_options.protoAction === "ignore") {
            value();
          } else {
            object3[key] = value();
          }
        } else if (suspectConstructorRx.test(key) === true) {
          if (_options.constructorAction === "error") {
            error("Object contains forbidden constructor property");
          } else if (_options.constructorAction === "ignore") {
            value();
          } else {
            object3[key] = value();
          }
        } else {
          object3[key] = value();
        }
        white();
        if (ch2 === "}") {
          next("}");
          return object3;
        }
        next(",");
        white();
      }
    }
    error("Bad object");
  };
  value = function() {
    white();
    switch (ch2) {
      case "{":
        return object2();
      case "[":
        return array2();
      case '"':
        return string();
      case "-":
        return number();
      default:
        return ch2 >= "0" && ch2 <= "9" ? number() : word();
    }
  };
  return function(source, reviver) {
    var result;
    text = source + "";
    at2 = 0;
    ch2 = " ";
    result = value();
    white();
    if (ch2) {
      error("Syntax error");
    }
    return typeof reviver === "function" ? function walk(holder, key) {
      var v, value2 = holder[key];
      if (value2 && typeof value2 === "object") {
        Object.keys(value2).forEach(function(k2) {
          v = walk(value2, k2);
          if (v !== void 0) {
            value2[k2] = v;
          } else {
            delete value2[k2];
          }
        });
      }
      return reviver.call(holder, key, value2);
    }({ "": result }, "") : result;
  };
};
var parse = json_parse$1;
var json_stringify = stringifyExports.stringify;
var json_parse = parse;
jsonBigint.exports = function(options) {
  return {
    parse: json_parse(options),
    stringify: json_stringify
  };
};
jsonBigint.exports.parse = json_parse();
jsonBigint.exports.stringify = json_stringify;
var jsonBigintExports = jsonBigint.exports;
const JSONbigWithoutConfig = /* @__PURE__ */ getDefaultExportFromCjs(jsonBigintExports);
var IntDecoding;
(function(IntDecoding2) {
  IntDecoding2["DEFAULT"] = "default";
  IntDecoding2["SAFE"] = "safe";
  IntDecoding2["MIXED"] = "mixed";
  IntDecoding2["BIGINT"] = "bigint";
})(IntDecoding || (IntDecoding = {}));
const IntDecoding$1 = IntDecoding;
const JSONbig = JSONbigWithoutConfig({ useNativeBigInt: true, strict: true });
function parseJSON(str, options) {
  const intDecoding = options && options.intDecoding ? options.intDecoding : IntDecoding$1.DEFAULT;
  return JSONbig.parse(str, (_, value) => {
    if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
      Object.setPrototypeOf(value, Object.prototype);
    }
    if (typeof value === "bigint") {
      if (intDecoding === "safe" && value > Number.MAX_SAFE_INTEGER) {
        throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
      }
      if (intDecoding === "bigint" || intDecoding === "mixed" && value > Number.MAX_SAFE_INTEGER) {
        return value;
      }
      return Number(value);
    }
    if (typeof value === "number") {
      if (intDecoding === "bigint" && Number.isInteger(value)) {
        return BigInt(value);
      }
    }
    return value;
  });
}
function arrayEqual(a, b2) {
  if (a.length !== b2.length) {
    return false;
  }
  return Array.from(a).every((val, i) => val === b2[i]);
}
function concatArrays(...arrs) {
  const size2 = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c = new Uint8Array(size2);
  let offset = 0;
  for (let i = 0; i < arrs.length; i++) {
    c.set(arrs[i], offset);
    offset += arrs[i].length;
  }
  return c;
}
function removeUndefinedProperties(obj) {
  const mutableCopy = { ...obj };
  Object.keys(mutableCopy).forEach((key) => {
    if (typeof mutableCopy[key] === "undefined")
      delete mutableCopy[key];
  });
  return mutableCopy;
}
function encodeUint64(num) {
  const isInteger = typeof num === "bigint" || Number.isInteger(num);
  if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
    throw new Error("Input is not a 64-bit unsigned integer");
  }
  const encoding = new Uint8Array(8);
  const view = new DataView(encoding.buffer);
  view.setBigUint64(0, BigInt(num));
  return encoding;
}
function decodeUint64(data, decodingMode = "safe") {
  if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
    throw new Error(`Unknown decodingMode option: ${decodingMode}`);
  }
  if (data.byteLength === 0 || data.byteLength > 8) {
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
  }
  const padding = new Uint8Array(8 - data.byteLength);
  const encoding = concatArrays(padding, data);
  const view = new DataView(encoding.buffer);
  const num = view.getBigUint64(0);
  const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);
  if (decodingMode === "safe") {
    if (isBig) {
      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    }
    return Number(num);
  }
  if (decodingMode === "mixed" && !isBig) {
    return Number(num);
  }
  return num;
}
const ALGORAND_ADDRESS_BYTE_LENGTH = 36;
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_ADDRESS_LENGTH = 58;
const ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
const MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
  77,
  117,
  108,
  116,
  105,
  115,
  105,
  103,
  65,
  100,
  100,
  114
]);
const APP_ID_PREFIX = buffer.Buffer.from("appID");
const MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
const CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
const INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
const INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
const INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
const UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
function decodeAddress(address) {
  if (typeof address !== "string" || address.length !== ALGORAND_ADDRESS_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const decoded = base32.decode.asBytes(address.toString());
  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  const cs2 = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
  const checksum = genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH);
  if (!arrayEqual(checksum, cs2))
    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
  return { publicKey: pk, checksum: cs2 };
}
function isValidAddress(address) {
  try {
    decodeAddress(address);
  } catch (e) {
    return false;
  }
  return true;
}
function encodeAddress(address) {
  const checksum = genericHash(address).slice(PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, PUBLIC_KEY_LENGTH);
  const addr = base32.encode(concatArrays(address, checksum));
  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH);
}
function fromMultisigPreImg({ version: version2, threshold, pks }) {
  if (version2 !== 1 || version2 > 255 || version2 < 0) {
    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
  }
  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
  }
  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
  if (pkLen !== PUBLIC_KEY_LENGTH) {
    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
  }
  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
  merged.set([version2], MULTISIG_PREIMG2ADDR_PREFIX.length);
  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
  for (let i = 0; i < pks.length; i++) {
    if (pks[i].length !== pkLen) {
      throw new Error(INVALID_MSIG_PK_ERROR_MSG);
    }
    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);
  }
  return new Uint8Array(genericHash(merged));
}
function fromMultisigPreImgAddrs({ version: version2, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  return encodeAddress(fromMultisigPreImg({ version: version2, threshold, pks }));
}
function getApplicationAddress(appID) {
  const toBeSigned = concatArrays(APP_ID_PREFIX, encodeUint64(appID));
  const hash = genericHash(toBeSigned);
  return encodeAddress(new Uint8Array(hash));
}
var msgpack_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    return function(t) {
      var e = {};
      function r(n) {
        if (e[n])
          return e[n].exports;
        var i = e[n] = { i: n, l: false, exports: {} };
        return t[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
      }
      return r.m = t, r.c = e, r.d = function(t2, e2, n) {
        r.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
      }, r.r = function(t2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, r.t = function(t2, e2) {
        if (1 & e2 && (t2 = r(t2)), 8 & e2)
          return t2;
        if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
          return t2;
        var n = /* @__PURE__ */ Object.create(null);
        if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
          for (var i in t2)
            r.d(n, i, (function(e3) {
              return t2[e3];
            }).bind(null, i));
        return n;
      }, r.n = function(t2) {
        var e2 = t2 && t2.__esModule ? function() {
          return t2.default;
        } : function() {
          return t2;
        };
        return r.d(e2, "a", e2), e2;
      }, r.o = function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }, r.p = "", r(r.s = 0);
    }([function(t, e, r) {
      r.r(e), r.d(e, "encode", function() {
        return T;
      }), r.d(e, "decode", function() {
        return V2;
      }), r.d(e, "decodeAsync", function() {
        return Y;
      }), r.d(e, "decodeArrayStream", function() {
        return Z;
      }), r.d(e, "decodeStream", function() {
        return $;
      }), r.d(e, "Decoder", function() {
        return O2;
      }), r.d(e, "Encoder", function() {
        return I;
      }), r.d(e, "ExtensionCodec", function() {
        return S2;
      }), r.d(e, "ExtData", function() {
        return p2;
      }), r.d(e, "EXT_TIMESTAMP", function() {
        return w;
      }), r.d(e, "encodeDateToTimeSpec", function() {
        return g;
      }), r.d(e, "encodeTimeSpecToTimestamp", function() {
        return v;
      }), r.d(e, "decodeTimestampToTimeSpec", function() {
        return U;
      }), r.d(e, "encodeTimestampExtension", function() {
        return b2;
      }), r.d(e, "decodeTimestampExtension", function() {
        return m2;
      });
      var n = function(t2, e2) {
        var r2 = "function" == typeof Symbol && t2[Symbol.iterator];
        if (!r2)
          return t2;
        var n2, i2, o2 = r2.call(t2), s2 = [];
        try {
          for (; (void 0 === e2 || e2-- > 0) && !(n2 = o2.next()).done; )
            s2.push(n2.value);
        } catch (t3) {
          i2 = { error: t3 };
        } finally {
          try {
            n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
          } finally {
            if (i2)
              throw i2.error;
          }
        }
        return s2;
      }, i = function() {
        for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
          t2 = t2.concat(n(arguments[e2]));
        return t2;
      }, o = "undefined" != typeof process && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
      function s(t2) {
        for (var e2 = t2.length, r2 = 0, n2 = 0; n2 < e2; ) {
          var i2 = t2.charCodeAt(n2++);
          if (0 != (4294967168 & i2))
            if (0 == (4294965248 & i2))
              r2 += 2;
            else {
              if (i2 >= 55296 && i2 <= 56319 && n2 < e2) {
                var o2 = t2.charCodeAt(n2);
                56320 == (64512 & o2) && (++n2, i2 = ((1023 & i2) << 10) + (1023 & o2) + 65536);
              }
              r2 += 0 == (4294901760 & i2) ? 3 : 4;
            }
          else
            r2++;
        }
        return r2;
      }
      var a = o ? new TextEncoder() : void 0, h2 = "undefined" != typeof process ? 200 : 0;
      var u2 = (null == a ? void 0 : a.encodeInto) ? function(t2, e2, r2) {
        a.encodeInto(t2, e2.subarray(r2));
      } : function(t2, e2, r2) {
        e2.set(a.encode(t2), r2);
      };
      function c(t2, e2, r2) {
        for (var n2 = e2, o2 = n2 + r2, s2 = [], a2 = ""; n2 < o2; ) {
          var h3 = t2[n2++];
          if (0 == (128 & h3))
            s2.push(h3);
          else if (192 == (224 & h3)) {
            var u3 = 63 & t2[n2++];
            s2.push((31 & h3) << 6 | u3);
          } else if (224 == (240 & h3)) {
            u3 = 63 & t2[n2++];
            var c2 = 63 & t2[n2++];
            s2.push((31 & h3) << 12 | u3 << 6 | c2);
          } else if (240 == (248 & h3)) {
            var f3 = (7 & h3) << 18 | (u3 = 63 & t2[n2++]) << 12 | (c2 = 63 & t2[n2++]) << 6 | 63 & t2[n2++];
            f3 > 65535 && (f3 -= 65536, s2.push(f3 >>> 10 & 1023 | 55296), f3 = 56320 | 1023 & f3), s2.push(f3);
          } else
            s2.push(h3);
          s2.length >= 4096 && (a2 += String.fromCharCode.apply(String, i(s2)), s2.length = 0);
        }
        return s2.length > 0 && (a2 += String.fromCharCode.apply(String, i(s2))), a2;
      }
      var f2 = o ? new TextDecoder() : null, l2 = "undefined" != typeof process ? 200 : 0;
      var p2 = function(t2, e2) {
        this.type = t2, this.data = e2;
      };
      function d2(t2, e2, r2) {
        var n2 = Math.floor(r2 / 4294967296), i2 = r2;
        t2.setUint32(e2, n2), t2.setUint32(e2 + 4, i2);
      }
      function y2(t2, e2) {
        var r2 = t2.getInt32(e2), n2 = t2.getUint32(e2 + 4), i2 = r2 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r2 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && 0 === n2, o2 = r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        return i2 || o2 ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2;
      }
      var w = -1;
      function v(t2) {
        var e2 = t2.sec, r2 = t2.nsec;
        if (e2 >= 0 && r2 >= 0 && e2 <= 17179869183) {
          if (0 === r2 && e2 <= 4294967295) {
            var n2 = new Uint8Array(4);
            return (s2 = new DataView(n2.buffer)).setUint32(0, e2), n2;
          }
          var i2 = e2 / 4294967296, o2 = 4294967295 & e2;
          n2 = new Uint8Array(8);
          return (s2 = new DataView(n2.buffer)).setUint32(0, r2 << 2 | 3 & i2), s2.setUint32(4, o2), n2;
        }
        var s2;
        n2 = new Uint8Array(12);
        return (s2 = new DataView(n2.buffer)).setUint32(0, r2), d2(s2, 4, e2), n2;
      }
      function g(t2) {
        var e2 = t2.getTime(), r2 = Math.floor(e2 / 1e3), n2 = 1e6 * (e2 - 1e3 * r2), i2 = Math.floor(n2 / 1e9);
        return { sec: r2 + i2, nsec: n2 - 1e9 * i2 };
      }
      function b2(t2) {
        return t2 instanceof Date ? v(g(t2)) : null;
      }
      function U(t2) {
        var e2 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
        switch (t2.byteLength) {
          case 4:
            return { sec: e2.getUint32(0), nsec: 0 };
          case 8:
            var r2 = e2.getUint32(0);
            return { sec: 4294967296 * (3 & r2) + e2.getUint32(4), nsec: r2 >>> 2 };
          case 12:
            return { sec: y2(e2, 4), nsec: e2.getUint32(0) };
          default:
            throw new Error("Unrecognized data size for timestamp: " + t2.length);
        }
      }
      function m2(t2) {
        var e2 = U(t2);
        return new Date(1e3 * e2.sec + e2.nsec / 1e6);
      }
      var x2 = { type: w, encode: b2, decode: m2 }, S2 = function() {
        function t2() {
          this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x2);
        }
        return t2.prototype.register = function(t3) {
          var e2 = t3.type, r2 = t3.encode, n2 = t3.decode;
          if (e2 >= 0)
            this.encoders[e2] = r2, this.decoders[e2] = n2;
          else {
            var i2 = 1 + e2;
            this.builtInEncoders[i2] = r2, this.builtInDecoders[i2] = n2;
          }
        }, t2.prototype.tryToEncode = function(t3, e2) {
          for (var r2 = 0; r2 < this.builtInEncoders.length; r2++) {
            if (null != (n2 = this.builtInEncoders[r2])) {
              if (null != (i2 = n2(t3, e2)))
                return new p2(-1 - r2, i2);
            }
          }
          for (r2 = 0; r2 < this.encoders.length; r2++) {
            var n2, i2;
            if (null != (n2 = this.encoders[r2])) {
              if (null != (i2 = n2(t3, e2)))
                return new p2(r2, i2);
            }
          }
          return t3 instanceof p2 ? t3 : null;
        }, t2.prototype.decode = function(t3, e2, r2) {
          var n2 = e2 < 0 ? this.builtInDecoders[-1 - e2] : this.decoders[e2];
          return n2 ? n2(t3, e2, r2) : new p2(e2, t3);
        }, t2.defaultCodec = new t2(), t2;
      }();
      function B(t2) {
        return t2 instanceof Uint8Array ? t2 : ArrayBuffer.isView(t2) ? new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength) : t2 instanceof ArrayBuffer ? new Uint8Array(t2) : Uint8Array.from(t2);
      }
      var E2 = function(t2) {
        var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t2[e2], n2 = 0;
        if (r2)
          return r2.call(t2);
        if (t2 && "number" == typeof t2.length)
          return { next: function() {
            return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
          } };
        throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, I = function() {
        function t2(t3, e2, r2, n2, i2, o2, s2, a2) {
          void 0 === t3 && (t3 = S2.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 100), void 0 === n2 && (n2 = 2048), void 0 === i2 && (i2 = false), void 0 === o2 && (o2 = false), void 0 === s2 && (s2 = false), void 0 === a2 && (a2 = false), this.extensionCodec = t3, this.context = e2, this.maxDepth = r2, this.initialBufferSize = n2, this.sortKeys = i2, this.forceFloat32 = o2, this.ignoreUndefined = s2, this.forceIntegerToFloat = a2, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
        }
        return t2.prototype.getUint8Array = function() {
          return this.bytes.subarray(0, this.pos);
        }, t2.prototype.reinitializeState = function() {
          this.pos = 0;
        }, t2.prototype.encode = function(t3) {
          return this.reinitializeState(), this.doEncode(t3, 1), this.getUint8Array();
        }, t2.prototype.doEncode = function(t3, e2) {
          if (e2 > this.maxDepth)
            throw new Error("Too deep objects in depth " + e2);
          null == t3 ? this.encodeNil() : "boolean" == typeof t3 ? this.encodeBoolean(t3) : "number" == typeof t3 ? this.encodeNumber(t3) : "string" == typeof t3 ? this.encodeString(t3) : "bigint" == typeof t3 ? this.encodebigint(t3) : this.encodeObject(t3, e2);
        }, t2.prototype.ensureBufferSizeToWrite = function(t3) {
          var e2 = this.pos + t3;
          this.view.byteLength < e2 && this.resizeBuffer(2 * e2);
        }, t2.prototype.resizeBuffer = function(t3) {
          var e2 = new ArrayBuffer(t3), r2 = new Uint8Array(e2), n2 = new DataView(e2);
          r2.set(this.bytes), this.view = n2, this.bytes = r2;
        }, t2.prototype.encodeNil = function() {
          this.writeU8(192);
        }, t2.prototype.encodeBoolean = function(t3) {
          false === t3 ? this.writeU8(194) : this.writeU8(195);
        }, t2.prototype.encodeNumber = function(t3) {
          Number.isSafeInteger(t3) && !this.forceIntegerToFloat ? t3 >= 0 ? t3 < 128 ? this.writeU8(t3) : t3 < 256 ? (this.writeU8(204), this.writeU8(t3)) : t3 < 65536 ? (this.writeU8(205), this.writeU16(t3)) : t3 < 4294967296 ? (this.writeU8(206), this.writeU32(t3)) : (this.writeU8(207), this.writeU64(t3)) : t3 >= -32 ? this.writeU8(224 | t3 + 32) : t3 >= -128 ? (this.writeU8(208), this.writeI8(t3)) : t3 >= -32768 ? (this.writeU8(209), this.writeI16(t3)) : t3 >= -2147483648 ? (this.writeU8(210), this.writeI32(t3)) : (this.writeU8(211), this.writeI64(t3)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t3)) : (this.writeU8(203), this.writeF64(t3));
        }, t2.prototype.encodebigint = function(t3) {
          t3 >= BigInt(0) ? t3 < BigInt(128) ? this.writeU8(Number(t3)) : t3 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(t3))) : t3 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(t3))) : t3 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(t3))) : (this.writeU8(207), this.writeBig64(t3)) : t3 >= BigInt(-32) ? this.writeU8(224 | Number(t3) + 32) : t3 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(t3))) : t3 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(t3))) : t3 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(t3))) : (this.writeU8(211), this.writeBig64(t3));
        }, t2.prototype.writeStringHeader = function(t3) {
          if (t3 < 32)
            this.writeU8(160 + t3);
          else if (t3 < 256)
            this.writeU8(217), this.writeU8(t3);
          else if (t3 < 65536)
            this.writeU8(218), this.writeU16(t3);
          else {
            if (!(t3 < 4294967296))
              throw new Error("Too long string: " + t3 + " bytes in UTF-8");
            this.writeU8(219), this.writeU32(t3);
          }
        }, t2.prototype.encodeString = function(t3) {
          var e2 = t3.length;
          if (o && e2 > h2) {
            var r2 = s(t3);
            this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), u2(t3, this.bytes, this.pos), this.pos += r2;
          } else {
            r2 = s(t3);
            this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), function(t4, e3, r3) {
              for (var n2 = t4.length, i2 = r3, o2 = 0; o2 < n2; ) {
                var s2 = t4.charCodeAt(o2++);
                if (0 != (4294967168 & s2)) {
                  if (0 == (4294965248 & s2))
                    e3[i2++] = s2 >> 6 & 31 | 192;
                  else {
                    if (s2 >= 55296 && s2 <= 56319 && o2 < n2) {
                      var a2 = t4.charCodeAt(o2);
                      56320 == (64512 & a2) && (++o2, s2 = ((1023 & s2) << 10) + (1023 & a2) + 65536);
                    }
                    0 == (4294901760 & s2) ? (e3[i2++] = s2 >> 12 & 15 | 224, e3[i2++] = s2 >> 6 & 63 | 128) : (e3[i2++] = s2 >> 18 & 7 | 240, e3[i2++] = s2 >> 12 & 63 | 128, e3[i2++] = s2 >> 6 & 63 | 128);
                  }
                  e3[i2++] = 63 & s2 | 128;
                } else
                  e3[i2++] = s2;
              }
            }(t3, this.bytes, this.pos), this.pos += r2;
          }
        }, t2.prototype.encodeObject = function(t3, e2) {
          var r2 = this.extensionCodec.tryToEncode(t3, this.context);
          if (null != r2)
            this.encodeExtension(r2);
          else if (Array.isArray(t3))
            this.encodeArray(t3, e2);
          else if (ArrayBuffer.isView(t3))
            this.encodeBinary(t3);
          else {
            if ("object" != typeof t3)
              throw new Error("Unrecognized object: " + Object.prototype.toString.apply(t3));
            this.encodeMap(t3, e2);
          }
        }, t2.prototype.encodeBinary = function(t3) {
          var e2 = t3.byteLength;
          if (e2 < 256)
            this.writeU8(196), this.writeU8(e2);
          else if (e2 < 65536)
            this.writeU8(197), this.writeU16(e2);
          else {
            if (!(e2 < 4294967296))
              throw new Error("Too large binary: " + e2);
            this.writeU8(198), this.writeU32(e2);
          }
          var r2 = B(t3);
          this.writeU8a(r2);
        }, t2.prototype.encodeArray = function(t3, e2) {
          var r2, n2, i2 = t3.length;
          if (i2 < 16)
            this.writeU8(144 + i2);
          else if (i2 < 65536)
            this.writeU8(220), this.writeU16(i2);
          else {
            if (!(i2 < 4294967296))
              throw new Error("Too large array: " + i2);
            this.writeU8(221), this.writeU32(i2);
          }
          try {
            for (var o2 = E2(t3), s2 = o2.next(); !s2.done; s2 = o2.next()) {
              var a2 = s2.value;
              this.doEncode(a2, e2 + 1);
            }
          } catch (t4) {
            r2 = { error: t4 };
          } finally {
            try {
              s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
        }, t2.prototype.countWithoutUndefined = function(t3, e2) {
          var r2, n2, i2 = 0;
          try {
            for (var o2 = E2(e2), s2 = o2.next(); !s2.done; s2 = o2.next()) {
              void 0 !== t3[s2.value] && i2++;
            }
          } catch (t4) {
            r2 = { error: t4 };
          } finally {
            try {
              s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return i2;
        }, t2.prototype.encodeMap = function(t3, e2) {
          var r2, n2, i2 = Object.keys(t3);
          this.sortKeys && i2.sort();
          var o2 = this.ignoreUndefined ? this.countWithoutUndefined(t3, i2) : i2.length;
          if (o2 < 16)
            this.writeU8(128 + o2);
          else if (o2 < 65536)
            this.writeU8(222), this.writeU16(o2);
          else {
            if (!(o2 < 4294967296))
              throw new Error("Too large map object: " + o2);
            this.writeU8(223), this.writeU32(o2);
          }
          try {
            for (var s2 = E2(i2), a2 = s2.next(); !a2.done; a2 = s2.next()) {
              var h3 = a2.value, u3 = t3[h3];
              this.ignoreUndefined && void 0 === u3 || (this.encodeString(h3), this.doEncode(u3, e2 + 1));
            }
          } catch (t4) {
            r2 = { error: t4 };
          } finally {
            try {
              a2 && !a2.done && (n2 = s2.return) && n2.call(s2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
        }, t2.prototype.encodeExtension = function(t3) {
          var e2 = t3.data.length;
          if (1 === e2)
            this.writeU8(212);
          else if (2 === e2)
            this.writeU8(213);
          else if (4 === e2)
            this.writeU8(214);
          else if (8 === e2)
            this.writeU8(215);
          else if (16 === e2)
            this.writeU8(216);
          else if (e2 < 256)
            this.writeU8(199), this.writeU8(e2);
          else if (e2 < 65536)
            this.writeU8(200), this.writeU16(e2);
          else {
            if (!(e2 < 4294967296))
              throw new Error("Too large extension object: " + e2);
            this.writeU8(201), this.writeU32(e2);
          }
          this.writeI8(t3.type), this.writeU8a(t3.data);
        }, t2.prototype.writeU8 = function(t3) {
          this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t3), this.pos++;
        }, t2.prototype.writeU8a = function(t3) {
          var e2 = t3.length;
          this.ensureBufferSizeToWrite(e2), this.bytes.set(t3, this.pos), this.pos += e2;
        }, t2.prototype.writeI8 = function(t3) {
          this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t3), this.pos++;
        }, t2.prototype.writeU16 = function(t3) {
          this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t3), this.pos += 2;
        }, t2.prototype.writeI16 = function(t3) {
          this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t3), this.pos += 2;
        }, t2.prototype.writeU32 = function(t3) {
          this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t3), this.pos += 4;
        }, t2.prototype.writeI32 = function(t3) {
          this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t3), this.pos += 4;
        }, t2.prototype.writeF32 = function(t3) {
          this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t3), this.pos += 4;
        }, t2.prototype.writeF64 = function(t3) {
          this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t3), this.pos += 8;
        }, t2.prototype.writeU64 = function(t3) {
          this.ensureBufferSizeToWrite(8), function(t4, e2, r2) {
            var n2 = r2 / 4294967296, i2 = r2;
            t4.setUint32(e2, n2), t4.setUint32(e2 + 4, i2);
          }(this.view, this.pos, t3), this.pos += 8;
        }, t2.prototype.writeI64 = function(t3) {
          this.ensureBufferSizeToWrite(8), d2(this.view, this.pos, t3), this.pos += 8;
        }, t2.prototype.writeBig64 = function(t3) {
          this.ensureBufferSizeToWrite(8), function(t4, e2, r2) {
            var n2 = Number(r2 / BigInt(4294967296)), i2 = Number(r2 % BigInt(4294967296));
            n2 < 0 && 0 !== i2 && (n2 -= 1), t4.setUint32(e2, n2), t4.setUint32(e2 + 4, i2);
          }(this.view, this.pos, t3), this.pos += 8;
        }, t2;
      }(), A = {};
      function T(t2, e2) {
        return void 0 === e2 && (e2 = A), new I(e2.extensionCodec, e2.context, e2.maxDepth, e2.initialBufferSize, e2.sortKeys, e2.forceFloat32, e2.ignoreUndefined, e2.forceIntegerToFloat).encode(t2);
      }
      function L2(t2) {
        return (t2 < 0 ? "-" : "") + "0x" + Math.abs(t2).toString(16).padStart(2, "0");
      }
      var M = function() {
        function t2(t3, e2) {
          void 0 === t3 && (t3 = 16), void 0 === e2 && (e2 = 16), this.maxKeyLength = t3, this.maxLengthPerKey = e2, this.hit = 0, this.miss = 0, this.caches = [];
          for (var r2 = 0; r2 < this.maxKeyLength; r2++)
            this.caches.push([]);
        }
        return t2.prototype.canBeCached = function(t3) {
          return t3 > 0 && t3 <= this.maxKeyLength;
        }, t2.prototype.get = function(t3, e2, r2) {
          var n2 = this.caches[r2 - 1], i2 = n2.length;
          t:
            for (var o2 = 0; o2 < i2; o2++) {
              for (var s2 = n2[o2], a2 = s2.bytes, h3 = 0; h3 < r2; h3++)
                if (a2[h3] !== t3[e2 + h3])
                  continue t;
              return s2.value;
            }
          return null;
        }, t2.prototype.store = function(t3, e2) {
          var r2 = this.caches[t3.length - 1], n2 = { bytes: t3, value: e2 };
          r2.length >= this.maxLengthPerKey ? r2[Math.random() * r2.length | 0] = n2 : r2.push(n2);
        }, t2.prototype.decode = function(t3, e2, r2) {
          var n2 = this.get(t3, e2, r2);
          if (null != n2)
            return this.hit++, n2;
          this.miss++;
          var i2 = c(t3, e2, r2), o2 = Uint8Array.prototype.slice.call(t3, e2, e2 + r2);
          return this.store(o2, i2), i2;
        }, t2;
      }(), k2 = function(t2, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, o2) {
          function s2(t3) {
            try {
              h3(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              h3(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function h3(t3) {
            var e3;
            t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          h3((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, z2 = function(t2, e2) {
        var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return s2.label++, { value: o4[1], done: false };
                    case 5:
                      s2.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        s2 = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        s2.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && s2.label < i2[1]) {
                        s2.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && s2.label < i2[2]) {
                        s2.label = i2[2], s2.ops.push(o4);
                        break;
                      }
                      i2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  o4 = e2.call(t2, s2);
                } catch (t3) {
                  o4 = [6, t3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
              if (5 & o4[0])
                throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }, D2 = function(t2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var e2, r2 = t2[Symbol.asyncIterator];
        return r2 ? r2.call(t2) : (t2 = "function" == typeof __values ? __values(t2) : t2[Symbol.iterator](), e2 = {}, n2("next"), n2("throw"), n2("return"), e2[Symbol.asyncIterator] = function() {
          return this;
        }, e2);
        function n2(r3) {
          e2[r3] = t2[r3] && function(e3) {
            return new Promise(function(n3, i2) {
              (function(t3, e4, r4, n4) {
                Promise.resolve(n4).then(function(e5) {
                  t3({ value: e5, done: r4 });
                }, e4);
              })(n3, i2, (e3 = t2[r3](e3)).done, e3.value);
            });
          };
        }
      }, N2 = function(t2) {
        return this instanceof N2 ? (this.v = t2, this) : new N2(t2);
      }, C2 = function(t2, e2, r2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var n2, i2 = r2.apply(t2, e2 || []), o2 = [];
        return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
          return this;
        }, n2;
        function s2(t3) {
          i2[t3] && (n2[t3] = function(e3) {
            return new Promise(function(r3, n3) {
              o2.push([t3, e3, r3, n3]) > 1 || a2(t3, e3);
            });
          });
        }
        function a2(t3, e3) {
          try {
            (r3 = i2[t3](e3)).value instanceof N2 ? Promise.resolve(r3.value.v).then(h3, u3) : c2(o2[0][2], r3);
          } catch (t4) {
            c2(o2[0][3], t4);
          }
          var r3;
        }
        function h3(t3) {
          a2("next", t3);
        }
        function u3(t3) {
          a2("throw", t3);
        }
        function c2(t3, e3) {
          t3(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
        }
      }, P2 = new DataView(new ArrayBuffer(0)), F2 = new Uint8Array(P2.buffer), j2 = function() {
        try {
          P2.getInt8(0);
        } catch (t2) {
          return t2.constructor;
        }
        throw new Error("never reached");
      }(), _ = new j2("Insufficient data"), W2 = new M(), O2 = function() {
        function t2(t3, e2, r2, n2, i2, o2, s2, a2) {
          void 0 === t3 && (t3 = S2.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 4294967295), void 0 === n2 && (n2 = 4294967295), void 0 === i2 && (i2 = 4294967295), void 0 === o2 && (o2 = 4294967295), void 0 === s2 && (s2 = 4294967295), void 0 === a2 && (a2 = W2), this.extensionCodec = t3, this.context = e2, this.maxStrLength = r2, this.maxBinLength = n2, this.maxArrayLength = i2, this.maxMapLength = o2, this.maxExtLength = s2, this.keyDecoder = a2, this.totalPos = 0, this.pos = 0, this.view = P2, this.bytes = F2, this.headByte = -1, this.stack = [];
        }
        return t2.prototype.reinitializeState = function() {
          this.totalPos = 0, this.headByte = -1;
        }, t2.prototype.setBuffer = function(t3) {
          this.bytes = B(t3), this.view = function(t4) {
            if (t4 instanceof ArrayBuffer)
              return new DataView(t4);
            var e2 = B(t4);
            return new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
          }(this.bytes), this.pos = 0;
        }, t2.prototype.appendBuffer = function(t3) {
          if (-1 !== this.headByte || this.hasRemaining()) {
            var e2 = this.bytes.subarray(this.pos), r2 = B(t3), n2 = new Uint8Array(e2.length + r2.length);
            n2.set(e2), n2.set(r2, e2.length), this.setBuffer(n2);
          } else
            this.setBuffer(t3);
        }, t2.prototype.hasRemaining = function(t3) {
          return void 0 === t3 && (t3 = 1), this.view.byteLength - this.pos >= t3;
        }, t2.prototype.createNoExtraBytesError = function(t3) {
          var e2 = this.view, r2 = this.pos;
          return new RangeError("Extra " + (e2.byteLength - r2) + " of " + e2.byteLength + " byte(s) found at buffer[" + t3 + "]");
        }, t2.prototype.decode = function(t3) {
          return this.reinitializeState(), this.setBuffer(t3), this.doDecodeSingleSync();
        }, t2.prototype.doDecodeSingleSync = function() {
          var t3 = this.doDecodeSync();
          if (this.hasRemaining())
            throw this.createNoExtraBytesError(this.pos);
          return t3;
        }, t2.prototype.decodeAsync = function(t3) {
          var e2, r2, n2, i2;
          return k2(this, void 0, void 0, function() {
            var o2, s2, a2, h3, u3, c2, f3, l3;
            return z2(this, function(p3) {
              switch (p3.label) {
                case 0:
                  o2 = false, p3.label = 1;
                case 1:
                  p3.trys.push([1, 6, 7, 12]), e2 = D2(t3), p3.label = 2;
                case 2:
                  return [4, e2.next()];
                case 3:
                  if ((r2 = p3.sent()).done)
                    return [3, 5];
                  if (a2 = r2.value, o2)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(a2);
                  try {
                    s2 = this.doDecodeSync(), o2 = true;
                  } catch (t4) {
                    if (!(t4 instanceof j2))
                      throw t4;
                  }
                  this.totalPos += this.pos, p3.label = 4;
                case 4:
                  return [3, 2];
                case 5:
                  return [3, 12];
                case 6:
                  return h3 = p3.sent(), n2 = { error: h3 }, [3, 12];
                case 7:
                  return p3.trys.push([7, , 10, 11]), r2 && !r2.done && (i2 = e2.return) ? [4, i2.call(e2)] : [3, 9];
                case 8:
                  p3.sent(), p3.label = 9;
                case 9:
                  return [3, 11];
                case 10:
                  if (n2)
                    throw n2.error;
                  return [7];
                case 11:
                  return [7];
                case 12:
                  if (o2) {
                    if (this.hasRemaining())
                      throw this.createNoExtraBytesError(this.totalPos);
                    return [2, s2];
                  }
                  throw c2 = (u3 = this).headByte, f3 = u3.pos, l3 = u3.totalPos, new RangeError("Insufficient data in parcing " + L2(c2) + " at " + l3 + " (" + f3 + " in the current buffer)");
              }
            });
          });
        }, t2.prototype.decodeArrayStream = function(t3) {
          return this.decodeMultiAsync(t3, true);
        }, t2.prototype.decodeStream = function(t3) {
          return this.decodeMultiAsync(t3, false);
        }, t2.prototype.decodeMultiAsync = function(t3, e2) {
          return C2(this, arguments, function() {
            var r2, n2, i2, o2, s2, a2, h3, u3, c2;
            return z2(this, function(f3) {
              switch (f3.label) {
                case 0:
                  r2 = e2, n2 = -1, f3.label = 1;
                case 1:
                  f3.trys.push([1, 13, 14, 19]), i2 = D2(t3), f3.label = 2;
                case 2:
                  return [4, N2(i2.next())];
                case 3:
                  if ((o2 = f3.sent()).done)
                    return [3, 12];
                  if (s2 = o2.value, e2 && 0 === n2)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(s2), r2 && (n2 = this.readArraySize(), r2 = false, this.complete()), f3.label = 4;
                case 4:
                  f3.trys.push([4, 9, , 10]), f3.label = 5;
                case 5:
                  return [4, N2(this.doDecodeSync())];
                case 6:
                  return [4, f3.sent()];
                case 7:
                  return f3.sent(), 0 == --n2 ? [3, 8] : [3, 5];
                case 8:
                  return [3, 10];
                case 9:
                  if (!((a2 = f3.sent()) instanceof j2))
                    throw a2;
                  return [3, 10];
                case 10:
                  this.totalPos += this.pos, f3.label = 11;
                case 11:
                  return [3, 2];
                case 12:
                  return [3, 19];
                case 13:
                  return h3 = f3.sent(), u3 = { error: h3 }, [3, 19];
                case 14:
                  return f3.trys.push([14, , 17, 18]), o2 && !o2.done && (c2 = i2.return) ? [4, N2(c2.call(i2))] : [3, 16];
                case 15:
                  f3.sent(), f3.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  if (u3)
                    throw u3.error;
                  return [7];
                case 18:
                  return [7];
                case 19:
                  return [2];
              }
            });
          });
        }, t2.prototype.doDecodeSync = function() {
          t:
            for (; ; ) {
              var t3 = this.readHeadByte(), e2 = void 0;
              if (t3 >= 224)
                e2 = t3 - 256;
              else if (t3 < 192)
                if (t3 < 128)
                  e2 = t3;
                else if (t3 < 144) {
                  if (0 !== (n2 = t3 - 128)) {
                    this.pushMapState(n2), this.complete();
                    continue t;
                  }
                  e2 = {};
                } else if (t3 < 160) {
                  if (0 !== (n2 = t3 - 144)) {
                    this.pushArrayState(n2), this.complete();
                    continue t;
                  }
                  e2 = [];
                } else {
                  var r2 = t3 - 160;
                  e2 = this.decodeUtf8String(r2, 0);
                }
              else if (192 === t3)
                e2 = null;
              else if (194 === t3)
                e2 = false;
              else if (195 === t3)
                e2 = true;
              else if (202 === t3)
                e2 = this.readF32();
              else if (203 === t3)
                e2 = this.readF64();
              else if (204 === t3)
                e2 = this.readU8();
              else if (205 === t3)
                e2 = this.readU16();
              else if (206 === t3)
                e2 = this.readU32();
              else if (207 === t3)
                e2 = this.readU64();
              else if (208 === t3)
                e2 = this.readI8();
              else if (209 === t3)
                e2 = this.readI16();
              else if (210 === t3)
                e2 = this.readI32();
              else if (211 === t3)
                e2 = this.readI64();
              else if (217 === t3) {
                r2 = this.lookU8();
                e2 = this.decodeUtf8String(r2, 1);
              } else if (218 === t3) {
                r2 = this.lookU16();
                e2 = this.decodeUtf8String(r2, 2);
              } else if (219 === t3) {
                r2 = this.lookU32();
                e2 = this.decodeUtf8String(r2, 4);
              } else if (220 === t3) {
                if (0 !== (n2 = this.readU16())) {
                  this.pushArrayState(n2), this.complete();
                  continue t;
                }
                e2 = [];
              } else if (221 === t3) {
                if (0 !== (n2 = this.readU32())) {
                  this.pushArrayState(n2), this.complete();
                  continue t;
                }
                e2 = [];
              } else if (222 === t3) {
                if (0 !== (n2 = this.readU16())) {
                  this.pushMapState(n2), this.complete();
                  continue t;
                }
                e2 = {};
              } else if (223 === t3) {
                if (0 !== (n2 = this.readU32())) {
                  this.pushMapState(n2), this.complete();
                  continue t;
                }
                e2 = {};
              } else if (196 === t3) {
                var n2 = this.lookU8();
                e2 = this.decodeBinary(n2, 1);
              } else if (197 === t3) {
                n2 = this.lookU16();
                e2 = this.decodeBinary(n2, 2);
              } else if (198 === t3) {
                n2 = this.lookU32();
                e2 = this.decodeBinary(n2, 4);
              } else if (212 === t3)
                e2 = this.decodeExtension(1, 0);
              else if (213 === t3)
                e2 = this.decodeExtension(2, 0);
              else if (214 === t3)
                e2 = this.decodeExtension(4, 0);
              else if (215 === t3)
                e2 = this.decodeExtension(8, 0);
              else if (216 === t3)
                e2 = this.decodeExtension(16, 0);
              else if (199 === t3) {
                n2 = this.lookU8();
                e2 = this.decodeExtension(n2, 1);
              } else if (200 === t3) {
                n2 = this.lookU16();
                e2 = this.decodeExtension(n2, 2);
              } else {
                if (201 !== t3)
                  throw new Error("Unrecognized type byte: " + L2(t3));
                n2 = this.lookU32();
                e2 = this.decodeExtension(n2, 4);
              }
              this.complete();
              for (var i2 = this.stack; i2.length > 0; ) {
                var o2 = i2[i2.length - 1];
                if (0 === o2.type) {
                  if (o2.array[o2.position] = e2, o2.position++, o2.position !== o2.size)
                    continue t;
                  i2.pop(), e2 = o2.array;
                } else {
                  if (1 === o2.type) {
                    if (s2 = void 0, "string" !== (s2 = typeof e2) && "number" !== s2)
                      throw new Error("The type of key must be string or number but " + typeof e2);
                    o2.key = e2, o2.type = 2;
                    continue t;
                  }
                  if (o2.map[o2.key] = e2, o2.readCount++, o2.readCount !== o2.size) {
                    o2.key = null, o2.type = 1;
                    continue t;
                  }
                  i2.pop(), e2 = o2.map;
                }
              }
              return e2;
            }
          var s2;
        }, t2.prototype.readHeadByte = function() {
          return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
        }, t2.prototype.complete = function() {
          this.headByte = -1;
        }, t2.prototype.readArraySize = function() {
          var t3 = this.readHeadByte();
          switch (t3) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default:
              if (t3 < 160)
                return t3 - 144;
              throw new Error("Unrecognized array type byte: " + L2(t3));
          }
        }, t2.prototype.pushMapState = function(t3) {
          if (t3 > this.maxMapLength)
            throw new Error("Max length exceeded: map length (" + t3 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
          this.stack.push({ type: 1, size: t3, key: null, readCount: 0, map: {} });
        }, t2.prototype.pushArrayState = function(t3) {
          if (t3 > this.maxArrayLength)
            throw new Error("Max length exceeded: array length (" + t3 + ") > maxArrayLength (" + this.maxArrayLength + ")");
          this.stack.push({ type: 0, size: t3, array: new Array(t3), position: 0 });
        }, t2.prototype.decodeUtf8String = function(t3, e2) {
          var r2;
          if (t3 > this.maxStrLength)
            throw new Error("Max length exceeded: UTF-8 byte length (" + t3 + ") > maxStrLength (" + this.maxStrLength + ")");
          if (this.bytes.byteLength < this.pos + e2 + t3)
            throw _;
          var n2, i2 = this.pos + e2;
          return n2 = this.stateIsMapKey() && (null === (r2 = this.keyDecoder) || void 0 === r2 ? void 0 : r2.canBeCached(t3)) ? this.keyDecoder.decode(this.bytes, i2, t3) : o && t3 > l2 ? function(t4, e3, r3) {
            var n3 = t4.subarray(e3, e3 + r3);
            return f2.decode(n3);
          }(this.bytes, i2, t3) : c(this.bytes, i2, t3), this.pos += e2 + t3, n2;
        }, t2.prototype.stateIsMapKey = function() {
          return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
        }, t2.prototype.decodeBinary = function(t3, e2) {
          if (t3 > this.maxBinLength)
            throw new Error("Max length exceeded: bin length (" + t3 + ") > maxBinLength (" + this.maxBinLength + ")");
          if (!this.hasRemaining(t3 + e2))
            throw _;
          var r2 = this.pos + e2, n2 = this.bytes.subarray(r2, r2 + t3);
          return this.pos += e2 + t3, n2;
        }, t2.prototype.decodeExtension = function(t3, e2) {
          if (t3 > this.maxExtLength)
            throw new Error("Max length exceeded: ext length (" + t3 + ") > maxExtLength (" + this.maxExtLength + ")");
          var r2 = this.view.getInt8(this.pos + e2), n2 = this.decodeBinary(t3, e2 + 1);
          return this.extensionCodec.decode(n2, r2, this.context);
        }, t2.prototype.lookU8 = function() {
          return this.view.getUint8(this.pos);
        }, t2.prototype.lookU16 = function() {
          return this.view.getUint16(this.pos);
        }, t2.prototype.lookU32 = function() {
          return this.view.getUint32(this.pos);
        }, t2.prototype.readU8 = function() {
          var t3 = this.view.getUint8(this.pos);
          return this.pos++, t3;
        }, t2.prototype.readI8 = function() {
          var t3 = this.view.getInt8(this.pos);
          return this.pos++, t3;
        }, t2.prototype.readU16 = function() {
          var t3 = this.view.getUint16(this.pos);
          return this.pos += 2, t3;
        }, t2.prototype.readI16 = function() {
          var t3 = this.view.getInt16(this.pos);
          return this.pos += 2, t3;
        }, t2.prototype.readU32 = function() {
          var t3 = this.view.getUint32(this.pos);
          return this.pos += 4, t3;
        }, t2.prototype.readI32 = function() {
          var t3 = this.view.getInt32(this.pos);
          return this.pos += 4, t3;
        }, t2.prototype.readU64 = function() {
          var t3, e2, r2, n2, i2 = (t3 = this.view, e2 = this.pos, r2 = t3.getUint32(e2), n2 = t3.getUint32(e2 + 4), r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2);
          return this.pos += 8, i2;
        }, t2.prototype.readI64 = function() {
          var t3 = y2(this.view, this.pos);
          return this.pos += 8, t3;
        }, t2.prototype.readF32 = function() {
          var t3 = this.view.getFloat32(this.pos);
          return this.pos += 4, t3;
        }, t2.prototype.readF64 = function() {
          var t3 = this.view.getFloat64(this.pos);
          return this.pos += 8, t3;
        }, t2;
      }(), R2 = {};
      function V2(t2, e2) {
        return void 0 === e2 && (e2 = R2), new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decode(t2);
      }
      var K2 = function(t2, e2) {
        var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return s2.label++, { value: o4[1], done: false };
                    case 5:
                      s2.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        s2 = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        s2.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && s2.label < i2[1]) {
                        s2.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && s2.label < i2[2]) {
                        s2.label = i2[2], s2.ops.push(o4);
                        break;
                      }
                      i2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  o4 = e2.call(t2, s2);
                } catch (t3) {
                  o4 = [6, t3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
              if (5 & o4[0])
                throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }, G = function(t2) {
        return this instanceof G ? (this.v = t2, this) : new G(t2);
      }, H2 = function(t2, e2, r2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var n2, i2 = r2.apply(t2, e2 || []), o2 = [];
        return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
          return this;
        }, n2;
        function s2(t3) {
          i2[t3] && (n2[t3] = function(e3) {
            return new Promise(function(r3, n3) {
              o2.push([t3, e3, r3, n3]) > 1 || a2(t3, e3);
            });
          });
        }
        function a2(t3, e3) {
          try {
            (r3 = i2[t3](e3)).value instanceof G ? Promise.resolve(r3.value.v).then(h3, u3) : c2(o2[0][2], r3);
          } catch (t4) {
            c2(o2[0][3], t4);
          }
          var r3;
        }
        function h3(t3) {
          a2("next", t3);
        }
        function u3(t3) {
          a2("throw", t3);
        }
        function c2(t3, e3) {
          t3(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
        }
      };
      function X(t2) {
        if (null == t2)
          throw new Error("Assertion Failure: value must not be null nor undefined");
      }
      function q(t2) {
        return null != t2[Symbol.asyncIterator] ? t2 : function(t3) {
          return H2(this, arguments, function() {
            var e2, r2, n2, i2;
            return K2(this, function(o2) {
              switch (o2.label) {
                case 0:
                  e2 = t3.getReader(), o2.label = 1;
                case 1:
                  o2.trys.push([1, , 9, 10]), o2.label = 2;
                case 2:
                  return [4, G(e2.read())];
                case 3:
                  return r2 = o2.sent(), n2 = r2.done, i2 = r2.value, n2 ? [4, G(void 0)] : [3, 5];
                case 4:
                  return [2, o2.sent()];
                case 5:
                  return X(i2), [4, G(i2)];
                case 6:
                  return [4, o2.sent()];
                case 7:
                  return o2.sent(), [3, 2];
                case 8:
                  return [3, 10];
                case 9:
                  return e2.releaseLock(), [7];
                case 10:
                  return [2];
              }
            });
          });
        }(t2);
      }
      var J2 = function(t2, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, o2) {
          function s2(t3) {
            try {
              h3(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              h3(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function h3(t3) {
            var e3;
            t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          h3((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, Q = function(t2, e2) {
        var r2, n2, i2, o2, s2 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                    case 0:
                    case 1:
                      i2 = o4;
                      break;
                    case 4:
                      return s2.label++, { value: o4[1], done: false };
                    case 5:
                      s2.label++, n2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                        s2 = 0;
                        continue;
                      }
                      if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                        s2.label = o4[1];
                        break;
                      }
                      if (6 === o4[0] && s2.label < i2[1]) {
                        s2.label = i2[1], i2 = o4;
                        break;
                      }
                      if (i2 && s2.label < i2[2]) {
                        s2.label = i2[2], s2.ops.push(o4);
                        break;
                      }
                      i2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  o4 = e2.call(t2, s2);
                } catch (t3) {
                  o4 = [6, t3], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
              if (5 & o4[0])
                throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      };
      function Y(t2, e2) {
        return void 0 === e2 && (e2 = R2), J2(this, void 0, void 0, function() {
          var r2;
          return Q(this, function(n2) {
            return r2 = q(t2), [2, new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeAsync(r2)];
          });
        });
      }
      function Z(t2, e2) {
        void 0 === e2 && (e2 = R2);
        var r2 = q(t2);
        return new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeArrayStream(r2);
      }
      function $(t2, e2) {
        void 0 === e2 && (e2 = R2);
        var r2 = q(t2);
        return new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeStream(r2);
      }
    }]);
  });
})(msgpack_min);
var msgpack_minExports = msgpack_min.exports;
const ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function containsEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0) {
        return { containsEmpty: true, firstEmptyKey: key };
      }
    }
  }
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function rawEncode(obj) {
  const options = { sortKeys: true };
  return msgpack_minExports.encode(obj, options);
}
function encode(obj) {
  const emptyCheck = containsEmpty(obj);
  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  }
  return rawEncode(obj);
}
function decode$1(buffer2) {
  return msgpack_minExports.decode(buffer2);
}
function translateBoxReference(reference, foreignApps, appIndex) {
  const referenceId = reference.appIndex;
  const referenceName = reference.name;
  const isOwnReference = referenceId === 0 || referenceId === appIndex;
  let index2 = 0;
  if (foreignApps != null) {
    index2 = foreignApps.indexOf(referenceId) + 1;
  }
  if (index2 === 0 && !isOwnReference) {
    throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
  }
  return { i: index2, n: referenceName };
}
function translateBoxReferences(references, foreignApps, appIndex) {
  if (references == null)
    return [];
  return references.map((bx) => translateBoxReference(bx, foreignApps, appIndex));
}
var TransactionType;
(function(TransactionType2) {
  TransactionType2["pay"] = "pay";
  TransactionType2["keyreg"] = "keyreg";
  TransactionType2["acfg"] = "acfg";
  TransactionType2["axfer"] = "axfer";
  TransactionType2["afrz"] = "afrz";
  TransactionType2["appl"] = "appl";
  TransactionType2["stpf"] = "stpf";
})(TransactionType || (TransactionType = {}));
function isTransactionType(s) {
  return s === TransactionType.pay || s === TransactionType.keyreg || s === TransactionType.acfg || s === TransactionType.axfer || s === TransactionType.afrz || s === TransactionType.appl || s === TransactionType.stpf;
}
var OnApplicationComplete;
(function(OnApplicationComplete2) {
  OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
  OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
  OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
  OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
  OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
  OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
})(OnApplicationComplete || (OnApplicationComplete = {}));
const ALGORAND_TRANSACTION_LENGTH = 52;
const ALGORAND_MIN_TX_FEE = 1e3;
const ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
const ALGORAND_MAX_ASSET_DECIMALS = 19;
const NUM_ADDL_BYTES_AFTER_SIGNING = 75;
const ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH = 5;
const ALGORAND_TRANSACTION_ADDRESS_LENGTH = 32;
const ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH = 5;
const ASSET_METADATA_HASH_LENGTH = 32;
const KEYREG_VOTE_KEY_LENGTH = 32;
const KEYREG_SELECTION_KEY_LENGTH = 32;
const KEYREG_STATE_PROOF_KEY_LENGTH = 64;
function getKeyregKey(input, inputName, length) {
  if (input == null) {
    return void 0;
  }
  let inputAsBuffer;
  if (typeof input === "string") {
    inputAsBuffer = buffer.Buffer.from(input, "base64");
  } else if (input.constructor === Uint8Array) {
    inputAsBuffer = buffer.Buffer.from(input);
  } else if (buffer.Buffer.isBuffer(input)) {
    inputAsBuffer = input;
  }
  if (inputAsBuffer == null || inputAsBuffer.byteLength !== length) {
    throw Error(`${inputName} must be a ${length} byte Uint8Array or Buffer or base64 string.`);
  }
  return inputAsBuffer;
}
let Transaction$1 = class Transaction {
  constructor({ ...transaction2 }) {
    this.name = "Transaction";
    this.tag = buffer.Buffer.from("TX");
    const defaults = {
      type: TransactionType.pay,
      flatFee: false,
      nonParticipation: false
    };
    if (typeof transaction2.type === "undefined") {
      transaction2.type = defaults.type;
    }
    if (typeof transaction2.flatFee === "undefined") {
      transaction2.flatFee = defaults.flatFee;
    }
    if (transaction2.type === TransactionType.keyreg && typeof transaction2.voteKey !== "undefined" && typeof transaction2.nonParticipation === "undefined") {
      transaction2.nonParticipation = defaults.nonParticipation;
    }
    if (transaction2.suggestedParams !== void 0) {
      const reference = transaction2;
      reference.genesisHash = reference.suggestedParams.genesisHash;
      reference.fee = reference.suggestedParams.fee;
      if (reference.suggestedParams.flatFee !== void 0)
        reference.flatFee = reference.suggestedParams.flatFee;
      reference.firstRound = reference.suggestedParams.firstRound;
      reference.lastRound = reference.suggestedParams.lastRound;
      reference.genesisID = reference.suggestedParams.genesisID;
    }
    const txn = transaction2;
    txn.from = decodeAddress(txn.from);
    if (txn.to !== void 0)
      txn.to = decodeAddress(txn.to);
    if (txn.closeRemainderTo !== void 0)
      txn.closeRemainderTo = decodeAddress(txn.closeRemainderTo);
    if (txn.assetManager !== void 0)
      txn.assetManager = decodeAddress(txn.assetManager);
    if (txn.assetReserve !== void 0)
      txn.assetReserve = decodeAddress(txn.assetReserve);
    if (txn.assetFreeze !== void 0)
      txn.assetFreeze = decodeAddress(txn.assetFreeze);
    if (txn.assetClawback !== void 0)
      txn.assetClawback = decodeAddress(txn.assetClawback);
    if (txn.assetRevocationTarget !== void 0)
      txn.assetRevocationTarget = decodeAddress(txn.assetRevocationTarget);
    if (txn.freezeAccount !== void 0)
      txn.freezeAccount = decodeAddress(txn.freezeAccount);
    if (txn.reKeyTo !== void 0)
      txn.reKeyTo = decodeAddress(txn.reKeyTo);
    if (txn.genesisHash === void 0)
      throw Error("genesis hash must be specified and in a base64 string.");
    txn.genesisHash = buffer.Buffer.from(txn.genesisHash, "base64");
    if (txn.amount !== void 0 && (!(Number.isSafeInteger(txn.amount) || typeof txn.amount === "bigint" && txn.amount <= BigInt("0xffffffffffffffff")) || txn.amount < 0))
      throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (!Number.isSafeInteger(txn.fee) || txn.fee < 0)
      throw Error("fee must be a positive number and smaller than 2^53-1");
    if (!Number.isSafeInteger(txn.firstRound) || txn.firstRound < 0)
      throw Error("firstRound must be a positive number");
    if (!Number.isSafeInteger(txn.lastRound) || txn.lastRound < 0)
      throw Error("lastRound must be a positive number");
    if (txn.extraPages !== void 0 && (!Number.isInteger(txn.extraPages) || txn.extraPages < 0 || txn.extraPages > 3))
      throw Error("extraPages must be an Integer between and including 0 to 3");
    if (txn.assetTotal !== void 0 && (!(Number.isSafeInteger(txn.assetTotal) || typeof txn.assetTotal === "bigint" && txn.assetTotal <= BigInt("0xffffffffffffffff")) || txn.assetTotal < 0))
      throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (txn.assetDecimals !== void 0 && (!Number.isSafeInteger(txn.assetDecimals) || txn.assetDecimals < 0 || txn.assetDecimals > ALGORAND_MAX_ASSET_DECIMALS))
      throw Error(`assetDecimals must be a positive number and smaller than ${ALGORAND_MAX_ASSET_DECIMALS.toString()}`);
    if (txn.assetIndex !== void 0 && (!Number.isSafeInteger(txn.assetIndex) || txn.assetIndex < 0))
      throw Error("Asset index must be a positive number and smaller than 2^53-1");
    if (txn.appIndex !== void 0 && (!Number.isSafeInteger(txn.appIndex) || txn.appIndex < 0))
      throw Error("Application index must be a positive number and smaller than 2^53-1");
    if (txn.appLocalInts !== void 0 && (!Number.isSafeInteger(txn.appLocalInts) || txn.appLocalInts < 0))
      throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
    if (txn.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appLocalByteSlices) || txn.appLocalByteSlices < 0))
      throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalInts !== void 0 && (!Number.isSafeInteger(txn.appGlobalInts) || txn.appGlobalInts < 0))
      throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appGlobalByteSlices) || txn.appGlobalByteSlices < 0))
      throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appApprovalProgram !== void 0) {
      if (txn.appApprovalProgram.constructor !== Uint8Array)
        throw Error("appApprovalProgram must be a Uint8Array.");
    }
    if (txn.appClearProgram !== void 0) {
      if (txn.appClearProgram.constructor !== Uint8Array)
        throw Error("appClearProgram must be a Uint8Array.");
    }
    if (txn.appArgs !== void 0) {
      if (!Array.isArray(txn.appArgs))
        throw Error("appArgs must be an Array of Uint8Array.");
      txn.appArgs = txn.appArgs.slice();
      txn.appArgs.forEach((arg) => {
        if (arg.constructor !== Uint8Array)
          throw Error("each element of AppArgs must be a Uint8Array.");
      });
    } else {
      txn.appArgs = [];
    }
    if (txn.appAccounts !== void 0) {
      if (!Array.isArray(txn.appAccounts))
        throw Error("appAccounts must be an Array of addresses.");
      txn.appAccounts = txn.appAccounts.map((addressAsString) => decodeAddress(addressAsString));
    }
    if (txn.appForeignApps !== void 0) {
      if (!Array.isArray(txn.appForeignApps))
        throw Error("appForeignApps must be an Array of integers.");
      txn.appForeignApps = txn.appForeignApps.slice();
      txn.appForeignApps.forEach((foreignAppIndex) => {
        if (!Number.isSafeInteger(foreignAppIndex) || foreignAppIndex < 0)
          throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.appForeignAssets !== void 0) {
      if (!Array.isArray(txn.appForeignAssets))
        throw Error("appForeignAssets must be an Array of integers.");
      txn.appForeignAssets = txn.appForeignAssets.slice();
      txn.appForeignAssets.forEach((foreignAssetIndex) => {
        if (!Number.isSafeInteger(foreignAssetIndex) || foreignAssetIndex < 0)
          throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.boxes !== void 0) {
      if (!Array.isArray(txn.boxes))
        throw Error("boxes must be an Array of BoxReference.");
      txn.boxes = txn.boxes.slice();
      txn.boxes.forEach((box2) => {
        if (!Number.isSafeInteger(box2.appIndex) || box2.name.constructor !== Uint8Array)
          throw Error("box app index must be a number and name must be an Uint8Array.");
      });
    }
    if (txn.assetMetadataHash !== void 0 && txn.assetMetadataHash.length !== 0) {
      if (typeof txn.assetMetadataHash === "string") {
        txn.assetMetadataHash = new Uint8Array(buffer.Buffer.from(txn.assetMetadataHash));
      }
      if (txn.assetMetadataHash.constructor !== Uint8Array || txn.assetMetadataHash.byteLength !== ASSET_METADATA_HASH_LENGTH) {
        throw Error(`assetMetadataHash must be a ${ASSET_METADATA_HASH_LENGTH} byte Uint8Array or string.`);
      }
      if (txn.assetMetadataHash.every((value) => value === 0)) {
        txn.assetMetadataHash = void 0;
      }
    } else {
      txn.assetMetadataHash = void 0;
    }
    if (txn.note !== void 0) {
      if (txn.note.constructor !== Uint8Array)
        throw Error("note must be a Uint8Array.");
    } else {
      txn.note = new Uint8Array(0);
    }
    if (txn.lease !== void 0) {
      if (txn.lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (txn.lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      if (txn.lease.every((value) => value === 0)) {
        txn.lease = new Uint8Array(0);
      }
    } else {
      txn.lease = new Uint8Array(0);
    }
    txn.voteKey = getKeyregKey(txn.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH);
    txn.selectionKey = getKeyregKey(txn.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH);
    txn.stateProofKey = getKeyregKey(txn.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH);
    if (txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.stateProofKey || txn.voteLast || txn.voteKeyDilution)) {
      throw new Error("nonParticipation is true but participation params are present.");
    }
    if (!txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.stateProofKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution) && !(txn.voteKey && txn.selectionKey && txn.voteFirst && txn.voteLast && txn.voteKeyDilution)) {
      throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
    }
    delete txn.suggestedParams;
    Object.assign(this, removeUndefinedProperties(txn));
    if (!txn.flatFee) {
      this.fee *= this.estimateSize();
      if (this.fee < ALGORAND_MIN_TX_FEE) {
        this.fee = ALGORAND_MIN_TX_FEE;
      }
    }
    this.group = void 0;
    if (txn.stateProofType !== void 0 && (!Number.isSafeInteger(txn.stateProofType) || txn.stateProofType < 0))
      throw Error("State Proof type must be a positive number and smaller than 2^53-1");
    if (txn.stateProofMessage !== void 0) {
      if (txn.stateProofMessage.constructor !== Uint8Array)
        throw Error("stateProofMessage must be a Uint8Array.");
    } else {
      txn.stateProofMessage = new Uint8Array(0);
    }
    if (txn.stateProof !== void 0) {
      if (txn.stateProof.constructor !== Uint8Array)
        throw Error("stateProof must be a Uint8Array.");
    } else {
      txn.stateProof = new Uint8Array(0);
    }
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    if (this.type === "pay") {
      const txn = {
        amt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: "pay",
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group
      };
      if (this.closeRemainderTo !== void 0 && encodeAddress(this.closeRemainderTo.publicKey) !== ALGORAND_ZERO_ADDRESS_STRING) {
        txn.close = buffer.Buffer.from(this.closeRemainderTo.publicKey);
      }
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.to !== void 0)
        txn.rcv = buffer.Buffer.from(this.to.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.rekey)
        delete txn.rekey;
      return txn;
    }
    if (this.type === "keyreg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        votekey: this.voteKey,
        selkey: this.selectionKey,
        sprfkey: this.stateProofKey,
        votefst: this.voteFirst,
        votelst: this.voteLast,
        votekd: this.voteKeyDilution
      };
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.nonParticipation) {
        txn.nonpart = true;
      }
      if (!txn.selkey)
        delete txn.selkey;
      if (!txn.votekey)
        delete txn.votekey;
      if (!txn.sprfkey)
        delete txn.sprfkey;
      if (!txn.votefst)
        delete txn.votefst;
      if (!txn.votelst)
        delete txn.votelst;
      if (!txn.votekd)
        delete txn.votekd;
      return txn;
    }
    if (this.type === "acfg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        caid: this.assetIndex,
        apar: {
          t: this.assetTotal,
          df: this.assetDefaultFrozen,
          dc: this.assetDecimals
        }
      };
      if (this.assetManager !== void 0)
        txn.apar.m = buffer.Buffer.from(this.assetManager.publicKey);
      if (this.assetReserve !== void 0)
        txn.apar.r = buffer.Buffer.from(this.assetReserve.publicKey);
      if (this.assetFreeze !== void 0)
        txn.apar.f = buffer.Buffer.from(this.assetFreeze.publicKey);
      if (this.assetClawback !== void 0)
        txn.apar.c = buffer.Buffer.from(this.assetClawback.publicKey);
      if (this.assetName !== void 0)
        txn.apar.an = this.assetName;
      if (this.assetUnitName !== void 0)
        txn.apar.un = this.assetUnitName;
      if (this.assetURL !== void 0)
        txn.apar.au = this.assetURL;
      if (this.assetMetadataHash !== void 0)
        txn.apar.am = buffer.Buffer.from(this.assetMetadataHash);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (!txn.caid)
        delete txn.caid;
      if (!txn.apar.t && !txn.apar.un && !txn.apar.an && !txn.apar.df && !txn.apar.m && !txn.apar.r && !txn.apar.f && !txn.apar.c && !txn.apar.au && !txn.apar.am && !txn.apar.dc) {
        delete txn.apar;
      } else {
        if (!txn.apar.t)
          delete txn.apar.t;
        if (!txn.apar.dc)
          delete txn.apar.dc;
        if (!txn.apar.un)
          delete txn.apar.un;
        if (!txn.apar.an)
          delete txn.apar.an;
        if (!txn.apar.df)
          delete txn.apar.df;
        if (!txn.apar.m)
          delete txn.apar.m;
        if (!txn.apar.r)
          delete txn.apar.r;
        if (!txn.apar.f)
          delete txn.apar.f;
        if (!txn.apar.c)
          delete txn.apar.c;
        if (!txn.apar.au)
          delete txn.apar.au;
        if (!txn.apar.am)
          delete txn.apar.am;
      }
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "axfer") {
      const txn = {
        aamt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        arcv: buffer.Buffer.from(this.to.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        xaid: this.assetIndex
      };
      if (this.closeRemainderTo !== void 0)
        txn.aclose = buffer.Buffer.from(this.closeRemainderTo.publicKey);
      if (this.assetRevocationTarget !== void 0)
        txn.asnd = buffer.Buffer.from(this.assetRevocationTarget.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.aamt)
        delete txn.aamt;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.aclose)
        delete txn.aclose;
      if (!txn.asnd)
        delete txn.asnd;
      if (!txn.rekey)
        delete txn.rekey;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "afrz") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        faid: this.assetIndex,
        afrz: this.freezeState
      };
      if (this.freezeAccount !== void 0)
        txn.fadd = buffer.Buffer.from(this.freezeAccount.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.afrz)
        delete txn.afrz;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "appl") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        apid: this.appIndex,
        apan: this.appOnComplete,
        apls: {
          nui: this.appLocalInts,
          nbs: this.appLocalByteSlices
        },
        apgs: {
          nui: this.appGlobalInts,
          nbs: this.appGlobalByteSlices
        },
        apfa: this.appForeignApps,
        apas: this.appForeignAssets,
        apep: this.extraPages,
        apbx: translateBoxReferences(this.boxes, this.appForeignApps, this.appIndex)
      };
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.appApprovalProgram !== void 0) {
        txn.apap = buffer.Buffer.from(this.appApprovalProgram);
      }
      if (this.appClearProgram !== void 0) {
        txn.apsu = buffer.Buffer.from(this.appClearProgram);
      }
      if (this.appArgs !== void 0) {
        txn.apaa = this.appArgs.map((arg) => buffer.Buffer.from(arg));
      }
      if (this.appAccounts !== void 0) {
        txn.apat = this.appAccounts.map((decodedAddress) => buffer.Buffer.from(decodedAddress.publicKey));
      }
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apls.nui)
        delete txn.apls.nui;
      if (!txn.apls.nbs)
        delete txn.apls.nbs;
      if (!txn.apls.nui && !txn.apls.nbs)
        delete txn.apls;
      if (!txn.apgs.nui)
        delete txn.apgs.nui;
      if (!txn.apgs.nbs)
        delete txn.apgs.nbs;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apgs.nui && !txn.apgs.nbs)
        delete txn.apgs;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      for (const box2 of txn.apbx) {
        if (!box2.i)
          delete box2.i;
        if (!box2.n || !box2.n.length)
          delete box2.n;
      }
      if (!txn.apbx || !txn.apbx.length)
        delete txn.apbx;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "stpf") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        sptype: this.stateProofType,
        spmsg: buffer.Buffer.from(this.stateProofMessage),
        sp: buffer.Buffer.from(this.stateProof)
      };
      if (!txn.sptype)
        delete txn.sptype;
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    return void 0;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txnForEnc) {
    const txn = Object.create(this.prototype);
    txn.name = "Transaction";
    txn.tag = buffer.Buffer.from("TX");
    txn.genesisID = txnForEnc.gen;
    txn.genesisHash = buffer.Buffer.from(txnForEnc.gh);
    if (!isTransactionType(txnForEnc.type)) {
      throw new Error(`Unrecognized transaction type: ${txnForEnc.type}`);
    }
    txn.type = txnForEnc.type;
    txn.fee = txnForEnc.fee;
    txn.firstRound = txnForEnc.fv;
    txn.lastRound = txnForEnc.lv;
    txn.note = new Uint8Array(txnForEnc.note);
    txn.lease = new Uint8Array(txnForEnc.lx);
    txn.from = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.snd)));
    if (txnForEnc.grp !== void 0)
      txn.group = buffer.Buffer.from(txnForEnc.grp);
    if (txnForEnc.rekey !== void 0)
      txn.reKeyTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rekey)));
    if (txnForEnc.type === "pay") {
      txn.amount = txnForEnc.amt;
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rcv)));
      if (txnForEnc.close !== void 0)
        txn.closeRemainderTo = decodeAddress(encodeAddress(txnForEnc.close));
    } else if (txnForEnc.type === "keyreg") {
      if (txnForEnc.votekey !== void 0) {
        txn.voteKey = buffer.Buffer.from(txnForEnc.votekey);
      }
      if (txnForEnc.selkey !== void 0) {
        txn.selectionKey = buffer.Buffer.from(txnForEnc.selkey);
      }
      if (txnForEnc.sprfkey !== void 0) {
        txn.stateProofKey = buffer.Buffer.from(txnForEnc.sprfkey);
      }
      if (txnForEnc.votekd !== void 0) {
        txn.voteKeyDilution = txnForEnc.votekd;
      }
      if (txnForEnc.votefst !== void 0) {
        txn.voteFirst = txnForEnc.votefst;
      }
      if (txnForEnc.votelst !== void 0) {
        txn.voteLast = txnForEnc.votelst;
      }
      if (txnForEnc.nonpart !== void 0) {
        txn.nonParticipation = txnForEnc.nonpart;
      }
    } else if (txnForEnc.type === "acfg") {
      if (txnForEnc.caid !== void 0) {
        txn.assetIndex = txnForEnc.caid;
      }
      if (txnForEnc.apar !== void 0) {
        txn.assetTotal = txnForEnc.apar.t;
        txn.assetDefaultFrozen = txnForEnc.apar.df;
        if (txnForEnc.apar.dc !== void 0)
          txn.assetDecimals = txnForEnc.apar.dc;
        if (txnForEnc.apar.m !== void 0)
          txn.assetManager = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.m)));
        if (txnForEnc.apar.r !== void 0)
          txn.assetReserve = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.r)));
        if (txnForEnc.apar.f !== void 0)
          txn.assetFreeze = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.f)));
        if (txnForEnc.apar.c !== void 0)
          txn.assetClawback = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.c)));
        if (txnForEnc.apar.un !== void 0)
          txn.assetUnitName = txnForEnc.apar.un;
        if (txnForEnc.apar.an !== void 0)
          txn.assetName = txnForEnc.apar.an;
        if (txnForEnc.apar.au !== void 0)
          txn.assetURL = txnForEnc.apar.au;
        if (txnForEnc.apar.am !== void 0)
          txn.assetMetadataHash = txnForEnc.apar.am;
      }
    } else if (txnForEnc.type === "axfer") {
      if (txnForEnc.xaid !== void 0) {
        txn.assetIndex = txnForEnc.xaid;
      }
      if (txnForEnc.aamt !== void 0)
        txn.amount = txnForEnc.aamt;
      if (txnForEnc.aclose !== void 0) {
        txn.closeRemainderTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.aclose)));
      }
      if (txnForEnc.asnd !== void 0) {
        txn.assetRevocationTarget = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.asnd)));
      }
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.arcv)));
    } else if (txnForEnc.type === "afrz") {
      if (txnForEnc.afrz !== void 0) {
        txn.freezeState = txnForEnc.afrz;
      }
      if (txnForEnc.faid !== void 0) {
        txn.assetIndex = txnForEnc.faid;
      }
      txn.freezeAccount = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.fadd)));
    } else if (txnForEnc.type === "appl") {
      if (txnForEnc.apid !== void 0) {
        txn.appIndex = txnForEnc.apid;
      }
      if (txnForEnc.apan !== void 0) {
        txn.appOnComplete = txnForEnc.apan;
      }
      if (txnForEnc.apls !== void 0) {
        if (txnForEnc.apls.nui !== void 0)
          txn.appLocalInts = txnForEnc.apls.nui;
        if (txnForEnc.apls.nbs !== void 0)
          txn.appLocalByteSlices = txnForEnc.apls.nbs;
      }
      if (txnForEnc.apgs !== void 0) {
        if (txnForEnc.apgs.nui !== void 0)
          txn.appGlobalInts = txnForEnc.apgs.nui;
        if (txnForEnc.apgs.nbs !== void 0)
          txn.appGlobalByteSlices = txnForEnc.apgs.nbs;
      }
      if (txnForEnc.apep !== void 0) {
        txn.extraPages = txnForEnc.apep;
      }
      if (txnForEnc.apap !== void 0) {
        txn.appApprovalProgram = new Uint8Array(txnForEnc.apap);
      }
      if (txnForEnc.apsu !== void 0) {
        txn.appClearProgram = new Uint8Array(txnForEnc.apsu);
      }
      if (txnForEnc.apaa !== void 0) {
        txn.appArgs = txnForEnc.apaa.map((arg) => new Uint8Array(arg));
      }
      if (txnForEnc.apat !== void 0) {
        txn.appAccounts = txnForEnc.apat.map((addressBytes) => decodeAddress(encodeAddress(new Uint8Array(addressBytes))));
      }
      if (txnForEnc.apfa !== void 0) {
        txn.appForeignApps = txnForEnc.apfa;
      }
      if (txnForEnc.apas !== void 0) {
        txn.appForeignAssets = txnForEnc.apas;
      }
      if (txnForEnc.apbx !== void 0) {
        txn.boxes = txnForEnc.apbx.map((box2) => ({
          // We return 0 for the app ID so that it's guaranteed translateBoxReferences will
          // translate the app index back to 0. If we instead returned the called app ID,
          // translateBoxReferences would translate the app index to a nonzero value if the called
          // app is also in the foreign app array.
          appIndex: box2.i ? txn.appForeignApps[box2.i - 1] : 0,
          name: box2.n
        }));
      }
    } else if (txnForEnc.type === "stpf") {
      if (txnForEnc.sptype !== void 0) {
        txn.stateProofType = txnForEnc.sptype;
      }
      if (txnForEnc.sp !== void 0) {
        txn.stateProof = txnForEnc.sp;
      }
      if (txnForEnc.spmsg !== void 0) {
        txn.stateProofMessage = txnForEnc.spmsg;
      }
    }
    return txn;
  }
  estimateSize() {
    return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
  }
  bytesToSign() {
    const encodedMsg = this.toByte();
    return buffer.Buffer.from(concatArrays(this.tag, encodedMsg));
  }
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
  // returns the raw signature
  rawSignTxn(sk) {
    const toBeSigned = this.bytesToSign();
    const sig = sign(toBeSigned, sk);
    return buffer.Buffer.from(sig);
  }
  signTxn(sk) {
    const sTxn = {
      sig: this.rawSignTxn(sk),
      txn: this.get_obj_for_encoding()
    };
    const keypair = keyPairFromSecretKey(sk);
    const pubKeyFromSk = keypair.publicKey;
    if (encodeAddress(pubKeyFromSk) !== encodeAddress(this.from.publicKey)) {
      sTxn.sgnr = buffer.Buffer.from(pubKeyFromSk);
    }
    return new Uint8Array(encode(sTxn));
  }
  attachSignature(signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error("Invalid signature length");
    }
    const sTxn = {
      sig: buffer.Buffer.from(signature),
      txn: this.get_obj_for_encoding()
    };
    if (signerAddr !== encodeAddress(this.from.publicKey)) {
      const signerPublicKey = decodeAddress(signerAddr).publicKey;
      sTxn.sgnr = buffer.Buffer.from(signerPublicKey);
    }
    return new Uint8Array(encode(sTxn));
  }
  rawTxID() {
    const enMsg = this.toByte();
    const gh2 = buffer.Buffer.from(concatArrays(this.tag, enMsg));
    return buffer.Buffer.from(genericHash(gh2));
  }
  txID() {
    const hash = this.rawTxID();
    return base32.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
  }
  // add a lease to a transaction not yet having
  // supply feePerByte to increment fee accordingly
  addLease(lease, feePerByte = 0) {
    let mutableLease;
    if (lease !== void 0) {
      if (lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      mutableLease = new Uint8Array(lease);
    } else {
      mutableLease = new Uint8Array(0);
    }
    this.lease = mutableLease;
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH + ALGORAND_TRANSACTION_LEASE_LENGTH) * feePerByte;
    }
  }
  // add the rekey-to field to a transaction not yet having it
  // supply feePerByte to increment fee accordingly
  addRekey(reKeyTo, feePerByte = 0) {
    if (reKeyTo !== void 0) {
      this.reKeyTo = decodeAddress(reKeyTo);
    }
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH + ALGORAND_TRANSACTION_ADDRESS_LENGTH) * feePerByte;
    }
  }
  // build display dict for prettyPrint and toString
  // eslint-disable-next-line no-underscore-dangle
  _getDictForDisplay() {
    const forPrinting = {
      ...this
    };
    forPrinting.tag = forPrinting.tag.toString();
    forPrinting.from = encodeAddress(forPrinting.from.publicKey);
    if (forPrinting.to !== void 0)
      forPrinting.to = encodeAddress(forPrinting.to.publicKey);
    if (forPrinting.freezeAccount !== void 0)
      forPrinting.freezeAccount = encodeAddress(forPrinting.freezeAccount.publicKey);
    if (forPrinting.closeRemainderTo !== void 0)
      forPrinting.closeRemainderTo = encodeAddress(forPrinting.closeRemainderTo.publicKey);
    if (forPrinting.assetManager !== void 0)
      forPrinting.assetManager = encodeAddress(forPrinting.assetManager.publicKey);
    if (forPrinting.assetReserve !== void 0)
      forPrinting.assetReserve = encodeAddress(forPrinting.assetReserve.publicKey);
    if (forPrinting.assetFreeze !== void 0)
      forPrinting.assetFreeze = encodeAddress(forPrinting.assetFreeze.publicKey);
    if (forPrinting.assetClawback !== void 0)
      forPrinting.assetClawback = encodeAddress(forPrinting.assetClawback.publicKey);
    if (forPrinting.assetRevocationTarget !== void 0)
      forPrinting.assetRevocationTarget = encodeAddress(forPrinting.assetRevocationTarget.publicKey);
    if (forPrinting.reKeyTo !== void 0)
      forPrinting.reKeyTo = encodeAddress(forPrinting.reKeyTo.publicKey);
    forPrinting.genesisHash = forPrinting.genesisHash.toString("base64");
    return forPrinting;
  }
  // pretty print the transaction to console
  prettyPrint() {
    console.log(this._getDictForDisplay());
  }
  // get string representation
  toString() {
    return JSON.stringify(this._getDictForDisplay());
  }
};
function encodeUnsignedSimulateTransaction(transactionObject) {
  const objToEncode = {
    txn: transactionObject.get_obj_for_encoding()
  };
  return encode(objToEncode);
}
function encodeUnsignedTransaction(transactionObject) {
  const objToEncode = transactionObject.get_obj_for_encoding();
  return encode(objToEncode);
}
function decodeUnsignedTransaction(transactionBuffer) {
  const partlyDecodedObject = decode$1(transactionBuffer);
  return Transaction$1.from_obj_for_encoding(partlyDecodedObject);
}
function decodeSignedTransaction(transactionBuffer) {
  const stxnDecoded = decode$1(transactionBuffer);
  const stxn = {
    ...stxnDecoded,
    txn: Transaction$1.from_obj_for_encoding(stxnDecoded.txn)
  };
  return stxn;
}
function instantiateTxnIfNeeded(transactionLike) {
  return transactionLike instanceof Transaction$1 ? transactionLike : new Transaction$1(transactionLike);
}
class Bid {
  constructor({ bidderKey, bidAmount, bidID, auctionKey, auctionID, maxPrice }) {
    this.name = "Bid";
    this.tag = buffer.Buffer.from([97, 66]);
    const decodedBidderKey = decodeAddress(bidderKey);
    const decodedAuctionKey = decodeAddress(auctionKey);
    if (!Number.isSafeInteger(bidAmount) || bidAmount < 0)
      throw Error("Bid amount must be positive and 2^53-1");
    if (!Number.isSafeInteger(bidID) || bidID < 0)
      throw Error("BidID must be positive and 2^53-1");
    if (!Number.isSafeInteger(auctionID) || auctionID < 0)
      throw Error("auctionID must be positive");
    Object.assign(this, {
      bidderKey: decodedBidderKey,
      bidAmount,
      bidID,
      auctionKey: decodedAuctionKey,
      auctionID,
      maxPrice
    });
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    return {
      bidder: buffer.Buffer.from(this.bidderKey.publicKey),
      cur: this.bidAmount,
      price: this.maxPrice,
      id: this.bidID,
      auc: buffer.Buffer.from(this.auctionKey.publicKey),
      aid: this.auctionID
    };
  }
  signBid(sk) {
    const encodedMsg = encode(this.get_obj_for_encoding());
    const toBeSigned = buffer.Buffer.from(concatArrays(this.tag, encodedMsg));
    const sig = sign(toBeSigned, sk);
    const sBid = {
      sig: buffer.Buffer.from(sig),
      bid: this.get_obj_for_encoding()
    };
    const note = {
      t: "b",
      b: sBid
    };
    return new Uint8Array(encode(note));
  }
}
const MICROALGOS_TO_ALGOS_RATIO = 1e6;
const INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
function microalgosToAlgos(microalgos) {
  if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
    throw new Error(INVALID_MICROALGOS_ERROR_MSG);
  }
  return microalgos / MICROALGOS_TO_ALGOS_RATIO;
}
function algosToMicroalgos(algos) {
  const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
  return Math.round(microalgos);
}
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F2.prototype = global2;
    return new F2();
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports2.Headers = Headers;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
class URLTokenBaseHTTPError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "URLTokenBaseHTTPError";
    this.response = response;
  }
}
class URLTokenBaseHTTPClient {
  constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
    this.defaultHeaders = defaultHeaders;
    const fixedBaseServer = baseServer.endsWith("/") ? baseServer : `${baseServer}/`;
    const baseServerURL = new URL(fixedBaseServer);
    if (typeof port !== "undefined") {
      baseServerURL.port = port.toString();
    }
    if (baseServerURL.protocol.length === 0) {
      throw new Error("Invalid base server URL, protocol must be defined.");
    }
    this.baseURL = baseServerURL;
    this.tokenHeader = tokenHeader;
  }
  /**
   * Compute the URL for a path relative to the instance's address
   * @param relativePath - A path string
   * @param query - An optional key-value object of query parameters to add to the URL. If the
   *   relativePath already has query parameters on it, the additional parameters defined here will
   *   be added to the URL without modifying those (unless a key collision occurs).
   * @returns A URL string
   */
  getURL(relativePath, query) {
    let fixedRelativePath;
    if (relativePath.startsWith("./")) {
      fixedRelativePath = relativePath;
    } else if (relativePath.startsWith("/")) {
      fixedRelativePath = `.${relativePath}`;
    } else {
      fixedRelativePath = `./${relativePath}`;
    }
    const address = new URL(fixedRelativePath, this.baseURL);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        address.searchParams.set(key, value);
      }
    }
    return address.toString();
  }
  static formatFetchResponseHeaders(headers) {
    const headersObj = {};
    headers.forEach((key, value) => {
      headersObj[key] = value;
    });
    return headersObj;
  }
  static async checkHttpError(res) {
    if (res.ok) {
      return;
    }
    let body = null;
    let bodyErrorMessage = null;
    try {
      body = new Uint8Array(await res.arrayBuffer());
      const decoded = JSON.parse(buffer.Buffer.from(body).toString());
      if (decoded.message) {
        bodyErrorMessage = decoded.message;
      }
    } catch (_) {
    }
    let message = `Network request error. Received status ${res.status} (${res.statusText})`;
    if (bodyErrorMessage) {
      message += `: ${bodyErrorMessage}`;
    }
    throw new URLTokenBaseHTTPError(message, {
      body,
      status: res.status,
      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    });
  }
  static async formatFetchResponse(res) {
    await this.checkHttpError(res);
    return {
      body: new Uint8Array(await res.arrayBuffer()),
      status: res.status,
      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    };
  }
  async get(relativePath, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await browserPonyfillExports.fetch(this.getURL(relativePath, query), {
      mode: "cors",
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async post(relativePath, data, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await browserPonyfillExports.fetch(this.getURL(relativePath, query), {
      method: "POST",
      mode: "cors",
      body: data,
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async delete(relativePath, data, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await browserPonyfillExports.fetch(this.getURL(relativePath, query), {
      method: "DELETE",
      mode: "cors",
      body: data,
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
}
function removeFalsyOrEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0)
        delete obj[key];
    }
  }
  return obj;
}
function tolowerCaseKeys(o) {
  return Object.keys(o).reduce((c, k2) => (c[k2.toLowerCase()] = o[k2], c), {});
}
function getAcceptFormat(query) {
  if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
    switch (query.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  } else
    return "application/json";
}
class HTTPClient {
  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
    if (baseServer !== void 0) {
      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
    } else {
      this.bc = bcOrTokenHeader;
    }
  }
  /**
   * Parse JSON using either the built-in JSON.parse or utils.parseJSON
   * depending on whether jsonOptions are provided or not
   *
   * @param text - JSON data
   * @param status - Status of the response (used in case parseJSON fails)
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   */
  static parseJSON(text, status, jsonOptions = {}) {
    try {
      if (Object.keys(jsonOptions).length === 0) {
        return text && JSON.parse(text);
      }
      return text && parseJSON(text, jsonOptions);
    } catch (err_) {
      const err = err_;
      err.rawResponse = text || null;
      err.statusCode = status;
      throw err;
    }
  }
  /**
   * Serialize the data according to the requestHeaders
   * Assumes that requestHeaders contain a key "content-type"
   * If the content-type is "application/json", data is JSON serialized
   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
   * or an Uint8Array
   * @private
   */
  static serializeData(data, requestHeaders) {
    if (!data) {
      return new Uint8Array(0);
    }
    if (requestHeaders["content-type"] === "application/json") {
      return new Uint8Array(buffer.Buffer.from(JSON.stringify(data)));
    }
    if (typeof data === "string") {
      return new Uint8Array(buffer.Buffer.from(data));
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  /**
   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
   * Parse the body in
   * Modifies in place res and return the result
   */
  static prepareResponse(res, format, parseBody, jsonOptions = {}) {
    let { body } = res;
    let text;
    if (format !== "application/msgpack") {
      text = body && buffer.Buffer.from(body).toString() || "";
    }
    if (parseBody && format === "application/json") {
      body = HTTPClient.parseJSON(text, res.status, jsonOptions);
    }
    return {
      ...res,
      body,
      text,
      ok: Math.trunc(res.status / 100) === 2
    };
  }
  /**
   * Prepare an error with a response
   * (the type of errors BaseHTTPClient are supposed to throw)
   * by adding the status and preparing the internal response
   * @private
   */
  static prepareResponseError(err) {
    if (err.response) {
      err.response = HTTPClient.prepareResponse(err.response, "application/json", true);
      err.status = err.response.status;
    }
    return err;
  }
  /**
   * Send a GET request.
   * @param relativePath - The path of the request.
   * @param query - An object containing the query parameters of the request.
   * @param requestHeaders - An object containing additional request headers to use.
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   * @param parseBody - An optional boolean indicating whether the response body should be parsed
   *   or not.
   * @returns Response object.
   */
  async get(relativePath, query, requestHeaders = {}, jsonOptions = {}, parseBody = true) {
    const format = getAcceptFormat(query);
    const fullHeaders = { ...requestHeaders, accept: format };
    try {
      const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);
      return HTTPClient.prepareResponse(res, format, parseBody, jsonOptions);
    } catch (err) {
      throw HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a POST request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   */
  async post(relativePath, data, requestHeaders = {}, query, parseBody = true) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders)
    };
    try {
      const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders);
      return HTTPClient.prepareResponse(res, "application/json", parseBody);
    } catch (err) {
      throw HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a DELETE request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   */
  async delete(relativePath, data, requestHeaders = {}, parseBody = true) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders)
    };
    const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
    return HTTPClient.prepareResponse(res, "application/json", parseBody);
  }
}
function convertTokenStringToTokenHeader(token = "", headerIdentifier) {
  const tokenHeader = {};
  if (token === "") {
    return tokenHeader;
  }
  tokenHeader[headerIdentifier] = token;
  return tokenHeader;
}
function isBaseHTTPClient(tbc) {
  return typeof tbc.get === "function";
}
class ServiceClient {
  constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
    if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
      this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
    } else {
      let tokenHeader;
      if (typeof tokenHeaderOrStrOrBaseClient === "string") {
        tokenHeader = convertTokenStringToTokenHeader(tokenHeaderOrStrOrBaseClient, tokenHeaderIdentifier);
      } else {
        tokenHeader = tokenHeaderOrStrOrBaseClient;
      }
      this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
    }
    this.intDecoding = IntDecoding$1.DEFAULT;
  }
  /**
   * Set the default int decoding method for all JSON requests this client creates.
   * @param method - \{"default" | "safe" | "mixed" | "bigint"\} method The method to use when parsing the
   *   response for request. Must be one of "default", "safe", "mixed", or "bigint". See
   *   JSONRequest.setIntDecoding for more details about what each method does.
   */
  setIntEncoding(method) {
    this.intDecoding = method;
  }
  /**
   * Get the default int decoding method for all JSON requests this client creates.
   */
  getIntEncoding() {
    return this.intDecoding;
  }
}
function _is_primitive(val) {
  return val === void 0 || val == null || typeof val !== "object" && typeof val !== "function";
}
function _get_obj_for_encoding(val, binary) {
  let targetPropValue;
  if (val instanceof Uint8Array) {
    targetPropValue = binary ? val : buffer.Buffer.from(val).toString("base64");
  } else if (typeof val.get_obj_for_encoding === "function") {
    targetPropValue = val.get_obj_for_encoding(binary);
  } else if (Array.isArray(val)) {
    targetPropValue = [];
    for (const elem of val) {
      targetPropValue.push(_get_obj_for_encoding(elem, binary));
    }
  } else if (typeof val === "object") {
    const obj = {};
    for (const prop of Object.keys(val)) {
      obj[prop] = _get_obj_for_encoding(val[prop], binary);
    }
    targetPropValue = obj;
  } else if (_is_primitive(val)) {
    targetPropValue = val;
  } else {
    throw new Error(`Unsupported value: ${String(val)}`);
  }
  return targetPropValue;
}
class BaseModel {
  /**
   * Get an object ready for encoding to either JSON or msgpack.
   * @param binary - Use true to indicate that the encoding can handle raw binary objects
   *   (Uint8Arrays). Use false to indicate that raw binary objects should be converted to base64
   *   strings. True should be used for objects that will be encoded with msgpack, and false should
   *   be used for objects that will be encoded with JSON.
   */
  get_obj_for_encoding(binary = false) {
    const obj = {};
    for (const prop of Object.keys(this.attribute_map)) {
      const name = this.attribute_map[prop];
      const value = this[prop];
      if (typeof value !== "undefined") {
        obj[name] = value === null ? null : _get_obj_for_encoding(value, binary);
      }
    }
    return obj;
  }
}
let Account$1 = class Account extends BaseModel {
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param minBalance - MicroAlgo balance required by the account.
   * The requirement grows based on asset and application usage.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param createdApps - (appp) parameters of applications created by this account including app global
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * @param totalBoxBytes - (tbxb) The total number of bytes used by this account's app's box keys and
   * values.
   * @param totalBoxes - (tbx) The number of existing boxes created by this account's app.
   */
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, participation, rewardBase, sigType, totalBoxBytes, totalBoxes }) {
    super();
    this.address = address;
    this.amount = amount;
    this.amountWithoutPendingRewards = amountWithoutPendingRewards;
    this.minBalance = minBalance;
    this.pendingRewards = pendingRewards;
    this.rewards = rewards;
    this.round = round;
    this.status = status;
    this.totalAppsOptedIn = totalAppsOptedIn;
    this.totalAssetsOptedIn = totalAssetsOptedIn;
    this.totalCreatedApps = totalCreatedApps;
    this.totalCreatedAssets = totalCreatedAssets;
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = appsTotalExtraPages;
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = authAddr;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.participation = participation;
    this.rewardBase = rewardBase;
    this.sigType = sigType;
    this.totalBoxBytes = totalBoxBytes;
    this.totalBoxes = totalBoxes;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      amountWithoutPendingRewards: "amount-without-pending-rewards",
      minBalance: "min-balance",
      pendingRewards: "pending-rewards",
      rewards: "rewards",
      round: "round",
      status: "status",
      totalAppsOptedIn: "total-apps-opted-in",
      totalAssetsOptedIn: "total-assets-opted-in",
      totalCreatedApps: "total-created-apps",
      totalCreatedAssets: "total-created-assets",
      appsLocalState: "apps-local-state",
      appsTotalExtraPages: "apps-total-extra-pages",
      appsTotalSchema: "apps-total-schema",
      assets: "assets",
      authAddr: "auth-addr",
      createdApps: "created-apps",
      createdAssets: "created-assets",
      participation: "participation",
      rewardBase: "reward-base",
      sigType: "sig-type",
      totalBoxBytes: "total-box-bytes",
      totalBoxes: "total-boxes"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["amount-without-pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${data}`);
    if (typeof data["min-balance"] === "undefined")
      throw new Error(`Response is missing required field 'min-balance': ${data}`);
    if (typeof data["pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${data}`);
    if (typeof data["rewards"] === "undefined")
      throw new Error(`Response is missing required field 'rewards': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["status"] === "undefined")
      throw new Error(`Response is missing required field 'status': ${data}`);
    if (typeof data["total-apps-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${data}`);
    if (typeof data["total-assets-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${data}`);
    if (typeof data["total-created-apps"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${data}`);
    if (typeof data["total-created-assets"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${data}`);
    return new Account({
      address: data["address"],
      amount: data["amount"],
      amountWithoutPendingRewards: data["amount-without-pending-rewards"],
      minBalance: data["min-balance"],
      pendingRewards: data["pending-rewards"],
      rewards: data["rewards"],
      round: data["round"],
      status: data["status"],
      totalAppsOptedIn: data["total-apps-opted-in"],
      totalAssetsOptedIn: data["total-assets-opted-in"],
      totalCreatedApps: data["total-created-apps"],
      totalCreatedAssets: data["total-created-assets"],
      appsLocalState: typeof data["apps-local-state"] !== "undefined" ? data["apps-local-state"].map(ApplicationLocalState$1.from_obj_for_encoding) : void 0,
      appsTotalExtraPages: data["apps-total-extra-pages"],
      appsTotalSchema: typeof data["apps-total-schema"] !== "undefined" ? ApplicationStateSchema$1.from_obj_for_encoding(data["apps-total-schema"]) : void 0,
      assets: typeof data["assets"] !== "undefined" ? data["assets"].map(AssetHolding$1.from_obj_for_encoding) : void 0,
      authAddr: data["auth-addr"],
      createdApps: typeof data["created-apps"] !== "undefined" ? data["created-apps"].map(Application$1.from_obj_for_encoding) : void 0,
      createdAssets: typeof data["created-assets"] !== "undefined" ? data["created-assets"].map(Asset$1.from_obj_for_encoding) : void 0,
      participation: typeof data["participation"] !== "undefined" ? AccountParticipation$1.from_obj_for_encoding(data["participation"]) : void 0,
      rewardBase: data["reward-base"],
      sigType: data["sig-type"],
      totalBoxBytes: data["total-box-bytes"],
      totalBoxes: data["total-boxes"]
    });
  }
};
class AccountApplicationResponse extends BaseModel {
  /**
   * Creates a new `AccountApplicationResponse` object.
   * @param round - The round for which this information is relevant.
   * @param appLocalState - (appl) the application local data stored in this account.
   * The raw account uses `AppLocalState` for this type.
   * @param createdApp - (appp) parameters of the application created by this account including app
   * global data.
   * The raw account uses `AppParams` for this type.
   */
  constructor({ round, appLocalState, createdApp }) {
    super();
    this.round = round;
    this.appLocalState = appLocalState;
    this.createdApp = createdApp;
    this.attribute_map = {
      round: "round",
      appLocalState: "app-local-state",
      createdApp: "created-app"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    return new AccountApplicationResponse({
      round: data["round"],
      appLocalState: typeof data["app-local-state"] !== "undefined" ? ApplicationLocalState$1.from_obj_for_encoding(data["app-local-state"]) : void 0,
      createdApp: typeof data["created-app"] !== "undefined" ? ApplicationParams$1.from_obj_for_encoding(data["created-app"]) : void 0
    });
  }
}
class AccountAssetResponse extends BaseModel {
  /**
   * Creates a new `AccountAssetResponse` object.
   * @param round - The round for which this information is relevant.
   * @param assetHolding - (asset) Details about the asset held by this account.
   * The raw account uses `AssetHolding` for this type.
   * @param createdAsset - (apar) parameters of the asset created by this account.
   * The raw account uses `AssetParams` for this type.
   */
  constructor({ round, assetHolding, createdAsset }) {
    super();
    this.round = round;
    this.assetHolding = assetHolding;
    this.createdAsset = createdAsset;
    this.attribute_map = {
      round: "round",
      assetHolding: "asset-holding",
      createdAsset: "created-asset"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    return new AccountAssetResponse({
      round: data["round"],
      assetHolding: typeof data["asset-holding"] !== "undefined" ? AssetHolding$1.from_obj_for_encoding(data["asset-holding"]) : void 0,
      createdAsset: typeof data["created-asset"] !== "undefined" ? AssetParams$1.from_obj_for_encoding(data["created-asset"]) : void 0
    });
  }
}
let AccountParticipation$1 = class AccountParticipation extends BaseModel {
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    super();
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(buffer.Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.attribute_map = {
      selectionParticipationKey: "selection-participation-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key",
      stateProofKey: "state-proof-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["selection-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${data}`);
    if (typeof data["vote-first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${data}`);
    if (typeof data["vote-key-dilution"] === "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${data}`);
    if (typeof data["vote-last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${data}`);
    if (typeof data["vote-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${data}`);
    return new AccountParticipation({
      selectionParticipationKey: data["selection-participation-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"],
      stateProofKey: data["state-proof-key"]
    });
  }
};
let AccountStateDelta$1 = class AccountStateDelta extends BaseModel {
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    super();
    this.address = address;
    this.delta = delta;
    this.attribute_map = {
      address: "address",
      delta: "delta"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (!Array.isArray(data["delta"]))
      throw new Error(`Response is missing required array field 'delta': ${data}`);
    return new AccountStateDelta({
      address: data["address"],
      delta: data["delta"].map(EvalDeltaKeyValue$1.from_obj_for_encoding)
    });
  }
};
let Application$1 = class Application extends BaseModel {
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   */
  constructor({ id: id2, params }) {
    super();
    this.id = id2;
    this.params = params;
    this.attribute_map = {
      id: "id",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Application({
      id: data["id"],
      params: ApplicationParams$1.from_obj_for_encoding(data["params"])
    });
  }
};
let ApplicationLocalState$1 = class ApplicationLocalState extends BaseModel {
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param keyValue - (tkv) storage.
   */
  constructor({ id: id2, schema, keyValue }) {
    super();
    this.id = id2;
    this.schema = schema;
    this.keyValue = keyValue;
    this.attribute_map = {
      id: "id",
      schema: "schema",
      keyValue: "key-value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["schema"] === "undefined")
      throw new Error(`Response is missing required field 'schema': ${data}`);
    return new ApplicationLocalState({
      id: data["id"],
      schema: ApplicationStateSchema$1.from_obj_for_encoding(data["schema"]),
      keyValue: typeof data["key-value"] !== "undefined" ? data["key-value"].map(TealKeyValue$1.from_obj_for_encoding) : void 0
    });
  }
};
let ApplicationParams$1 = class ApplicationParams extends BaseModel {
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - (gs) global state
   * @param globalStateSchema - (gsch) global schema
   * @param localStateSchema - (lsch) local schema
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState: globalState2, globalStateSchema, localStateSchema }) {
    super();
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(buffer.Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(buffer.Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.creator = creator;
    this.extraProgramPages = extraProgramPages;
    this.globalState = globalState2;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.attribute_map = {
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      creator: "creator",
      extraProgramPages: "extra-program-pages",
      globalState: "global-state",
      globalStateSchema: "global-state-schema",
      localStateSchema: "local-state-schema"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["approval-program"] === "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${data}`);
    if (typeof data["clear-state-program"] === "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${data}`);
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    return new ApplicationParams({
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      creator: data["creator"],
      extraProgramPages: data["extra-program-pages"],
      globalState: typeof data["global-state"] !== "undefined" ? data["global-state"].map(TealKeyValue$1.from_obj_for_encoding) : void 0,
      globalStateSchema: typeof data["global-state-schema"] !== "undefined" ? ApplicationStateSchema$1.from_obj_for_encoding(data["global-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? ApplicationStateSchema$1.from_obj_for_encoding(data["local-state-schema"]) : void 0
    });
  }
};
let ApplicationStateSchema$1 = class ApplicationStateSchema extends BaseModel {
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numUint - (nui) num of uints.
   * @param numByteSlice - (nbs) num of byte slices.
   */
  constructor({ numUint, numByteSlice }) {
    super();
    this.numUint = numUint;
    this.numByteSlice = numByteSlice;
    this.attribute_map = {
      numUint: "num-uint",
      numByteSlice: "num-byte-slice"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    return new ApplicationStateSchema({
      numUint: data["num-uint"],
      numByteSlice: data["num-byte-slice"]
    });
  }
};
let Asset$1 = class Asset extends BaseModel {
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ index: index2, params }) {
    super();
    this.index = index2;
    this.params = params;
    this.attribute_map = {
      index: "index",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Asset({
      index: data["index"],
      params: AssetParams$1.from_obj_for_encoding(data["params"])
    });
  }
};
let AssetHolding$1 = class AssetHolding extends BaseModel {
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   */
  constructor({ amount, assetId, isFrozen }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.isFrozen = isFrozen;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      isFrozen: "is-frozen"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new AssetHolding({
      amount: data["amount"],
      assetId: data["asset-id"],
      isFrozen: data["is-frozen"]
    });
  }
};
let AssetParams$1 = class AssetParams extends BaseModel {
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    super();
    this.creator = creator;
    this.decimals = decimals;
    this.total = total;
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(buffer.Buffer.from(metadataHash, "base64")) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(buffer.Buffer.from(nameB64, "base64")) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(buffer.Buffer.from(unitNameB64, "base64")) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(buffer.Buffer.from(urlB64, "base64")) : urlB64;
    this.attribute_map = {
      creator: "creator",
      decimals: "decimals",
      total: "total",
      clawback: "clawback",
      defaultFrozen: "default-frozen",
      freeze: "freeze",
      manager: "manager",
      metadataHash: "metadata-hash",
      name: "name",
      nameB64: "name-b64",
      reserve: "reserve",
      unitName: "unit-name",
      unitNameB64: "unit-name-b64",
      url: "url",
      urlB64: "url-b64"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    if (typeof data["decimals"] === "undefined")
      throw new Error(`Response is missing required field 'decimals': ${data}`);
    if (typeof data["total"] === "undefined")
      throw new Error(`Response is missing required field 'total': ${data}`);
    return new AssetParams({
      creator: data["creator"],
      decimals: data["decimals"],
      total: data["total"],
      clawback: data["clawback"],
      defaultFrozen: data["default-frozen"],
      freeze: data["freeze"],
      manager: data["manager"],
      metadataHash: data["metadata-hash"],
      name: data["name"],
      nameB64: data["name-b64"],
      reserve: data["reserve"],
      unitName: data["unit-name"],
      unitNameB64: data["unit-name-b64"],
      url: data["url"],
      urlB64: data["url-b64"]
    });
  }
};
class BlockHashResponse extends BaseModel {
  /**
   * Creates a new `BlockHashResponse` object.
   * @param blockhash - Block header hash.
   */
  constructor({ blockhash }) {
    super();
    this.blockhash = blockhash;
    this.attribute_map = {
      blockhash: "blockHash"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["blockHash"] === "undefined")
      throw new Error(`Response is missing required field 'blockHash': ${data}`);
    return new BlockHashResponse({
      blockhash: data["blockHash"]
    });
  }
}
class BlockResponse extends BaseModel {
  /**
   * Creates a new `BlockResponse` object.
   * @param block - Block header data.
   * @param cert - Optional certificate object. This is only included when the format is set to
   * message pack.
   */
  constructor({ block, cert }) {
    super();
    this.block = block;
    this.cert = cert;
    this.attribute_map = {
      block: "block",
      cert: "cert"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["block"] === "undefined")
      throw new Error(`Response is missing required field 'block': ${data}`);
    return new BlockResponse({
      block: data["block"],
      cert: data["cert"]
    });
  }
}
let Box$1 = class Box extends BaseModel {
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name, value }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.value = typeof value === "string" ? new Uint8Array(buffer.Buffer.from(value, "base64")) : value;
    this.attribute_map = {
      name: "name",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new Box({
      name: data["name"],
      value: data["value"]
    });
  }
};
let BoxDescriptor$1 = class BoxDescriptor extends BaseModel {
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.attribute_map = {
      name: "name"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    return new BoxDescriptor({
      name: data["name"]
    });
  }
};
let BoxesResponse$1 = class BoxesResponse extends BaseModel {
  /**
   * Creates a new `BoxesResponse` object.
   * @param boxes -
   */
  constructor({ boxes }) {
    super();
    this.boxes = boxes;
    this.attribute_map = {
      boxes: "boxes"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["boxes"]))
      throw new Error(`Response is missing required array field 'boxes': ${data}`);
    return new BoxesResponse({
      boxes: data["boxes"].map(BoxDescriptor$1.from_obj_for_encoding)
    });
  }
};
class BuildVersion extends BaseModel {
  /**
   * Creates a new `BuildVersion` object.
   * @param branch -
   * @param buildNumber -
   * @param channel -
   * @param commitHash -
   * @param major -
   * @param minor -
   */
  constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
    super();
    this.branch = branch;
    this.buildNumber = buildNumber;
    this.channel = channel;
    this.commitHash = commitHash;
    this.major = major;
    this.minor = minor;
    this.attribute_map = {
      branch: "branch",
      buildNumber: "build_number",
      channel: "channel",
      commitHash: "commit_hash",
      major: "major",
      minor: "minor"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["branch"] === "undefined")
      throw new Error(`Response is missing required field 'branch': ${data}`);
    if (typeof data["build_number"] === "undefined")
      throw new Error(`Response is missing required field 'build_number': ${data}`);
    if (typeof data["channel"] === "undefined")
      throw new Error(`Response is missing required field 'channel': ${data}`);
    if (typeof data["commit_hash"] === "undefined")
      throw new Error(`Response is missing required field 'commit_hash': ${data}`);
    if (typeof data["major"] === "undefined")
      throw new Error(`Response is missing required field 'major': ${data}`);
    if (typeof data["minor"] === "undefined")
      throw new Error(`Response is missing required field 'minor': ${data}`);
    return new BuildVersion({
      branch: data["branch"],
      buildNumber: data["build_number"],
      channel: data["channel"],
      commitHash: data["commit_hash"],
      major: data["major"],
      minor: data["minor"]
    });
  }
}
class CompileResponse extends BaseModel {
  /**
   * Creates a new `CompileResponse` object.
   * @param hash - base32 SHA512_256 of program bytes (Address style)
   * @param result - base64 encoded program bytes
   * @param sourcemap - JSON of the source map
   */
  constructor({ hash, result, sourcemap }) {
    super();
    this.hash = hash;
    this.result = result;
    this.sourcemap = sourcemap;
    this.attribute_map = {
      hash: "hash",
      result: "result",
      sourcemap: "sourcemap"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["hash"] === "undefined")
      throw new Error(`Response is missing required field 'hash': ${data}`);
    if (typeof data["result"] === "undefined")
      throw new Error(`Response is missing required field 'result': ${data}`);
    return new CompileResponse({
      hash: data["hash"],
      result: data["result"],
      sourcemap: data["sourcemap"]
    });
  }
}
class DisassembleResponse extends BaseModel {
  /**
   * Creates a new `DisassembleResponse` object.
   * @param result - disassembled Teal code
   */
  constructor({ result }) {
    super();
    this.result = result;
    this.attribute_map = {
      result: "result"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["result"] === "undefined")
      throw new Error(`Response is missing required field 'result': ${data}`);
    return new DisassembleResponse({
      result: data["result"]
    });
  }
}
class DryrunRequest extends BaseModel {
  /**
   * Creates a new `DryrunRequest` object.
   * @param accounts -
   * @param apps -
   * @param latestTimestamp - LatestTimestamp is available to some TEAL scripts. Defaults to the latest
   * confirmed timestamp this algod is attached to.
   * @param protocolVersion - ProtocolVersion specifies a specific version string to operate under, otherwise
   * whatever the current protocol of the network this algod is running in.
   * @param round - Round is available to some TEAL scripts. Defaults to the current round on the
   * network this algod is attached to.
   * @param sources -
   * @param txns -
   */
  constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
    super();
    this.accounts = accounts;
    this.apps = apps;
    this.latestTimestamp = latestTimestamp;
    this.protocolVersion = protocolVersion;
    this.round = round;
    this.sources = sources;
    this.txns = txns;
    this.attribute_map = {
      accounts: "accounts",
      apps: "apps",
      latestTimestamp: "latest-timestamp",
      protocolVersion: "protocol-version",
      round: "round",
      sources: "sources",
      txns: "txns"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["accounts"]))
      throw new Error(`Response is missing required array field 'accounts': ${data}`);
    if (!Array.isArray(data["apps"]))
      throw new Error(`Response is missing required array field 'apps': ${data}`);
    if (typeof data["latest-timestamp"] === "undefined")
      throw new Error(`Response is missing required field 'latest-timestamp': ${data}`);
    if (typeof data["protocol-version"] === "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (!Array.isArray(data["sources"]))
      throw new Error(`Response is missing required array field 'sources': ${data}`);
    if (!Array.isArray(data["txns"]))
      throw new Error(`Response is missing required array field 'txns': ${data}`);
    return new DryrunRequest({
      accounts: data["accounts"].map(Account$1.from_obj_for_encoding),
      apps: data["apps"].map(Application$1.from_obj_for_encoding),
      latestTimestamp: data["latest-timestamp"],
      protocolVersion: data["protocol-version"],
      round: data["round"],
      sources: data["sources"].map(DryrunSource.from_obj_for_encoding),
      txns: data["txns"]
    });
  }
}
class DryrunResponse extends BaseModel {
  /**
   * Creates a new `DryrunResponse` object.
   * @param error -
   * @param protocolVersion - Protocol version is the protocol version Dryrun was operated under.
   * @param txns -
   */
  constructor({ error, protocolVersion, txns }) {
    super();
    this.error = error;
    this.protocolVersion = protocolVersion;
    this.txns = txns;
    this.attribute_map = {
      error: "error",
      protocolVersion: "protocol-version",
      txns: "txns"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["error"] === "undefined")
      throw new Error(`Response is missing required field 'error': ${data}`);
    if (typeof data["protocol-version"] === "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${data}`);
    if (!Array.isArray(data["txns"]))
      throw new Error(`Response is missing required array field 'txns': ${data}`);
    return new DryrunResponse({
      error: data["error"],
      protocolVersion: data["protocol-version"],
      txns: data["txns"].map(DryrunTxnResult.from_obj_for_encoding)
    });
  }
}
class DryrunSource extends BaseModel {
  /**
   * Creates a new `DryrunSource` object.
   * @param fieldName - FieldName is what kind of sources this is. If lsig then it goes into the
   * transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the
   * Approval Program or Clear State Program of application[this.AppIndex].
   * @param source -
   * @param txnIndex -
   * @param appIndex -
   */
  constructor({ fieldName, source, txnIndex, appIndex }) {
    super();
    this.fieldName = fieldName;
    this.source = source;
    this.txnIndex = txnIndex;
    this.appIndex = appIndex;
    this.attribute_map = {
      fieldName: "field-name",
      source: "source",
      txnIndex: "txn-index",
      appIndex: "app-index"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["field-name"] === "undefined")
      throw new Error(`Response is missing required field 'field-name': ${data}`);
    if (typeof data["source"] === "undefined")
      throw new Error(`Response is missing required field 'source': ${data}`);
    if (typeof data["txn-index"] === "undefined")
      throw new Error(`Response is missing required field 'txn-index': ${data}`);
    if (typeof data["app-index"] === "undefined")
      throw new Error(`Response is missing required field 'app-index': ${data}`);
    return new DryrunSource({
      fieldName: data["field-name"],
      source: data["source"],
      txnIndex: data["txn-index"],
      appIndex: data["app-index"]
    });
  }
}
class DryrunState extends BaseModel {
  /**
   * Creates a new `DryrunState` object.
   * @param line - Line number
   * @param pc - Program counter
   * @param stack -
   * @param error - Evaluation error if any
   * @param scratch -
   */
  constructor({ line, pc: pc2, stack, error, scratch }) {
    super();
    this.line = line;
    this.pc = pc2;
    this.stack = stack;
    this.error = error;
    this.scratch = scratch;
    this.attribute_map = {
      line: "line",
      pc: "pc",
      stack: "stack",
      error: "error",
      scratch: "scratch"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["line"] === "undefined")
      throw new Error(`Response is missing required field 'line': ${data}`);
    if (typeof data["pc"] === "undefined")
      throw new Error(`Response is missing required field 'pc': ${data}`);
    if (!Array.isArray(data["stack"]))
      throw new Error(`Response is missing required array field 'stack': ${data}`);
    return new DryrunState({
      line: data["line"],
      pc: data["pc"],
      stack: data["stack"].map(TealValue$1.from_obj_for_encoding),
      error: data["error"],
      scratch: typeof data["scratch"] !== "undefined" ? data["scratch"].map(TealValue$1.from_obj_for_encoding) : void 0
    });
  }
}
class DryrunTxnResult extends BaseModel {
  /**
   * Creates a new `DryrunTxnResult` object.
   * @param disassembly - Disassembled program line by line.
   * @param appCallMessages -
   * @param appCallTrace -
   * @param budgetAdded - Budget added during execution of app call transaction.
   * @param budgetConsumed - Budget consumed during execution of app call transaction.
   * @param globalDelta - Application state delta.
   * @param localDeltas -
   * @param logicSigDisassembly - Disassembled lsig program line by line.
   * @param logicSigMessages -
   * @param logicSigTrace -
   * @param logs -
   */
  constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
    super();
    this.disassembly = disassembly;
    this.appCallMessages = appCallMessages;
    this.appCallTrace = appCallTrace;
    this.budgetAdded = budgetAdded;
    this.budgetConsumed = budgetConsumed;
    this.globalDelta = globalDelta;
    this.localDeltas = localDeltas;
    this.logicSigDisassembly = logicSigDisassembly;
    this.logicSigMessages = logicSigMessages;
    this.logicSigTrace = logicSigTrace;
    this.logs = logs;
    this.attribute_map = {
      disassembly: "disassembly",
      appCallMessages: "app-call-messages",
      appCallTrace: "app-call-trace",
      budgetAdded: "budget-added",
      budgetConsumed: "budget-consumed",
      globalDelta: "global-delta",
      localDeltas: "local-deltas",
      logicSigDisassembly: "logic-sig-disassembly",
      logicSigMessages: "logic-sig-messages",
      logicSigTrace: "logic-sig-trace",
      logs: "logs"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["disassembly"]))
      throw new Error(`Response is missing required array field 'disassembly': ${data}`);
    return new DryrunTxnResult({
      disassembly: data["disassembly"],
      appCallMessages: data["app-call-messages"],
      appCallTrace: typeof data["app-call-trace"] !== "undefined" ? data["app-call-trace"].map(DryrunState.from_obj_for_encoding) : void 0,
      budgetAdded: data["budget-added"],
      budgetConsumed: data["budget-consumed"],
      globalDelta: typeof data["global-delta"] !== "undefined" ? data["global-delta"].map(EvalDeltaKeyValue$1.from_obj_for_encoding) : void 0,
      localDeltas: typeof data["local-deltas"] !== "undefined" ? data["local-deltas"].map(AccountStateDelta$1.from_obj_for_encoding) : void 0,
      logicSigDisassembly: data["logic-sig-disassembly"],
      logicSigMessages: data["logic-sig-messages"],
      logicSigTrace: typeof data["logic-sig-trace"] !== "undefined" ? data["logic-sig-trace"].map(DryrunState.from_obj_for_encoding) : void 0,
      logs: data["logs"]
    });
  }
}
let ErrorResponse$1 = class ErrorResponse extends BaseModel {
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    super();
    this.message = message;
    this.data = data;
    this.attribute_map = {
      message: "message",
      data: "data"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    return new ErrorResponse({
      message: data["message"],
      data: data["data"]
    });
  }
};
let EvalDelta$1 = class EvalDelta extends BaseModel {
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action: action2, bytes, uint }) {
    super();
    this.action = action2;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      action: "action",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["action"] === "undefined")
      throw new Error(`Response is missing required field 'action': ${data}`);
    return new EvalDelta({
      action: data["action"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
};
let EvalDeltaKeyValue$1 = class EvalDeltaKeyValue extends BaseModel {
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new EvalDeltaKeyValue({
      key: data["key"],
      value: EvalDelta$1.from_obj_for_encoding(data["value"])
    });
  }
};
class GetBlockTimeStampOffsetResponse extends BaseModel {
  /**
   * Creates a new `GetBlockTimeStampOffsetResponse` object.
   * @param offset - Timestamp offset in seconds.
   */
  constructor({ offset }) {
    super();
    this.offset = offset;
    this.attribute_map = {
      offset: "offset"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["offset"] === "undefined")
      throw new Error(`Response is missing required field 'offset': ${data}`);
    return new GetBlockTimeStampOffsetResponse({
      offset: data["offset"]
    });
  }
}
class GetSyncRoundResponse extends BaseModel {
  /**
   * Creates a new `GetSyncRoundResponse` object.
   * @param round - The minimum sync round for the ledger.
   */
  constructor({ round }) {
    super();
    this.round = round;
    this.attribute_map = {
      round: "round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    return new GetSyncRoundResponse({
      round: data["round"]
    });
  }
}
class KvDelta extends BaseModel {
  /**
   * Creates a new `KvDelta` object.
   * @param key - The key, base64 encoded.
   * @param value - The new value of the KV store entry, base64 encoded.
   */
  constructor({ key, value }) {
    super();
    this.key = typeof key === "string" ? new Uint8Array(buffer.Buffer.from(key, "base64")) : key;
    this.value = typeof value === "string" ? new Uint8Array(buffer.Buffer.from(value, "base64")) : value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new KvDelta({
      key: data["key"],
      value: data["value"]
    });
  }
}
class LedgerStateDeltaForTransactionGroup extends BaseModel {
  /**
   * Creates a new `LedgerStateDeltaForTransactionGroup` object.
   * @param delta - Ledger StateDelta object
   * @param ids -
   */
  constructor({ delta, ids }) {
    super();
    this.delta = delta;
    this.ids = ids;
    this.attribute_map = {
      delta: "delta",
      ids: "ids"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["delta"] === "undefined")
      throw new Error(`Response is missing required field 'delta': ${data}`);
    if (!Array.isArray(data["ids"]))
      throw new Error(`Response is missing required array field 'ids': ${data}`);
    return new LedgerStateDeltaForTransactionGroup({
      delta: data["delta"],
      ids: data["ids"]
    });
  }
}
let LightBlockHeaderProof$1 = class LightBlockHeaderProof extends BaseModel {
  /**
   * Creates a new `LightBlockHeaderProof` object.
   * @param index - The index of the light block header in the vector commitment tree
   * @param proof - The encoded proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   */
  constructor({ index: index2, proof, treedepth }) {
    super();
    this.index = index2;
    this.proof = typeof proof === "string" ? new Uint8Array(buffer.Buffer.from(proof, "base64")) : proof;
    this.treedepth = treedepth;
    this.attribute_map = {
      index: "index",
      proof: "proof",
      treedepth: "treedepth"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["proof"] === "undefined")
      throw new Error(`Response is missing required field 'proof': ${data}`);
    if (typeof data["treedepth"] === "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${data}`);
    return new LightBlockHeaderProof({
      index: data["index"],
      proof: data["proof"],
      treedepth: data["treedepth"]
    });
  }
};
class NodeStatusResponse extends BaseModel {
  /**
   * Creates a new `NodeStatusResponse` object.
   * @param catchupTime - CatchupTime in nanoseconds
   * @param lastRound - LastRound indicates the last round seen
   * @param lastVersion - LastVersion indicates the last consensus version supported
   * @param nextVersion - NextVersion of consensus protocol to use
   * @param nextVersionRound - NextVersionRound is the round at which the next consensus version will apply
   * @param nextVersionSupported - NextVersionSupported indicates whether the next consensus version is supported
   * by this node
   * @param stoppedAtUnsupportedRound - StoppedAtUnsupportedRound indicates that the node does not support the new
   * rounds and has stopped making progress
   * @param timeSinceLastRound - TimeSinceLastRound in nanoseconds
   * @param catchpoint - The current catchpoint that is being caught up to
   * @param catchpointAcquiredBlocks - The number of blocks that have already been obtained by the node as part of the
   * catchup
   * @param catchpointProcessedAccounts - The number of accounts from the current catchpoint that have been processed so
   * far as part of the catchup
   * @param catchpointProcessedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * processed so far as part of the catchup
   * @param catchpointTotalAccounts - The total number of accounts included in the current catchpoint
   * @param catchpointTotalBlocks - The total number of blocks that are required to complete the current catchpoint
   * catchup
   * @param catchpointTotalKvs - The total number of key-values (KVs) included in the current catchpoint
   * @param catchpointVerifiedAccounts - The number of accounts from the current catchpoint that have been verified so
   * far as part of the catchup
   * @param catchpointVerifiedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * verified so far as part of the catchup
   * @param lastCatchpoint - The last catchpoint seen by the node
   * @param upgradeDelay - Upgrade delay
   * @param upgradeNextProtocolVoteBefore - Next protocol round
   * @param upgradeNoVotes - No votes cast for consensus upgrade
   * @param upgradeNodeVote - This node's upgrade vote
   * @param upgradeVoteRounds - Total voting rounds for current upgrade
   * @param upgradeVotes - Total votes cast for consensus upgrade
   * @param upgradeVotesRequired - Yes votes required for consensus upgrade
   * @param upgradeYesVotes - Yes votes cast for consensus upgrade
   */
  constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointProcessedKvs, catchpointTotalAccounts, catchpointTotalBlocks, catchpointTotalKvs, catchpointVerifiedAccounts, catchpointVerifiedKvs, lastCatchpoint, upgradeDelay, upgradeNextProtocolVoteBefore, upgradeNoVotes, upgradeNodeVote, upgradeVoteRounds, upgradeVotes, upgradeVotesRequired, upgradeYesVotes }) {
    super();
    this.catchupTime = catchupTime;
    this.lastRound = lastRound;
    this.lastVersion = lastVersion;
    this.nextVersion = nextVersion;
    this.nextVersionRound = nextVersionRound;
    this.nextVersionSupported = nextVersionSupported;
    this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
    this.timeSinceLastRound = timeSinceLastRound;
    this.catchpoint = catchpoint;
    this.catchpointAcquiredBlocks = catchpointAcquiredBlocks;
    this.catchpointProcessedAccounts = catchpointProcessedAccounts;
    this.catchpointProcessedKvs = catchpointProcessedKvs;
    this.catchpointTotalAccounts = catchpointTotalAccounts;
    this.catchpointTotalBlocks = catchpointTotalBlocks;
    this.catchpointTotalKvs = catchpointTotalKvs;
    this.catchpointVerifiedAccounts = catchpointVerifiedAccounts;
    this.catchpointVerifiedKvs = catchpointVerifiedKvs;
    this.lastCatchpoint = lastCatchpoint;
    this.upgradeDelay = upgradeDelay;
    this.upgradeNextProtocolVoteBefore = upgradeNextProtocolVoteBefore;
    this.upgradeNoVotes = upgradeNoVotes;
    this.upgradeNodeVote = upgradeNodeVote;
    this.upgradeVoteRounds = upgradeVoteRounds;
    this.upgradeVotes = upgradeVotes;
    this.upgradeVotesRequired = upgradeVotesRequired;
    this.upgradeYesVotes = upgradeYesVotes;
    this.attribute_map = {
      catchupTime: "catchup-time",
      lastRound: "last-round",
      lastVersion: "last-version",
      nextVersion: "next-version",
      nextVersionRound: "next-version-round",
      nextVersionSupported: "next-version-supported",
      stoppedAtUnsupportedRound: "stopped-at-unsupported-round",
      timeSinceLastRound: "time-since-last-round",
      catchpoint: "catchpoint",
      catchpointAcquiredBlocks: "catchpoint-acquired-blocks",
      catchpointProcessedAccounts: "catchpoint-processed-accounts",
      catchpointProcessedKvs: "catchpoint-processed-kvs",
      catchpointTotalAccounts: "catchpoint-total-accounts",
      catchpointTotalBlocks: "catchpoint-total-blocks",
      catchpointTotalKvs: "catchpoint-total-kvs",
      catchpointVerifiedAccounts: "catchpoint-verified-accounts",
      catchpointVerifiedKvs: "catchpoint-verified-kvs",
      lastCatchpoint: "last-catchpoint",
      upgradeDelay: "upgrade-delay",
      upgradeNextProtocolVoteBefore: "upgrade-next-protocol-vote-before",
      upgradeNoVotes: "upgrade-no-votes",
      upgradeNodeVote: "upgrade-node-vote",
      upgradeVoteRounds: "upgrade-vote-rounds",
      upgradeVotes: "upgrade-votes",
      upgradeVotesRequired: "upgrade-votes-required",
      upgradeYesVotes: "upgrade-yes-votes"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["catchup-time"] === "undefined")
      throw new Error(`Response is missing required field 'catchup-time': ${data}`);
    if (typeof data["last-round"] === "undefined")
      throw new Error(`Response is missing required field 'last-round': ${data}`);
    if (typeof data["last-version"] === "undefined")
      throw new Error(`Response is missing required field 'last-version': ${data}`);
    if (typeof data["next-version"] === "undefined")
      throw new Error(`Response is missing required field 'next-version': ${data}`);
    if (typeof data["next-version-round"] === "undefined")
      throw new Error(`Response is missing required field 'next-version-round': ${data}`);
    if (typeof data["next-version-supported"] === "undefined")
      throw new Error(`Response is missing required field 'next-version-supported': ${data}`);
    if (typeof data["stopped-at-unsupported-round"] === "undefined")
      throw new Error(`Response is missing required field 'stopped-at-unsupported-round': ${data}`);
    if (typeof data["time-since-last-round"] === "undefined")
      throw new Error(`Response is missing required field 'time-since-last-round': ${data}`);
    return new NodeStatusResponse({
      catchupTime: data["catchup-time"],
      lastRound: data["last-round"],
      lastVersion: data["last-version"],
      nextVersion: data["next-version"],
      nextVersionRound: data["next-version-round"],
      nextVersionSupported: data["next-version-supported"],
      stoppedAtUnsupportedRound: data["stopped-at-unsupported-round"],
      timeSinceLastRound: data["time-since-last-round"],
      catchpoint: data["catchpoint"],
      catchpointAcquiredBlocks: data["catchpoint-acquired-blocks"],
      catchpointProcessedAccounts: data["catchpoint-processed-accounts"],
      catchpointProcessedKvs: data["catchpoint-processed-kvs"],
      catchpointTotalAccounts: data["catchpoint-total-accounts"],
      catchpointTotalBlocks: data["catchpoint-total-blocks"],
      catchpointTotalKvs: data["catchpoint-total-kvs"],
      catchpointVerifiedAccounts: data["catchpoint-verified-accounts"],
      catchpointVerifiedKvs: data["catchpoint-verified-kvs"],
      lastCatchpoint: data["last-catchpoint"],
      upgradeDelay: data["upgrade-delay"],
      upgradeNextProtocolVoteBefore: data["upgrade-next-protocol-vote-before"],
      upgradeNoVotes: data["upgrade-no-votes"],
      upgradeNodeVote: data["upgrade-node-vote"],
      upgradeVoteRounds: data["upgrade-vote-rounds"],
      upgradeVotes: data["upgrade-votes"],
      upgradeVotesRequired: data["upgrade-votes-required"],
      upgradeYesVotes: data["upgrade-yes-votes"]
    });
  }
}
class PendingTransactionResponse extends BaseModel {
  /**
   * Creates a new `PendingTransactionResponse` object.
   * @param poolError - Indicates that the transaction was kicked out of this node's transaction pool
   * (and specifies why that happened). An empty string indicates the transaction
   * wasn't kicked out of this node's txpool due to an error.
   * @param txn - The raw signed transaction.
   * @param applicationIndex - The application index if the transaction was found and it created an
   * application.
   * @param assetClosingAmount - The number of the asset's unit that were transferred to the close-to address.
   * @param assetIndex - The asset index if the transaction was found and it created an asset.
   * @param closeRewards - Rewards in microalgos applied to the close remainder to account.
   * @param closingAmount - Closing amount for the transaction.
   * @param confirmedRound - The round where this transaction was confirmed, if present.
   * @param globalStateDelta - Global state key/value changes for the application being executed by this
   * transaction.
   * @param innerTxns - Inner transactions produced by application execution.
   * @param localStateDelta - Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - Logs for the application being executed by this transaction.
   * @param receiverRewards - Rewards in microalgos applied to the receiver account.
   * @param senderRewards - Rewards in microalgos applied to the sender account.
   */
  constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
    super();
    this.poolError = poolError;
    this.txn = txn;
    this.applicationIndex = applicationIndex;
    this.assetClosingAmount = assetClosingAmount;
    this.assetIndex = assetIndex;
    this.closeRewards = closeRewards;
    this.closingAmount = closingAmount;
    this.confirmedRound = confirmedRound;
    this.globalStateDelta = globalStateDelta;
    this.innerTxns = innerTxns;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.receiverRewards = receiverRewards;
    this.senderRewards = senderRewards;
    this.attribute_map = {
      poolError: "pool-error",
      txn: "txn",
      applicationIndex: "application-index",
      assetClosingAmount: "asset-closing-amount",
      assetIndex: "asset-index",
      closeRewards: "close-rewards",
      closingAmount: "closing-amount",
      confirmedRound: "confirmed-round",
      globalStateDelta: "global-state-delta",
      innerTxns: "inner-txns",
      localStateDelta: "local-state-delta",
      logs: "logs",
      receiverRewards: "receiver-rewards",
      senderRewards: "sender-rewards"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["pool-error"] === "undefined")
      throw new Error(`Response is missing required field 'pool-error': ${data}`);
    if (typeof data["txn"] === "undefined")
      throw new Error(`Response is missing required field 'txn': ${data}`);
    return new PendingTransactionResponse({
      poolError: data["pool-error"],
      txn: data["txn"],
      applicationIndex: data["application-index"],
      assetClosingAmount: data["asset-closing-amount"],
      assetIndex: data["asset-index"],
      closeRewards: data["close-rewards"],
      closingAmount: data["closing-amount"],
      confirmedRound: data["confirmed-round"],
      globalStateDelta: typeof data["global-state-delta"] !== "undefined" ? data["global-state-delta"].map(EvalDeltaKeyValue$1.from_obj_for_encoding) : void 0,
      innerTxns: typeof data["inner-txns"] !== "undefined" ? data["inner-txns"].map(PendingTransactionResponse.from_obj_for_encoding) : void 0,
      localStateDelta: typeof data["local-state-delta"] !== "undefined" ? data["local-state-delta"].map(AccountStateDelta$1.from_obj_for_encoding) : void 0,
      logs: data["logs"],
      receiverRewards: data["receiver-rewards"],
      senderRewards: data["sender-rewards"]
    });
  }
}
class PendingTransactionsResponse extends BaseModel {
  /**
   * Creates a new `PendingTransactionsResponse` object.
   * @param topTransactions - An array of signed transaction objects.
   * @param totalTransactions - Total number of transactions in the pool.
   */
  constructor({ topTransactions, totalTransactions }) {
    super();
    this.topTransactions = topTransactions;
    this.totalTransactions = totalTransactions;
    this.attribute_map = {
      topTransactions: "top-transactions",
      totalTransactions: "total-transactions"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["top-transactions"]))
      throw new Error(`Response is missing required array field 'top-transactions': ${data}`);
    if (typeof data["total-transactions"] === "undefined")
      throw new Error(`Response is missing required field 'total-transactions': ${data}`);
    return new PendingTransactionsResponse({
      topTransactions: data["top-transactions"],
      totalTransactions: data["total-transactions"]
    });
  }
}
class PostTransactionsResponse extends BaseModel {
  /**
   * Creates a new `PostTransactionsResponse` object.
   * @param txid - encoding of the transaction hash.
   */
  constructor({ txid }) {
    super();
    this.txid = txid;
    this.attribute_map = {
      txid: "txId"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["txId"] === "undefined")
      throw new Error(`Response is missing required field 'txId': ${data}`);
    return new PostTransactionsResponse({
      txid: data["txId"]
    });
  }
}
class SimulateRequest extends BaseModel {
  /**
   * Creates a new `SimulateRequest` object.
   * @param txnGroups - The transaction groups to simulate.
   * @param allowEmptySignatures - Allow transactions without signatures to be simulated as if they had correct
   * signatures.
   * @param allowMoreLogging - Lifts limits on log opcode usage during simulation.
   * @param extraOpcodeBudget - Applies extra opcode budget during simulation for each transaction group.
   */
  constructor({ txnGroups, allowEmptySignatures, allowMoreLogging, extraOpcodeBudget }) {
    super();
    this.txnGroups = txnGroups;
    this.allowEmptySignatures = allowEmptySignatures;
    this.allowMoreLogging = allowMoreLogging;
    this.extraOpcodeBudget = extraOpcodeBudget;
    this.attribute_map = {
      txnGroups: "txn-groups",
      allowEmptySignatures: "allow-empty-signatures",
      allowMoreLogging: "allow-more-logging",
      extraOpcodeBudget: "extra-opcode-budget"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["txn-groups"]))
      throw new Error(`Response is missing required array field 'txn-groups': ${data}`);
    return new SimulateRequest({
      txnGroups: data["txn-groups"].map(SimulateRequestTransactionGroup.from_obj_for_encoding),
      allowEmptySignatures: data["allow-empty-signatures"],
      allowMoreLogging: data["allow-more-logging"],
      extraOpcodeBudget: data["extra-opcode-budget"]
    });
  }
}
class SimulateRequestTransactionGroup extends BaseModel {
  /**
   * Creates a new `SimulateRequestTransactionGroup` object.
   * @param txns - An atomic transaction group.
   */
  constructor({ txns }) {
    super();
    this.txns = txns;
    this.attribute_map = {
      txns: "txns"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["txns"]))
      throw new Error(`Response is missing required array field 'txns': ${data}`);
    return new SimulateRequestTransactionGroup({
      txns: data["txns"]
    });
  }
}
class SimulateResponse extends BaseModel {
  /**
   * Creates a new `SimulateResponse` object.
   * @param lastRound - The round immediately preceding this simulation. State changes through this
   * round were used to run this simulation.
   * @param txnGroups - A result object for each transaction group that was simulated.
   * @param version - The version of this response object.
   * @param evalOverrides - The set of parameters and limits override during simulation. If this set of
   * parameters is present, then evaluation parameters may differ from standard
   * evaluation in certain ways.
   */
  constructor({ lastRound, txnGroups, version: version2, evalOverrides }) {
    super();
    this.lastRound = lastRound;
    this.txnGroups = txnGroups;
    this.version = version2;
    this.evalOverrides = evalOverrides;
    this.attribute_map = {
      lastRound: "last-round",
      txnGroups: "txn-groups",
      version: "version",
      evalOverrides: "eval-overrides"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["last-round"] === "undefined")
      throw new Error(`Response is missing required field 'last-round': ${data}`);
    if (!Array.isArray(data["txn-groups"]))
      throw new Error(`Response is missing required array field 'txn-groups': ${data}`);
    if (typeof data["version"] === "undefined")
      throw new Error(`Response is missing required field 'version': ${data}`);
    return new SimulateResponse({
      lastRound: data["last-round"],
      txnGroups: data["txn-groups"].map(SimulateTransactionGroupResult.from_obj_for_encoding),
      version: data["version"],
      evalOverrides: typeof data["eval-overrides"] !== "undefined" ? SimulationEvalOverrides.from_obj_for_encoding(data["eval-overrides"]) : void 0
    });
  }
}
class SimulateTransactionGroupResult extends BaseModel {
  /**
   * Creates a new `SimulateTransactionGroupResult` object.
   * @param txnResults - Simulation result for individual transactions
   * @param appBudgetAdded - Total budget added during execution of app calls in the transaction group.
   * @param appBudgetConsumed - Total budget consumed during execution of app calls in the transaction group.
   * @param failedAt - If present, indicates which transaction in this group caused the failure. This
   * array represents the path to the failing transaction. Indexes are zero based,
   * the first element indicates the top-level transaction, and successive elements
   * indicate deeper inner transactions.
   * @param failureMessage - If present, indicates that the transaction group failed and specifies why that
   * happened
   */
  constructor({ txnResults, appBudgetAdded, appBudgetConsumed, failedAt, failureMessage }) {
    super();
    this.txnResults = txnResults;
    this.appBudgetAdded = appBudgetAdded;
    this.appBudgetConsumed = appBudgetConsumed;
    this.failedAt = failedAt;
    this.failureMessage = failureMessage;
    this.attribute_map = {
      txnResults: "txn-results",
      appBudgetAdded: "app-budget-added",
      appBudgetConsumed: "app-budget-consumed",
      failedAt: "failed-at",
      failureMessage: "failure-message"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["txn-results"]))
      throw new Error(`Response is missing required array field 'txn-results': ${data}`);
    return new SimulateTransactionGroupResult({
      txnResults: data["txn-results"].map(SimulateTransactionResult.from_obj_for_encoding),
      appBudgetAdded: data["app-budget-added"],
      appBudgetConsumed: data["app-budget-consumed"],
      failedAt: data["failed-at"],
      failureMessage: data["failure-message"]
    });
  }
}
class SimulateTransactionResult extends BaseModel {
  /**
   * Creates a new `SimulateTransactionResult` object.
   * @param txnResult - Details about a pending transaction. If the transaction was recently confirmed,
   * includes confirmation details like the round and reward details.
   * @param appBudgetConsumed - Budget used during execution of an app call transaction. This value includes
   * budged used by inner app calls spawned by this transaction.
   * @param logicSigBudgetConsumed - Budget used during execution of a logic sig transaction.
   */
  constructor({ txnResult, appBudgetConsumed, logicSigBudgetConsumed }) {
    super();
    this.txnResult = txnResult;
    this.appBudgetConsumed = appBudgetConsumed;
    this.logicSigBudgetConsumed = logicSigBudgetConsumed;
    this.attribute_map = {
      txnResult: "txn-result",
      appBudgetConsumed: "app-budget-consumed",
      logicSigBudgetConsumed: "logic-sig-budget-consumed"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["txn-result"] === "undefined")
      throw new Error(`Response is missing required field 'txn-result': ${data}`);
    return new SimulateTransactionResult({
      txnResult: PendingTransactionResponse.from_obj_for_encoding(data["txn-result"]),
      appBudgetConsumed: data["app-budget-consumed"],
      logicSigBudgetConsumed: data["logic-sig-budget-consumed"]
    });
  }
}
class SimulationEvalOverrides extends BaseModel {
  /**
   * Creates a new `SimulationEvalOverrides` object.
   * @param allowEmptySignatures - If true, transactions without signatures are allowed and simulated as if they
   * were properly signed.
   * @param extraOpcodeBudget - The extra opcode budget added to each transaction group during simulation
   * @param maxLogCalls - The maximum log calls one can make during simulation
   * @param maxLogSize - The maximum byte number to log during simulation
   */
  constructor({ allowEmptySignatures, extraOpcodeBudget, maxLogCalls, maxLogSize }) {
    super();
    this.allowEmptySignatures = allowEmptySignatures;
    this.extraOpcodeBudget = extraOpcodeBudget;
    this.maxLogCalls = maxLogCalls;
    this.maxLogSize = maxLogSize;
    this.attribute_map = {
      allowEmptySignatures: "allow-empty-signatures",
      extraOpcodeBudget: "extra-opcode-budget",
      maxLogCalls: "max-log-calls",
      maxLogSize: "max-log-size"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new SimulationEvalOverrides({
      allowEmptySignatures: data["allow-empty-signatures"],
      extraOpcodeBudget: data["extra-opcode-budget"],
      maxLogCalls: data["max-log-calls"],
      maxLogSize: data["max-log-size"]
    });
  }
}
let StateProof$1 = class StateProof extends BaseModel {
  /**
   * Creates a new `StateProof` object.
   * @param message - Represents the message that the state proofs are attesting to.
   * @param stateproof - The encoded StateProof for the message.
   */
  constructor({ message, stateproof }) {
    super();
    this.message = message;
    this.stateproof = typeof stateproof === "string" ? new Uint8Array(buffer.Buffer.from(stateproof, "base64")) : stateproof;
    this.attribute_map = {
      message: "Message",
      stateproof: "StateProof"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["Message"] === "undefined")
      throw new Error(`Response is missing required field 'Message': ${data}`);
    if (typeof data["StateProof"] === "undefined")
      throw new Error(`Response is missing required field 'StateProof': ${data}`);
    return new StateProof({
      message: StateProofMessage.from_obj_for_encoding(data["Message"]),
      stateproof: data["StateProof"]
    });
  }
};
class StateProofMessage extends BaseModel {
  /**
   * Creates a new `StateProofMessage` object.
   * @param blockheaderscommitment - The vector commitment root on all light block headers within a state proof
   * interval.
   * @param firstattestedround - The first round the message attests to.
   * @param lastattestedround - The last round the message attests to.
   * @param lnprovenweight - An integer value representing the natural log of the proven weight with 16 bits
   * of precision. This value would be used to verify the next state proof.
   * @param voterscommitment - The vector commitment root of the top N accounts to sign the next StateProof.
   */
  constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment }) {
    super();
    this.blockheaderscommitment = typeof blockheaderscommitment === "string" ? new Uint8Array(buffer.Buffer.from(blockheaderscommitment, "base64")) : blockheaderscommitment;
    this.firstattestedround = firstattestedround;
    this.lastattestedround = lastattestedround;
    this.lnprovenweight = lnprovenweight;
    this.voterscommitment = typeof voterscommitment === "string" ? new Uint8Array(buffer.Buffer.from(voterscommitment, "base64")) : voterscommitment;
    this.attribute_map = {
      blockheaderscommitment: "BlockHeadersCommitment",
      firstattestedround: "FirstAttestedRound",
      lastattestedround: "LastAttestedRound",
      lnprovenweight: "LnProvenWeight",
      voterscommitment: "VotersCommitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["BlockHeadersCommitment"] === "undefined")
      throw new Error(`Response is missing required field 'BlockHeadersCommitment': ${data}`);
    if (typeof data["FirstAttestedRound"] === "undefined")
      throw new Error(`Response is missing required field 'FirstAttestedRound': ${data}`);
    if (typeof data["LastAttestedRound"] === "undefined")
      throw new Error(`Response is missing required field 'LastAttestedRound': ${data}`);
    if (typeof data["LnProvenWeight"] === "undefined")
      throw new Error(`Response is missing required field 'LnProvenWeight': ${data}`);
    if (typeof data["VotersCommitment"] === "undefined")
      throw new Error(`Response is missing required field 'VotersCommitment': ${data}`);
    return new StateProofMessage({
      blockheaderscommitment: data["BlockHeadersCommitment"],
      firstattestedround: data["FirstAttestedRound"],
      lastattestedround: data["LastAttestedRound"],
      lnprovenweight: data["LnProvenWeight"],
      voterscommitment: data["VotersCommitment"]
    });
  }
}
class SupplyResponse extends BaseModel {
  /**
   * Creates a new `SupplyResponse` object.
   * @param currentRound - Round
   * @param onlineMoney - OnlineMoney
   * @param totalMoney - TotalMoney
   */
  constructor({ currentRound, onlineMoney, totalMoney }) {
    super();
    this.currentRound = currentRound;
    this.onlineMoney = onlineMoney;
    this.totalMoney = totalMoney;
    this.attribute_map = {
      currentRound: "current_round",
      onlineMoney: "online-money",
      totalMoney: "total-money"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current_round"] === "undefined")
      throw new Error(`Response is missing required field 'current_round': ${data}`);
    if (typeof data["online-money"] === "undefined")
      throw new Error(`Response is missing required field 'online-money': ${data}`);
    if (typeof data["total-money"] === "undefined")
      throw new Error(`Response is missing required field 'total-money': ${data}`);
    return new SupplyResponse({
      currentRound: data["current_round"],
      onlineMoney: data["online-money"],
      totalMoney: data["total-money"]
    });
  }
}
let TealKeyValue$1 = class TealKeyValue extends BaseModel {
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new TealKeyValue({
      key: data["key"],
      value: TealValue$1.from_obj_for_encoding(data["value"])
    });
  }
};
let TealValue$1 = class TealValue extends BaseModel {
  /**
   * Creates a new `TealValue` object.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param bytes - (tb) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ type, bytes, uint }) {
    super();
    this.type = type;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      type: "type",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["type"] === "undefined")
      throw new Error(`Response is missing required field 'type': ${data}`);
    if (typeof data["bytes"] === "undefined")
      throw new Error(`Response is missing required field 'bytes': ${data}`);
    if (typeof data["uint"] === "undefined")
      throw new Error(`Response is missing required field 'uint': ${data}`);
    return new TealValue({
      type: data["type"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
};
class TransactionGroupLedgerStateDeltasForRoundResponse extends BaseModel {
  /**
   * Creates a new `TransactionGroupLedgerStateDeltasForRoundResponse` object.
   * @param deltas -
   */
  constructor({ deltas }) {
    super();
    this.deltas = deltas;
    this.attribute_map = {
      deltas: "deltas"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["Deltas"]))
      throw new Error(`Response is missing required array field 'Deltas': ${data}`);
    return new TransactionGroupLedgerStateDeltasForRoundResponse({
      deltas: data["Deltas"].map(LedgerStateDeltaForTransactionGroup.from_obj_for_encoding)
    });
  }
}
class TransactionParametersResponse extends BaseModel {
  /**
   * Creates a new `TransactionParametersResponse` object.
   * @param consensusVersion - ConsensusVersion indicates the consensus protocol version
   * as of LastRound.
   * @param fee - Fee is the suggested transaction fee
   * Fee is in units of micro-Algos per byte.
   * Fee may fall to zero but transactions must still have a fee of
   * at least MinTxnFee for the current network protocol.
   * @param genesisHash - GenesisHash is the hash of the genesis block.
   * @param genesisId - GenesisID is an ID listed in the genesis block.
   * @param lastRound - LastRound indicates the last round seen
   * @param minFee - The minimum transaction fee (not per byte) required for the
   * txn to validate for the current network protocol.
   */
  constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
    super();
    this.consensusVersion = consensusVersion;
    this.fee = fee;
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(buffer.Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.lastRound = lastRound;
    this.minFee = minFee;
    this.attribute_map = {
      consensusVersion: "consensus-version",
      fee: "fee",
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      lastRound: "last-round",
      minFee: "min-fee"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["consensus-version"] === "undefined")
      throw new Error(`Response is missing required field 'consensus-version': ${data}`);
    if (typeof data["fee"] === "undefined")
      throw new Error(`Response is missing required field 'fee': ${data}`);
    if (typeof data["genesis-hash"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${data}`);
    if (typeof data["genesis-id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${data}`);
    if (typeof data["last-round"] === "undefined")
      throw new Error(`Response is missing required field 'last-round': ${data}`);
    if (typeof data["min-fee"] === "undefined")
      throw new Error(`Response is missing required field 'min-fee': ${data}`);
    return new TransactionParametersResponse({
      consensusVersion: data["consensus-version"],
      fee: data["fee"],
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      lastRound: data["last-round"],
      minFee: data["min-fee"]
    });
  }
}
class TransactionProofResponse extends BaseModel {
  /**
   * Creates a new `TransactionProofResponse` object.
   * @param idx - Index of the transaction in the block's payset.
   * @param proof - Proof of transaction membership.
   * @param stibhash - Hash of SignedTxnInBlock for verifying proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   * @param hashtype - The type of hash function used to create the proof, must be one of:
   * * sha512_256
   * * sha256
   */
  constructor({ idx, proof, stibhash, treedepth, hashtype }) {
    super();
    this.idx = idx;
    this.proof = typeof proof === "string" ? new Uint8Array(buffer.Buffer.from(proof, "base64")) : proof;
    this.stibhash = typeof stibhash === "string" ? new Uint8Array(buffer.Buffer.from(stibhash, "base64")) : stibhash;
    this.treedepth = treedepth;
    this.hashtype = hashtype;
    this.attribute_map = {
      idx: "idx",
      proof: "proof",
      stibhash: "stibhash",
      treedepth: "treedepth",
      hashtype: "hashtype"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["idx"] === "undefined")
      throw new Error(`Response is missing required field 'idx': ${data}`);
    if (typeof data["proof"] === "undefined")
      throw new Error(`Response is missing required field 'proof': ${data}`);
    if (typeof data["stibhash"] === "undefined")
      throw new Error(`Response is missing required field 'stibhash': ${data}`);
    if (typeof data["treedepth"] === "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${data}`);
    return new TransactionProofResponse({
      idx: data["idx"],
      proof: data["proof"],
      stibhash: data["stibhash"],
      treedepth: data["treedepth"],
      hashtype: data["hashtype"]
    });
  }
}
class Version extends BaseModel {
  /**
   * Creates a new `Version` object.
   * @param build -
   * @param genesisHashB64 -
   * @param genesisId -
   * @param versions -
   */
  constructor({ build, genesisHashB64, genesisId, versions }) {
    super();
    this.build = build;
    this.genesisHashB64 = typeof genesisHashB64 === "string" ? new Uint8Array(buffer.Buffer.from(genesisHashB64, "base64")) : genesisHashB64;
    this.genesisId = genesisId;
    this.versions = versions;
    this.attribute_map = {
      build: "build",
      genesisHashB64: "genesis_hash_b64",
      genesisId: "genesis_id",
      versions: "versions"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["build"] === "undefined")
      throw new Error(`Response is missing required field 'build': ${data}`);
    if (typeof data["genesis_hash_b64"] === "undefined")
      throw new Error(`Response is missing required field 'genesis_hash_b64': ${data}`);
    if (typeof data["genesis_id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis_id': ${data}`);
    if (!Array.isArray(data["versions"]))
      throw new Error(`Response is missing required array field 'versions': ${data}`);
    return new Version({
      build: BuildVersion.from_obj_for_encoding(data["build"]),
      genesisHashB64: data["genesis_hash_b64"],
      genesisId: data["genesis_id"],
      versions: data["versions"]
    });
  }
}
const types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account: Account$1,
  AccountApplicationResponse,
  AccountAssetResponse,
  AccountParticipation: AccountParticipation$1,
  AccountStateDelta: AccountStateDelta$1,
  Application: Application$1,
  ApplicationLocalState: ApplicationLocalState$1,
  ApplicationParams: ApplicationParams$1,
  ApplicationStateSchema: ApplicationStateSchema$1,
  Asset: Asset$1,
  AssetHolding: AssetHolding$1,
  AssetParams: AssetParams$1,
  BlockHashResponse,
  BlockResponse,
  Box: Box$1,
  BoxDescriptor: BoxDescriptor$1,
  BoxesResponse: BoxesResponse$1,
  BuildVersion,
  CompileResponse,
  DisassembleResponse,
  DryrunRequest,
  DryrunResponse,
  DryrunSource,
  DryrunState,
  DryrunTxnResult,
  ErrorResponse: ErrorResponse$1,
  EvalDelta: EvalDelta$1,
  EvalDeltaKeyValue: EvalDeltaKeyValue$1,
  GetBlockTimeStampOffsetResponse,
  GetSyncRoundResponse,
  KvDelta,
  LedgerStateDeltaForTransactionGroup,
  LightBlockHeaderProof: LightBlockHeaderProof$1,
  NodeStatusResponse,
  PendingTransactionResponse,
  PendingTransactionsResponse,
  PostTransactionsResponse,
  SimulateRequest,
  SimulateRequestTransactionGroup,
  SimulateResponse,
  SimulateTransactionGroupResult,
  SimulateTransactionResult,
  SimulationEvalOverrides,
  StateProof: StateProof$1,
  StateProofMessage,
  SupplyResponse,
  TealKeyValue: TealKeyValue$1,
  TealValue: TealValue$1,
  TransactionGroupLedgerStateDeltasForRoundResponse,
  TransactionParametersResponse,
  TransactionProofResponse,
  Version
}, Symbol.toStringTag, { value: "Module" }));
class JSONRequest {
  /**
   * @param client - HTTPClient object.
   * @param intDecoding - The method to use
   *   for decoding integers from this request's response. See the setIntDecoding method for more
   *   details.
   */
  constructor(client, intDecoding) {
    this.c = client;
    this.query = {};
    this.intDecoding = intDecoding || IntDecoding$1.DEFAULT;
  }
  /**
   * Prepare a JSON response before returning it.
   *
   * Use this method to change and restructure response
   * data as needed after receiving it from the `do()` method.
   * @param body - Response body received
   * @category JSONRequest
   */
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return body;
  }
  /**
   * Execute the request.
   * @param headers - Additional headers to send in the request. Optional.
   * @returns A promise which resolves to the parsed response data.
   * @category JSONRequest
   */
  async do(headers = {}) {
    const jsonOptions = {};
    if (this.intDecoding !== "default") {
      jsonOptions.intDecoding = this.intDecoding;
    }
    const res = await this.c.get(this.path(), this.query, headers, jsonOptions);
    return this.prepare(res.body);
  }
  /**
   * Execute the request, but do not process the response data in any way.
   * @param headers - Additional headers to send in the request. Optional.
   * @returns A promise which resolves to the raw response data, exactly as returned by the server.
   * @category JSONRequest
   */
  async doRaw(headers = {}) {
    const res = await this.c.get(this.path(), this.query, headers, {}, false);
    return res.body;
  }
  /**
   * Configure how integers in this request's JSON response will be decoded.
   *
   * The options are:
   * * "default": Integers will be decoded according to JSON.parse, meaning they will all be
   *   Numbers and any values greater than Number.MAX_SAFE_INTEGER will lose precision.
   * * "safe": All integers will be decoded as Numbers, but if any values are greater than
   *   Number.MAX_SAFE_INTEGER an error will be thrown.
   * * "mixed": Integers will be decoded as Numbers if they are less than or equal to
   *   Number.MAX_SAFE_INTEGER, otherwise they will be decoded as BigInts.
   * * "bigint": All integers will be decoded as BigInts.
   *
   * @param method - The method to use when parsing the
   *   response for this request. Must be one of "default", "safe", "mixed", or "bigint".
   * @category JSONRequest
   */
  setIntDecoding(method) {
    if (method !== "default" && method !== "safe" && method !== "mixed" && method !== "bigint")
      throw new Error(`Invalid method for int decoding: ${method}`);
    this.intDecoding = method;
    return this;
  }
}
class AccountInformation extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Exclude assets and application data from results
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address)
   *        .exclude('all')
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
}
class AccountAssetInformation extends JSONRequest {
  constructor(c, intDecoding, account, assetID) {
    super(c, intDecoding);
    this.account = account;
    this.assetID = assetID;
    this.account = account;
    this.assetID = assetID;
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
}
class AccountApplicationInformation extends JSONRequest {
  constructor(c, intDecoding, account, applicationID) {
    super(c, intDecoding);
    this.account = account;
    this.applicationID = applicationID;
    this.account = account;
    this.applicationID = applicationID;
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
}
let Block$1 = class Block extends JSONRequest {
  constructor(c, roundNumber) {
    super(c);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
    this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
};
function setHeaders$1(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
class Compile extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/compile`;
  }
  sourcemap(map2 = true) {
    this.query.sourcemap = map2;
    return this;
  }
  /**
   * Executes compile
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders$1(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.source), txHeaders, this.query);
    return res.body;
  }
}
class Dryrun extends JSONRequest {
  constructor(c, dr2) {
    super(c);
    this.blob = encode(dr2.get_obj_for_encoding(true));
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/teal/dryrun";
  }
  /**
   * Executes dryrun
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders$1(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.blob), txHeaders);
    return res.body;
  }
}
class Genesis extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/genesis";
  }
}
class GetAssetByID extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
}
class GetApplicationByID extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
}
class GetBlockHash extends JSONRequest {
  constructor(c, intDecoding, roundNumber) {
    super(c, intDecoding);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
}
class GetApplicationBoxByName extends JSONRequest {
  constructor(c, intDecoding, index2, name) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    const encodedName = buffer.Buffer.from(name).toString("base64");
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return Box$1.from_obj_for_encoding(body);
  }
}
class GetApplicationBoxes extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    this.query.max = 0;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResult = await algodClient
   *        .GetApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  max(max) {
    this.query.max = max;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return BoxesResponse$1.from_obj_for_encoding(body);
  }
}
let HealthCheck$1 = class HealthCheck extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
  async do(headers = {}) {
    const res = await this.c.get(this.path(), {}, headers);
    if (!res.ok) {
      throw new Error(`Health response: ${res.status}`);
    }
    return {};
  }
};
class PendingTransactionInformation extends JSONRequest {
  constructor(c, txid) {
    super(c);
    this.txid = txid;
    this.txid = txid;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
}
class PendingTransactions extends JSONRequest {
  constructor(c) {
    super(c);
    this.query.format = "msgpack";
  }
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/pending";
  }
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
  /* eslint-enable class-methods-use-this */
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
}
class PendingTransactionsByAddress extends JSONRequest {
  constructor(c, address) {
    super(c);
    this.address = address;
    this.address = address;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
}
class GetTransactionProof extends JSONRequest {
  constructor(c, intDecoding, round, txID) {
    super(c, intDecoding);
    this.round = round;
    this.txID = txID;
    this.round = round;
    this.txID = txID;
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  /**
   * Exclude assets and application data from results
   * The type of hash function used to create the proof, must be one of: "sha512_256", "sha256"
   *
   * #### Example
   * ```typescript
   * const hashType = "sha256";
   * const round = 123456;
   * const txId = "abc123;
   * const txProof = await algodClient.getTransactionProof(round, txId)
   *        .hashType(hashType)
   *        .do();
   * ```
   *
   * @param hashType
   * @category query
   */
  hashType(hashType) {
    this.query.hashtype = hashType;
    return this;
  }
}
function setSendTransactionHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/x-binary";
  }
  return hdrs;
}
function isByteArray(array2) {
  return array2 && array2.byteLength !== void 0;
}
class SendRawTransaction extends JSONRequest {
  constructor(c, stxOrStxs) {
    super(c);
    let forPosting = stxOrStxs;
    if (Array.isArray(stxOrStxs)) {
      if (!stxOrStxs.every(isByteArray)) {
        throw new TypeError("Array elements must be byte arrays");
      }
      forPosting = concatArrays(...stxOrStxs);
    } else if (!isByteArray(forPosting)) {
      throw new TypeError("Argument must be byte array");
    }
    this.txnBytesToPost = forPosting;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  async do(headers = {}) {
    const txHeaders = setSendTransactionHeaders(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.txnBytesToPost), txHeaders);
    return res.body;
  }
}
class Status extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/status";
  }
}
class StatusAfterBlock extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    if (!Number.isInteger(round))
      throw Error("round should be an integer");
    this.round = round;
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
}
class SuggestedParamsRequest extends JSONRequest {
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/params";
  }
  prepare(body) {
    return {
      flatFee: false,
      fee: body.fee,
      firstRound: body["last-round"],
      lastRound: body["last-round"] + 1e3,
      genesisID: body["genesis-id"],
      genesisHash: body["genesis-hash"],
      minFee: body["min-fee"]
    };
  }
}
class Supply extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/ledger/supply";
  }
}
class Versions extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/versions";
  }
}
class LightBlockHeaderProof2 extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
}
class StateProof2 extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
}
class SetSyncRound extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/ledger/sync/${this.round}`;
  }
  async do(headers = {}) {
    const res = await this.c.post(this.path(), headers);
    return res.body;
  }
}
class GetSyncRound extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/ledger/sync`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return GetSyncRoundResponse.from_obj_for_encoding(body);
  }
}
class SetBlockOffsetTimestamp extends JSONRequest {
  constructor(c, intDecoding, offset) {
    super(c, intDecoding);
    this.offset = offset;
    this.offset = offset;
  }
  path() {
    return `/v2/devmode/blocks/offset/${this.offset}`;
  }
  async do(headers = {}) {
    const res = await this.c.post(this.path(), headers);
    return res.body;
  }
}
class GetBlockOffsetTimestamp extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/devmode/blocks/offset`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return GetBlockTimeStampOffsetResponse.from_obj_for_encoding(body);
  }
}
function setHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
class Disassemble extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/disassemble`;
  }
  /**
   * Executes disassemble
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.source), txHeaders, this.query);
    return res.body;
  }
}
function setSimulateTransactionsHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/msgpack";
  }
  return hdrs;
}
class SimulateRawTransactions extends JSONRequest {
  constructor(c, request) {
    super(c);
    this.query.format = "msgpack";
    this.requestBytes = rawEncode(request.get_obj_for_encoding(true));
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions/simulate";
  }
  async do(headers = {}) {
    const txHeaders = setSimulateTransactionsHeaders(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.requestBytes), txHeaders, this.query, false);
    return this.prepare(res.body);
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    const decoded = decode$1(body);
    return SimulateResponse.from_obj_for_encoding(decoded);
  }
}
class Ready extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/ready`;
  }
}
class UnsetSyncRound extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/ledger/sync`;
  }
  async do(headers = {}) {
    const res = await this.c.delete(this.path(), headers);
    return res.body;
  }
}
class GetLedgerStateDeltaForTransactionGroup extends JSONRequest {
  constructor(c, intDecoding, id2) {
    super(c, intDecoding);
    this.id = id2;
    this.id = id2;
    this.query = { format: "json" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/txn/group/${this.id}`;
  }
}
class GetLedgerStateDelta extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
    this.query = { format: "json" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/${this.round}`;
  }
}
class GetTransactionGroupLedgerStateDeltasForRound extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
    this.query = { format: "json" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/${this.round}/txn/group`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return TransactionGroupLedgerStateDeltasForRoundResponse.from_obj_for_encoding(body);
  }
}
class AlgodClient extends ServiceClient {
  /**
   * Create an AlgodClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
   * const server = "http://localhost";
   * const port   = 4001;
   * const algodClient = new algosdk.Algodv2(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The algod token from the Algorand node you are interacting with
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer, port, headers = {}) {
    super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns OK if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await algodClient.healthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-health)
   * @category GET
   */
  healthCheck() {
    return new HealthCheck$1(this.c);
  }
  /**
   * Retrieves the supported API versions, binary build versions, and genesis information.
   *
   * #### Example
   * ```typescript
   * const versionsDetails = await algodClient.versionsCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-versions)
   * @category GET
   */
  versionsCheck() {
    return new Versions(this.c);
  }
  /**
   * Broadcasts a raw transaction to the network.
   *
   * #### Example
   * ```typescript
   * const { txId } = await algodClient.sendRawTransaction(signedTxns).do();
   * const result = await waitForConfirmation(algodClient, txid, 3);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactions)
   *
   * @remarks
   * Often used with {@linkcode waitForConfirmation}
   * @param stxOrStxs - Signed transactions
   * @category POST
   */
  sendRawTransaction(stxOrStxs) {
    return new SendRawTransaction(this.c, stxOrStxs);
  }
  /**
   * Returns the given account's status, balance and spendable amounts.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @category GET
   */
  accountInformation(account) {
    return new AccountInformation(this.c, this.intDecoding, account);
  }
  /**
   * Returns the given account's asset information for a specific asset.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountAssetInfo = await algodClient.accountAssetInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The asset ID to look up.
   * @category GET
   */
  accountAssetInformation(account, index2) {
    return new AccountAssetInformation(this.c, this.intDecoding, account, index2);
  }
  /**
   * Returns the given account's application information for a specific application.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountInfo = await algodClient.accountApplicationInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The application ID to look up.
   * @category GET
   */
  accountApplicationInformation(account, index2) {
    return new AccountApplicationInformation(this.c, this.intDecoding, account, index2);
  }
  /**
   * Gets the block info for the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.block(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksround)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  block(roundNumber) {
    return new Block$1(this.c, roundNumber);
  }
  /**
   * Get the block hash for the block on the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.getBlockHash(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundhash)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  getBlockHash(roundNumber) {
    return new GetBlockHash(this.c, this.intDecoding, roundNumber);
  }
  /**
   * Returns the transaction information for a specific pending transaction.
   *
   * #### Example
   * ```typescript
   * const txId = "DRJS6R745A7GFVMXEXWP4TGVDGKW7VILFTA7HC2BR2GRLHNY5CTA";
   * const pending = await algodClient.pendingTransactionInformation(txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspendingtxid)
   *
   * @remarks
   * <br><br>
   * There are several cases when this might succeed:
   * - transaction committed (committed round > 0)
   * - transaction still in the pool (committed round = 0, pool error = "")
   * - transaction removed from pool due to error (committed round = 0, pool error != "")
   *
   * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
   *
   * @param txid - The TxID string of the pending transaction to look up.
   * @category GET
   */
  pendingTransactionInformation(txid) {
    return new PendingTransactionInformation(this.c, txid);
  }
  /**
   * Returns the list of pending transactions in the pool, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const pendingTxns = await algodClient.pendingTransactionsInformation().do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const pendingTxns = await algodClient
   *     .pendingTransactionsInformation()
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspending)
   * @category GET
   */
  pendingTransactionsInformation() {
    return new PendingTransactions(this.c);
  }
  /**
   * Returns the list of pending transactions sent by the address, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxnsByAddr = await algodClient.pendingTransactionByAddress(address).do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxns = await algodClient
   *     .pendingTransactionByAddress(address)
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddresstransactionspending)
   * @param address - The address of the sender.
   * @category GET
   */
  pendingTransactionByAddress(address) {
    return new PendingTransactionsByAddress(this.c, address);
  }
  /**
   * Retrieves the StatusResponse from the running node.
   *
   * #### Example
   * ```typescript
   * const status = await algodClient.status().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2status)
   * @category GET
   */
  status() {
    return new Status(this.c, this.intDecoding);
  }
  /**
   * Waits for a specific round to occur then returns the `StatusResponse` for that round.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const statusAfterBlock = await algodClient.statusAfterBlock(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2statuswait-for-block-afterround)
   * @param round - The number of the round to wait for.
   * @category GET
   */
  statusAfterBlock(round) {
    return new StatusAfterBlock(this.c, this.intDecoding, round);
  }
  /**
   * Returns the common needed parameters for a new transaction.
   *
   * #### Example
   * ```typescript
   * const suggestedParams = await algodClient.getTransactionParams().do();
   * const amountInMicroAlgos = algosdk.algosToMicroalgos(2); // 2 Algos
   * const unsignedTxn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
   *   from: senderAddress,
   *   to: receiverAddress,
   *   amount: amountInMicroAlgos,
   *   suggestedParams: suggestedParams,
   * });
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionsparams)
   *
   * @remarks
   * Often used with
   * {@linkcode makePaymentTxnWithSuggestedParamsFromObject}, {@linkcode algosToMicroalgos}
   * @category GET
   */
  getTransactionParams() {
    return new SuggestedParamsRequest(this.c);
  }
  /**
   * Returns the supply details for the specified node's ledger.
   *
   * #### Example
   * ```typescript
   * const supplyDetails = await algodClient.supply().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersupply)
   * @category GET
   */
  supply() {
    return new Supply(this.c, this.intDecoding);
  }
  /**
   * Compiles TEAL source code to binary, returns base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style).
   *
   * #### Example
   * ```typescript
   * const source = "TEAL SOURCE CODE";
   * const compiledSmartContract = await algodClient.compile(source).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealcompile)
   * @remarks
   * This endpoint is only enabled when a node's configuration file sets `EnableDeveloperAPI` to true.
   * @param source
   * @category POST
   */
  compile(source) {
    return new Compile(this.c, source);
  }
  /**
   * Given the program bytes, return the TEAL source code in plain text.
   *
   * #### Example
   * ```typescript
   * const bytecode = "TEAL bytecode";
   * const disassembledSource = await algodClient.disassemble(bytecode).do();
   * ```
   *
   * @remarks This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
   * @param source
   */
  disassemble(source) {
    return new Disassemble(this.c, source);
  }
  /**
   * Provides debugging information for a transaction (or group).
   *
   * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configureation file sets `EnableDeveloperAPI` to true.
   *
   * #### Example
   * ```typescript
   * const dryRunResult = await algodClient.dryrun(dr).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealdryrun)
   * @param dr
   * @category POST
   */
  dryrun(dr2) {
    return new Dryrun(this.c, dr2);
  }
  /**
   * Given an asset ID, return asset information including creator, name, total supply and
   * special addresses.
   *
   * #### Example
   * ```typescript
   * const asset_id = 163650;
   * const asset = await algodClient.getAssetByID(asset_id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   * @category GET
   */
  getAssetByID(index2) {
    return new GetAssetByID(this.c, this.intDecoding, index2);
  }
  /**
   * Given an application ID, return the application information including creator, approval
   * and clear programs, global and local schemas, and global state.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const app = await algodClient.getApplicationByID(index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-id)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationByID(index2) {
    return new GetApplicationByID(this.c, this.intDecoding, index2);
  }
  /**
   * Given an application ID and the box name (key), return the value stored in the box.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxName = Buffer.from("foo");
   * const boxResponse = await algodClient.getApplicationBoxByName(index, boxName).do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idbox)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxByName(index2, boxName) {
    return new GetApplicationBoxByName(this.c, this.intDecoding, index2, boxName);
  }
  /**
   * Given an application ID, return all the box names associated with the app.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxesResponse = await algodClient.getApplicationBoxes(index).max(3).do();
   * const boxNames = boxesResponse.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idboxes)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxes(index2) {
    return new GetApplicationBoxes(this.c, this.intDecoding, index2);
  }
  /**
   * Returns the entire genesis file.
   *
   * #### Example
   * ```typescript
   * const genesis = await algodClient.genesis().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-genesis)
   * @category GET
   */
  genesis() {
    return new Genesis(this.c, this.intDecoding);
  }
  /**
   * Returns a Merkle proof for a given transaction in a block.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const proof = await algodClient.getTransactionProof(round, txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundtransactionstxidproof)
   * @param round - The round in which the transaction appears.
   * @param txID - The transaction ID for which to generate a proof.
   * @category GET
   */
  getTransactionProof(round, txID) {
    return new GetTransactionProof(this.c, this.intDecoding, round, txID);
  }
  /**
   * Gets a proof for a given light block header inside a state proof commitment.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const lightBlockHeaderProof = await algodClient.getLightBlockHeaderProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2blocksroundlightheaderproof)
   * @param round
   */
  getLightBlockHeaderProof(round) {
    return new LightBlockHeaderProof2(this.c, this.intDecoding, round);
  }
  /**
   * Gets a state proof that covers a given round.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const stateProof = await algodClient.getStateProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2stateproofsround)
   * @param round
   */
  getStateProof(round) {
    return new StateProof2(this.c, this.intDecoding, round);
  }
  /**
   * Simulate a list of a signed transaction objects being sent to the network.
   *
   * #### Example
   * ```typescript
   * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
   * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
   * const txgroup = algosdk.assignGroupID([txn1, txn2]);
   *
   * // Actually sign the first transaction
   * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
   * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
   * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
   *
   * const resp = await client.simulateRawTransactions([signedTxn1, signedTxn2]).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
   * @param stxOrStxs
   * @category POST
   */
  simulateRawTransactions(stxOrStxs) {
    const txnObjects = [];
    if (Array.isArray(stxOrStxs)) {
      for (const stxn of stxOrStxs) {
        txnObjects.push(decode$1(stxn));
      }
    } else {
      txnObjects.push(decode$1(stxOrStxs));
    }
    const request = new SimulateRequest({
      txnGroups: [
        new SimulateRequestTransactionGroup({
          txns: txnObjects
        })
      ]
    });
    return this.simulateTransactions(request);
  }
  /**
   * Simulate transactions being sent to the network.
   *
   * #### Example
   * ```typescript
   * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
   * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
   * const txgroup = algosdk.assignGroupID([txn1, txn2]);
   *
   * // Actually sign the first transaction
   * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
   * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
   * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
   *
   * const request = new modelsv2.SimulateRequest({
   *  txnGroups: [
   *    new modelsv2.SimulateRequestTransactionGroup({
   *       // Must decode the signed txn bytes into an object
   *       txns: [algosdk.decodeObj(signedTxn1), algosdk.decodeObj(signedTxn2)]
   *     }),
   *   ],
   * });
   * const resp = await client.simulateRawTransactions(request).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
   * @param request
   * @category POST
   */
  simulateTransactions(request) {
    return new SimulateRawTransactions(this.c, request);
  }
  /**
   * Set the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
   *
   *  #### Example
   *  ```typesecript
   *  const offset = 60
   *  await client.setBlockOffsetTimestamp(offset).do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2devmodeblocksoffsetoffset)
   * @param offset
   * @category POST
   */
  setBlockOffsetTimestamp(offset) {
    return new SetBlockOffsetTimestamp(this.c, this.intDecoding, offset);
  }
  /**
   * Get the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
   *
   *  #### Example
   *  ```typesecript
   *  const currentOffset = await client.getBlockOffsetTimestamp().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2devmodeblocksoffset)
   * @category GET
   */
  getBlockOffsetTimestamp() {
    return new GetBlockOffsetTimestamp(this.c, this.intDecoding);
  }
  /**
   * Set the sync round on the ledger (algod must have EnableFollowMode: true), restricting catchup.
   *
   *  #### Example
   *  ```typesecript
   *  const round = 10000
   *  await client.setSyncRound(round).do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2ledgersyncround)
   * @param round
   * @category POST
   */
  setSyncRound(round) {
    return new SetSyncRound(this.c, this.intDecoding, round);
  }
  /**
   * Un-Set the sync round on the ledger (algod must have EnableFollowMode: true), removing the restriction on catchup.
   *
   *  #### Example
   *  ```typesecript
   *  await client.unsetSyncRound().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#delete-v2ledgersync)
   * @category DELETE
   */
  unsetSyncRound() {
    return new UnsetSyncRound(this.c, this.intDecoding);
  }
  /**
   * Get the current sync round on the ledger (algod must have EnableFollowMode: true).
   *
   *  #### Example
   *  ```typesecript
   *  const currentSyncRound = await client.getSyncRound().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersync)
   * @category GET
   */
  getSyncRound() {
    return new GetSyncRound(this.c, this.intDecoding);
  }
  /**
   * Ready check which returns 200 OK if algod is healthy and caught up
   *
   *  #### Example
   *  ```typesecript
   *  await client.ready().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-ready)
   * @category GET
   */
  ready() {
    return new Ready(this.c, this.intDecoding);
  }
  /**
   * GetLedgerStateDeltaForTransactionGroup returns the ledger delta for the txn group identified by id
   *
   * #### Example
   * ```typescript
   * const id = "ABC123";
   * await client.getLedgerStateDeltaForTransactionGroup(id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltastxngroupid)
   * @param id txn ID or group ID to be searched for
   * @category GET
   */
  getLedgerStateDeltaForTransactionGroup(id2) {
    return new GetLedgerStateDeltaForTransactionGroup(this.c, this.intDecoding, id2);
  }
  /**
   * GetLedgerStateDelta returns the ledger delta for the entire round
   *
   * #### Example
   * ```typescript
   * const round = 12345;
   * await client.getLedgerStateDelta(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasround)
   * @param round the round number to be searched for
   * @category GET
   */
  getLedgerStateDelta(round) {
    return new GetLedgerStateDelta(this.c, this.intDecoding, round);
  }
  /**
   * GetTransactionGroupLedgerStateDeltasForRound returns all ledger deltas for txn groups in the provided round
   *
   * #### Example
   * ```typescript
   * const round = 12345;
   * await client.getTransactionGroupLedgerStateDeltasForRound(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasroundtxngroup)
   * @param round the round number to be searched for
   * @category GET
   */
  getTransactionGroupLedgerStateDeltasForRound(round) {
    return new GetTransactionGroupLedgerStateDeltasForRound(this.c, this.intDecoding, round);
  }
}
class Kmd extends ServiceClient {
  constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
    super("X-KMD-API-Token", token, baseServer, port, headers);
  }
  /**
   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
   */
  async versions() {
    const res = await this.c.get("/versions");
    return res.body;
  }
  /**
   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
   */
  async listWallets() {
    const res = await this.c.get("/v1/wallets");
    return res.body;
  }
  /**
   * createWallet creates a wallet with the specified name, password, driver,
   * and master derivation key. If the master derivation key is blank, one is
   * generated internally to kmd. CreateWallet returns a CreateWalletResponse
   * containing information about the new wallet.
   * @param walletName
   * @param walletPassword
   * @param walletDriverName
   * @param walletMDK
   */
  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = "sqlite") {
    const req = {
      wallet_name: walletName,
      wallet_driver_name: walletDriverName,
      wallet_password: walletPassword,
      master_derivation_key: buffer.Buffer.from(walletMDK).toString("base64")
    };
    const res = await this.c.post("/v1/wallet", req);
    return res.body;
  }
  /**
   * initWalletHandle accepts a wallet ID and a wallet password, and returns an
   * initWalletHandleResponse containing a wallet handle token. This wallet
   * handle token can be used for subsequent operations on this wallet, like key
   * generation, transaction signing, etc.. WalletHandleTokens expire after a
   * configurable number of seconds, and must be renewed periodically with
   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
   * you're done interacting with this wallet.
   * @param walletID
   * @param walletPassword
   */
  async initWalletHandle(walletID, walletPassword) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/wallet/init", req);
    return res.body;
  }
  /**
   * releaseWalletHandle invalidates the passed wallet handle token, making
   * it unusuable for subsequent wallet operations.
   * @param walletHandle
   */
  async releaseWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/release", req);
    return res.body;
  }
  /**
   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
   * the expiration time to some number of seconds in the future. It returns a
   * RenewWalletHandleResponse containing the walletHandle and the number of
   * seconds until expiration
   * @param walletHandle
   */
  async renewWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/renew", req);
    return res.body;
  }
  /**
   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
   * and renames the underlying wallet.
   * @param walletID
   * @param walletPassword
   * @param newWalletName
   */
  async renameWallet(walletID, walletPassword, newWalletName) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword,
      wallet_name: newWalletName
    };
    const res = await this.c.post("/v1/wallet/rename", req);
    return res.body;
  }
  /**
   * getWallet accepts a wallet handle and returns high level information about
   * this wallet in a GetWalletResponse.
   * @param walletHandle
   */
  async getWallet(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/info", req);
    return res.body;
  }
  /**
   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
   * returns an ExportMasterDerivationKeyResponse containing the master
   * derivation key. This key can be used as an argument to CreateWallet in
   * order to recover the keys generated by this wallet. The master derivation
   * key can be encoded as a sequence of words using the mnemonic library, and
   * @param walletHandle
   * @param walletPassword
   */
  async exportMasterDerivationKey(walletHandle, walletPassword) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/master-key/export", req);
    return {
      master_derivation_key: buffer.Buffer.from(res.body.master_derivation_key, "base64")
    };
  }
  /**
   * importKey accepts a wallet handle and an ed25519 private key, and imports
   * the key into the wallet. It returns an ImportKeyResponse containing the
   * address corresponding to this private key.
   * @param walletHandle
   * @param secretKey
   */
  async importKey(walletHandle, secretKey) {
    const req = {
      wallet_handle_token: walletHandle,
      private_key: buffer.Buffer.from(secretKey).toString("base64")
    };
    const res = await this.c.post("/v1/key/import", req);
    return res.body;
  }
  /**
   * exportKey accepts a wallet handle, wallet password, and address, and returns
   * an ExportKeyResponse containing the ed25519 private key corresponding to the
   * address stored in the wallet.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/key/export", req);
    return { private_key: buffer.Buffer.from(res.body.private_key, "base64") };
  }
  /**
   * generateKey accepts a wallet handle, and then generates the next key in the
   * wallet using its internal master derivation key. Two wallets with the same
   * master derivation key will generate the same sequence of keys.
   * @param walletHandle
   */
  async generateKey(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle,
      display_mnemonic: false
    };
    const res = await this.c.post("/v1/key", req);
    return res.body;
  }
  /**
   * deleteKey accepts a wallet handle, wallet password, and address, and deletes
   * the information about this address from the wallet (including address and
   * secret key). If DeleteKey is called on a key generated using GenerateKey,
   * the same key will not be generated again. However, if a wallet is recovered
   * using the master derivation key, a key generated in this way can be
   * recovered.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/key", req);
    return res.body;
  }
  /**
   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
   * all of the addresses for which this wallet contains secret keys.
   * @param walletHandle
   */
  async listKeys(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/key/list", req);
    return res.body;
  }
  /**
   * signTransaction accepts a wallet handle, wallet password, and a transaction,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * Sender field.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   */
  async signTransaction(walletHandle, walletPassword, transaction2) {
    const tx2 = instantiateTxnIfNeeded(transaction2);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: buffer.Buffer.from(tx2.toByte()).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return buffer.Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  /**
   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * publicKey arg.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)
   */
  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction2, publicKey) {
    const tx2 = instantiateTxnIfNeeded(transaction2);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: buffer.Buffer.from(tx2.toByte()).toString("base64"),
      public_key: buffer.Buffer.from(publicKey).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return buffer.Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  /**
   * listMultisig accepts a wallet handle and returns a ListMultisigResponse
   * containing the multisig addresses whose preimages are stored in this wallet.
   * A preimage is the information needed to reconstruct this multisig address,
   * including multisig version information, threshold information, and a list
   * of public keys.
   * @param walletHandle
   */
  async listMultisig(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/multisig/list", req);
    return res.body;
  }
  /**
   * importMultisig accepts a wallet handle and the information required to
   * generate a multisig address. It derives this address, and stores all of the
   * information within the wallet. It returns a ImportMultisigResponse with the
   * derived address.
   * @param walletHandle
   * @param version
   * @param threshold
   * @param pks
   */
  async importMultisig(walletHandle, version2, threshold, pks) {
    const req = {
      wallet_handle_token: walletHandle,
      multisig_version: version2,
      threshold,
      pks
    };
    const res = await this.c.post("/v1/multisig/import", req);
    return res.body;
  }
  /**
   * exportMultisig accepts a wallet handle, wallet password, and multisig
   * address, and returns an ExportMultisigResponse containing the stored
   * multisig preimage. The preimage contains all of the information necessary
   * to derive the multisig address, including version, threshold, and a list of
   * public keys.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportMultisig(walletHandle, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr
    };
    const res = await this.c.post("/v1/multisig/export", req);
    return res.body;
  }
  /**
   * signMultisigTransaction accepts a wallet handle, wallet password,
   * transaction, public key (*not* an address), and an optional partial
   * MultisigSig. It looks up the secret key corresponding to the public key, and
   * returns a SignMultisigTransactionResponse containing a MultisigSig with a
   * signature by the secret key included.
   * @param walletHandle
   * @param pw
   * @param tx
   * @param pk
   * @param partial
   */
  async signMultisigTransaction(walletHandle, pw, transaction2, pk, partial) {
    const tx2 = instantiateTxnIfNeeded(transaction2);
    const req = {
      wallet_handle_token: walletHandle,
      transaction: buffer.Buffer.from(tx2.toByte()).toString("base64"),
      public_key: buffer.Buffer.from(pk).toString("base64"),
      partial_multisig: partial,
      wallet_password: pw
    };
    const res = await this.c.post("/v1/multisig/sign", req);
    return res.body;
  }
  /**
   * deleteMultisig accepts a wallet handle, wallet password, and multisig
   * address, and deletes the information about this multisig address from the
   * wallet (including address and secret key).
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteMultisig(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/multisig", req);
    return res.body;
  }
}
class MakeHealthCheck extends JSONRequest {
  /**
   * @returns `/health`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
}
class LookupAssetBalances extends JSONRequest {
  /**
   * Returns the list of accounts which hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}/balances`
   */
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filtered results should have an asset balance greater than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const minBalance = 1000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyGreaterThan(minBalance)
   *        .do();
   * ```
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an asset balance less than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxBalance = 2000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyLessThan(maxBalance)
   *        .do();
   * ```
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   *
   * const assetBalancesPage1 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetBalancesPage2 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetBalancesPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
function base64StringFunnel(data) {
  if (typeof data === "string") {
    return data;
  }
  return buffer.Buffer.from(data).toString("base64");
}
class LookupAccountTransactions extends JSONRequest {
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/transactions`
   */
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txType("appl")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .sigType("msig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id2) {
    this.query["asset-id"] = id2;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * The next page of results. Use the next token provided by the previous results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   *
   * const accountTxnsPage1 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountTxnsPage2 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .nextToken(accountTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
}
class LookupAssetTransactions extends JSONRequest {
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}/transactions`
   */
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txType("axfer")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .sigType("lsig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const minBalance = 300000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const maxBalance = 500000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "sender";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .do();
   * ```
   *
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address;
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   *
   * const assetTxnsPage1 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetTxnsPage2 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
}
class LookupBlock extends JSONRequest {
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  /**
   * @returns `/v2/blocks/${round}`
   */
  path() {
    return `/v2/blocks/${this.round}`;
  }
  /**
   * Header only flag. When this is set to true, returned block does not contain the
   * transactions.
   */
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
}
class LookupTransactionByID extends JSONRequest {
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  constructor(c, intDecoding, txID) {
    super(c, intDecoding);
    this.txID = txID;
    this.txID = txID;
  }
  /**
   * @returns `/v2/transactions/${txID}`
   */
  path() {
    return `/v2/transactions/${this.txID}`;
  }
}
class LookupAccountByID extends JSONRequest {
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}`
   */
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll()
   *        .do();
   * ```
   * @param value
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
}
class LookupAccountAssets extends JSONRequest {
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/assets`
   */
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .assetId(assetId)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetId(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
}
class LookupAccountCreatedAssets extends JSONRequest {
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/created-assets`
   */
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetID(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
}
class LookupAccountAppLocalStates extends JSONRequest {
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/apps-local-state`
   */
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index2) {
    this.query["application-id"] = index2;
    return this;
  }
}
class LookupAccountCreatedApplications extends JSONRequest {
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/created-applications`
   */
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index2) {
    this.query["application-id"] = index2;
    return this;
  }
}
class LookupAssetByID extends JSONRequest {
  /**
   * Returns asset information of the queried asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}`
   */
  path() {
    return `/v2/assets/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class LookupApplications extends JSONRequest {
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/applications/${index}`
   */
  path() {
    return `/v2/applications/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class LookupApplicationLogs extends JSONRequest {
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  constructor(c, intDecoding, appID) {
    super(c, intDecoding);
    this.appID = appID;
    this.appID = appID;
  }
  /**
   * @returns `/v2/applications/${appID}/logs`
   */
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const appLogsPage1 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   *
   * const appLogsPage2 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .nextToken(appLogsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Only include transactions with this sender address.
   *
   * #### Example
   * ```typescript
   * const sender = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .sender(sender)
   *        .do();
   * ```
   *
   * @param senderAddress
   * @category query
   */
  sender(senderAddress) {
    this.query["sender-address"] = senderAddress;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
}
class Account2 extends BaseModel {
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalBoxBytes - For app-accounts only. The total number of bytes allocated for the keys and
   * values of boxes which belong to the associated application.
   * @param totalBoxes - For app-accounts only. The total number of boxes which belong to the associated
   * application.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param closedAtRound - Round during which this account was most recently closed.
   * @param createdApps - (appp) parameters of applications created by this account including app global
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param createdAtRound - Round during which this account first appeared in a transaction.
   * @param deleted - Whether or not this account is currently closed.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * * or null if unknown
   */
  constructor({ address, amount, amountWithoutPendingRewards, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalBoxBytes, totalBoxes, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, closedAtRound, createdApps, createdAssets, createdAtRound, deleted, participation, rewardBase, sigType }) {
    super();
    this.address = address;
    this.amount = amount;
    this.amountWithoutPendingRewards = amountWithoutPendingRewards;
    this.pendingRewards = pendingRewards;
    this.rewards = rewards;
    this.round = round;
    this.status = status;
    this.totalAppsOptedIn = totalAppsOptedIn;
    this.totalAssetsOptedIn = totalAssetsOptedIn;
    this.totalBoxBytes = totalBoxBytes;
    this.totalBoxes = totalBoxes;
    this.totalCreatedApps = totalCreatedApps;
    this.totalCreatedAssets = totalCreatedAssets;
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = appsTotalExtraPages;
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = authAddr;
    this.closedAtRound = closedAtRound;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.participation = participation;
    this.rewardBase = rewardBase;
    this.sigType = sigType;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      amountWithoutPendingRewards: "amount-without-pending-rewards",
      pendingRewards: "pending-rewards",
      rewards: "rewards",
      round: "round",
      status: "status",
      totalAppsOptedIn: "total-apps-opted-in",
      totalAssetsOptedIn: "total-assets-opted-in",
      totalBoxBytes: "total-box-bytes",
      totalBoxes: "total-boxes",
      totalCreatedApps: "total-created-apps",
      totalCreatedAssets: "total-created-assets",
      appsLocalState: "apps-local-state",
      appsTotalExtraPages: "apps-total-extra-pages",
      appsTotalSchema: "apps-total-schema",
      assets: "assets",
      authAddr: "auth-addr",
      closedAtRound: "closed-at-round",
      createdApps: "created-apps",
      createdAssets: "created-assets",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      participation: "participation",
      rewardBase: "reward-base",
      sigType: "sig-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["amount-without-pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${data}`);
    if (typeof data["pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${data}`);
    if (typeof data["rewards"] === "undefined")
      throw new Error(`Response is missing required field 'rewards': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["status"] === "undefined")
      throw new Error(`Response is missing required field 'status': ${data}`);
    if (typeof data["total-apps-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${data}`);
    if (typeof data["total-assets-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${data}`);
    if (typeof data["total-box-bytes"] === "undefined")
      throw new Error(`Response is missing required field 'total-box-bytes': ${data}`);
    if (typeof data["total-boxes"] === "undefined")
      throw new Error(`Response is missing required field 'total-boxes': ${data}`);
    if (typeof data["total-created-apps"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${data}`);
    if (typeof data["total-created-assets"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${data}`);
    return new Account2({
      address: data["address"],
      amount: data["amount"],
      amountWithoutPendingRewards: data["amount-without-pending-rewards"],
      pendingRewards: data["pending-rewards"],
      rewards: data["rewards"],
      round: data["round"],
      status: data["status"],
      totalAppsOptedIn: data["total-apps-opted-in"],
      totalAssetsOptedIn: data["total-assets-opted-in"],
      totalBoxBytes: data["total-box-bytes"],
      totalBoxes: data["total-boxes"],
      totalCreatedApps: data["total-created-apps"],
      totalCreatedAssets: data["total-created-assets"],
      appsLocalState: typeof data["apps-local-state"] !== "undefined" ? data["apps-local-state"].map(ApplicationLocalState2.from_obj_for_encoding) : void 0,
      appsTotalExtraPages: data["apps-total-extra-pages"],
      appsTotalSchema: typeof data["apps-total-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["apps-total-schema"]) : void 0,
      assets: typeof data["assets"] !== "undefined" ? data["assets"].map(AssetHolding2.from_obj_for_encoding) : void 0,
      authAddr: data["auth-addr"],
      closedAtRound: data["closed-at-round"],
      createdApps: typeof data["created-apps"] !== "undefined" ? data["created-apps"].map(Application2.from_obj_for_encoding) : void 0,
      createdAssets: typeof data["created-assets"] !== "undefined" ? data["created-assets"].map(Asset2.from_obj_for_encoding) : void 0,
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      participation: typeof data["participation"] !== "undefined" ? AccountParticipation2.from_obj_for_encoding(data["participation"]) : void 0,
      rewardBase: data["reward-base"],
      sigType: data["sig-type"]
    });
  }
}
class AccountParticipation2 extends BaseModel {
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    super();
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(buffer.Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.attribute_map = {
      selectionParticipationKey: "selection-participation-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key",
      stateProofKey: "state-proof-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["selection-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${data}`);
    if (typeof data["vote-first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${data}`);
    if (typeof data["vote-key-dilution"] === "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${data}`);
    if (typeof data["vote-last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${data}`);
    if (typeof data["vote-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${data}`);
    return new AccountParticipation2({
      selectionParticipationKey: data["selection-participation-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"],
      stateProofKey: data["state-proof-key"]
    });
  }
}
class AccountResponse extends BaseModel {
  /**
   * Creates a new `AccountResponse` object.
   * @param account - Account information at a given round.
   * Definition:
   * data/basics/userBalance.go : AccountData
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ account, currentRound }) {
    super();
    this.account = account;
    this.currentRound = currentRound;
    this.attribute_map = {
      account: "account",
      currentRound: "current-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["account"] === "undefined")
      throw new Error(`Response is missing required field 'account': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AccountResponse({
      account: Account2.from_obj_for_encoding(data["account"]),
      currentRound: data["current-round"]
    });
  }
}
class AccountStateDelta2 extends BaseModel {
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    super();
    this.address = address;
    this.delta = delta;
    this.attribute_map = {
      address: "address",
      delta: "delta"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (!Array.isArray(data["delta"]))
      throw new Error(`Response is missing required array field 'delta': ${data}`);
    return new AccountStateDelta2({
      address: data["address"],
      delta: data["delta"].map(EvalDeltaKeyValue2.from_obj_for_encoding)
    });
  }
}
class AccountsResponse extends BaseModel {
  /**
   * Creates a new `AccountsResponse` object.
   * @param accounts -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ accounts, currentRound, nextToken }) {
    super();
    this.accounts = accounts;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      accounts: "accounts",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["accounts"]))
      throw new Error(`Response is missing required array field 'accounts': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AccountsResponse({
      accounts: data["accounts"].map(Account2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class Application2 extends BaseModel {
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   * @param createdAtRound - Round when this application was created.
   * @param deleted - Whether or not this application is currently deleted.
   * @param deletedAtRound - Round when this application was deleted.
   */
  constructor({ id: id2, params, createdAtRound, deleted, deletedAtRound }) {
    super();
    this.id = id2;
    this.params = params;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.deletedAtRound = deletedAtRound;
    this.attribute_map = {
      id: "id",
      params: "params",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      deletedAtRound: "deleted-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Application2({
      id: data["id"],
      params: ApplicationParams2.from_obj_for_encoding(data["params"]),
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      deletedAtRound: data["deleted-at-round"]
    });
  }
}
class ApplicationLocalState2 extends BaseModel {
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param closedOutAtRound - Round when account closed out of the application.
   * @param deleted - Whether or not the application local state is currently deleted from its
   * account.
   * @param keyValue - (tkv) storage.
   * @param optedInAtRound - Round when the account opted into the application.
   */
  constructor({ id: id2, schema, closedOutAtRound, deleted, keyValue, optedInAtRound }) {
    super();
    this.id = id2;
    this.schema = schema;
    this.closedOutAtRound = closedOutAtRound;
    this.deleted = deleted;
    this.keyValue = keyValue;
    this.optedInAtRound = optedInAtRound;
    this.attribute_map = {
      id: "id",
      schema: "schema",
      closedOutAtRound: "closed-out-at-round",
      deleted: "deleted",
      keyValue: "key-value",
      optedInAtRound: "opted-in-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["schema"] === "undefined")
      throw new Error(`Response is missing required field 'schema': ${data}`);
    return new ApplicationLocalState2({
      id: data["id"],
      schema: ApplicationStateSchema2.from_obj_for_encoding(data["schema"]),
      closedOutAtRound: data["closed-out-at-round"],
      deleted: data["deleted"],
      keyValue: typeof data["key-value"] !== "undefined" ? data["key-value"].map(TealKeyValue2.from_obj_for_encoding) : void 0,
      optedInAtRound: data["opted-in-at-round"]
    });
  }
}
class ApplicationLocalStatesResponse extends BaseModel {
  /**
   * Creates a new `ApplicationLocalStatesResponse` object.
   * @param appsLocalStates -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ appsLocalStates, currentRound, nextToken }) {
    super();
    this.appsLocalStates = appsLocalStates;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      appsLocalStates: "apps-local-states",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["apps-local-states"]))
      throw new Error(`Response is missing required array field 'apps-local-states': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationLocalStatesResponse({
      appsLocalStates: data["apps-local-states"].map(ApplicationLocalState2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class ApplicationLogData extends BaseModel {
  /**
   * Creates a new `ApplicationLogData` object.
   * @param logs - (lg) Logs for the application being executed by the transaction.
   * @param txid - Transaction ID
   */
  constructor({ logs, txid }) {
    super();
    this.logs = logs;
    this.txid = txid;
    this.attribute_map = {
      logs: "logs",
      txid: "txid"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["logs"]))
      throw new Error(`Response is missing required array field 'logs': ${data}`);
    if (typeof data["txid"] === "undefined")
      throw new Error(`Response is missing required field 'txid': ${data}`);
    return new ApplicationLogData({
      logs: data["logs"],
      txid: data["txid"]
    });
  }
}
class ApplicationLogsResponse extends BaseModel {
  /**
   * Creates a new `ApplicationLogsResponse` object.
   * @param applicationId - (appidx) application index.
   * @param currentRound - Round at which the results were computed.
   * @param logData -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, currentRound, logData, nextToken }) {
    super();
    this.applicationId = applicationId;
    this.currentRound = currentRound;
    this.logData = logData;
    this.nextToken = nextToken;
    this.attribute_map = {
      applicationId: "application-id",
      currentRound: "current-round",
      logData: "log-data",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationLogsResponse({
      applicationId: data["application-id"],
      currentRound: data["current-round"],
      logData: typeof data["log-data"] !== "undefined" ? data["log-data"].map(ApplicationLogData.from_obj_for_encoding) : void 0,
      nextToken: data["next-token"]
    });
  }
}
class ApplicationParams2 extends BaseModel {
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - [\gs) global schema
   * @param globalStateSchema - [\gsch) global schema
   * @param localStateSchema - [\lsch) local schema
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState: globalState2, globalStateSchema, localStateSchema }) {
    super();
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(buffer.Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(buffer.Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.creator = creator;
    this.extraProgramPages = extraProgramPages;
    this.globalState = globalState2;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.attribute_map = {
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      creator: "creator",
      extraProgramPages: "extra-program-pages",
      globalState: "global-state",
      globalStateSchema: "global-state-schema",
      localStateSchema: "local-state-schema"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["approval-program"] === "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${data}`);
    if (typeof data["clear-state-program"] === "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${data}`);
    return new ApplicationParams2({
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      creator: data["creator"],
      extraProgramPages: data["extra-program-pages"],
      globalState: typeof data["global-state"] !== "undefined" ? data["global-state"].map(TealKeyValue2.from_obj_for_encoding) : void 0,
      globalStateSchema: typeof data["global-state-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["global-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["local-state-schema"]) : void 0
    });
  }
}
class ApplicationResponse extends BaseModel {
  /**
   * Creates a new `ApplicationResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param application - Application index and its parameters
   */
  constructor({ currentRound, application }) {
    super();
    this.currentRound = currentRound;
    this.application = application;
    this.attribute_map = {
      currentRound: "current-round",
      application: "application"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationResponse({
      currentRound: data["current-round"],
      application: typeof data["application"] !== "undefined" ? Application2.from_obj_for_encoding(data["application"]) : void 0
    });
  }
}
class ApplicationStateSchema2 extends BaseModel {
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numByteSlice - (nbs) num of byte slices.
   * @param numUint - (nui) num of uints.
   */
  constructor({ numByteSlice, numUint }) {
    super();
    this.numByteSlice = numByteSlice;
    this.numUint = numUint;
    this.attribute_map = {
      numByteSlice: "num-byte-slice",
      numUint: "num-uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    return new ApplicationStateSchema2({
      numByteSlice: data["num-byte-slice"],
      numUint: data["num-uint"]
    });
  }
}
class ApplicationsResponse extends BaseModel {
  /**
   * Creates a new `ApplicationsResponse` object.
   * @param applications -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applications, currentRound, nextToken }) {
    super();
    this.applications = applications;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      applications: "applications",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["applications"]))
      throw new Error(`Response is missing required array field 'applications': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationsResponse({
      applications: data["applications"].map(Application2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class Asset2 extends BaseModel {
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   * @param createdAtRound - Round during which this asset was created.
   * @param deleted - Whether or not this asset is currently deleted.
   * @param destroyedAtRound - Round during which this asset was destroyed.
   */
  constructor({ index: index2, params, createdAtRound, deleted, destroyedAtRound }) {
    super();
    this.index = index2;
    this.params = params;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.destroyedAtRound = destroyedAtRound;
    this.attribute_map = {
      index: "index",
      params: "params",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      destroyedAtRound: "destroyed-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Asset2({
      index: data["index"],
      params: AssetParams2.from_obj_for_encoding(data["params"]),
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      destroyedAtRound: data["destroyed-at-round"]
    });
  }
}
class AssetBalancesResponse extends BaseModel {
  /**
   * Creates a new `AssetBalancesResponse` object.
   * @param balances -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ balances, currentRound, nextToken }) {
    super();
    this.balances = balances;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      balances: "balances",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["balances"]))
      throw new Error(`Response is missing required array field 'balances': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetBalancesResponse({
      balances: data["balances"].map(MiniAssetHolding.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class AssetHolding2 extends BaseModel {
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   * @param deleted - Whether or not the asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into this asset holding.
   * @param optedOutAtRound - Round during which the account opted out of this asset holding.
   */
  constructor({ amount, assetId, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = optedInAtRound;
    this.optedOutAtRound = optedOutAtRound;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      isFrozen: "is-frozen",
      deleted: "deleted",
      optedInAtRound: "opted-in-at-round",
      optedOutAtRound: "opted-out-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new AssetHolding2({
      amount: data["amount"],
      assetId: data["asset-id"],
      isFrozen: data["is-frozen"],
      deleted: data["deleted"],
      optedInAtRound: data["opted-in-at-round"],
      optedOutAtRound: data["opted-out-at-round"]
    });
  }
}
class AssetHoldingsResponse extends BaseModel {
  /**
   * Creates a new `AssetHoldingsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    super();
    this.assets = assets;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      assets: "assets",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["assets"]))
      throw new Error(`Response is missing required array field 'assets': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetHoldingsResponse({
      assets: data["assets"].map(AssetHolding2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class AssetParams2 extends BaseModel {
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    super();
    this.creator = creator;
    this.decimals = decimals;
    this.total = total;
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(buffer.Buffer.from(metadataHash, "base64")) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(buffer.Buffer.from(nameB64, "base64")) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(buffer.Buffer.from(unitNameB64, "base64")) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(buffer.Buffer.from(urlB64, "base64")) : urlB64;
    this.attribute_map = {
      creator: "creator",
      decimals: "decimals",
      total: "total",
      clawback: "clawback",
      defaultFrozen: "default-frozen",
      freeze: "freeze",
      manager: "manager",
      metadataHash: "metadata-hash",
      name: "name",
      nameB64: "name-b64",
      reserve: "reserve",
      unitName: "unit-name",
      unitNameB64: "unit-name-b64",
      url: "url",
      urlB64: "url-b64"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    if (typeof data["decimals"] === "undefined")
      throw new Error(`Response is missing required field 'decimals': ${data}`);
    if (typeof data["total"] === "undefined")
      throw new Error(`Response is missing required field 'total': ${data}`);
    return new AssetParams2({
      creator: data["creator"],
      decimals: data["decimals"],
      total: data["total"],
      clawback: data["clawback"],
      defaultFrozen: data["default-frozen"],
      freeze: data["freeze"],
      manager: data["manager"],
      metadataHash: data["metadata-hash"],
      name: data["name"],
      nameB64: data["name-b64"],
      reserve: data["reserve"],
      unitName: data["unit-name"],
      unitNameB64: data["unit-name-b64"],
      url: data["url"],
      urlB64: data["url-b64"]
    });
  }
}
class AssetResponse extends BaseModel {
  /**
   * Creates a new `AssetResponse` object.
   * @param asset - Specifies both the unique identifier and the parameters for an asset
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ asset, currentRound }) {
    super();
    this.asset = asset;
    this.currentRound = currentRound;
    this.attribute_map = {
      asset: "asset",
      currentRound: "current-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["asset"] === "undefined")
      throw new Error(`Response is missing required field 'asset': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetResponse({
      asset: Asset2.from_obj_for_encoding(data["asset"]),
      currentRound: data["current-round"]
    });
  }
}
class AssetsResponse extends BaseModel {
  /**
   * Creates a new `AssetsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    super();
    this.assets = assets;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      assets: "assets",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["assets"]))
      throw new Error(`Response is missing required array field 'assets': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetsResponse({
      assets: data["assets"].map(Asset2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class Block2 extends BaseModel {
  /**
   * Creates a new `Block` object.
   * @param genesisHash - (gh) hash to which this block belongs.
   * @param genesisId - (gen) ID to which this block belongs.
   * @param previousBlockHash - (prev) Previous block hash.
   * @param round - (rnd) Current round on which this block was appended to the chain.
   * @param seed - (seed) Sortition seed.
   * @param timestamp - (ts) Block creation timestamp in seconds since eposh
   * @param transactionsRoot - (txn) TransactionsRoot authenticates the set of transactions appearing in the
   * block. More specifically, it's the root of a merkle tree whose leaves are the
   * block's Txids, in lexicographic order. For the empty block, it's 0. Note that
   * the TxnRoot does not authenticate the signatures on the transactions, only the
   * transactions themselves. Two blocks with the same transactions but in a
   * different order and with different signatures will have the same TxnRoot.
   * @param transactionsRootSha256 - (txn256) TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a
   * vector commitment instead of a merkle tree, and SHA256 hash function instead of
   * the default SHA512_256. This commitment can be used on environments where only
   * the SHA256 function exists.
   * @param participationUpdates - Participation account data that needs to be checked/acted on by the network.
   * @param rewards - Fields relating to rewards,
   * @param stateProofTracking - Tracks the status of state proofs.
   * @param transactions - (txns) list of transactions corresponding to a given round.
   * @param txnCounter - (tc) TxnCounter counts the number of transactions committed in the ledger, from
   * the time at which support for this feature was introduced.
   * Specifically, TxnCounter is the number of the next transaction that will be
   * committed after this block. It is 0 when no transactions have ever been
   * committed (since TxnCounter started being supported).
   * @param upgradeState - Fields relating to a protocol upgrade.
   * @param upgradeVote - Fields relating to voting for a protocol upgrade.
   */
  constructor({ genesisHash, genesisId, previousBlockHash, round, seed, timestamp, transactionsRoot, transactionsRootSha256, participationUpdates, rewards, stateProofTracking, transactions, txnCounter, upgradeState, upgradeVote }) {
    super();
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(buffer.Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.previousBlockHash = typeof previousBlockHash === "string" ? new Uint8Array(buffer.Buffer.from(previousBlockHash, "base64")) : previousBlockHash;
    this.round = round;
    this.seed = typeof seed === "string" ? new Uint8Array(buffer.Buffer.from(seed, "base64")) : seed;
    this.timestamp = timestamp;
    this.transactionsRoot = typeof transactionsRoot === "string" ? new Uint8Array(buffer.Buffer.from(transactionsRoot, "base64")) : transactionsRoot;
    this.transactionsRootSha256 = typeof transactionsRootSha256 === "string" ? new Uint8Array(buffer.Buffer.from(transactionsRootSha256, "base64")) : transactionsRootSha256;
    this.participationUpdates = participationUpdates;
    this.rewards = rewards;
    this.stateProofTracking = stateProofTracking;
    this.transactions = transactions;
    this.txnCounter = txnCounter;
    this.upgradeState = upgradeState;
    this.upgradeVote = upgradeVote;
    this.attribute_map = {
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      previousBlockHash: "previous-block-hash",
      round: "round",
      seed: "seed",
      timestamp: "timestamp",
      transactionsRoot: "transactions-root",
      transactionsRootSha256: "transactions-root-sha256",
      participationUpdates: "participation-updates",
      rewards: "rewards",
      stateProofTracking: "state-proof-tracking",
      transactions: "transactions",
      txnCounter: "txn-counter",
      upgradeState: "upgrade-state",
      upgradeVote: "upgrade-vote"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["genesis-hash"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${data}`);
    if (typeof data["genesis-id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${data}`);
    if (typeof data["previous-block-hash"] === "undefined")
      throw new Error(`Response is missing required field 'previous-block-hash': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["seed"] === "undefined")
      throw new Error(`Response is missing required field 'seed': ${data}`);
    if (typeof data["timestamp"] === "undefined")
      throw new Error(`Response is missing required field 'timestamp': ${data}`);
    if (typeof data["transactions-root"] === "undefined")
      throw new Error(`Response is missing required field 'transactions-root': ${data}`);
    if (typeof data["transactions-root-sha256"] === "undefined")
      throw new Error(`Response is missing required field 'transactions-root-sha256': ${data}`);
    return new Block2({
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      previousBlockHash: data["previous-block-hash"],
      round: data["round"],
      seed: data["seed"],
      timestamp: data["timestamp"],
      transactionsRoot: data["transactions-root"],
      transactionsRootSha256: data["transactions-root-sha256"],
      participationUpdates: typeof data["participation-updates"] !== "undefined" ? ParticipationUpdates.from_obj_for_encoding(data["participation-updates"]) : void 0,
      rewards: typeof data["rewards"] !== "undefined" ? BlockRewards.from_obj_for_encoding(data["rewards"]) : void 0,
      stateProofTracking: typeof data["state-proof-tracking"] !== "undefined" ? data["state-proof-tracking"].map(StateProofTracking.from_obj_for_encoding) : void 0,
      transactions: typeof data["transactions"] !== "undefined" ? data["transactions"].map(Transaction2.from_obj_for_encoding) : void 0,
      txnCounter: data["txn-counter"],
      upgradeState: typeof data["upgrade-state"] !== "undefined" ? BlockUpgradeState.from_obj_for_encoding(data["upgrade-state"]) : void 0,
      upgradeVote: typeof data["upgrade-vote"] !== "undefined" ? BlockUpgradeVote.from_obj_for_encoding(data["upgrade-vote"]) : void 0
    });
  }
}
class BlockRewards extends BaseModel {
  /**
   * Creates a new `BlockRewards` object.
   * @param feeSink - (fees) accepts transaction fees, it can only spend to the incentive pool.
   * @param rewardsCalculationRound - (rwcalr) number of leftover MicroAlgos after the distribution of rewards-rate
   * MicroAlgos for every reward unit in the next round.
   * @param rewardsLevel - (earn) How many rewards, in MicroAlgos, have been distributed to each RewardUnit
   * of MicroAlgos since genesis.
   * @param rewardsPool - (rwd) accepts periodic injections from the fee-sink and continually
   * redistributes them as rewards.
   * @param rewardsRate - (rate) Number of new MicroAlgos added to the participation stake from rewards at
   * the next round.
   * @param rewardsResidue - (frac) Number of leftover MicroAlgos after the distribution of
   * RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
   */
  constructor({ feeSink, rewardsCalculationRound, rewardsLevel, rewardsPool, rewardsRate, rewardsResidue }) {
    super();
    this.feeSink = feeSink;
    this.rewardsCalculationRound = rewardsCalculationRound;
    this.rewardsLevel = rewardsLevel;
    this.rewardsPool = rewardsPool;
    this.rewardsRate = rewardsRate;
    this.rewardsResidue = rewardsResidue;
    this.attribute_map = {
      feeSink: "fee-sink",
      rewardsCalculationRound: "rewards-calculation-round",
      rewardsLevel: "rewards-level",
      rewardsPool: "rewards-pool",
      rewardsRate: "rewards-rate",
      rewardsResidue: "rewards-residue"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["fee-sink"] === "undefined")
      throw new Error(`Response is missing required field 'fee-sink': ${data}`);
    if (typeof data["rewards-calculation-round"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-calculation-round': ${data}`);
    if (typeof data["rewards-level"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-level': ${data}`);
    if (typeof data["rewards-pool"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-pool': ${data}`);
    if (typeof data["rewards-rate"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-rate': ${data}`);
    if (typeof data["rewards-residue"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-residue': ${data}`);
    return new BlockRewards({
      feeSink: data["fee-sink"],
      rewardsCalculationRound: data["rewards-calculation-round"],
      rewardsLevel: data["rewards-level"],
      rewardsPool: data["rewards-pool"],
      rewardsRate: data["rewards-rate"],
      rewardsResidue: data["rewards-residue"]
    });
  }
}
class BlockUpgradeState extends BaseModel {
  /**
   * Creates a new `BlockUpgradeState` object.
   * @param currentProtocol - (proto) The current protocol version.
   * @param nextProtocol - (nextproto) The next proposed protocol version.
   * @param nextProtocolApprovals - (nextyes) Number of blocks which approved the protocol upgrade.
   * @param nextProtocolSwitchOn - (nextswitch) Round on which the protocol upgrade will take effect.
   * @param nextProtocolVoteBefore - (nextbefore) Deadline round for this protocol upgrade (No votes will be consider
   * after this round).
   */
  constructor({ currentProtocol, nextProtocol, nextProtocolApprovals, nextProtocolSwitchOn, nextProtocolVoteBefore }) {
    super();
    this.currentProtocol = currentProtocol;
    this.nextProtocol = nextProtocol;
    this.nextProtocolApprovals = nextProtocolApprovals;
    this.nextProtocolSwitchOn = nextProtocolSwitchOn;
    this.nextProtocolVoteBefore = nextProtocolVoteBefore;
    this.attribute_map = {
      currentProtocol: "current-protocol",
      nextProtocol: "next-protocol",
      nextProtocolApprovals: "next-protocol-approvals",
      nextProtocolSwitchOn: "next-protocol-switch-on",
      nextProtocolVoteBefore: "next-protocol-vote-before"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-protocol"] === "undefined")
      throw new Error(`Response is missing required field 'current-protocol': ${data}`);
    return new BlockUpgradeState({
      currentProtocol: data["current-protocol"],
      nextProtocol: data["next-protocol"],
      nextProtocolApprovals: data["next-protocol-approvals"],
      nextProtocolSwitchOn: data["next-protocol-switch-on"],
      nextProtocolVoteBefore: data["next-protocol-vote-before"]
    });
  }
}
class BlockUpgradeVote extends BaseModel {
  /**
   * Creates a new `BlockUpgradeVote` object.
   * @param upgradeApprove - (upgradeyes) Indicates a yes vote for the current proposal.
   * @param upgradeDelay - (upgradedelay) Indicates the time between acceptance and execution.
   * @param upgradePropose - (upgradeprop) Indicates a proposed upgrade.
   */
  constructor({ upgradeApprove, upgradeDelay, upgradePropose }) {
    super();
    this.upgradeApprove = upgradeApprove;
    this.upgradeDelay = upgradeDelay;
    this.upgradePropose = upgradePropose;
    this.attribute_map = {
      upgradeApprove: "upgrade-approve",
      upgradeDelay: "upgrade-delay",
      upgradePropose: "upgrade-propose"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new BlockUpgradeVote({
      upgradeApprove: data["upgrade-approve"],
      upgradeDelay: data["upgrade-delay"],
      upgradePropose: data["upgrade-propose"]
    });
  }
}
class Box2 extends BaseModel {
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name, value }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.value = typeof value === "string" ? new Uint8Array(buffer.Buffer.from(value, "base64")) : value;
    this.attribute_map = {
      name: "name",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new Box2({
      name: data["name"],
      value: data["value"]
    });
  }
}
class BoxDescriptor2 extends BaseModel {
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.attribute_map = {
      name: "name"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    return new BoxDescriptor2({
      name: data["name"]
    });
  }
}
class BoxesResponse2 extends BaseModel {
  /**
   * Creates a new `BoxesResponse` object.
   * @param applicationId - (appidx) application index.
   * @param boxes -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, boxes, nextToken }) {
    super();
    this.applicationId = applicationId;
    this.boxes = boxes;
    this.nextToken = nextToken;
    this.attribute_map = {
      applicationId: "application-id",
      boxes: "boxes",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    if (!Array.isArray(data["boxes"]))
      throw new Error(`Response is missing required array field 'boxes': ${data}`);
    return new BoxesResponse2({
      applicationId: data["application-id"],
      boxes: data["boxes"].map(BoxDescriptor2.from_obj_for_encoding),
      nextToken: data["next-token"]
    });
  }
}
class ErrorResponse2 extends BaseModel {
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    super();
    this.message = message;
    this.data = data;
    this.attribute_map = {
      message: "message",
      data: "data"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    return new ErrorResponse2({
      message: data["message"],
      data: data["data"]
    });
  }
}
class EvalDelta2 extends BaseModel {
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action: action2, bytes, uint }) {
    super();
    this.action = action2;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      action: "action",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["action"] === "undefined")
      throw new Error(`Response is missing required field 'action': ${data}`);
    return new EvalDelta2({
      action: data["action"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
}
class EvalDeltaKeyValue2 extends BaseModel {
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new EvalDeltaKeyValue2({
      key: data["key"],
      value: EvalDelta2.from_obj_for_encoding(data["value"])
    });
  }
}
class HashFactory extends BaseModel {
  /**
   * Creates a new `HashFactory` object.
   * @param hashType - (t)
   */
  constructor({ hashType }) {
    super();
    this.hashType = hashType;
    this.attribute_map = {
      hashType: "hash-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new HashFactory({
      hashType: data["hash-type"]
    });
  }
}
class HealthCheck2 extends BaseModel {
  /**
   * Creates a new `HealthCheck` object.
   * @param dbAvailable -
   * @param isMigrating -
   * @param message -
   * @param round -
   * @param version - Current version.
   * @param data -
   * @param errors -
   */
  constructor({ dbAvailable, isMigrating, message, round, version: version2, data, errors }) {
    super();
    this.dbAvailable = dbAvailable;
    this.isMigrating = isMigrating;
    this.message = message;
    this.round = round;
    this.version = version2;
    this.data = data;
    this.errors = errors;
    this.attribute_map = {
      dbAvailable: "db-available",
      isMigrating: "is-migrating",
      message: "message",
      round: "round",
      version: "version",
      data: "data",
      errors: "errors"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["db-available"] === "undefined")
      throw new Error(`Response is missing required field 'db-available': ${data}`);
    if (typeof data["is-migrating"] === "undefined")
      throw new Error(`Response is missing required field 'is-migrating': ${data}`);
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["version"] === "undefined")
      throw new Error(`Response is missing required field 'version': ${data}`);
    return new HealthCheck2({
      dbAvailable: data["db-available"],
      isMigrating: data["is-migrating"],
      message: data["message"],
      round: data["round"],
      version: data["version"],
      data: data["data"],
      errors: data["errors"]
    });
  }
}
class IndexerStateProofMessage extends BaseModel {
  /**
   * Creates a new `IndexerStateProofMessage` object.
   * @param blockHeadersCommitment - (b)
   * @param firstAttestedRound - (f)
   * @param latestAttestedRound - (l)
   * @param lnProvenWeight - (P)
   * @param votersCommitment - (v)
   */
  constructor({ blockHeadersCommitment, firstAttestedRound, latestAttestedRound, lnProvenWeight, votersCommitment }) {
    super();
    this.blockHeadersCommitment = typeof blockHeadersCommitment === "string" ? new Uint8Array(buffer.Buffer.from(blockHeadersCommitment, "base64")) : blockHeadersCommitment;
    this.firstAttestedRound = firstAttestedRound;
    this.latestAttestedRound = latestAttestedRound;
    this.lnProvenWeight = lnProvenWeight;
    this.votersCommitment = typeof votersCommitment === "string" ? new Uint8Array(buffer.Buffer.from(votersCommitment, "base64")) : votersCommitment;
    this.attribute_map = {
      blockHeadersCommitment: "block-headers-commitment",
      firstAttestedRound: "first-attested-round",
      latestAttestedRound: "latest-attested-round",
      lnProvenWeight: "ln-proven-weight",
      votersCommitment: "voters-commitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new IndexerStateProofMessage({
      blockHeadersCommitment: data["block-headers-commitment"],
      firstAttestedRound: data["first-attested-round"],
      latestAttestedRound: data["latest-attested-round"],
      lnProvenWeight: data["ln-proven-weight"],
      votersCommitment: data["voters-commitment"]
    });
  }
}
class MerkleArrayProof extends BaseModel {
  /**
   * Creates a new `MerkleArrayProof` object.
   * @param hashFactory -
   * @param path - (pth)
   * @param treeDepth - (td)
   */
  constructor({ hashFactory, path, treeDepth }) {
    super();
    this.hashFactory = hashFactory;
    this.path = path;
    this.treeDepth = treeDepth;
    this.attribute_map = {
      hashFactory: "hash-factory",
      path: "path",
      treeDepth: "tree-depth"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new MerkleArrayProof({
      hashFactory: typeof data["hash-factory"] !== "undefined" ? HashFactory.from_obj_for_encoding(data["hash-factory"]) : void 0,
      path: data["path"],
      treeDepth: data["tree-depth"]
    });
  }
}
class MiniAssetHolding extends BaseModel {
  /**
   * Creates a new `MiniAssetHolding` object.
   * @param address -
   * @param amount -
   * @param isFrozen -
   * @param deleted - Whether or not this asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into the asset.
   * @param optedOutAtRound - Round during which the account opted out of the asset.
   */
  constructor({ address, amount, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    super();
    this.address = address;
    this.amount = amount;
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = optedInAtRound;
    this.optedOutAtRound = optedOutAtRound;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      isFrozen: "is-frozen",
      deleted: "deleted",
      optedInAtRound: "opted-in-at-round",
      optedOutAtRound: "opted-out-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new MiniAssetHolding({
      address: data["address"],
      amount: data["amount"],
      isFrozen: data["is-frozen"],
      deleted: data["deleted"],
      optedInAtRound: data["opted-in-at-round"],
      optedOutAtRound: data["opted-out-at-round"]
    });
  }
}
class ParticipationUpdates extends BaseModel {
  /**
   * Creates a new `ParticipationUpdates` object.
   * @param expiredParticipationAccounts - (partupdrmv) a list of online accounts that needs to be converted to offline
   * since their participation key expired.
   */
  constructor({ expiredParticipationAccounts }) {
    super();
    this.expiredParticipationAccounts = expiredParticipationAccounts;
    this.attribute_map = {
      expiredParticipationAccounts: "expired-participation-accounts"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new ParticipationUpdates({
      expiredParticipationAccounts: data["expired-participation-accounts"]
    });
  }
}
class StateProofFields extends BaseModel {
  /**
   * Creates a new `StateProofFields` object.
   * @param partProofs - (P)
   * @param positionsToReveal - (pr) Sequence of reveal positions.
   * @param reveals - (r) Note that this is actually stored as a map[uint64] - Reveal in the actual
   * msgp
   * @param saltVersion - (v) Salt version of the merkle signature.
   * @param sigCommit - (c)
   * @param sigProofs - (S)
   * @param signedWeight - (w)
   */
  constructor({ partProofs, positionsToReveal, reveals, saltVersion, sigCommit, sigProofs, signedWeight }) {
    super();
    this.partProofs = partProofs;
    this.positionsToReveal = positionsToReveal;
    this.reveals = reveals;
    this.saltVersion = saltVersion;
    this.sigCommit = typeof sigCommit === "string" ? new Uint8Array(buffer.Buffer.from(sigCommit, "base64")) : sigCommit;
    this.sigProofs = sigProofs;
    this.signedWeight = signedWeight;
    this.attribute_map = {
      partProofs: "part-proofs",
      positionsToReveal: "positions-to-reveal",
      reveals: "reveals",
      saltVersion: "salt-version",
      sigCommit: "sig-commit",
      sigProofs: "sig-proofs",
      signedWeight: "signed-weight"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofFields({
      partProofs: typeof data["part-proofs"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["part-proofs"]) : void 0,
      positionsToReveal: data["positions-to-reveal"],
      reveals: typeof data["reveals"] !== "undefined" ? data["reveals"].map(StateProofReveal.from_obj_for_encoding) : void 0,
      saltVersion: data["salt-version"],
      sigCommit: data["sig-commit"],
      sigProofs: typeof data["sig-proofs"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["sig-proofs"]) : void 0,
      signedWeight: data["signed-weight"]
    });
  }
}
class StateProofParticipant extends BaseModel {
  /**
   * Creates a new `StateProofParticipant` object.
   * @param verifier - (p)
   * @param weight - (w)
   */
  constructor({ verifier, weight }) {
    super();
    this.verifier = verifier;
    this.weight = weight;
    this.attribute_map = {
      verifier: "verifier",
      weight: "weight"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofParticipant({
      verifier: typeof data["verifier"] !== "undefined" ? StateProofVerifier.from_obj_for_encoding(data["verifier"]) : void 0,
      weight: data["weight"]
    });
  }
}
class StateProofReveal extends BaseModel {
  /**
   * Creates a new `StateProofReveal` object.
   * @param participant - (p)
   * @param position - The position in the signature and participants arrays corresponding to this
   * entry.
   * @param sigSlot - (s)
   */
  constructor({ participant, position, sigSlot }) {
    super();
    this.participant = participant;
    this.position = position;
    this.sigSlot = sigSlot;
    this.attribute_map = {
      participant: "participant",
      position: "position",
      sigSlot: "sig-slot"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofReveal({
      participant: typeof data["participant"] !== "undefined" ? StateProofParticipant.from_obj_for_encoding(data["participant"]) : void 0,
      position: data["position"],
      sigSlot: typeof data["sig-slot"] !== "undefined" ? StateProofSigSlot.from_obj_for_encoding(data["sig-slot"]) : void 0
    });
  }
}
class StateProofSigSlot extends BaseModel {
  /**
   * Creates a new `StateProofSigSlot` object.
   * @param lowerSigWeight - (l) The total weight of signatures in the lower-numbered slots.
   * @param signature -
   */
  constructor({ lowerSigWeight, signature }) {
    super();
    this.lowerSigWeight = lowerSigWeight;
    this.signature = signature;
    this.attribute_map = {
      lowerSigWeight: "lower-sig-weight",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofSigSlot({
      lowerSigWeight: data["lower-sig-weight"],
      signature: typeof data["signature"] !== "undefined" ? StateProofSignature.from_obj_for_encoding(data["signature"]) : void 0
    });
  }
}
class StateProofSignature extends BaseModel {
  /**
   * Creates a new `StateProofSignature` object.
   * @param falconSignature -
   * @param merkleArrayIndex -
   * @param proof -
   * @param verifyingKey - (vkey)
   */
  constructor({ falconSignature, merkleArrayIndex, proof, verifyingKey }) {
    super();
    this.falconSignature = typeof falconSignature === "string" ? new Uint8Array(buffer.Buffer.from(falconSignature, "base64")) : falconSignature;
    this.merkleArrayIndex = merkleArrayIndex;
    this.proof = proof;
    this.verifyingKey = typeof verifyingKey === "string" ? new Uint8Array(buffer.Buffer.from(verifyingKey, "base64")) : verifyingKey;
    this.attribute_map = {
      falconSignature: "falcon-signature",
      merkleArrayIndex: "merkle-array-index",
      proof: "proof",
      verifyingKey: "verifying-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofSignature({
      falconSignature: data["falcon-signature"],
      merkleArrayIndex: data["merkle-array-index"],
      proof: typeof data["proof"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["proof"]) : void 0,
      verifyingKey: data["verifying-key"]
    });
  }
}
class StateProofTracking extends BaseModel {
  /**
   * Creates a new `StateProofTracking` object.
   * @param nextRound - (n) Next round for which we will accept a state proof transaction.
   * @param onlineTotalWeight - (t) The total number of microalgos held by the online accounts during the
   * StateProof round.
   * @param type - State Proof Type. Note the raw object uses map with this as key.
   * @param votersCommitment - (v) Root of a vector commitment containing online accounts that will help sign
   * the proof.
   */
  constructor({ nextRound, onlineTotalWeight, type, votersCommitment }) {
    super();
    this.nextRound = nextRound;
    this.onlineTotalWeight = onlineTotalWeight;
    this.type = type;
    this.votersCommitment = typeof votersCommitment === "string" ? new Uint8Array(buffer.Buffer.from(votersCommitment, "base64")) : votersCommitment;
    this.attribute_map = {
      nextRound: "next-round",
      onlineTotalWeight: "online-total-weight",
      type: "type",
      votersCommitment: "voters-commitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofTracking({
      nextRound: data["next-round"],
      onlineTotalWeight: data["online-total-weight"],
      type: data["type"],
      votersCommitment: data["voters-commitment"]
    });
  }
}
class StateProofVerifier extends BaseModel {
  /**
   * Creates a new `StateProofVerifier` object.
   * @param commitment - (cmt) Represents the root of the vector commitment tree.
   * @param keyLifetime - (lf) Key lifetime.
   */
  constructor({ commitment, keyLifetime }) {
    super();
    this.commitment = typeof commitment === "string" ? new Uint8Array(buffer.Buffer.from(commitment, "base64")) : commitment;
    this.keyLifetime = keyLifetime;
    this.attribute_map = {
      commitment: "commitment",
      keyLifetime: "key-lifetime"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofVerifier({
      commitment: data["commitment"],
      keyLifetime: data["key-lifetime"]
    });
  }
}
class StateSchema extends BaseModel {
  /**
   * Creates a new `StateSchema` object.
   * @param numByteSlice - Maximum number of TEAL byte slices that may be stored in the key/value store.
   * @param numUint - Maximum number of TEAL uints that may be stored in the key/value store.
   */
  constructor({ numByteSlice, numUint }) {
    super();
    this.numByteSlice = numByteSlice;
    this.numUint = numUint;
    this.attribute_map = {
      numByteSlice: "num-byte-slice",
      numUint: "num-uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    return new StateSchema({
      numByteSlice: data["num-byte-slice"],
      numUint: data["num-uint"]
    });
  }
}
class TealKeyValue2 extends BaseModel {
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new TealKeyValue2({
      key: data["key"],
      value: TealValue2.from_obj_for_encoding(data["value"])
    });
  }
}
class TealValue2 extends BaseModel {
  /**
   * Creates a new `TealValue` object.
   * @param bytes - (tb) bytes value.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param uint - (ui) uint value.
   */
  constructor({ bytes, type, uint }) {
    super();
    this.bytes = bytes;
    this.type = type;
    this.uint = uint;
    this.attribute_map = {
      bytes: "bytes",
      type: "type",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["bytes"] === "undefined")
      throw new Error(`Response is missing required field 'bytes': ${data}`);
    if (typeof data["type"] === "undefined")
      throw new Error(`Response is missing required field 'type': ${data}`);
    if (typeof data["uint"] === "undefined")
      throw new Error(`Response is missing required field 'uint': ${data}`);
    return new TealValue2({
      bytes: data["bytes"],
      type: data["type"],
      uint: data["uint"]
    });
  }
}
class Transaction2 extends BaseModel {
  /**
   * Creates a new `Transaction` object.
   * @param fee - (fee) Transaction fee.
   * @param firstValid - (fv) First valid round for this transaction.
   * @param lastValid - (lv) Last valid round for this transaction.
   * @param sender - (snd) Sender's address.
   * @param applicationTransaction - Fields for application transactions.
   * Definition:
   * data/transactions/application.go : ApplicationCallTxnFields
   * @param assetConfigTransaction - Fields for asset allocation, re-configuration, and destruction.
   * A zero value for asset-id indicates asset creation.
   * A zero value for the params indicates asset destruction.
   * Definition:
   * data/transactions/asset.go : AssetConfigTxnFields
   * @param assetFreezeTransaction - Fields for an asset freeze transaction.
   * Definition:
   * data/transactions/asset.go : AssetFreezeTxnFields
   * @param assetTransferTransaction - Fields for an asset transfer transaction.
   * Definition:
   * data/transactions/asset.go : AssetTransferTxnFields
   * @param authAddr - (sgnr) this is included with signed transactions when the signing address does
   * not equal the sender. The backend can use this to ensure that auth addr is equal
   * to the accounts auth addr.
   * @param closeRewards - (rc) rewards applied to close-remainder-to account.
   * @param closingAmount - (ca) closing amount for transaction.
   * @param confirmedRound - Round when the transaction was confirmed.
   * @param createdApplicationIndex - Specifies an application index (ID) if an application was created with this
   * transaction.
   * @param createdAssetIndex - Specifies an asset index (ID) if an asset was created with this transaction.
   * @param genesisHash - (gh) Hash of genesis block.
   * @param genesisId - (gen) genesis block ID.
   * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
   * transaction.
   * @param group - (grp) Base64 encoded byte array of a sha512/256 digest. When present indicates
   * that this transaction is part of a transaction group and the value is the
   * sha512/256 hash of the transactions in that group.
   * @param id - Transaction ID
   * @param innerTxns - Inner transactions produced by application execution.
   * @param intraRoundOffset - Offset into the round where this transaction was confirmed.
   * @param keyregTransaction - Fields for a keyreg transaction.
   * Definition:
   * data/transactions/keyreg.go : KeyregTxnFields
   * @param lease - (lx) Base64 encoded 32-byte array. Lease enforces mutual exclusion of
   * transactions. If this field is nonzero, then once the transaction is confirmed,
   * it acquires the lease identified by the (Sender, Lease) pair of the transaction
   * until the LastValid round passes. While this transaction possesses the lease, no
   * other transaction specifying this lease can be confirmed.
   * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - (lg) Logs for the application being executed by this transaction.
   * @param note - (note) Free form data.
   * @param paymentTransaction - Fields for a payment transaction.
   * Definition:
   * data/transactions/payment.go : PaymentTxnFields
   * @param receiverRewards - (rr) rewards applied to receiver account.
   * @param rekeyTo - (rekey) when included in a valid transaction, the accounts auth addr will be
   * updated with this value and future signatures must be signed with the key
   * represented by this address.
   * @param roundTime - Time when the block this transaction is in was confirmed.
   * @param senderRewards - (rs) rewards applied to sender account.
   * @param signature - Validation signature associated with some data. Only one of the signatures
   * should be provided.
   * @param stateProofTransaction - Fields for a state proof transaction.
   * Definition:
   * data/transactions/stateproof.go : StateProofTxnFields
   * @param txType - (type) Indicates what type of transaction this is. Different types have
   * different fields.
   * Valid types, and where their fields are stored:
   * * (pay) payment-transaction
   * * (keyreg) keyreg-transaction
   * * (acfg) asset-config-transaction
   * * (axfer) asset-transfer-transaction
   * * (afrz) asset-freeze-transaction
   * * (appl) application-transaction
   * * (stpf) state-proof-transaction
   */
  constructor({ fee, firstValid, lastValid, sender, applicationTransaction, assetConfigTransaction, assetFreezeTransaction, assetTransferTransaction, authAddr, closeRewards, closingAmount, confirmedRound, createdApplicationIndex, createdAssetIndex, genesisHash, genesisId, globalStateDelta, group, id: id2, innerTxns, intraRoundOffset, keyregTransaction, lease, localStateDelta, logs, note, paymentTransaction, receiverRewards, rekeyTo, roundTime, senderRewards, signature, stateProofTransaction, txType }) {
    super();
    this.fee = fee;
    this.firstValid = firstValid;
    this.lastValid = lastValid;
    this.sender = sender;
    this.applicationTransaction = applicationTransaction;
    this.assetConfigTransaction = assetConfigTransaction;
    this.assetFreezeTransaction = assetFreezeTransaction;
    this.assetTransferTransaction = assetTransferTransaction;
    this.authAddr = authAddr;
    this.closeRewards = closeRewards;
    this.closingAmount = closingAmount;
    this.confirmedRound = confirmedRound;
    this.createdApplicationIndex = createdApplicationIndex;
    this.createdAssetIndex = createdAssetIndex;
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(buffer.Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.globalStateDelta = globalStateDelta;
    this.group = typeof group === "string" ? new Uint8Array(buffer.Buffer.from(group, "base64")) : group;
    this.id = id2;
    this.innerTxns = innerTxns;
    this.intraRoundOffset = intraRoundOffset;
    this.keyregTransaction = keyregTransaction;
    this.lease = typeof lease === "string" ? new Uint8Array(buffer.Buffer.from(lease, "base64")) : lease;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.note = typeof note === "string" ? new Uint8Array(buffer.Buffer.from(note, "base64")) : note;
    this.paymentTransaction = paymentTransaction;
    this.receiverRewards = receiverRewards;
    this.rekeyTo = rekeyTo;
    this.roundTime = roundTime;
    this.senderRewards = senderRewards;
    this.signature = signature;
    this.stateProofTransaction = stateProofTransaction;
    this.txType = txType;
    this.attribute_map = {
      fee: "fee",
      firstValid: "first-valid",
      lastValid: "last-valid",
      sender: "sender",
      applicationTransaction: "application-transaction",
      assetConfigTransaction: "asset-config-transaction",
      assetFreezeTransaction: "asset-freeze-transaction",
      assetTransferTransaction: "asset-transfer-transaction",
      authAddr: "auth-addr",
      closeRewards: "close-rewards",
      closingAmount: "closing-amount",
      confirmedRound: "confirmed-round",
      createdApplicationIndex: "created-application-index",
      createdAssetIndex: "created-asset-index",
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      globalStateDelta: "global-state-delta",
      group: "group",
      id: "id",
      innerTxns: "inner-txns",
      intraRoundOffset: "intra-round-offset",
      keyregTransaction: "keyreg-transaction",
      lease: "lease",
      localStateDelta: "local-state-delta",
      logs: "logs",
      note: "note",
      paymentTransaction: "payment-transaction",
      receiverRewards: "receiver-rewards",
      rekeyTo: "rekey-to",
      roundTime: "round-time",
      senderRewards: "sender-rewards",
      signature: "signature",
      stateProofTransaction: "state-proof-transaction",
      txType: "tx-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["fee"] === "undefined")
      throw new Error(`Response is missing required field 'fee': ${data}`);
    if (typeof data["first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'first-valid': ${data}`);
    if (typeof data["last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'last-valid': ${data}`);
    if (typeof data["sender"] === "undefined")
      throw new Error(`Response is missing required field 'sender': ${data}`);
    return new Transaction2({
      fee: data["fee"],
      firstValid: data["first-valid"],
      lastValid: data["last-valid"],
      sender: data["sender"],
      applicationTransaction: typeof data["application-transaction"] !== "undefined" ? TransactionApplication.from_obj_for_encoding(data["application-transaction"]) : void 0,
      assetConfigTransaction: typeof data["asset-config-transaction"] !== "undefined" ? TransactionAssetConfig.from_obj_for_encoding(data["asset-config-transaction"]) : void 0,
      assetFreezeTransaction: typeof data["asset-freeze-transaction"] !== "undefined" ? TransactionAssetFreeze.from_obj_for_encoding(data["asset-freeze-transaction"]) : void 0,
      assetTransferTransaction: typeof data["asset-transfer-transaction"] !== "undefined" ? TransactionAssetTransfer.from_obj_for_encoding(data["asset-transfer-transaction"]) : void 0,
      authAddr: data["auth-addr"],
      closeRewards: data["close-rewards"],
      closingAmount: data["closing-amount"],
      confirmedRound: data["confirmed-round"],
      createdApplicationIndex: data["created-application-index"],
      createdAssetIndex: data["created-asset-index"],
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      globalStateDelta: typeof data["global-state-delta"] !== "undefined" ? data["global-state-delta"].map(EvalDeltaKeyValue2.from_obj_for_encoding) : void 0,
      group: data["group"],
      id: data["id"],
      innerTxns: typeof data["inner-txns"] !== "undefined" ? data["inner-txns"].map(Transaction2.from_obj_for_encoding) : void 0,
      intraRoundOffset: data["intra-round-offset"],
      keyregTransaction: typeof data["keyreg-transaction"] !== "undefined" ? TransactionKeyreg.from_obj_for_encoding(data["keyreg-transaction"]) : void 0,
      lease: data["lease"],
      localStateDelta: typeof data["local-state-delta"] !== "undefined" ? data["local-state-delta"].map(AccountStateDelta2.from_obj_for_encoding) : void 0,
      logs: data["logs"],
      note: data["note"],
      paymentTransaction: typeof data["payment-transaction"] !== "undefined" ? TransactionPayment.from_obj_for_encoding(data["payment-transaction"]) : void 0,
      receiverRewards: data["receiver-rewards"],
      rekeyTo: data["rekey-to"],
      roundTime: data["round-time"],
      senderRewards: data["sender-rewards"],
      signature: typeof data["signature"] !== "undefined" ? TransactionSignature.from_obj_for_encoding(data["signature"]) : void 0,
      stateProofTransaction: typeof data["state-proof-transaction"] !== "undefined" ? TransactionStateProof.from_obj_for_encoding(data["state-proof-transaction"]) : void 0,
      txType: data["tx-type"]
    });
  }
}
class TransactionApplication extends BaseModel {
  /**
   * Creates a new `TransactionApplication` object.
   * @param applicationId - (apid) ID of the application being configured or empty if creating.
   * @param accounts - (apat) List of accounts in addition to the sender that may be accessed from the
   * application's approval-program and clear-state-program.
   * @param applicationArgs - (apaa) transaction specific arguments accessed from the application's
   * approval-program and clear-state-program.
   * @param approvalProgram - (apap) Logic executed for every application transaction, except when
   * on-completion is set to "clear". It can read and write global state for the
   * application, as well as account-specific local state. Approval programs may
   * reject the transaction.
   * @param clearStateProgram - (apsu) Logic executed for application transactions with on-completion set to
   * "clear". It can read and write global state for the application, as well as
   * account-specific local state. Clear state programs cannot reject the
   * transaction.
   * @param extraProgramPages - (epp) specifies the additional app program len requested in pages.
   * @param foreignApps - (apfa) Lists the applications in addition to the application-id whose global
   * states may be accessed by this application's approval-program and
   * clear-state-program. The access is read-only.
   * @param foreignAssets - (apas) lists the assets whose parameters may be accessed by this application's
   * ApprovalProgram and ClearStateProgram. The access is read-only.
   * @param globalStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param localStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param onCompletion - (apan) defines the what additional actions occur with the transaction.
   * Valid types:
   * * noop
   * * optin
   * * closeout
   * * clear
   * * update
   * * update
   * * delete
   */
  constructor({ applicationId, accounts, applicationArgs, approvalProgram, clearStateProgram, extraProgramPages, foreignApps, foreignAssets, globalStateSchema, localStateSchema, onCompletion }) {
    super();
    this.applicationId = applicationId;
    this.accounts = accounts;
    this.applicationArgs = applicationArgs;
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(buffer.Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(buffer.Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.extraProgramPages = extraProgramPages;
    this.foreignApps = foreignApps;
    this.foreignAssets = foreignAssets;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.onCompletion = onCompletion;
    this.attribute_map = {
      applicationId: "application-id",
      accounts: "accounts",
      applicationArgs: "application-args",
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      extraProgramPages: "extra-program-pages",
      foreignApps: "foreign-apps",
      foreignAssets: "foreign-assets",
      globalStateSchema: "global-state-schema",
      localStateSchema: "local-state-schema",
      onCompletion: "on-completion"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    return new TransactionApplication({
      applicationId: data["application-id"],
      accounts: data["accounts"],
      applicationArgs: data["application-args"],
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      extraProgramPages: data["extra-program-pages"],
      foreignApps: data["foreign-apps"],
      foreignAssets: data["foreign-assets"],
      globalStateSchema: typeof data["global-state-schema"] !== "undefined" ? StateSchema.from_obj_for_encoding(data["global-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? StateSchema.from_obj_for_encoding(data["local-state-schema"]) : void 0,
      onCompletion: data["on-completion"]
    });
  }
}
class TransactionAssetConfig extends BaseModel {
  /**
   * Creates a new `TransactionAssetConfig` object.
   * @param assetId - (xaid) ID of the asset being configured or empty if creating.
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ assetId, params }) {
    super();
    this.assetId = assetId;
    this.params = params;
    this.attribute_map = {
      assetId: "asset-id",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionAssetConfig({
      assetId: data["asset-id"],
      params: typeof data["params"] !== "undefined" ? AssetParams2.from_obj_for_encoding(data["params"]) : void 0
    });
  }
}
class TransactionAssetFreeze extends BaseModel {
  /**
   * Creates a new `TransactionAssetFreeze` object.
   * @param address - (fadd) Address of the account whose asset is being frozen or thawed.
   * @param assetId - (faid) ID of the asset being frozen or thawed.
   * @param newFreezeStatus - (afrz) The new freeze status.
   */
  constructor({ address, assetId, newFreezeStatus }) {
    super();
    this.address = address;
    this.assetId = assetId;
    this.newFreezeStatus = newFreezeStatus;
    this.attribute_map = {
      address: "address",
      assetId: "asset-id",
      newFreezeStatus: "new-freeze-status"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["new-freeze-status"] === "undefined")
      throw new Error(`Response is missing required field 'new-freeze-status': ${data}`);
    return new TransactionAssetFreeze({
      address: data["address"],
      assetId: data["asset-id"],
      newFreezeStatus: data["new-freeze-status"]
    });
  }
}
class TransactionAssetTransfer extends BaseModel {
  /**
   * Creates a new `TransactionAssetTransfer` object.
   * @param amount - (aamt) Amount of asset to transfer. A zero amount transferred to self allocates
   * that asset in the account's Assets map.
   * @param assetId - (xaid) ID of the asset being transferred.
   * @param receiver - (arcv) Recipient address of the transfer.
   * @param closeAmount - Number of assets transfered to the close-to account as part of the transaction.
   * @param closeTo - (aclose) Indicates that the asset should be removed from the account's Assets
   * map, and specifies where the remaining asset holdings should be transferred.
   * It's always valid to transfer remaining asset holdings to the creator account.
   * @param sender - (asnd) The effective sender during a clawback transactions. If this is not a
   * zero value, the real transaction sender must be the Clawback address from the
   * AssetParams.
   */
  constructor({ amount, assetId, receiver, closeAmount, closeTo, sender }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.receiver = receiver;
    this.closeAmount = closeAmount;
    this.closeTo = closeTo;
    this.sender = sender;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      receiver: "receiver",
      closeAmount: "close-amount",
      closeTo: "close-to",
      sender: "sender"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["receiver"] === "undefined")
      throw new Error(`Response is missing required field 'receiver': ${data}`);
    return new TransactionAssetTransfer({
      amount: data["amount"],
      assetId: data["asset-id"],
      receiver: data["receiver"],
      closeAmount: data["close-amount"],
      closeTo: data["close-to"],
      sender: data["sender"]
    });
  }
}
class TransactionKeyreg extends BaseModel {
  /**
   * Creates a new `TransactionKeyreg` object.
   * @param nonParticipation - (nonpart) Mark the account as participating or non-participating.
   * @param selectionParticipationKey - (selkey) Public key used with the Verified Random Function (VRF) result during
   * committee selection.
   * @param stateProofKey - (sprfkey) State proof key used in key registration transactions.
   * @param voteFirstValid - (votefst) First round this participation key is valid.
   * @param voteKeyDilution - (votekd) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (votelst) Last round this participation key is valid.
   * @param voteParticipationKey - (votekey) Participation public key used in key registration transactions.
   */
  constructor({ nonParticipation, selectionParticipationKey, stateProofKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey }) {
    super();
    this.nonParticipation = nonParticipation;
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(buffer.Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.attribute_map = {
      nonParticipation: "non-participation",
      selectionParticipationKey: "selection-participation-key",
      stateProofKey: "state-proof-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionKeyreg({
      nonParticipation: data["non-participation"],
      selectionParticipationKey: data["selection-participation-key"],
      stateProofKey: data["state-proof-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"]
    });
  }
}
class TransactionPayment extends BaseModel {
  /**
   * Creates a new `TransactionPayment` object.
   * @param amount - (amt) number of MicroAlgos intended to be transferred.
   * @param receiver - (rcv) receiver's address.
   * @param closeAmount - Number of MicroAlgos that were sent to the close-remainder-to address when
   * closing the sender account.
   * @param closeRemainderTo - (close) when set, indicates that the sending account should be closed and all
   * remaining funds be transferred to this address.
   */
  constructor({ amount, receiver, closeAmount, closeRemainderTo }) {
    super();
    this.amount = amount;
    this.receiver = receiver;
    this.closeAmount = closeAmount;
    this.closeRemainderTo = closeRemainderTo;
    this.attribute_map = {
      amount: "amount",
      receiver: "receiver",
      closeAmount: "close-amount",
      closeRemainderTo: "close-remainder-to"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["receiver"] === "undefined")
      throw new Error(`Response is missing required field 'receiver': ${data}`);
    return new TransactionPayment({
      amount: data["amount"],
      receiver: data["receiver"],
      closeAmount: data["close-amount"],
      closeRemainderTo: data["close-remainder-to"]
    });
  }
}
class TransactionResponse extends BaseModel {
  /**
   * Creates a new `TransactionResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transaction - Contains all fields common to all transactions and serves as an envelope to all
   * transactions type. Represents both regular and inner transactions.
   * Definition:
   * data/transactions/signedtxn.go : SignedTxn
   * data/transactions/transaction.go : Transaction
   */
  constructor({ currentRound, transaction: transaction2 }) {
    super();
    this.currentRound = currentRound;
    this.transaction = transaction2;
    this.attribute_map = {
      currentRound: "current-round",
      transaction: "transaction"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    if (typeof data["transaction"] === "undefined")
      throw new Error(`Response is missing required field 'transaction': ${data}`);
    return new TransactionResponse({
      currentRound: data["current-round"],
      transaction: Transaction2.from_obj_for_encoding(data["transaction"])
    });
  }
}
class TransactionSignature extends BaseModel {
  /**
   * Creates a new `TransactionSignature` object.
   * @param logicsig - (lsig) Programatic transaction signature.
   * Definition:
   * data/transactions/logicsig.go
   * @param multisig - (msig) structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param sig - (sig) Standard ed25519 signature.
   */
  constructor({ logicsig, multisig, sig }) {
    super();
    this.logicsig = logicsig;
    this.multisig = multisig;
    this.sig = typeof sig === "string" ? new Uint8Array(buffer.Buffer.from(sig, "base64")) : sig;
    this.attribute_map = {
      logicsig: "logicsig",
      multisig: "multisig",
      sig: "sig"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignature({
      logicsig: typeof data["logicsig"] !== "undefined" ? TransactionSignatureLogicsig.from_obj_for_encoding(data["logicsig"]) : void 0,
      multisig: typeof data["multisig"] !== "undefined" ? TransactionSignatureMultisig.from_obj_for_encoding(data["multisig"]) : void 0,
      sig: data["sig"]
    });
  }
}
class TransactionSignatureLogicsig extends BaseModel {
  /**
   * Creates a new `TransactionSignatureLogicsig` object.
   * @param logic - (l) Program signed by a signature or multi signature, or hashed to be the
   * address of ana ccount. Base64 encoded TEAL program.
   * @param args - (arg) Logic arguments, base64 encoded.
   * @param multisigSignature - (msig) structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param signature - (sig) ed25519 signature.
   */
  constructor({ logic, args, multisigSignature, signature }) {
    super();
    this.logic = typeof logic === "string" ? new Uint8Array(buffer.Buffer.from(logic, "base64")) : logic;
    this.args = args;
    this.multisigSignature = multisigSignature;
    this.signature = typeof signature === "string" ? new Uint8Array(buffer.Buffer.from(signature, "base64")) : signature;
    this.attribute_map = {
      logic: "logic",
      args: "args",
      multisigSignature: "multisig-signature",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["logic"] === "undefined")
      throw new Error(`Response is missing required field 'logic': ${data}`);
    return new TransactionSignatureLogicsig({
      logic: data["logic"],
      args: data["args"],
      multisigSignature: typeof data["multisig-signature"] !== "undefined" ? TransactionSignatureMultisig.from_obj_for_encoding(data["multisig-signature"]) : void 0,
      signature: data["signature"]
    });
  }
}
class TransactionSignatureMultisig extends BaseModel {
  /**
   * Creates a new `TransactionSignatureMultisig` object.
   * @param subsignature - (subsig) holds pairs of public key and signatures.
   * @param threshold - (thr)
   * @param version - (v)
   */
  constructor({ subsignature, threshold, version: version2 }) {
    super();
    this.subsignature = subsignature;
    this.threshold = threshold;
    this.version = version2;
    this.attribute_map = {
      subsignature: "subsignature",
      threshold: "threshold",
      version: "version"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignatureMultisig({
      subsignature: typeof data["subsignature"] !== "undefined" ? data["subsignature"].map(TransactionSignatureMultisigSubsignature.from_obj_for_encoding) : void 0,
      threshold: data["threshold"],
      version: data["version"]
    });
  }
}
class TransactionSignatureMultisigSubsignature extends BaseModel {
  /**
   * Creates a new `TransactionSignatureMultisigSubsignature` object.
   * @param publicKey - (pk)
   * @param signature - (s)
   */
  constructor({ publicKey, signature }) {
    super();
    this.publicKey = typeof publicKey === "string" ? new Uint8Array(buffer.Buffer.from(publicKey, "base64")) : publicKey;
    this.signature = typeof signature === "string" ? new Uint8Array(buffer.Buffer.from(signature, "base64")) : signature;
    this.attribute_map = {
      publicKey: "public-key",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignatureMultisigSubsignature({
      publicKey: data["public-key"],
      signature: data["signature"]
    });
  }
}
class TransactionStateProof extends BaseModel {
  /**
   * Creates a new `TransactionStateProof` object.
   * @param message - (spmsg)
   * @param stateProof - (sp) represents a state proof.
   * Definition:
   * crypto/stateproof/structs.go : StateProof
   * @param stateProofType - (sptype) Type of the state proof. Integer representing an entry defined in
   * protocol/stateproof.go
   */
  constructor({ message, stateProof, stateProofType }) {
    super();
    this.message = message;
    this.stateProof = stateProof;
    this.stateProofType = stateProofType;
    this.attribute_map = {
      message: "message",
      stateProof: "state-proof",
      stateProofType: "state-proof-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionStateProof({
      message: typeof data["message"] !== "undefined" ? IndexerStateProofMessage.from_obj_for_encoding(data["message"]) : void 0,
      stateProof: typeof data["state-proof"] !== "undefined" ? StateProofFields.from_obj_for_encoding(data["state-proof"]) : void 0,
      stateProofType: data["state-proof-type"]
    });
  }
}
class TransactionsResponse extends BaseModel {
  /**
   * Creates a new `TransactionsResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transactions -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ currentRound, transactions, nextToken }) {
    super();
    this.currentRound = currentRound;
    this.transactions = transactions;
    this.nextToken = nextToken;
    this.attribute_map = {
      currentRound: "current-round",
      transactions: "transactions",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    if (!Array.isArray(data["transactions"]))
      throw new Error(`Response is missing required array field 'transactions': ${data}`);
    return new TransactionsResponse({
      currentRound: data["current-round"],
      transactions: data["transactions"].map(Transaction2.from_obj_for_encoding),
      nextToken: data["next-token"]
    });
  }
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account: Account2,
  AccountParticipation: AccountParticipation2,
  AccountResponse,
  AccountStateDelta: AccountStateDelta2,
  AccountsResponse,
  Application: Application2,
  ApplicationLocalState: ApplicationLocalState2,
  ApplicationLocalStatesResponse,
  ApplicationLogData,
  ApplicationLogsResponse,
  ApplicationParams: ApplicationParams2,
  ApplicationResponse,
  ApplicationStateSchema: ApplicationStateSchema2,
  ApplicationsResponse,
  Asset: Asset2,
  AssetBalancesResponse,
  AssetHolding: AssetHolding2,
  AssetHoldingsResponse,
  AssetParams: AssetParams2,
  AssetResponse,
  AssetsResponse,
  Block: Block2,
  BlockRewards,
  BlockUpgradeState,
  BlockUpgradeVote,
  Box: Box2,
  BoxDescriptor: BoxDescriptor2,
  BoxesResponse: BoxesResponse2,
  ErrorResponse: ErrorResponse2,
  EvalDelta: EvalDelta2,
  EvalDeltaKeyValue: EvalDeltaKeyValue2,
  HashFactory,
  HealthCheck: HealthCheck2,
  IndexerStateProofMessage,
  MerkleArrayProof,
  MiniAssetHolding,
  ParticipationUpdates,
  StateProofFields,
  StateProofParticipant,
  StateProofReveal,
  StateProofSigSlot,
  StateProofSignature,
  StateProofTracking,
  StateProofVerifier,
  StateSchema,
  TealKeyValue: TealKeyValue2,
  TealValue: TealValue2,
  Transaction: Transaction2,
  TransactionApplication,
  TransactionAssetConfig,
  TransactionAssetFreeze,
  TransactionAssetTransfer,
  TransactionKeyreg,
  TransactionPayment,
  TransactionResponse,
  TransactionSignature,
  TransactionSignatureLogicsig,
  TransactionSignatureMultisig,
  TransactionSignatureMultisigSubsignature,
  TransactionStateProof,
  TransactionsResponse
}, Symbol.toStringTag, { value: "Module" }));
class LookupApplicationBoxByIDandName extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, intDecoding, index2, boxName) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    const encodedName = buffer.Buffer.from(boxName).toString("base64");
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return Box2.from_obj_for_encoding(body);
  }
}
class SearchAccounts extends JSONRequest {
  /**
   * @returns `/v2/accounts`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/accounts";
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for accounts with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude accounts with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id2) {
    this.query["asset-id"] = id2;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const accountsPage1 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   *
   * const accountsPage2 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .nextToken(accountsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks For performance reasons, this parameter may be disabled on some configurations.
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include accounts that use this spending key.
   *
   * #### Example
   * ```typescript
   * const authAddr = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .authAddr(authAddr)
   *        .do();
   * ```
   *
   * @param authAddr
   */
  authAddr(authAddr) {
    this.query["auth-addr"] = authAddr;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
}
class SearchForTransactions extends JSONRequest {
  /**
   * @returns `/v2/transactions`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txType("keyreg")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .sigType("sig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupBlock(targetBlock).do()`
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetTransactions(assetId).do()`
   * @param id
   * @category query
   */
  assetID(id2) {
    this.query["asset-id"] = id2;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "freeze-target";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAccountTransactions(address).do()`
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address;
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const txnsPage1 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   *
   * const txnsPage2 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .nextToken(txnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
}
class SearchForAssets extends JSONRequest {
  /**
   * @returns `/v2/assets`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/assets";
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filter just assets with the given creator address.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .creator(address)
   *        .do();
   * ```
   *
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  /**
   * Filter just assets with the given name.
   *
   * #### Example
   * ```typescript
   * const name = "Test Token";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .name(name)
   *        .do();
   * ```
   *
   * @param name
   * @category query
   */
  name(name) {
    this.query.name = name;
    return this;
  }
  /**
   * Filter just assets with the given unit.
   *
   * #### Example
   * ```typescript
   * const unit = "test";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .unit(unit)
   *        .do();
   * ```
   *
   * @param unit
   * @category query
   */
  unit(unit) {
    this.query.unit = unit;
    return this;
  }
  /**
   * Asset ID for filter, as int.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .index(assetId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetByID(assetId).do();`
   * @param index
   * @category query
   */
  index(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const assetsPage1 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   *
   * const assetsPage2 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .nextToken(assetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class SearchForApplications extends JSONRequest {
  /**
   * @returns `/v2/applications`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/applications";
  }
  /**
   * Application ID for filter, as int
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .index(appId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupApplications(appId).do()`
   * @param index
   * @category query
   */
  index(index2) {
    this.query["application-id"] = index2;
    return this;
  }
  /**
   * Creator for filter, as string
   *
   * #### Example
   * ```typescript
   * const creator = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .creator(creator)
   *        .do();
   * ```
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const appsPage1 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   *
   * const appsPage2 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .nextToken(appsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class SearchForApplicationBoxes extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResponse = await indexerClient
   *        .searchForApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return BoxesResponse2.from_obj_for_encoding(body);
  }
}
class IndexerClient extends ServiceClient {
  /**
   * Create an IndexerClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "";
   * const server = "http://localhost";
   * const port   = 8980;
   * const indexerClient = new algosdk.Indexer(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node with indexer, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The API token for the Indexer API
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
    super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns the health object for the service.
   * Returns 200 if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await indexerClient.makeHealthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-health)
   * @category GET
   */
  makeHealthCheck() {
    return new MakeHealthCheck(this.c, this.intDecoding);
  }
  /**
   * Returns the list of accounts who hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetBalances(index2) {
    return new LookupAssetBalances(this.c, this.intDecoding, index2);
  }
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetTransactions(index2) {
    return new LookupAssetTransactions(this.c, this.intDecoding, index2);
  }
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   * @category GET
   */
  lookupAccountTransactions(account) {
    return new LookupAccountTransactions(this.c, this.intDecoding, account);
  }
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  lookupBlock(round) {
    return new LookupBlock(this.c, this.intDecoding, round);
  }
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  lookupTransactionByID(txID) {
    return new LookupTransactionByID(this.c, this.intDecoding, txID);
  }
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountByID(account) {
    return new LookupAccountByID(this.c, this.intDecoding, account);
  }
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAssets(account) {
    return new LookupAccountAssets(this.c, this.intDecoding, account);
  }
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedAssets(account) {
    return new LookupAccountCreatedAssets(this.c, this.intDecoding, account);
  }
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAppLocalStates(account) {
    return new LookupAccountAppLocalStates(this.c, this.intDecoding, account);
  }
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedApplications(account) {
    return new LookupAccountCreatedApplications(this.c, this.intDecoding, account);
  }
  /**
   * Returns information about the passed asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The ID of the asset ot look up.
   * @category GET
   */
  lookupAssetByID(index2) {
    return new LookupAssetByID(this.c, this.intDecoding, index2);
  }
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  lookupApplications(index2) {
    return new LookupApplications(this.c, this.intDecoding, index2);
  }
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  lookupApplicationLogs(appID) {
    return new LookupApplicationLogs(this.c, this.intDecoding, appID);
  }
  /**
   * Returns information about indexed accounts.
   *
   * #### Example
   * ```typescript
   * const accounts = await indexerClient.searchAccounts().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accounts)
   * @category GET
   */
  searchAccounts() {
    return new SearchAccounts(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient.searchForTransactions().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactions)
   * @category GET
   */
  searchForTransactions() {
    return new SearchForTransactions(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed assets.
   *
   * #### Example
   * ```typescript
   * const assets = await indexerClient.searchForAssets().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assets)
   * @category GET
   */
  searchForAssets() {
    return new SearchForAssets(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed applications.
   *
   * #### Example
   * ```typescript
   * const apps = await indexerClient.searchForApplications().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applications)
   * @category GET
   */
  searchForApplications() {
    return new SearchForApplications(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  searchForApplicationBoxes(appID) {
    return new SearchForApplicationBoxes(this.c, this.intDecoding, appID);
  }
  /**
   * Returns information about the application box given its name.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  lookupApplicationBoxByIDandName(appID, boxName) {
    return new LookupApplicationBoxByIDandName(this.c, this.intDecoding, appID, boxName);
  }
}
async function waitForConfirmation(client, txid, waitRounds) {
  const status = await client.status().do();
  if (typeof status === "undefined") {
    throw new Error("Unable to get node status");
  }
  const startRound = status["last-round"] + 1;
  let currentRound = startRound;
  while (currentRound < startRound + waitRounds) {
    let poolError = false;
    try {
      const pendingInfo = await client.pendingTransactionInformation(txid).do();
      if (pendingInfo["confirmed-round"]) {
        return pendingInfo;
      }
      if (pendingInfo["pool-error"]) {
        poolError = true;
        throw new Error(`Transaction Rejected: ${pendingInfo["pool-error"]}`);
      }
    } catch (err) {
      if (poolError) {
        throw err;
      }
    }
    await client.statusAfterBlock(currentRound).do();
    currentRound += 1;
  }
  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
}
function bigIntToBytes(bi2, size2) {
  let hex = bi2.toString(16);
  if (hex.length !== size2 * 2) {
    hex = hex.padStart(size2 * 2, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0, j2 = 0; i < hex.length / 2; i++, j2 += 2) {
    byteArray[i] = parseInt(hex.slice(j2, j2 + 2), 16);
  }
  return byteArray;
}
function bytesToBigInt(bytes) {
  let res = BigInt(0);
  const buf = buffer.Buffer.from(bytes);
  for (let i = 0; i < bytes.length; i++) {
    res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);
  }
  return res;
}
function generateAccount() {
  const keys = keyPair();
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
const english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
const FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
const NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
function toUint11Array(buffer8) {
  const buffer11 = [];
  let acc = 0;
  let accBits = 0;
  function add2(octet) {
    acc |= octet << accBits;
    accBits += 8;
    if (accBits >= 11) {
      buffer11.push(acc & 2047);
      acc >>= 11;
      accBits -= 11;
    }
  }
  function flush() {
    if (accBits) {
      buffer11.push(acc);
    }
  }
  buffer8.forEach(add2);
  flush();
  return buffer11;
}
function applyWords(nums) {
  return nums.map((n) => english[n]);
}
function computeChecksum(seed) {
  const hashBuffer = genericHash(seed);
  const uint11Hash = toUint11Array(hashBuffer);
  const words = applyWords(uint11Hash);
  return words[0];
}
function mnemonicFromSeed(seed) {
  if (seed.length !== SEED_BTYES_LENGTH) {
    throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
  }
  const uint11Array = toUint11Array(seed);
  const words = applyWords(uint11Array);
  const checksumWord = computeChecksum(seed);
  return `${words.join(" ")} ${checksumWord}`;
}
function toUint8Array(buffer11) {
  const buffer8 = [];
  let acc = 0;
  let accBits = 0;
  function add2(ui11) {
    acc |= ui11 << accBits;
    accBits += 11;
    while (accBits >= 8) {
      buffer8.push(acc & 255);
      acc >>= 8;
      accBits -= 8;
    }
  }
  function flush() {
    if (accBits) {
      buffer8.push(acc);
    }
  }
  buffer11.forEach(add2);
  flush();
  return new Uint8Array(buffer8);
}
function seedFromMnemonic(mnemonic) {
  const words = mnemonic.split(" ");
  const key = words.slice(0, 24);
  for (const w of key) {
    if (english.indexOf(w) === -1)
      throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
  }
  const checksum = words[words.length - 1];
  const uint11Array = key.map((word) => english.indexOf(word));
  let uint8Array = toUint8Array(uint11Array);
  if (uint8Array.length !== 33)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  if (uint8Array[uint8Array.length - 1] !== 0)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  uint8Array = uint8Array.slice(0, uint8Array.length - 1);
  const cs2 = computeChecksum(uint8Array);
  if (cs2 === checksum)
    return uint8Array;
  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
}
function mnemonicToSecretKey(mn2) {
  const seed = seedFromMnemonic(mn2);
  const keys = keyPairFromSeed(seed);
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
function secretKeyToMnemonic(sk) {
  const seed = sk.slice(0, SEED_BTYES_LENGTH);
  return mnemonicFromSeed(seed);
}
function mnemonicToMasterDerivationKey(mn2) {
  return seedFromMnemonic(mn2);
}
function masterDerivationKeyToMnemonic(mdk) {
  return mnemonicFromSeed(mdk);
}
const ALGORAND_MAX_TX_GROUP_SIZE = 16;
class TxGroup {
  constructor(hashes) {
    this.name = "Transaction group";
    this.tag = buffer.Buffer.from("TG");
    if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
      const errorMsg = `${hashes.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;
      throw Error(errorMsg);
    }
    this.txGroupHashes = hashes;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const txgroup = {
      txlist: this.txGroupHashes
    };
    return txgroup;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txgroupForEnc) {
    const txn = Object.create(this.prototype);
    txn.name = "Transaction group";
    txn.tag = buffer.Buffer.from("TG");
    txn.txGroupHashes = [];
    for (const hash of txgroupForEnc.txlist) {
      txn.txGroupHashes.push(buffer.Buffer.from(hash));
    }
    return txn;
  }
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
}
function computeGroupID(txns) {
  const hashes = [];
  for (const txn of txns) {
    const tx2 = instantiateTxnIfNeeded(txn);
    hashes.push(tx2.rawTxID());
  }
  const txgroup = new TxGroup(hashes);
  const bytes = txgroup.toByte();
  const toBeHashed = buffer.Buffer.from(concatArrays(txgroup.tag, bytes));
  const gid = genericHash(toBeHashed);
  return buffer.Buffer.from(gid);
}
function assignGroupID(txns, from) {
  const gid = computeGroupID(txns);
  const result = [];
  for (const txn of txns) {
    const tx2 = instantiateTxnIfNeeded(txn);
    if (!from || encodeAddress(tx2.from.publicKey) === from) {
      tx2.group = gid;
      result.push(tx2);
    }
  }
  return result;
}
const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
const MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
const MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
const MULTISIG_NO_MUTATE_ERROR_MSG = "Cannot mutate a multisig field as it would invalidate all existing signatures.";
const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.";
const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = "Cannot add multisig signature. Signature is not of the correct length.";
function createMultisigTransaction(txn, { version: version2, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const subsigs = pks.map((pk) => ({ pk: buffer.Buffer.from(pk) }));
  const msig = {
    v: version2,
    thr: threshold,
    subsig: subsigs
  };
  const txnForEncoding = txn.get_obj_for_encoding();
  const signedTxn = {
    msig,
    txn: txnForEncoding
  };
  const msigAddr = fromMultisigPreImg({
    version: version2,
    threshold,
    pks
  });
  if (encodeAddress(txnForEncoding.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = buffer.Buffer.from(msigAddr);
  }
  return new Uint8Array(encode(signedTxn));
}
function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version: version2, threshold, pks }) {
  const encodedMsig = createMultisigTransaction(txn, {
    version: version2,
    threshold,
    addrs: pks.map((pk) => encodeAddress(pk))
  });
  const signedTxn = decode$1(encodedMsig);
  let keyExist = false;
  signedTxn.msig.subsig.forEach((subsig, i) => {
    if (bytesEqual(subsig.pk, myPk)) {
      keyExist = true;
      signedTxn.msig.subsig[i].s = rawSig;
    }
  });
  if (keyExist === false) {
    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
  }
  const msigAddr = fromMultisigPreImg({
    version: version2,
    threshold,
    pks
  });
  if (encodeAddress(signedTxn.txn.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = buffer.Buffer.from(msigAddr);
  }
  return new Uint8Array(encode(signedTxn));
}
class MultisigTransaction extends Transaction$1 {
  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */
  /**
   * Override inherited method to throw an error, as mutating transactions are prohibited in this context
   */
  addLease() {
    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
  }
  /**
   * Override inherited method to throw an error, as mutating transactions are prohibited in this context
   */
  addRekey() {
    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
  }
  signTxn(sk) {
    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);
  }
  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */
  /**
   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,
   * encoded with msgpack as a typed array.
   * @param version - multisig version
   * @param threshold - multisig threshold
   * @param pks - multisig public key list, order is important.
   * @param sk - an Algorand secret key to sign with.
   * @returns an encoded, partially signed multisig transaction.
   */
  partialSignTxn({ version: version2, threshold, pks }, sk) {
    const myPk = keyPairFromSecretKey(sk).publicKey;
    return createMultisigTransactionWithSignature(this, { rawSig: this.rawSignTxn(sk), myPk }, { version: version2, threshold, pks });
  }
  /**
   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns
   * a partially-signed multisig transaction, encoded with msgpack as a typed array.
   * @param metadata - multisig metadata
   * @param signerAddr - address of the signer
   * @param signature - raw multisig signature
   * @returns an encoded, partially signed multisig transaction.
   */
  partialSignWithMultisigSignature(metadata, signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
    }
    return createMultisigTransactionWithSignature(this, {
      rawSig: signature,
      myPk: decodeAddress(signerAddr).publicKey
    }, metadata);
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txnForEnc) {
    return super.from_obj_for_encoding(txnForEnc);
  }
}
function mergeMultisigTransactions(multisigTxnBlobs) {
  if (multisigTxnBlobs.length < 2) {
    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
  }
  const refSigTx = decode$1(multisigTxnBlobs[0]);
  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();
  const refAuthAddr = refSigTx.sgnr ? encodeAddress(refSigTx.sgnr) : void 0;
  const refPreImage = {
    version: refSigTx.msig.v,
    threshold: refSigTx.msig.thr,
    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
  };
  const refMsigAddr = encodeAddress(fromMultisigPreImg(refPreImage));
  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));
  for (let i = 1; i < multisigTxnBlobs.length; i++) {
    const unisig = decode$1(multisigTxnBlobs[i]);
    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);
    if (unisigAlgoTxn.txID() !== refTxID) {
      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
    }
    const authAddr = unisig.sgnr ? encodeAddress(unisig.sgnr) : void 0;
    if (refAuthAddr !== authAddr) {
      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
    }
    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    const preimg = {
      version: unisig.msig.v,
      threshold: unisig.msig.thr,
      pks: unisig.msig.subsig.map((subsig) => subsig.pk)
    };
    const msgigAddr = encodeAddress(fromMultisigPreImg(preimg));
    if (refMsigAddr !== msgigAddr) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    unisig.msig.subsig.forEach((uniSubsig, index2) => {
      if (!uniSubsig.s)
        return;
      const current = newSubsigs[index2];
      if (current.s && buffer.Buffer.compare(buffer.Buffer.from(uniSubsig.s), buffer.Buffer.from(current.s)) !== 0) {
        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
      }
      current.s = uniSubsig.s;
    });
  }
  const msig = {
    v: refSigTx.msig.v,
    thr: refSigTx.msig.thr,
    subsig: newSubsigs
  };
  const signedTxn = {
    msig,
    txn: refSigTx.txn
  };
  if (typeof refAuthAddr !== "undefined") {
    signedTxn.sgnr = buffer.Buffer.from(decodeAddress(refAuthAddr).publicKey);
  }
  return new Uint8Array(encode(signedTxn));
}
function verifyMultisig(toBeVerified, msig, publicKey) {
  const version2 = msig.v;
  const threshold = msig.thr;
  const subsigs = msig.subsig;
  const pks = subsigs.map((subsig) => subsig.pk);
  if (msig.subsig.length < threshold) {
    return false;
  }
  let pk;
  try {
    pk = fromMultisigPreImg({ version: version2, threshold, pks });
  } catch (e) {
    return false;
  }
  if (!arrayEqual(pk, publicKey)) {
    return false;
  }
  let counter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      counter += 1;
    }
  }
  if (counter < threshold) {
    return false;
  }
  let verifiedCounter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      if (verify(toBeVerified, subsig.s, subsig.pk)) {
        verifiedCounter += 1;
      }
    }
  }
  if (verifiedCounter < threshold) {
    return false;
  }
  return true;
}
function signMultisigTransaction(txn, { version: version2, threshold, addrs }, sk) {
  const expectedFromRaw = fromMultisigPreImgAddrs({
    version: version2,
    threshold,
    addrs
  });
  if (!Object.prototype.hasOwnProperty.call(txn, "from")) {
    txn.from = expectedFromRaw;
  }
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const txnAlreadyBuilt = txn instanceof Transaction$1;
  let algoTxn;
  let blob;
  if (txnAlreadyBuilt) {
    algoTxn = txn;
    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, { version: version2, threshold, pks }, sk);
  } else {
    algoTxn = new MultisigTransaction(txn);
    blob = algoTxn.partialSignTxn({ version: version2, threshold, pks }, sk);
  }
  return {
    txID: algoTxn.txID().toString(),
    blob
  };
}
function appendSignMultisigTransaction(multisigTxnBlob, { version: version2, threshold, addrs }, sk) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode$1(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignTxn({ version: version2, threshold, pks }, sk);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function appendSignRawMultisigSignature(multisigTxnBlob, { version: version2, threshold, addrs }, signerAddr, signature) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode$1(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({ version: version2, threshold, pks }, signerAddr, signature);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function multisigAddress({ version: version2, threshold, addrs }) {
  return fromMultisigPreImgAddrs({ version: version2, threshold, addrs });
}
function sanityCheckProgram(program) {
  if (!program || program.length === 0)
    throw new Error("empty program");
  const lineBreakOrd = "\n".charCodeAt(0);
  const blankSpaceOrd = " ".charCodeAt(0);
  const tildeOrd = "~".charCodeAt(0);
  const isPrintable = (x2) => blankSpaceOrd <= x2 && x2 <= tildeOrd;
  const isAsciiPrintable = program.every((x2) => x2 === lineBreakOrd || isPrintable(x2));
  if (isAsciiPrintable) {
    const programStr = buffer.Buffer.from(program).toString();
    if (isValidAddress(programStr))
      throw new Error("requesting program bytes, get Algorand address");
    if (buffer.Buffer.from(programStr, "base64").toString("base64") === programStr)
      throw new Error("program should not be b64 encoded");
    throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
class LogicSig {
  constructor(program, programArgs) {
    this.tag = buffer.Buffer.from("Program");
    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array || buffer.Buffer.isBuffer(arg)))) {
      throw new TypeError("Invalid arguments");
    }
    let args;
    if (programArgs != null)
      args = programArgs.map((arg) => new Uint8Array(arg));
    sanityCheckProgram(program);
    this.logic = program;
    this.args = args;
    this.sig = void 0;
    this.msig = void 0;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const obj = {
      l: this.logic
    };
    if (this.args) {
      obj.arg = this.args;
    }
    if (this.sig) {
      obj.sig = this.sig;
    } else if (this.msig) {
      obj.msig = this.msig;
    }
    return obj;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(encoded) {
    const lsig = new LogicSig(encoded.l, encoded.arg);
    lsig.sig = encoded.sig;
    lsig.msig = encoded.msig;
    return lsig;
  }
  /**
   * Performs signature verification
   * @param publicKey - Verification key (derived from sender address or escrow address)
   */
  verify(publicKey) {
    if (this.sig && this.msig) {
      return false;
    }
    try {
      sanityCheckProgram(this.logic);
    } catch (e) {
      return false;
    }
    const toBeSigned = concatArrays(this.tag, this.logic);
    if (!this.sig && !this.msig) {
      const hash = genericHash(toBeSigned);
      return arrayEqual(hash, publicKey);
    }
    if (this.sig) {
      return verify(toBeSigned, this.sig, publicKey);
    }
    return verifyMultisig(toBeSigned, this.msig, publicKey);
  }
  /**
   * Compute hash of the logic sig program (that is the same as escrow account address) as string address
   * @returns String representation of the address
   */
  address() {
    const toBeSigned = concatArrays(this.tag, this.logic);
    const hash = genericHash(toBeSigned);
    return encodeAddress(new Uint8Array(hash));
  }
  /**
   * Creates signature (if no msig provided) or multi signature otherwise
   * @param secretKey - Secret key to sign with
   * @param msig - Multisig account as \{version, threshold, addrs\}
   */
  sign(secretKey, msig) {
    if (msig == null) {
      this.sig = this.signProgram(secretKey);
    } else {
      const subsigs = msig.addrs.map((addr) => ({
        pk: decodeAddress(addr).publicKey
      }));
      this.msig = {
        v: msig.version,
        thr: msig.threshold,
        subsig: subsigs
      };
      const [sig, index2] = this.singleSignMultisig(secretKey, this.msig);
      this.msig.subsig[index2].s = sig;
    }
  }
  /**
   * Appends a signature to multi signature
   * @param secretKey - Secret key to sign with
   */
  appendToMultisig(secretKey) {
    if (this.msig === void 0) {
      throw new Error("no multisig present");
    }
    const [sig, index2] = this.singleSignMultisig(secretKey, this.msig);
    this.msig.subsig[index2].s = sig;
  }
  signProgram(secretKey) {
    const toBeSigned = concatArrays(this.tag, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  singleSignMultisig(secretKey, msig) {
    let index2 = -1;
    const myPk = keyPairFromSecretKey(secretKey).publicKey;
    for (let i = 0; i < msig.subsig.length; i++) {
      const { pk } = msig.subsig[i];
      if (arrayEqual(pk, myPk)) {
        index2 = i;
        break;
      }
    }
    if (index2 === -1) {
      throw new Error("invalid secret key");
    }
    const sig = this.signProgram(secretKey);
    return [sig, index2];
  }
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
  static fromByte(encoded) {
    const decodedObj = decode$1(encoded);
    return LogicSig.from_obj_for_encoding(decodedObj);
  }
}
class LogicSigAccount {
  /**
   * Create a new LogicSigAccount. By default this will create an escrow
   * LogicSig account. Call `sign` or `signMultisig` on the newly created
   * LogicSigAccount to make it a delegated account.
   *
   * @param program - The compiled TEAL program which contains the logic for
   *   this LogicSig.
   * @param args - An optional array of arguments for the program.
   */
  constructor(program, args) {
    this.lsig = new LogicSig(program, args);
    this.sigkey = void 0;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const obj = {
      lsig: this.lsig.get_obj_for_encoding()
    };
    if (this.sigkey) {
      obj.sigkey = this.sigkey;
    }
    return obj;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(encoded) {
    const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);
    lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);
    lsigAccount.sigkey = encoded.sigkey;
    return lsigAccount;
  }
  /**
   * Encode this object into msgpack.
   */
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
  /**
   * Decode a msgpack object into a LogicSigAccount.
   * @param encoded - The encoded LogicSigAccount.
   */
  static fromByte(encoded) {
    const decodedObj = decode$1(encoded);
    return LogicSigAccount.from_obj_for_encoding(decodedObj);
  }
  /**
   * Check if this LogicSigAccount has been delegated to another account with a
   * signature.
   *
   * Note this function only checks for the presence of a delegation signature.
   * To verify the delegation signature, use `verify`.
   */
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig);
  }
  /**
   * Verifies this LogicSig's program and signatures.
   * @returns true if and only if the LogicSig program and signatures are valid.
   */
  verify() {
    const addr = this.address();
    return this.lsig.verify(decodeAddress(addr).publicKey);
  }
  /**
   * Get the address of this LogicSigAccount.
   *
   * If the LogicSig is delegated to another account, this will return the
   * address of that account.
   *
   * If the LogicSig is not delegated to another account, this will return an
   *  escrow address that is the hash of the LogicSig's program code.
   */
  address() {
    if (this.lsig.sig && this.lsig.msig) {
      throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
    }
    if (this.lsig.sig) {
      if (!this.sigkey) {
        throw new Error("Signing key for delegated account is missing");
      }
      return encodeAddress(this.sigkey);
    }
    if (this.lsig.msig) {
      const msigMetadata = {
        version: this.lsig.msig.v,
        threshold: this.lsig.msig.thr,
        pks: this.lsig.msig.subsig.map((subsig) => subsig.pk)
      };
      return encodeAddress(fromMultisigPreImg(msigMetadata));
    }
    return this.lsig.address();
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. Use this function if the delegating account is a
   * multisig account.
   *
   * @param msig - The multisig delegating account
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account. Use `appendToMultisig` to add additional signatures
   *   from other members.
   */
  signMultisig(msig, secretKey) {
    this.lsig.sign(secretKey, msig);
  }
  /**
   * Adds an additional signature from a member of the delegating multisig
   * account.
   *
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account.
   */
  appendToMultisig(secretKey) {
    this.lsig.appendToMultisig(secretKey);
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. If the delegating account is a multisig account,
   * use `signMultisig` instead.
   *
   * @param secretKey - The secret key of the delegating account.
   */
  sign(secretKey) {
    this.lsig.sign(secretKey);
    this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
  }
}
function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
  if (!lsig.verify(lsigAddress)) {
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  }
  const signedTxn = {
    lsig: lsig.get_obj_for_encoding(),
    txn: txn.get_obj_for_encoding()
  };
  if (!bytesEqual(lsigAddress, txn.from.publicKey)) {
    signedTxn.sgnr = buffer.Buffer.from(lsigAddress);
  }
  return {
    txID: txn.txID().toString(),
    blob: encode(signedTxn)
  };
}
function signLogicSigTransactionObject(txn, lsigObject) {
  let lsig;
  let lsigAddress;
  if (lsigObject instanceof LogicSigAccount) {
    lsig = lsigObject.lsig;
    lsigAddress = decodeAddress(lsigObject.address()).publicKey;
  } else {
    lsig = lsigObject;
    if (lsig.sig) {
      lsigAddress = txn.from.publicKey;
    } else if (lsig.msig) {
      const msigMetadata = {
        version: lsig.msig.v,
        threshold: lsig.msig.thr,
        pks: lsig.msig.subsig.map((subsig) => subsig.pk)
      };
      lsigAddress = fromMultisigPreImg(msigMetadata);
    } else {
      lsigAddress = decodeAddress(lsig.address()).publicKey;
    }
  }
  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
}
function signLogicSigTransaction(txn, lsigObject) {
  const algoTxn = instantiateTxnIfNeeded(txn);
  return signLogicSigTransactionObject(algoTxn, lsigObject);
}
function logicSigFromByte(encoded) {
  return LogicSig.fromByte(encoded);
}
const SIGN_PROGRAM_DATA_PREFIX = buffer.Buffer.from("ProgData");
function tealSign(sk, data, programHash) {
  const parts = concatArrays(decodeAddress(programHash).publicKey, data);
  const toBeSigned = buffer.Buffer.from(concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));
  return sign(toBeSigned, sk);
}
function verifyTealSign(data, programHash, sig, pk) {
  const parts = concatArrays(decodeAddress(programHash).publicKey, data);
  const toBeSigned = buffer.Buffer.from(concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));
  return verify(toBeSigned, sig, pk);
}
function tealSignFromProgram(sk, data, program) {
  const lsig = new LogicSig(program);
  const contractAddress = lsig.address();
  return tealSign(sk, data, contractAddress);
}
let char_to_integer = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i) {
  char_to_integer[char] = i;
});
function decode(string) {
  let result = [];
  let shift2 = 0;
  let value = 0;
  for (let i = 0; i < string.length; i += 1) {
    let integer = char_to_integer[string[i]];
    if (integer === void 0) {
      throw new Error("Invalid character (" + string[i] + ")");
    }
    const has_continuation_bit = integer & 32;
    integer &= 31;
    value += integer << shift2;
    if (has_continuation_bit) {
      shift2 += 5;
    } else {
      const should_negate = value & 1;
      value >>>= 1;
      if (should_negate) {
        result.push(value === 0 ? -2147483648 : -value);
      } else {
        result.push(value);
      }
      value = shift2 = 0;
    }
  }
  return result;
}
class SourceMap {
  constructor({ version: version2, sources, names, mappings }) {
    this.version = version2;
    this.sources = sources;
    this.names = names;
    this.mappings = mappings;
    if (this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    const pcList = this.mappings.split(";").map((m2) => {
      const decoded = decode(m2);
      if (decoded.length > 2)
        return decoded[2];
      return void 0;
    });
    this.pcToLine = {};
    this.lineToPc = {};
    let lastLine = 0;
    for (const [pc2, lineDelta] of pcList.entries()) {
      if (lineDelta !== void 0) {
        lastLine += lineDelta;
      }
      if (!(lastLine in this.lineToPc))
        this.lineToPc[lastLine] = [];
      this.lineToPc[lastLine].push(pc2);
      this.pcToLine[pc2] = lastLine;
    }
  }
  getLineForPc(pc2) {
    return this.pcToLine[pc2];
  }
  getPcsForLine(line) {
    return this.lineToPc[line];
  }
}
const defaultAppId = 1380011588;
const defaultMaxWidth = 30;
function decodePrograms(ap2) {
  ap2.params["approval-program"] = buffer.Buffer.from(ap2.params["approval-program"].toString(), "base64");
  ap2.params["clear-state-program"] = buffer.Buffer.from(ap2.params["clear-state-program"].toString(), "base64");
  return ap2;
}
async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
  const appInfos = [];
  const acctInfos = [];
  const apps = [];
  const assets = [];
  const accts = [];
  for (const t of txns) {
    if (t.txn.type === TransactionType.appl) {
      accts.push(encodeAddress(t.txn.from.publicKey));
      if (t.txn.appAccounts)
        accts.push(...t.txn.appAccounts.map((a) => encodeAddress(a.publicKey)));
      if (t.txn.appForeignApps) {
        apps.push(...t.txn.appForeignApps);
        accts.push(...t.txn.appForeignApps.map((aidx) => getApplicationAddress(aidx)));
      }
      if (t.txn.appForeignAssets)
        assets.push(...t.txn.appForeignAssets);
      if (t.txn.appIndex === void 0 || t.txn.appIndex === 0) {
        appInfos.push(new Application$1({
          id: defaultAppId,
          params: new ApplicationParams$1({
            creator: encodeAddress(t.txn.from.publicKey),
            approvalProgram: t.txn.appApprovalProgram,
            clearStateProgram: t.txn.appClearProgram,
            localStateSchema: new ApplicationStateSchema$1({
              numUint: t.txn.appLocalInts,
              numByteSlice: t.txn.appLocalByteSlices
            }),
            globalStateSchema: new ApplicationStateSchema$1({
              numUint: t.txn.appGlobalInts,
              numByteSlice: t.txn.appGlobalByteSlices
            })
          })
        }));
      } else {
        apps.push(t.txn.appIndex);
        accts.push(getApplicationAddress(t.txn.appIndex));
      }
    }
  }
  const assetPromises = [];
  for (const assetId of [...new Set(assets)]) {
    assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
      accts.push(assetInfo.params.creator);
    }));
  }
  await Promise.all(assetPromises);
  const appPromises = [];
  for (const appId of [...new Set(apps)]) {
    appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
      const ai2 = decodePrograms(appInfo);
      appInfos.push(ai2);
      accts.push(ai2.params.creator);
    }));
  }
  await Promise.all(appPromises);
  const acctPromises = [];
  for (const acct of [...new Set(accts)]) {
    acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
      if ("created-apps" in acctInfo) {
        acctInfo["created-apps"] = acctInfo["created-apps"].map((app2) => decodePrograms(app2));
      }
      acctInfos.push(acctInfo);
    }));
  }
  await Promise.all(acctPromises);
  return new DryrunRequest({
    txns: txns.map((st) => ({ ...st, txn: st.txn.get_obj_for_encoding() })),
    accounts: acctInfos,
    apps: appInfos,
    latestTimestamp,
    round,
    protocolVersion,
    sources
  });
}
class DryrunStackValue {
  constructor(sv) {
    this.type = 0;
    this.bytes = "";
    this.uint = 0;
    this.type = sv.type;
    this.bytes = sv.bytes;
    this.uint = sv.uint;
  }
  toString() {
    if (this.type === 1) {
      return `0x${buffer.Buffer.from(this.bytes, "base64").toString("hex")}`;
    }
    return this.uint.toString();
  }
}
class DryrunTraceLine {
  constructor(line) {
    this.error = "";
    this.line = 0;
    this.pc = 0;
    this.scratch = [];
    this.stack = [];
    this.error = line.error === void 0 ? "" : line.error;
    this.line = line.line;
    this.pc = line.pc;
    this.scratch = line.scratch;
    this.stack = line.stack.map((sv) => new DryrunStackValue(sv));
  }
}
class DryrunTrace {
  constructor(t) {
    this.trace = [];
    if (t == null)
      return;
    this.trace = t.map((line) => new DryrunTraceLine(line));
  }
}
function truncate(str, maxValueWidth) {
  if (str.length > maxValueWidth && maxValueWidth > 0) {
    return `${str.slice(0, maxValueWidth)}...`;
  }
  return str;
}
function scratchToString(prevScratch, currScratch) {
  if (currScratch.length === 0)
    return "";
  let newScratchIdx = null;
  for (let idx = 0; idx < currScratch.length; idx++) {
    if (idx > prevScratch.length) {
      newScratchIdx = idx;
      continue;
    }
    if (JSON.stringify(prevScratch[idx]) !== JSON.stringify(currScratch[idx])) {
      newScratchIdx = idx;
    }
  }
  if (newScratchIdx == null)
    return "";
  const newScratch = currScratch[newScratchIdx];
  if (newScratch.bytes.length > 0) {
    return `${newScratchIdx} = 0x${buffer.Buffer.from(newScratch.bytes, "base64").toString("hex")}`;
  }
  return `${newScratchIdx} = ${newScratch.uint.toString()}`;
}
function stackToString(stack, reverse2) {
  const svs = reverse2 ? stack.reverse() : stack;
  return `[${svs.map((sv) => {
    switch (sv.type) {
      case 1:
        return `0x${buffer.Buffer.from(sv.bytes, "base64").toString("hex")}`;
      case 2:
        return `${sv.uint.toString()}`;
      default:
        return "";
    }
  }).join(", ")}]`;
}
class DryrunTransactionResult {
  constructor(dtr) {
    this.disassembly = [];
    this.appCallMessages = [];
    this.localDeltas = [];
    this.globalDelta = [];
    this.cost = 0;
    this.logicSigMessages = [];
    this.logicSigDisassembly = [];
    this.logs = [];
    this.appCallTrace = void 0;
    this.logicSigTrace = void 0;
    this.required = ["disassembly"];
    this.optionals = [
      "app-call-messages",
      "local-deltas",
      "global-delta",
      "cost",
      "logic-sig-messages",
      "logic-sig-disassembly",
      "logs"
    ];
    this.traces = ["app-call-trace", "logic-sig-trace"];
    this.disassembly = dtr.disassembly;
    this.appCallMessages = dtr["app-call-messages"];
    this.localDeltas = dtr["local-deltas"];
    this.globalDelta = dtr["global-delta"];
    this.cost = dtr.cost;
    this.logicSigMessages = dtr["logic-sig-messages"];
    this.logicSigDisassembly = dtr["logic-sig-disassembly"];
    this.logs = dtr.logs;
    this.appCallTrace = new DryrunTrace(dtr["app-call-trace"]);
    this.logicSigTrace = new DryrunTrace(dtr["logic-sig-trace"]);
  }
  appCallRejected() {
    return this.appCallMessages !== void 0 && this.appCallMessages.includes("REJECT");
  }
  logicSigRejected() {
    return this.logicSigMessages !== void 0 && this.logicSigMessages.includes("REJECT");
  }
  static trace(drt, disassembly, spc) {
    const maxWidth = spc.maxValueWidth || defaultMaxWidth;
    const lines = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let idx = 0; idx < drt.trace.length; idx++) {
      const { line, error, pc: pc2, scratch, stack } = drt.trace[idx];
      const currScratch = scratch !== void 0 ? scratch : [];
      const prevScratch = idx > 0 && drt.trace[idx - 1].scratch !== void 0 ? drt.trace[idx - 1].scratch : [];
      const src = error === "" ? disassembly[line] : `!! ${error} !!`;
      lines.push([
        pc2.toString().padEnd(3, " "),
        line.toString().padEnd(3, " "),
        truncate(src, maxWidth),
        truncate(scratchToString(prevScratch, currScratch), maxWidth),
        truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)
      ]);
    }
    const maxLengths = lines.reduce((prev, curr) => {
      const newVal = new Array(lines[0].length).fill(0);
      for (let idx = 0; idx < prev.length; idx++) {
        newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];
      }
      return newVal;
    }, new Array(lines[0].length).fill(0));
    return `${lines.map((line) => line.map((v, idx) => v.padEnd(maxLengths[idx] + 1, " ")).join("|").trim()).join("\n")}
`;
  }
  appTrace(spc) {
    if (this.appCallTrace === void 0 || !this.disassembly)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: false
      };
    return DryrunTransactionResult.trace(this.appCallTrace, this.disassembly, conf);
  }
  lsigTrace(spc) {
    if (this.logicSigTrace === void 0 || this.logicSigDisassembly === void 0)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: true
      };
    return DryrunTransactionResult.trace(this.logicSigTrace, this.logicSigDisassembly, conf);
  }
}
class DryrunResult {
  constructor(drrResp) {
    this.error = "";
    this.protocolVersion = "";
    this.txns = [];
    this.error = drrResp.error;
    this.protocolVersion = drrResp["protocol-version"];
    this.txns = drrResp.txns.map((txn) => new DryrunTransactionResult(txn));
  }
}
function makePaymentTxnWithSuggestedParams(from, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo) {
  const o = {
    from,
    to,
    amount,
    closeRemainderTo,
    note,
    suggestedParams,
    type: TransactionType.pay,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makePaymentTxnWithSuggestedParamsFromObject(o) {
  return makePaymentTxnWithSuggestedParams(o.from, o.to, o.amount, o.closeRemainderTo, o.note, o.suggestedParams, o.rekeyTo);
}
function makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation = false, stateProofKey = void 0) {
  const o = {
    from,
    note,
    voteKey,
    selectionKey,
    voteFirst,
    voteLast,
    voteKeyDilution,
    suggestedParams,
    type: TransactionType.keyreg,
    reKeyTo: rekeyTo,
    nonParticipation,
    stateProofKey
  };
  return new Transaction$1(o);
}
function makeKeyRegistrationTxnWithSuggestedParamsFromObject(o) {
  return makeKeyRegistrationTxnWithSuggestedParams(o.from, o.note, o.voteKey, o.selectionKey, o.voteFirst, o.voteLast, o.voteKeyDilution, o.suggestedParams, o.rekeyTo, o.nonParticipation, o.stateProofKey);
}
function makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo) {
  const o = {
    from,
    note,
    suggestedParams,
    assetTotal: total,
    assetDecimals: decimals,
    assetDefaultFrozen: defaultFrozen,
    assetUnitName: unitName,
    assetName,
    assetURL,
    assetMetadataHash,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetCreateTxnWithSuggestedParamsFromObject(o) {
  return makeAssetCreateTxnWithSuggestedParams(o.from, o.note, o.total, o.decimals, o.defaultFrozen, o.manager, o.reserve, o.freeze, o.clawback, o.unitName, o.assetName, o.assetURL, o.assetMetadataHash, o.suggestedParams, o.rekeyTo);
}
function makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking = true, rekeyTo) {
  if (strictEmptyAddressChecking && (manager === void 0 || reserve === void 0 || freeze === void 0 || clawback === void 0)) {
    throw Error("strict empty address checking was turned on, but at least one empty address was provided");
  }
  const o = {
    from,
    suggestedParams,
    assetIndex,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetConfigTxnWithSuggestedParamsFromObject(o) {
  return makeAssetConfigTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.manager, o.reserve, o.freeze, o.clawback, o.suggestedParams, o.strictEmptyAddressChecking, o.rekeyTo);
}
function makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    from,
    suggestedParams,
    assetIndex,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetDestroyTxnWithSuggestedParamsFromObject(o) {
  return makeAssetDestroyTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo) {
  const o = {
    from,
    type: TransactionType.afrz,
    freezeAccount: freezeTarget,
    assetIndex,
    freezeState,
    note,
    suggestedParams,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetFreezeTxnWithSuggestedParamsFromObject(o) {
  return makeAssetFreezeTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.freezeTarget, o.freezeState, o.suggestedParams, o.rekeyTo);
}
function makeAssetTransferTxnWithSuggestedParams(from, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    type: TransactionType.axfer,
    from,
    to,
    amount,
    suggestedParams,
    assetIndex,
    note,
    assetRevocationTarget: revocationTarget,
    closeRemainderTo,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetTransferTxnWithSuggestedParamsFromObject(o) {
  return makeAssetTransferTxnWithSuggestedParams(o.from, o.to, o.closeRemainderTo, o.revocationTarget, o.amount, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeApplicationCreateTxn(from, suggestedParams, onComplete, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, extraPages, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex: 0,
    appOnComplete: onComplete,
    appLocalInts: numLocalInts,
    appLocalByteSlices: numLocalByteSlices,
    appGlobalInts: numGlobalInts,
    appGlobalByteSlices: numGlobalByteSlices,
    appApprovalProgram: approvalProgram,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo,
    extraPages
  };
  return new Transaction$1(o);
}
function makeApplicationCreateTxnFromObject(o) {
  return makeApplicationCreateTxn(o.from, o.suggestedParams, o.onComplete, o.approvalProgram, o.clearProgram, o.numLocalInts, o.numLocalByteSlices, o.numGlobalInts, o.numGlobalByteSlices, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.extraPages, o.boxes);
}
function makeApplicationUpdateTxn(from, suggestedParams, appIndex, approvalProgram, clearProgram, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appApprovalProgram: approvalProgram,
    appOnComplete: OnApplicationComplete.UpdateApplicationOC,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationUpdateTxnFromObject(o) {
  return makeApplicationUpdateTxn(o.from, o.suggestedParams, o.appIndex, o.approvalProgram, o.clearProgram, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationDeleteTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.DeleteApplicationOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationDeleteTxnFromObject(o) {
  return makeApplicationDeleteTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationOptInTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.OptInOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationOptInTxnFromObject(o) {
  return makeApplicationOptInTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationCloseOutTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.CloseOutOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationCloseOutTxnFromObject(o) {
  return makeApplicationCloseOutTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationClearStateTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.ClearStateOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationClearStateTxnFromObject(o) {
  return makeApplicationClearStateTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationNoOpTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.NoOpOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationNoOpTxnFromObject(o) {
  return makeApplicationNoOpTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationCallTxnFromObject(options) {
  const o = {
    type: TransactionType.appl,
    from: options.from,
    suggestedParams: options.suggestedParams,
    appIndex: options.appIndex,
    appOnComplete: options.onComplete,
    appLocalInts: options.numLocalInts,
    appLocalByteSlices: options.numLocalByteSlices,
    appGlobalInts: options.numGlobalInts,
    appGlobalByteSlices: options.numGlobalByteSlices,
    appApprovalProgram: options.approvalProgram,
    appClearProgram: options.clearProgram,
    appArgs: options.appArgs,
    appAccounts: options.accounts,
    appForeignApps: options.foreignApps,
    appForeignAssets: options.foreignAssets,
    boxes: options.boxes,
    note: options.note,
    lease: options.lease,
    reKeyTo: options.rekeyTo,
    extraPages: options.extraPages
  };
  return new Transaction$1(o);
}
function makeBasicAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      signed.push(txnGroup[index2].signTxn(account.sk));
    }
    return Promise.resolve(signed);
  };
}
function makeLogicSigAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      const { blob } = signLogicSigTransactionObject(txnGroup[index2], account);
      signed.push(blob);
    }
    return Promise.resolve(signed);
  };
}
function makeMultiSigAccountTransactionSigner(msig, sks) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      const txn = txnGroup[index2];
      const partialSigs = [];
      for (const sk of sks) {
        const { blob } = signMultisigTransaction(txn, msig, sk);
        partialSigs.push(blob);
      }
      signed.push(mergeMultisigTransactions(partialSigs));
    }
    return Promise.resolve(signed);
  };
}
function makeEmptyTransactionSigner() {
  return (txnGroup, indexesToSign) => {
    const unsigned = [];
    for (const index2 of indexesToSign) {
      unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index2]));
    }
    return Promise.resolve(unsigned);
  };
}
function isTransactionWithSigner(value) {
  return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
}
const MAX_LEN = 2 ** 16 - 1;
const ADDR_BYTE_SIZE = 32;
const SINGLE_BYTE_SIZE = 1;
const SINGLE_BOOL_SIZE = 1;
const LENGTH_ENCODE_BYTE_SIZE = 2;
const staticArrayRegexp = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/;
const ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
class ABIType {
  // De-serializes the ABI type from a string using the ABI specs
  static from(str) {
    if (str.endsWith("[]")) {
      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));
      return new ABIArrayDynamicType(arrayArgType);
    }
    if (str.endsWith("]")) {
      const stringMatches = str.match(staticArrayRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed static array string: ${str}`);
      }
      const arrayLengthStr = stringMatches[2];
      const arrayLength = parseInt(arrayLengthStr, 10);
      if (arrayLength > MAX_LEN) {
        throw new Error(`array length exceeds limit ${MAX_LEN}`);
      }
      const arrayType = ABIType.from(stringMatches[1]);
      return new ABIArrayStaticType(arrayType, arrayLength);
    }
    if (str.startsWith("uint")) {
      const digitsOnly = (string) => [...string].every((c) => "0123456789".includes(c));
      const typeSizeStr = str.slice(4, str.length);
      if (!digitsOnly(typeSizeStr)) {
        throw new Error(`malformed uint string: ${typeSizeStr}`);
      }
      const typeSize = parseInt(typeSizeStr, 10);
      if (typeSize > MAX_LEN) {
        throw new Error(`malformed uint string: ${typeSize}`);
      }
      return new ABIUintType(typeSize);
    }
    if (str === "byte") {
      return new ABIByteType();
    }
    if (str.startsWith("ufixed")) {
      const stringMatches = str.match(ufixedRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed ufixed type: ${str}`);
      }
      const ufixedSize = parseInt(stringMatches[1], 10);
      const ufixedPrecision = parseInt(stringMatches[2], 10);
      return new ABIUfixedType(ufixedSize, ufixedPrecision);
    }
    if (str === "bool") {
      return new ABIBoolType();
    }
    if (str === "address") {
      return new ABIAddressType();
    }
    if (str === "string") {
      return new ABIStringType();
    }
    if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
      const tupleTypes = [];
      for (let i = 0; i < tupleContent.length; i++) {
        const ti2 = ABIType.from(tupleContent[i]);
        tupleTypes.push(ti2);
      }
      return new ABITupleType(tupleTypes);
    }
    throw new Error(`cannot convert a string ${str} to an ABI type`);
  }
}
class ABIUintType extends ABIType {
  constructor(size2) {
    super();
    if (size2 % 8 !== 0 || size2 < 8 || size2 > 512) {
      throw new Error(`unsupported uint type bitSize: ${size2}`);
    }
    this.bitSize = size2;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(other) {
    return other instanceof ABIUintType && this.bitSize === other.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    }
    return bytesToBigInt(byteString);
  }
}
class ABIUfixedType extends ABIType {
  constructor(size2, denominator) {
    super();
    if (size2 % 8 !== 0 || size2 < 8 || size2 > 512) {
      throw new Error(`unsupported ufixed type bitSize: ${size2}`);
    }
    if (denominator > 160 || denominator < 1) {
      throw new Error(`unsupported ufixed type precision: ${denominator}`);
    }
    this.bitSize = size2;
    this.precision = denominator;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(other) {
    return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    }
    return bytesToBigInt(byteString);
  }
}
class ABIAddressType extends ABIType {
  toString() {
    return "address";
  }
  equals(other) {
    return other instanceof ABIAddressType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return ADDR_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (typeof value === "string") {
      const decodedAddress = decodeAddress(value);
      return decodedAddress.publicKey;
    }
    if (value.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return value;
  }
  decode(byteString) {
    if (byteString.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return encodeAddress(byteString);
  }
}
class ABIBoolType extends ABIType {
  toString() {
    return "bool";
  }
  equals(other) {
    return other instanceof ABIBoolType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BOOL_SIZE;
  }
  encode(value) {
    if (typeof value !== "boolean") {
      throw new Error(`Cannot encode value as bool: ${value}`);
    }
    if (value) {
      return new Uint8Array([128]);
    }
    return new Uint8Array([0]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`bool string must be 1 byte long`);
    }
    const value = byteString[0];
    if (value === 128) {
      return true;
    }
    if (value === 0) {
      return false;
    }
    throw new Error(`boolean could not be decoded from the byte string`);
  }
}
class ABIByteType extends ABIType {
  toString() {
    return "byte";
  }
  equals(other) {
    return other instanceof ABIByteType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "number" && typeof value !== "bigint") {
      throw new Error(`Cannot encode value as byte: ${value}`);
    }
    if (typeof value === "bigint") {
      value = Number(value);
    }
    if (value < 0 || value > 255) {
      throw new Error(`${value} cannot be encoded into a byte`);
    }
    return new Uint8Array([value]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`byte string must be 1 byte long`);
    }
    return byteString[0];
  }
}
class ABIStringType extends ABIType {
  toString() {
    return "string";
  }
  equals(other) {
    return other instanceof ABIStringType;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as string: ${value}`);
    }
    const encodedBytes = buffer.Buffer.from(value);
    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);
    mergedBytes.set(encodedLength);
    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
    return mergedBytes;
  }
  decode(byteString) {
    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
    }
    const buf = buffer.Buffer.from(byteString);
    const byteLength2 = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
    if (byteLength2 !== byteValue.length) {
      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength2}, got ${byteValue.length}`);
    }
    return buffer.Buffer.from(byteValue).toString("utf-8");
  }
}
class ABIArrayStaticType extends ABIType {
  constructor(argType, arrayLength) {
    super();
    if (arrayLength < 0) {
      throw new Error(`static array must have a non negative length: ${arrayLength}`);
    }
    this.childType = argType;
    this.staticLength = arrayLength;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(other) {
    return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    if (this.childType.constructor === ABIBoolType) {
      return Math.ceil(this.staticLength / 8);
    }
    return this.staticLength * this.childType.byteLen();
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value.length !== this.staticLength) {
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
    }
    const convertedTuple = this.toABITupleType();
    return convertedTuple.encode(value);
  }
  decode(byteString) {
    const convertedTuple = this.toABITupleType();
    return convertedTuple.decode(byteString);
  }
  toABITupleType() {
    return new ABITupleType(Array(this.staticLength).fill(this.childType));
  }
}
class ABIArrayDynamicType extends ABIType {
  constructor(argType) {
    super();
    this.childType = argType;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(other) {
    return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const convertedTuple = this.toABITupleType(value.length);
    const encodedTuple = convertedTuple.encode(value);
    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = concatArrays(encodedLength, encodedTuple);
    return mergedBytes;
  }
  decode(byteString) {
    const buf = buffer.Buffer.from(byteString);
    const byteLength2 = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const convertedTuple = this.toABITupleType(byteLength2);
    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
  }
  toABITupleType(length) {
    return new ABITupleType(Array(length).fill(this.childType));
  }
}
class ABITupleType extends ABIType {
  constructor(argTypes) {
    super();
    if (argTypes.length >= MAX_LEN) {
      throw new Error("tuple type child type number larger than maximum uint16 error");
    }
    this.childTypes = argTypes;
  }
  toString() {
    const typeStrings = [];
    for (let i = 0; i < this.childTypes.length; i++) {
      typeStrings[i] = this.childTypes[i].toString();
    }
    return `(${typeStrings.join(",")})`;
  }
  equals(other) {
    return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index2) => child.equals(other.childTypes[index2]));
  }
  isDynamic() {
    const isDynamic = (child) => child.isDynamic();
    return this.childTypes.some(isDynamic);
  }
  byteLen() {
    let size2 = 0;
    for (let i = 0; i < this.childTypes.length; i++) {
      if (this.childTypes[i].constructor === ABIBoolType) {
        const after = findBoolLR(this.childTypes, i, 1);
        const boolNum = after + 1;
        i += after;
        size2 += Math.trunc((boolNum + 7) / 8);
      } else {
        const childByteSize = this.childTypes[i].byteLen();
        size2 += childByteSize;
      }
    }
    return size2;
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const values = Array.from(value);
    if (value.length > MAX_LEN) {
      throw new Error("length of tuple array should not exceed a uint16");
    }
    const tupleTypes = this.childTypes;
    const heads = [];
    const tails = [];
    const isDynamicIndex = /* @__PURE__ */ new Map();
    let i = 0;
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        isDynamicIndex.set(heads.length, true);
        heads.push(new Uint8Array([0, 0]));
        tails.push(tupleType.encode(values[i]));
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(tupleTypes, i, -1);
          let after = findBoolLR(tupleTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          }
          after = Math.min(7, after);
          const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));
          heads.push(bigIntToBytes(compressedInt, 1));
          i += after;
        } else {
          const encodedTupleValue = tupleType.encode(values[i]);
          heads.push(encodedTupleValue);
        }
        isDynamicIndex.set(i, false);
        tails.push(new Uint8Array());
      }
      i += 1;
    }
    let headLength = 0;
    for (const headElement of heads) {
      headLength += headElement.length;
    }
    let tailLength = 0;
    for (let j2 = 0; j2 < heads.length; j2++) {
      if (isDynamicIndex.get(j2)) {
        const headValue = headLength + tailLength;
        if (headValue > MAX_LEN) {
          throw new Error(`byte length of ${headValue} should not exceed a uint16`);
        }
        heads[j2] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
      }
      tailLength += tails[j2].length;
    }
    return concatArrays(...heads, ...tails);
  }
  decode(byteString) {
    const tupleTypes = this.childTypes;
    const dynamicSegments = [];
    const valuePartition = [];
    let i = 0;
    let iterIndex = 0;
    const buf = buffer.Buffer.from(byteString);
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
          throw new Error("dynamic type in tuple is too short to be decoded");
        }
        const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);
        if (dynamicSegments.length > 0) {
          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
            throw new Error("dynamic index segment miscalculation: left is greater than right index");
          }
        }
        const seg = {
          left: dynamicIndex,
          right: -1
        };
        dynamicSegments.push(seg);
        valuePartition.push(null);
        iterIndex += LENGTH_ENCODE_BYTE_SIZE;
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(this.childTypes, i, -1);
          let after = findBoolLR(this.childTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before bool number mod 8 === 0");
          }
          after = Math.min(7, after);
          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
            const boolMask = 128 >> boolIndex;
            if ((byteString[iterIndex] & boolMask) > 0) {
              valuePartition.push(new Uint8Array([128]));
            } else {
              valuePartition.push(new Uint8Array([0]));
            }
          }
          i += after;
          iterIndex += 1;
        } else {
          const currLen = tupleType.byteLen();
          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
          iterIndex += currLen;
        }
      }
      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
        throw new Error("input byte not enough to decode");
      }
      i += 1;
    }
    if (dynamicSegments.length > 0) {
      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
      iterIndex = byteString.length;
    }
    if (iterIndex < byteString.length) {
      throw new Error("input byte not fully consumed");
    }
    for (let j2 = 0; j2 < dynamicSegments.length; j2++) {
      const seg = dynamicSegments[j2];
      if (seg.left > seg.right) {
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      }
      if (j2 !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j2 + 1].left) {
        throw new Error("dynamic segment should be consecutive");
      }
    }
    let segIndex = 0;
    for (let j2 = 0; j2 < tupleTypes.length; j2++) {
      if (tupleTypes[j2].isDynamic()) {
        valuePartition[j2] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
        segIndex += 1;
      }
    }
    const returnValues = [];
    for (let j2 = 0; j2 < tupleTypes.length; j2++) {
      const valueTi = tupleTypes[j2].decode(valuePartition[j2]);
      returnValues.push(valueTi);
    }
    return returnValues;
  }
  static parseTupleContent(str) {
    if (str.length === 0) {
      return [];
    }
    if (str.endsWith(",") || str.startsWith(",")) {
      throw new Error("tuple string should not start with comma");
    }
    if (str.includes(",,")) {
      throw new Error("tuple string should not have consecutive commas");
    }
    const tupleStrings = [];
    let depth = 0;
    let word = "";
    for (const char of str) {
      word += char;
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        depth -= 1;
      } else if (char === ",") {
        if (depth === 0) {
          tupleStrings.push(word.slice(0, word.length - 1));
          word = "";
        }
      }
    }
    if (word.length !== 0) {
      tupleStrings.push(word);
    }
    if (depth !== 0) {
      throw new Error("tuple string has mismatched parentheses");
    }
    return tupleStrings;
  }
}
function compressMultipleBool(valueList) {
  let res = 0;
  if (valueList.length > 8) {
    throw new Error("value list passed in should be no greater than length 8");
  }
  for (let i = 0; i < valueList.length; i++) {
    const boolVal = valueList[i];
    if (typeof boolVal !== "boolean") {
      throw new Error("non-boolean values cannot be compressed into a byte");
    }
    if (boolVal) {
      res |= 1 << 7 - i;
    }
  }
  return res;
}
function findBoolLR(typeList, index2, delta) {
  let until = 0;
  while (true) {
    const curr = index2 + delta * until;
    if (typeList[curr].constructor === ABIBoolType) {
      if (curr !== typeList.length - 1 && delta === 1) {
        until += 1;
      } else if (curr > 0 && delta === -1) {
        until += 1;
      } else {
        break;
      }
    } else {
      until -= 1;
      break;
    }
  }
  return until;
}
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
function abiTypeIsTransaction(type) {
  return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
}
function abiCheckTransactionType(type, txn) {
  if (type === ABITransactionType.any) {
    return true;
  }
  return txn.type && txn.type.toString() === type.toString();
}
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
function abiTypeIsReference(type) {
  return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
}
function parseMethodSignature(signature) {
  const argsStart = signature.indexOf("(");
  if (argsStart === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  let argsEnd = -1;
  let depth = 0;
  for (let i = argsStart; i < signature.length; i++) {
    const char = signature[i];
    if (char === "(") {
      depth += 1;
    } else if (char === ")") {
      if (depth === 0) {
        break;
      }
      depth -= 1;
      if (depth === 0) {
        argsEnd = i;
        break;
      }
    }
  }
  if (argsEnd === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  return {
    name: signature.slice(0, argsStart),
    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
    returns: signature.slice(argsEnd + 1)
  };
}
class ABIMethod {
  constructor(params) {
    if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
      throw new Error("Invalid ABIMethod parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.args = params.args.map(({ type, name, desc }) => {
      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
        return {
          type,
          name,
          description: desc
        };
      }
      return {
        type: ABIType.from(type),
        name,
        description: desc
      };
    });
    this.returns = {
      type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
      description: params.returns.desc
    };
  }
  getSignature() {
    const args = this.args.map((arg) => arg.type.toString()).join(",");
    const returns = this.returns.type.toString();
    return `${this.name}(${args})${returns}`;
  }
  getSelector() {
    const hash = genericHash(this.getSignature());
    return new Uint8Array(hash.slice(0, 4));
  }
  txnCount() {
    let count = 1;
    for (const arg of this.args) {
      if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
        count += 1;
      }
    }
    return count;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      args: this.args.map(({ type, name, description }) => ({
        type: type.toString(),
        name,
        desc: description
      })),
      returns: {
        type: this.returns.type.toString(),
        desc: this.returns.description
      }
    };
  }
  static fromSignature(signature) {
    const { name, args, returns } = parseMethodSignature(signature);
    return new ABIMethod({
      name,
      args: args.map((arg) => ({ type: arg })),
      returns: { type: returns }
    });
  }
}
function getMethodByName(methods, name) {
  if (methods === null || !Array.isArray(methods) || !methods.every((item) => item instanceof ABIMethod))
    throw new Error("Methods list provided is null or not the correct type");
  const filteredMethods = methods.filter((m2) => m2.name === name);
  if (filteredMethods.length > 1)
    throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map((m2) => m2.getSignature()).join(",")}`);
  if (filteredMethods.length === 0)
    throw new Error(`found 0 methods with the name ${name}`);
  return filteredMethods[0];
}
class ABIContract {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
      throw new Error("Invalid ABIContract parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.networks = params.networks ? { ...params.networks } : {};
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      networks: this.networks,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
}
class ABIInterface {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
      throw new Error("Invalid ABIInterface parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
}
const RETURN_PREFIX = buffer.Buffer.from([21, 31, 124, 117]);
const MAX_APP_ARGS = 16;
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
function populateForeignArray(valueToAdd, array2, zeroValue) {
  if (zeroValue != null && valueToAdd === zeroValue) {
    return 0;
  }
  const offset = zeroValue == null ? 0 : 1;
  for (let i = 0; i < array2.length; i++) {
    if (valueToAdd === array2[i]) {
      return i + offset;
    }
  }
  array2.push(valueToAdd);
  return array2.length - 1 + offset;
}
class AtomicTransactionComposer {
  constructor() {
    this.status = AtomicTransactionComposerStatus.BUILDING;
    this.transactions = [];
    this.methodCalls = /* @__PURE__ */ new Map();
    this.signedTxns = [];
    this.txIDs = [];
  }
  /**
   * Get the status of this composer's transaction group.
   */
  getStatus() {
    return this.status;
  }
  /**
   * Get the number of transactions currently in this atomic group.
   */
  count() {
    return this.transactions.length;
  }
  /**
   * Create a new composer with the same underlying transactions. The new composer's status will be
   * BUILDING, so additional transactions may be added to it.
   */
  clone() {
    const theClone = new AtomicTransactionComposer();
    theClone.transactions = this.transactions.map(({ txn, signer }) => ({
      // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)
      txn: Transaction$1.from_obj_for_encoding({
        ...txn.get_obj_for_encoding(),
        // erase the group ID
        grp: void 0
      }),
      signer
    }));
    theClone.methodCalls = new Map(this.methodCalls);
    return theClone;
  }
  /**
   * Add a transaction to this atomic group.
   *
   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is
   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.
   */
  addTransaction(txnAndSigner) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {
      throw new Error("Cannot add a transaction with nonzero group ID");
    }
    this.transactions.push(txnAndSigner);
  }
  /**
   * Add a smart contract method call to this atomic group.
   *
   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction
   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid
   * for the given method.
   */
  addMethodCall({ appID, method, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, appAccounts, appForeignApps, appForeignAssets, boxes, note, lease, rekeyTo, signer }) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (appID === 0) {
      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
      }
    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
      if (approvalProgram == null || clearProgram == null) {
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      }
      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
      }
    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    }
    if (methodArgs == null) {
      methodArgs = [];
    }
    if (methodArgs.length !== method.args.length) {
      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);
    }
    let basicArgTypes = [];
    let basicArgValues = [];
    const txnArgs = [];
    const refArgTypes = [];
    const refArgValues = [];
    const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
    const boxReferences = !boxes ? [] : boxes;
    for (let i = 0; i < methodArgs.length; i++) {
      let argType = method.args[i].type;
      const argValue = methodArgs[i];
      if (abiTypeIsTransaction(argType)) {
        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
          throw new Error(`Expected ${argType} TransactionWithSigner for argument at index ${i}`);
        }
        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {
          throw new Error("Cannot add a transaction with nonzero group ID");
        }
        txnArgs.push(argValue);
        continue;
      }
      if (isTransactionWithSigner(argValue)) {
        throw new Error(`Expected non-transaction value for argument at index ${i}`);
      }
      if (abiTypeIsReference(argType)) {
        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
        refArgTypes.push(argType);
        refArgValues.push(argValue);
        argType = new ABIUintType(8);
      }
      if (typeof argType === "string") {
        throw new Error(`Unknown ABI type: ${argType}`);
      }
      basicArgTypes.push(argType);
      basicArgValues.push(argValue);
    }
    const resolvedRefIndexes = [];
    const foreignAccounts = appAccounts == null ? [] : appAccounts.slice();
    const foreignApps = appForeignApps == null ? [] : appForeignApps.slice();
    const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.slice();
    for (let i = 0; i < refArgTypes.length; i++) {
      const refType = refArgTypes[i];
      const refValue = refArgValues[i];
      let resolved = 0;
      switch (refType) {
        case ABIReferenceType.account: {
          const addressType = new ABIAddressType();
          const address = addressType.decode(addressType.encode(refValue));
          resolved = populateForeignArray(address, foreignAccounts, sender);
          break;
        }
        case ABIReferenceType.application: {
          const uint64Type = new ABIUintType(64);
          const refAppID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAppID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for application value, got ${refAppID}`);
          }
          resolved = populateForeignArray(Number(refAppID), foreignApps, appID);
          break;
        }
        case ABIReferenceType.asset: {
          const uint64Type = new ABIUintType(64);
          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAssetID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
          }
          resolved = populateForeignArray(Number(refAssetID), foreignAssets);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${refType}`);
      }
      resolvedRefIndexes.push(resolved);
    }
    for (let i = 0; i < resolvedRefIndexes.length; i++) {
      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);
      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];
    }
    if (basicArgTypes.length > MAX_APP_ARGS - 1) {
      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
      basicArgValues.push(lastArgTupleValues);
    }
    const appArgsEncoded = [method.getSelector()];
    for (let i = 0; i < basicArgTypes.length; i++) {
      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));
    }
    const appCall = {
      txn: makeApplicationCallTxnFromObject({
        from: sender,
        appIndex: appID,
        appArgs: appArgsEncoded,
        accounts: foreignAccounts,
        foreignApps,
        foreignAssets,
        boxes: boxReferences,
        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
        approvalProgram,
        clearProgram,
        numGlobalInts,
        numGlobalByteSlices,
        numLocalInts,
        numLocalByteSlices,
        extraPages,
        lease,
        note,
        rekeyTo,
        suggestedParams
      }),
      signer
    };
    this.transactions.push(...txnArgs, appCall);
    this.methodCalls.set(this.transactions.length - 1, method);
  }
  /**
   * Finalize the transaction group and returned the finalized transactions.
   *
   * The composer's status will be at least BUILT after executing this method.
   */
  buildGroup() {
    if (this.status === AtomicTransactionComposerStatus.BUILDING) {
      if (this.transactions.length === 0) {
        throw new Error("Cannot build a group with 0 transactions");
      }
      if (this.transactions.length > 1) {
        assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
      }
      this.status = AtomicTransactionComposerStatus.BUILT;
    }
    return this.transactions;
  }
  /**
   * Obtain signatures for each transaction in this group. If signatures have already been obtained,
   * this method will return cached versions of the signatures.
   *
   * The composer's status will be at least SIGNED after executing this method.
   *
   * An error will be thrown if signing any of the transactions fails.
   *
   * @returns A promise that resolves to an array of signed transactions.
   */
  async gatherSignatures() {
    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
      return this.signedTxns;
    }
    const txnsWithSigners = this.buildGroup();
    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
    const indexesPerSigner = /* @__PURE__ */ new Map();
    for (let i = 0; i < txnsWithSigners.length; i++) {
      const { signer } = txnsWithSigners[i];
      if (!indexesPerSigner.has(signer)) {
        indexesPerSigner.set(signer, []);
      }
      indexesPerSigner.get(signer).push(i);
    }
    const orderedSigners = Array.from(indexesPerSigner);
    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
    const signedTxns = txnsWithSigners.map(() => null);
    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
      const indexes = orderedSigners[signerIndex][1];
      const sigs = batchedSigs[signerIndex];
      for (let i = 0; i < indexes.length; i++) {
        signedTxns[indexes[i]] = sigs[i];
      }
    }
    if (!signedTxns.every((sig) => sig != null)) {
      throw new Error(`Missing signatures. Got ${signedTxns}`);
    }
    const txIDs = signedTxns.map((stxn, index2) => {
      try {
        return decodeSignedTransaction(stxn).txn.txID();
      } catch (err) {
        throw new Error(`Cannot decode signed transaction at index ${index2}. ${err}`);
      }
    });
    this.signedTxns = signedTxns;
    this.txIDs = txIDs;
    this.status = AtomicTransactionComposerStatus.SIGNED;
    return signedTxns;
  }
  /**
   * Send the transaction group to the network, but don't wait for it to be committed to a block. An
   * error will be thrown if submission fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method. If submission is
   * successful, this composer's status will update to SUBMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   *
   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.
   */
  async submit(client) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Transaction group cannot be resubmitted");
    }
    const stxns = await this.gatherSignatures();
    await client.sendRawTransaction(stxns).do();
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    return this.txIDs;
  }
  /**
   * Simulates the transaction group in the network.
   *
   * The composer will try to sign any transactions in the group, then simulate
   * the results.
   * Simulating the group will not change the composer's status.
   *
   * @param client - An Algodv2 client
   * @param request - SimulateRequest with options in simulation.
   *   If provided, the request's transaction group will be overrwritten by the composer's group,
   *   only simulation related options will be used.
   *
   * @returns A promise that, upon success, resolves to an object containing an
   *   array of results containing one element for each method call transaction
   *   in this group (ABIResult[]) and the SimulateResponse object.
   */
  async simulate(client, request) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Simulated Transaction group has already been submitted to the network");
    }
    const stxns = await this.gatherSignatures();
    const txnObjects = stxns.map((stxn) => decode$1(stxn));
    const currentRequest = request == null ? new SimulateRequest({ txnGroups: [] }) : request;
    currentRequest.txnGroups = [
      new SimulateRequestTransactionGroup({
        txns: txnObjects
      })
    ];
    const simulateResponse = await client.simulateTransactions(currentRequest).do();
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = this.txIDs[txnIndex];
      const pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;
      const methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      methodResults.push(AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo.get_obj_for_encoding()));
    }
    return { methodResults, simulateResponse };
  }
  /**
   * Send the transaction group to the network and wait until it's committed to a block. An error
   * will be thrown if submission or execution fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method, since execution is
   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.
   * If the execution is also successful, this composer's status will update to COMMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation
   *
   * @returns A promise that, upon success, resolves to an object containing the confirmed round for
   *   this transaction, the txIDs of the submitted transactions, and an array of results containing
   *   one element for each method call transaction in this group.
   */
  async execute(client, waitRounds) {
    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
      throw new Error("Transaction group has already been executed successfully");
    }
    const txIDs = await this.submit(client);
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    const firstMethodCallIndex = this.transactions.findIndex((_, index2) => this.methodCalls.has(index2));
    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
    this.status = AtomicTransactionComposerStatus.COMMITTED;
    const confirmedRound = confirmedTxnInfo["confirmed-round"];
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = txIDs[txnIndex];
      let methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      try {
        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : (
          // eslint-disable-next-line no-await-in-loop
          await client.pendingTransactionInformation(txID).do()
        );
        methodResult = AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);
      } catch (err) {
        methodResult.decodeError = err;
      }
      methodResults.push(methodResult);
    }
    return {
      confirmedRound,
      txIDs,
      methodResults
    };
  }
  /**
   * Parses a single ABI Method transaction log into a ABI result object.
   *
   * @param method
   * @param methodResult
   * @param pendingInfo
   * @returns An ABIResult object
   */
  static parseMethodResponse(method, methodResult, pendingInfo) {
    const returnedResult = methodResult;
    try {
      returnedResult.txInfo = pendingInfo;
      if (method.returns.type !== "void") {
        const logs = pendingInfo.logs || [];
        if (logs.length === 0) {
          throw new Error("App call transaction did not log a return value");
        }
        const lastLog = buffer.Buffer.from(logs[logs.length - 1], "base64");
        if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {
          throw new Error("App call transaction did not log a return value");
        }
        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
        returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);
      }
    } catch (err) {
      returnedResult.decodeError = err;
    }
    return returnedResult;
  }
}
AtomicTransactionComposer.MAX_GROUP_SIZE = 16;
const SIGN_BYTES_PREFIX = buffer.Buffer.from([77, 88]);
const MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
function signTransaction(txn, sk) {
  if (typeof txn.from === "undefined") {
    const key = keyPairFromSecretKey(sk);
    txn.from = encodeAddress(key.publicKey);
  }
  const algoTxn = instantiateTxnIfNeeded(txn);
  return {
    txID: algoTxn.txID().toString(),
    blob: algoTxn.signTxn(sk)
  };
}
function signBid(bid, sk) {
  const signedBid = new Bid(bid);
  return signedBid.signBid(sk);
}
function signBytes(bytes, sk) {
  const toBeSigned = buffer.Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const sig = sign(toBeSigned, sk);
  return sig;
}
function verifyBytes(bytes, signature, addr) {
  const toBeVerified = buffer.Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const pk = decodeAddress(addr).publicKey;
  return verify(toBeVerified, signature, pk);
}
function encodeObj(o) {
  return new Uint8Array(encode(o));
}
function decodeObj(o) {
  return decode$1(o);
}
const ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
const ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);
const algosdk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ABIAddressType,
  ABIArrayDynamicType,
  ABIArrayStaticType,
  ABIBoolType,
  ABIByteType,
  ABIContract,
  ABIInterface,
  ABIMethod,
  get ABIReferenceType() {
    return ABIReferenceType;
  },
  ABIStringType,
  get ABITransactionType() {
    return ABITransactionType;
  },
  ABITupleType,
  ABIType,
  ABIUfixedType,
  ABIUintType,
  ADDR_BYTE_SIZE,
  ALGORAND_MIN_TX_FEE,
  Algodv2: AlgodClient,
  AtomicTransactionComposer,
  get AtomicTransactionComposerStatus() {
    return AtomicTransactionComposerStatus;
  },
  DryrunResult,
  ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER,
  INVALID_MICROALGOS_ERROR_MSG,
  Indexer: IndexerClient,
  IntDecoding: IntDecoding$1,
  Kmd,
  LENGTH_ENCODE_BYTE_SIZE,
  LogicSig,
  LogicSigAccount,
  MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG,
  get OnApplicationComplete() {
    return OnApplicationComplete;
  },
  SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE,
  SourceMap,
  Transaction: Transaction$1,
  get TransactionType() {
    return TransactionType;
  },
  abiCheckTransactionType,
  abiTypeIsReference,
  abiTypeIsTransaction,
  algosToMicroalgos,
  appendSignMultisigTransaction,
  appendSignRawMultisigSignature,
  assignGroupID,
  bigIntToBytes,
  bytesToBigInt,
  computeGroupID,
  createDryrun,
  createMultisigTransaction,
  decodeAddress,
  decodeObj,
  decodeSignedTransaction,
  decodeUint64,
  decodeUnsignedTransaction,
  encodeAddress,
  encodeObj,
  encodeUint64,
  encodeUnsignedSimulateTransaction,
  encodeUnsignedTransaction,
  generateAccount,
  getApplicationAddress,
  getMethodByName,
  indexerModels: types,
  instantiateTxnIfNeeded,
  isTransactionWithSigner,
  isValidAddress,
  logicSigFromByte,
  makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBasicAccountTransactionSigner,
  makeEmptyTransactionSigner,
  makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner,
  makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic,
  mergeMultisigTransactions,
  microalgosToAlgos,
  mnemonicFromSeed,
  mnemonicToMasterDerivationKey,
  mnemonicToSecretKey,
  modelsv2: types$1,
  multisigAddress,
  secretKeyToMnemonic,
  seedFromMnemonic,
  signBid,
  signBytes,
  signLogicSigTransaction,
  signLogicSigTransactionObject,
  signMultisigTransaction,
  signTransaction,
  tealSign,
  tealSignFromProgram,
  verifyBytes,
  verifyMultisig,
  verifyTealSign,
  waitForConfirmation
}, Symbol.toStringTag, { value: "Module" }));
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die("Proxy not available");
  }
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop2() {
};
function isFunction$1(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject$1(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x2) {
    return isObject$1(x2) && x2[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object2) {
  var keys = Object.keys(object2);
  if (!hasGetOwnPropertySymbols) {
    return keys;
  }
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length) {
    return keys;
  }
  return [].concat(keys, symbols.filter(function(s) {
    return objectPrototype.propertyIsEnumerable.call(object2, s);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration");
var Atom = /* @__PURE__ */ function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = "Atom";
    }
    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.batchId_ = void 0;
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
    this.batchId_ = globalState.inBatch ? globalState.batchId : NaN;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    if (!globalState.inBatch || this.batchId_ !== globalState.batchId) {
      globalState.stateVersion = globalState.stateVersion < Number.MAX_SAFE_INTEGER ? globalState.stateVersion + 1 : Number.MIN_SAFE_INTEGER;
      this.batchId_ = NaN;
    }
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString2() {
    return this.name_;
  };
  return Atom2;
}();
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a, b2) {
  return a === b2;
}
function structuralComparer(a, b2) {
  return deepEqual(a, b2);
}
function shallowComparer(a, b2) {
  return deepEqual(a, b2, 1);
}
function defaultComparer(a, b2) {
  if (Object.is) {
    return Object.is(a, b2);
  }
  return a === b2 ? a !== 0 || 1 / a === 1 / b2 : a !== a && b2 !== b2;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v, _, name) {
  if (isObservable(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name
    });
  }
  if (isPlainObject(v)) {
    return observable.object(v, void 0, {
      name
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name
    });
  }
  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }
  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === void 0 || v === null) {
    return v;
  }
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name,
      deep: false
    });
  }
  if (isPlainObject(v)) {
    return observable.object(v, void 0, {
      name,
      deep: false
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name,
      deep: false
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name,
      deep: false
    });
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if (deepEqual(v, oldValue)) {
    return oldValue;
  }
  return v;
}
var OVERRIDE = "override";
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.value;
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      // https://github.com/mobxjs/mobx/discussions/3140
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.value;
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.get;
}
function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  _ref.annotationType_;
}
var AUTO = "true";
var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set5 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set5
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set5
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v, arg2, arg3) {
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v)) {
    return v;
  }
  if (isPlainObject(v)) {
    return observable.object(v, arg2, arg3);
  }
  if (Array.isArray(v)) {
    return observable.array(v, arg2);
  }
  if (isES6Map(v)) {
    return observable.map(v, arg2);
  }
  if (isES6Set(v)) {
    return observable.set(v, arg2);
  }
  if (typeof v === "object" && v !== null) {
    return v;
  }
  return observable.box(v, arg2);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set2(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    });
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
};
var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config, _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  function res() {
    return executeAction(actionName, autoAction2, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation);
  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = false;
  var startTime_ = 0;
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges2, func) {
  var prev = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges2) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var _Symbol$toPrimitive;
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /* @__PURE__ */ function(_Atom) {
  _inheritsLoose(ObservableValue2, _Atom);
  function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = "ObservableValue";
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    return _this;
  }
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set5(newValue) {
    this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      this.setNewValue_(newValue);
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get4() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON2() {
    return this.get();
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom);
var isObservableValue = /* @__PURE__ */ createInstanceofPredicate("ObservableValue", ObservableValue);
var _Symbol$toPrimitive$1;
_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /* @__PURE__ */ function() {
  function ComputedValue2(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) {
      die(31);
    }
    this.derivation = options.get;
    this.name_ = options.name || "ComputedValue";
    if (options.set) {
      this.setter_ = createAction("ComputedValue-setter", options.set);
    }
    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get4() {
    if (this.isComputing_) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set5(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) {
        die(33, this.name_);
      }
      this.isRunningSetter_ = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    );
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track2) {
    this.isComputing_ = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track2) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    {
      return;
    }
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive$1] = function() {
    return this.valueOf();
  };
  return ComputedValue2;
}();
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l2 = obs.length;
      for (var i = 0; i < l2; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  {
    return;
  }
}
function trackDerivedFunction(derivation, f2, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f2.call(context);
  } else {
    try {
      result = f2.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i02 = 0, l2 = derivation.unboundDepsCount_;
  for (var i = 0; i < l2; i++) {
    var dep = observing[i];
    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i02 !== i) {
        observing[i02] = dep;
      }
      i02++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i02;
  derivation.newObserving_ = null;
  l2 = prevObserving.length;
  while (l2--) {
    var _dep = prevObserving[l2];
    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue_ = 0;
  }
  while (i02--) {
    var _dep2 = observing[i02];
    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;
  while (i--) {
    removeObserver(obs[i], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;
  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.batchId = Number.MIN_SAFE_INTEGER;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
  this.stateVersion = Number.MIN_SAFE_INTEGER;
};
var canMergeGlobalState = true;
var globalState = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    setTimeout(function() {
      {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED) {
      global2.__mobxGlobals.UNCHANGED = {};
    }
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
  }
}();
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_) {
    observable2.lowestObserverState_ = node.dependenciesState_;
  }
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation_ === false) {
    observable2.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  if (globalState.inBatch === 0) {
    globalState.batchId = globalState.batchId < Number.MAX_SAFE_INTEGER ? globalState.batchId + 1 : Number.MIN_SAFE_INTEGER;
  }
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i < list.length; i++) {
      var observable2 = list[i];
      observable2.isPendingUnobservation_ = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved_) {
          observable2.isBeingObserved_ = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved_ && globalState.trackingContext) {
        observable2.isBeingObserved_ = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved_;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d2.onBecomeStale_();
    }
    d2.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d2.dependenciesState_ = IDerivationState_.STALE_;
    } else if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d2.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d2.onBecomeStale_();
    }
  });
}
var Reaction = /* @__PURE__ */ function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
          if (false)
            ;
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track2(fn) {
    if (this.isDisposed_) {
      return;
    }
    startBatch();
    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;
    if (this.isDisposed_) {
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message = "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    }
    globalState.globalReactionErrorHandlers.forEach(function(f2) {
      return f2(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;
      if (!this.isRunning_) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose2() {
      _this2.dispose();
      abortSignal == null ? void 0 : abortSignal.removeEventListener == null ? void 0 : abortSignal.removeEventListener("abort", dispose2);
    };
    abortSignal == null ? void 0 : abortSignal.addEventListener == null ? void 0 : abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    return dispose;
  };
  _proto.toString = function toString2() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
  };
  return Reaction2;
}();
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f2) {
  return f2();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error("[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l2 = remainingReactions.length; i < l2; i++) {
      remainingReactions[i].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function isSpyEnabled() {
  return false;
}
function spyReport(event) {
  {
    return;
  }
}
function spyReportStart(event) {
  {
    return;
  }
}
function spyReportEnd(change) {
  {
    return;
  }
}
function spy(listener) {
  {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction$1(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction$1(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
  };
  return res;
}
var action = /* @__PURE__ */ createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, void 0);
}
function isAction(thing) {
  return isFunction$1(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts2$signal, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction2 = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction2.isDisposed_) {
            reaction2.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  if (!((_opts2 = opts) != null && (_opts2$signal = _opts2.signal) != null && _opts2$signal.aborted)) {
    reaction2.schedule_();
  }
  return reaction2.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run2(f2) {
  return f2();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f2) {
    return setTimeout(f2, opts.delay);
  } : run;
}
function reaction(expression, effect, opts) {
  var _opts$name2, _opts4, _opts4$signal, _opts5;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name = (_opts$name2 = opts.name) != null ? _opts$name2 : "Reaction";
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_) {
      return;
    }
    var changed = false;
    r.track(function() {
      var nextValue = allowStateChanges(false, function() {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) {
      effectAction(value, oldValue, r);
    } else if (!firstTime && changed) {
      effectAction(value, oldValue, r);
    }
    firstTime = false;
  }
  if (!((_opts4 = opts) != null && (_opts4$signal = _opts4.signal) != null && _opts4$signal.aborted)) {
    r.schedule_();
  }
  return r.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction$1(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
function extendObservable(target, properties, annotations, options) {
  var descriptors = getOwnPropertyDescriptors(properties);
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(
        key,
        descriptors[key],
        // must pass "undefined" for { key: undefined }
        !annotations ? true : key in annotations ? annotations[key] : true
      );
    });
  });
  return target;
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction$1(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done) {
          return resolve(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction$1(promise.cancel)) {
    promise.cancel();
  }
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function _isComputed(value, property) {
  if (property === void 0) {
    return isComputedValue(value);
  }
  if (isObservableObject(value) === false) {
    return false;
  }
  if (!value[$mobx].values_.has(property)) {
    return false;
  }
  var atom = getAtom(value, property);
  return isComputedValue(atom);
}
function isComputedProp(value, propName) {
  return _isComputed(value, propName);
}
function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== void 0) {
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  return _isObservable(value);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }
  die(38);
}
function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction$1(cbOrFire)) {
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
  } else {
    return observeObservable(thing, propOrCb, cbOrFire);
  }
}
function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}
function cache(map2, key, value) {
  map2.set(key, value);
  return value;
}
function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
    return source;
  }
  if (isObservableValue(source) || isComputedValue(source)) {
    return toJSHelper(source.get(), __alreadySeen);
  }
  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function(value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }
  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, /* @__PURE__ */ new Set());
    source.forEach(function(value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }
  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, /* @__PURE__ */ new Map());
    source.forEach(function(value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    var _res3 = cache(__alreadySeen, source, {});
    apiOwnKeys(source).forEach(function(key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
function toJS(source, options) {
  return toJSHelper(source, /* @__PURE__ */ new Map());
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has2(target, name) {
    return getAdm(target).has_(name);
  },
  get: function get2(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set3(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name)) {
      return false;
    }
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty2(target, name) {
    var _getAdm$delete_;
    if (!isStringish(name)) {
      return false;
    }
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name, descriptor) {
    var _getAdm$definePropert;
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i = 0, l2 = interceptors.length; i < l2; i++) {
      change = interceptors[i](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i = 0, l2 = listeners.length; i < l2; i++) {
    listeners[i](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options) {
  initObservable(function() {
    var _annotations;
    var adm = asObservableObject(target, options)[$mobx];
    if (false)
      ;
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  });
  return target;
}
var keysSymbol = /* @__PURE__ */ Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
      keys["delete"]("constructor");
      keys["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys);
    }
    target[keysSymbol].forEach(function(key) {
      return adm.make_(
        key,
        // must pass "undefined" for { key: undefined }
        !overrides ? true : key in overrides ? overrides[key] : true
      );
    });
  });
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get3(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) {
      return adm;
    }
    if (name === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set4(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0) {
      return values.map(this.dehancer);
    }
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index2 === void 0) {
      index2 = 0;
    } else if (index2 > length) {
      index2 = length;
    } else if (index2 < 0) {
      index2 = Math.max(0, length + index2);
    }
    if (arguments.length === 1) {
      deleteCount = length - index2;
    } else if (deleteCount === void 0 || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length - index2));
    }
    if (newItems === void 0) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index2,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
      return _this.enhancer_(v, void 0);
    });
    if (this.legacyMode_ || false) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index2, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index2, index2 + deleteCount);
      var oldItems = this.values_.slice(index2 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i = 0; i < newItems.length; i++) {
        this.values_[index2 + i] = newItems[i];
      }
      for (var _i3 = 0; _i3 < oldItems.length; _i3++) {
        this.values_[index2 + newItems.length + _i3] = oldItems[_i3];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index2,
      newValue,
      oldValue
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index2,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get_ = function get_(index2) {
    if (this.legacyMode_ && index2 >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + index2);
      return void 0;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index2]);
  };
  _proto.set_ = function set_(index2, newValue) {
    var values = this.values_;
    if (this.legacyMode_ && index2 > values.length) {
      die(17, index2, values.length);
    }
    if (index2 < values.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index2];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index2,
          newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index2] = newValue;
        this.notifyArrayChildUpdate_(index2, newValue, oldValue);
      }
    } else {
      var newItems = new Array(index2 + 1 - values.length);
      for (var i = 0; i < newItems.length - 1; i++) {
        newItems[i] = void 0;
      }
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function() {
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
var arrayExtensions = {
  clear: function clear2() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index2, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index2);
      case 2:
        return adm.spliceWithArray_(index2, deleteCount);
    }
    return adm.spliceWithArray_(index2, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove2(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index2) {
      return callback.call(thisArg, element, index2, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index2) {
      return callback(accumulator, currentValue, index2, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject$1(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _Symbol$iterator, _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /* @__PURE__ */ function() {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction$1(Map)) {
      die(18);
    }
    initObservable(function() {
      _this.keysAtom_ = createAtom(false ? _this.name_ + ".keys()" : "ObservableMap.keys()");
      _this.data_ = /* @__PURE__ */ new Map();
      _this.hasMap_ = /* @__PURE__ */ new Map();
      if (initialData) {
        _this.merge(initialData);
      }
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has3(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key);
    }
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set5(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable2 = this.data_.get(key);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, "ObservableMap.key", false);
      _this4.data_.set(key, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get = function get4(key) {
    if (this.has(key)) {
      return this.dehanceValue_(this.data_.get(key).get());
    }
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[_Symbol$iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject(other)) {
        getPlainObjectKeys(other).forEach(function(key) {
          return _this5.set(key, other[key]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this5.set(key, value);
        });
      } else if (isES6Map(other)) {
        if (other.constructor !== Map) {
          die(19, other);
        }
        other.forEach(function(value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== void 0) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear3() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace2(values) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString2() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _createClass(ObservableMap2, [{
    key: "size",
    get: function get4() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get4() {
      return "Map";
    }
  }]);
  return ObservableMap2;
}();
var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map2 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map2.set(key, dataStructure[key]);
    }
    return map2;
  } else {
    return die(21, dataStructure);
  }
}
var _Symbol$iterator$1, _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /* @__PURE__ */ function() {
  function ObservableSet2(initialData, enhancer, name_) {
    var _this = this;
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction$1(Set)) {
      die(22);
    }
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    initObservable(function() {
      _this.atom_ = createAtom(_this.name_);
      if (initialData) {
        _this.replace(initialData);
      }
    });
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear3() {
    var _this2 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this2["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add2(value) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
    }
    if (!this.has(value)) {
      transaction(function() {
        _this3.data_.add(_this3.enhancer_(value, void 0));
        _this3.atom_.reportChanged();
      });
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this4 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      transaction(function() {
        _this4.atom_.reportChanged();
        _this4.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      return true;
    }
    return false;
  };
  _proto.has = function has3(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index2 = nextIndex;
        nextIndex += 1;
        return index2 < values.length ? {
          value: [keys[index2], values[index2]],
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.keys = function keys() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.replace = function replace2(other) {
    var _this5 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (isES6Set(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.toString = function toString2() {
    return "[object ObservableSet]";
  };
  _proto[_Symbol$iterator$1] = function() {
    return this.values();
  };
  _createClass(ObservableSet2, [{
    key: "size",
    get: function get4() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get4() {
      return "Set";
    }
  }]);
  return ObservableSet2;
}();
var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom("ObservableObject.keys");
    this.isPlainObject_ = isPlainObject(this.target_);
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable2 = this.values_.get(key);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = false;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0) {
          return;
        }
        if (outcome === 1) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable2);
      this.notifyPropertyAddition_(key, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change) {
          return null;
        }
      }
      options.name || (options.name = false ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change) {
        return null;
      }
    }
    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = false;
      var observable2 = this.values_.get(key);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (false)
        ;
      if (observable2) {
        this.values_["delete"](key);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (false)
          ;
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (false)
          ;
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;
    var notify = hasListeners(this);
    var notifySpy = false;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, change);
      }
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options) {
  var _options$name;
  if (hasProp(target, $mobx)) {
    return target;
  }
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get4() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set5(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject$1(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0);
var safariPrototypeSetterInheritanceBug = /* @__PURE__ */ function() {
  var v = false;
  var p2 = {};
  Object.defineProperty(p2, "0", {
    set: function set5() {
      v = true;
    }
  });
  Object.create(p2)["0"] = 1;
  return v === false;
}();
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(_StubArray, _Symbol$toStringTag2, _Symbol$iterator2) {
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  function LegacyObservableArray2(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    initObservable(function() {
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _assertThisInitialized(_this);
      addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
      if (initialValues && initialValues.length) {
        _this.spliceWithArray(0, 0, initialValues);
      }
      if (safariPrototypeSetterInheritanceBug) {
        Object.defineProperty(_assertThisInitialized(_this), "0", ENTRY_0);
      }
    });
    return _this;
  }
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      arrays.map(function(a) {
        return isObservableArray(a) ? a.slice() : a;
      })
    );
  };
  _proto[_Symbol$iterator2] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  _createClass(LegacyObservableArray2, [{
    key: "length",
    get: function get4() {
      return this[$mobx].getArrayLength_();
    },
    set: function set5(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get4() {
      return "Array";
    }
  }]);
  return LegacyObservableArray2;
}(StubArray, Symbol.toStringTag, Symbol.iterator);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop = _ref[0], fn = _ref[1];
  if (prop !== "concat") {
    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
  }
});
function createArrayEntryDescriptor(index2) {
  return {
    enumerable: false,
    configurable: true,
    get: function get4() {
      return this[$mobx].get_(index2);
    },
    set: function set5(value) {
      this[$mobx].set_(index2, value);
    }
  };
}
function createArrayBufferItem(index2) {
  defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
}
function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max + 100; index2++) {
      createArrayBufferItem(index2);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2) {
        die(25, property, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction$1(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== void 0) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
function initObservable(cb) {
  var derivation = untrackedStart();
  var allowStateChanges2 = allowStateChangesStart(true);
  startBatch();
  try {
    return cb();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges2);
    untrackedEnd(derivation);
  }
}
var toString = objectPrototype.toString;
function deepEqual(a, b2, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a, b2, depth);
}
function eq(a, b2, depth, aStack, bStack) {
  if (a === b2) {
    return a !== 0 || 1 / a === 1 / b2;
  }
  if (a == null || b2 == null) {
    return false;
  }
  if (a !== a) {
    return b2 !== b2;
  }
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b2 != "object") {
    return false;
  }
  var className = toString.call(a);
  if (className !== toString.call(b2)) {
    return false;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b2;
    case "[object Number]":
      if (+a !== +a) {
        return +b2 !== +b2;
      }
      return +a === 0 ? 1 / +a === 1 / b2 : +a === +b2;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b2;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b2);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a = unwrap(a);
  b2 = unwrap(b2);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a != "object" || typeof b2 != "object") {
      return false;
    }
    var aCtor = a.constructor, bCtor = b2.constructor;
    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b2) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) {
      return bStack[length] === b2;
    }
  }
  aStack.push(a);
  bStack.push(b2);
  if (areArrays) {
    length = a.length;
    if (length !== b2.length) {
      return false;
    }
    while (length--) {
      if (!eq(a[length], b2[length], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys = Object.keys(a);
    var key;
    length = keys.length;
    if (Object.keys(b2).length !== length) {
      return false;
    }
    while (length--) {
      key = keys[length];
      if (!(hasProp(b2, key) && eq(a[key], b2[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a) {
  if (isObservableArray(a)) {
    return a.slice();
  }
  if (isES6Map(a) || isObservableMap(a)) {
    return Array.from(a.entries());
  }
  if (isES6Set(a) || isObservableSet(a)) {
    return Array.from(a.entries());
  }
  return a;
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}
function getSelf() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(m2) {
  var g = getGlobal();
  if (typeof g[m2] === "undefined") {
    die("MobX requires global '" + m2 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}
var PersistStoreMap = /* @__PURE__ */ new Map();
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op2[1])).done)
          return t;
        if (y2 = 0, t)
          op2 = [op2[0] & 2, t.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t = op2;
            break;
          case 4:
            _.label++;
            return { value: op2[1], done: false };
          case 5:
            _.label++;
            y2 = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
              _.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op2;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op2);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _);
      } catch (e) {
        op2 = [6, e];
        y2 = 0;
      } finally {
        f2 = t = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
};
var mpsConfig = {};
var mpsReactionOptions = {};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op2[1])).done)
          return t;
        if (y2 = 0, t)
          op2 = [op2[0] & 2, t.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t = op2;
            break;
          case 4:
            _.label++;
            return { value: op2[1], done: false };
          case 5:
            _.label++;
            y2 = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
              _.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op2;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op2);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _);
      } catch (e) {
        op2 = [6, e];
        y2 = 0;
      } finally {
        f2 = t = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op2[1])).done)
          return t;
        if (y2 = 0, t)
          op2 = [op2[0] & 2, t.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t = op2;
            break;
          case 4:
            _.label++;
            return { value: op2[1], done: false };
          case 5:
            _.label++;
            y2 = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
              _.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op2;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op2);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _);
      } catch (e) {
        op2 = [6, e];
        y2 = 0;
      } finally {
        f2 = t = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
};
var buildExpireTimestamp = function(milliseconds) {
  return (/* @__PURE__ */ new Date()).getTime() + milliseconds;
};
var hasTimestampExpired = function(milliseconds) {
  var dateTimeNow = (/* @__PURE__ */ new Date()).getTime();
  var dateTimeExpiration = new Date(milliseconds).getTime();
  return dateTimeExpiration <= dateTimeNow;
};
var isObject = function(data) {
  return Boolean(data) && Array.isArray(data) === false && typeof data === "object";
};
var isFunction = function(functionToCheck) {
  return functionToCheck && functionToCheck instanceof Function;
};
var isStorageControllerLike = function(value) {
  if (typeof Storage !== "undefined" && value instanceof Storage) {
    return true;
  }
  return [
    value === null || value === void 0 ? void 0 : value.hasOwnProperty("getItem"),
    value === null || value === void 0 ? void 0 : value.hasOwnProperty("removeItem"),
    value === null || value === void 0 ? void 0 : value.hasOwnProperty("setItem"),
    isFunction(value === null || value === void 0 ? void 0 : value.getItem),
    isFunction(value === null || value === void 0 ? void 0 : value.removeItem),
    isFunction(value === null || value === void 0 ? void 0 : value.setItem)
  ].every(Boolean);
};
var isBrowser = typeof window !== "undefined";
var isNotProductionBuild = false;
var invalidStorageAdaptorWarningIf = function(storageAdaptor, storageName) {
  if (isBrowser && isNotProductionBuild && !isStorageControllerLike(storageAdaptor)) {
    console.warn("mobx-persist-store: ".concat(storageName, ` does not have a valid storage adaptor.

* Make sure the storage controller has 'getItem', 'setItem' and 'removeItem' methods."`));
  }
};
var duplicatedStoreWarningIf = function(hasPersistedStoreAlready, storageName) {
  if (isBrowser && isNotProductionBuild && hasPersistedStoreAlready) {
    console.warn(`mobx-persist-store: 'makePersistable' was called was called with the same storage name "`.concat(storageName, '".\n\n * Make sure you call "stopPersisting" before recreating "').concat(storageName, '" to avoid memory leaks. \n * Or double check you did not have two stores with the same name.'));
  }
};
var computedPersistWarningIf = function(isComputedProperty, propertyName) {
  if (isBrowser && isNotProductionBuild && isComputedProperty) {
    console.warn("mobx-persist-store: The property '".concat(propertyName, "' is computed and will not persist."));
  }
};
var actionPersistWarningIf = function(isComputedProperty, propertyName) {
  if (isBrowser && isNotProductionBuild && isComputedProperty) {
    console.warn("mobx-persist-store: The property '".concat(propertyName, "' is an action and will not persist."));
  }
};
var consoleDebug = function(isDebugMode, message, content) {
  if (content === void 0) {
    content = "";
  }
  if (isDebugMode && isBrowser && isNotProductionBuild) {
    console.info("%c mobx-persist-store: (Debug Mode) ".concat(message, " "), "background: #4B8CC5; color: black; display: block;", content);
  }
};
var isArrayForMap = function(value) {
  if (Array.isArray(value)) {
    return value.every(function(v) {
      return Array.isArray(v);
    });
  }
  return false;
};
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op2[1])).done)
          return t;
        if (y2 = 0, t)
          op2 = [op2[0] & 2, t.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t = op2;
            break;
          case 4:
            _.label++;
            return { value: op2[1], done: false };
          case 5:
            _.label++;
            y2 = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
              _.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op2;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op2);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _);
      } catch (e) {
        op2 = [6, e];
        y2 = 0;
      } finally {
        f2 = t = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
};
var StorageAdapter = (
  /** @class */
  function() {
    function StorageAdapter2(options) {
      this.options = options;
    }
    StorageAdapter2.prototype.setItem = function(key, item) {
      var _a3;
      return __awaiter$2(this, void 0, void 0, function() {
        var _b2, _c3, stringify2, _d3, debugMode, data, content;
        return __generator$2(this, function(_e2) {
          switch (_e2.label) {
            case 0:
              _b2 = this.options, _c3 = _b2.stringify, stringify2 = _c3 === void 0 ? true : _c3, _d3 = _b2.debugMode, debugMode = _d3 === void 0 ? false : _d3;
              data = this.options.expireIn ? Object.assign({}, item, {
                __mps__: {
                  expireInTimestamp: buildExpireTimestamp(this.options.expireIn)
                }
              }) : item;
              content = stringify2 ? JSON.stringify(data) : data;
              consoleDebug(debugMode, "".concat(key, " - setItem:"), content);
              return [4, (_a3 = this.options.storage) === null || _a3 === void 0 ? void 0 : _a3.setItem(key, content)];
            case 1:
              _e2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    StorageAdapter2.prototype.getItem = function(key) {
      var _a3, _b2;
      return __awaiter$2(this, void 0, void 0, function() {
        var _c3, _d3, removeOnExpiration, _e2, debugMode, storageData, parsedData, hasExpired;
        return __generator$2(this, function(_f3) {
          switch (_f3.label) {
            case 0:
              _c3 = this.options, _d3 = _c3.removeOnExpiration, removeOnExpiration = _d3 === void 0 ? true : _d3, _e2 = _c3.debugMode, debugMode = _e2 === void 0 ? false : _e2;
              return [4, (_a3 = this.options.storage) === null || _a3 === void 0 ? void 0 : _a3.getItem(key)];
            case 1:
              storageData = _f3.sent();
              try {
                parsedData = JSON.parse(storageData) || {};
              } catch (error) {
                parsedData = storageData || {};
              }
              hasExpired = hasTimestampExpired((_b2 = parsedData.__mps__) === null || _b2 === void 0 ? void 0 : _b2.expireInTimestamp);
              consoleDebug(debugMode, "".concat(key, " - hasExpired"), hasExpired);
              if (!(hasExpired && removeOnExpiration))
                return [3, 3];
              return [4, this.removeItem(key)];
            case 2:
              _f3.sent();
              _f3.label = 3;
            case 3:
              parsedData = hasExpired ? {} : parsedData;
              consoleDebug(debugMode, "".concat(key, " - (getItem):"), parsedData);
              return [2, parsedData];
          }
        });
      });
    };
    StorageAdapter2.prototype.removeItem = function(key) {
      var _a3;
      return __awaiter$2(this, void 0, void 0, function() {
        var _b2, debugMode;
        return __generator$2(this, function(_c3) {
          switch (_c3.label) {
            case 0:
              _b2 = this.options.debugMode, debugMode = _b2 === void 0 ? false : _b2;
              consoleDebug(debugMode, "".concat(key, " - (removeItem): storage was removed"));
              return [4, (_a3 = this.options.storage) === null || _a3 === void 0 ? void 0 : _a3.removeItem(key)];
            case 1:
              _c3.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return StorageAdapter2;
  }()
);
var isSerializableProperty = function(obj) {
  var keys = ["key", "serialize", "deserialize"];
  if (!isObject(obj)) {
    consoleDebug(!!mpsConfig.debugMode, "passed value is not an object", { obj });
    return false;
  }
  return keys.every(function(key) {
    if (obj.hasOwnProperty(key) && typeof key !== "undefined") {
      return true;
    }
    consoleDebug(!!mpsConfig.debugMode, "".concat(String(key), " not found in SerializableProperty"), { key, obj });
    return false;
  });
};
var makeSerializableProperties = function(properties) {
  return properties.reduce(function(acc, curr) {
    if (typeof curr === "string") {
      acc.push({
        key: curr,
        serialize: function(value) {
          return value;
        },
        deserialize: function(value) {
          return value;
        }
      });
      return acc;
    }
    if (isSerializableProperty(curr)) {
      acc.push(curr);
      return acc;
    }
    return acc;
  }, []);
};
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op2[1])).done)
          return t;
        if (y2 = 0, t)
          op2 = [op2[0] & 2, t.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t = op2;
            break;
          case 4:
            _.label++;
            return { value: op2[1], done: false };
          case 5:
            _.label++;
            y2 = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
              _.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op2;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op2);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _);
      } catch (e) {
        op2 = [6, e];
        y2 = 0;
      } finally {
        f2 = t = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
};
var PersistStore = (
  /** @class */
  function() {
    function PersistStore2(target, options, reactionOptions) {
      if (reactionOptions === void 0) {
        reactionOptions = {};
      }
      var _a3, _b2, _c3, _d3, _e2, _f3, _g2;
      this.cancelWatch = null;
      this.properties = [];
      this.reactionOptions = {};
      this.storageAdapter = null;
      this.target = null;
      this.debugMode = false;
      this.isHydrated = false;
      this.isPersisting = false;
      this.storageName = "";
      this.target = target;
      this.storageName = options.name;
      this.properties = makeSerializableProperties(options.properties);
      this.reactionOptions = Object.assign({ fireImmediately: true }, mpsReactionOptions, reactionOptions);
      this.debugMode = (_b2 = (_a3 = options.debugMode) !== null && _a3 !== void 0 ? _a3 : mpsConfig.debugMode) !== null && _b2 !== void 0 ? _b2 : false;
      this.storageAdapter = new StorageAdapter({
        expireIn: (_c3 = options.expireIn) !== null && _c3 !== void 0 ? _c3 : mpsConfig.expireIn,
        removeOnExpiration: (_e2 = (_d3 = options.removeOnExpiration) !== null && _d3 !== void 0 ? _d3 : mpsConfig.removeOnExpiration) !== null && _e2 !== void 0 ? _e2 : true,
        stringify: (_g2 = (_f3 = options.stringify) !== null && _f3 !== void 0 ? _f3 : mpsConfig.stringify) !== null && _g2 !== void 0 ? _g2 : true,
        storage: options.storage ? options.storage : mpsConfig.storage,
        debugMode: this.debugMode
      });
      makeObservable(this, {
        clearPersistedStore: action,
        hydrateStore: action,
        isHydrated: observable,
        isPersisting: observable,
        pausePersisting: action,
        startPersisting: action,
        stopPersisting: action
      }, { autoBind: true, deep: false });
      invalidStorageAdaptorWarningIf(this.storageAdapter.options.storage, this.storageName);
      consoleDebug(this.debugMode, "".concat(this.storageName, " - (makePersistable)"), {
        properties: this.properties,
        storageAdapter: this.storageAdapter,
        reactionOptions: this.reactionOptions
      });
    }
    PersistStore2.prototype.init = function() {
      return __awaiter$1(this, void 0, void 0, function() {
        return __generator$1(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [4, this.hydrateStore()];
            case 1:
              _a3.sent();
              this.startPersisting();
              return [2, this];
          }
        });
      });
    };
    PersistStore2.prototype.hydrateStore = function() {
      return __awaiter$1(this, void 0, void 0, function() {
        var isBeingWatched, data_1, target_1;
        var _this = this;
        return __generator$1(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              isBeingWatched = Boolean(this.cancelWatch);
              if (this.isPersisting) {
                this.pausePersisting();
              }
              runInAction(function() {
                _this.isHydrated = false;
                consoleDebug(_this.debugMode, "".concat(_this.storageName, " - (hydrateStore) isHydrated:"), _this.isHydrated);
              });
              if (!(this.storageAdapter && this.target))
                return [3, 2];
              return [4, this.storageAdapter.getItem(this.storageName)];
            case 1:
              data_1 = _a3.sent();
              target_1 = this.target;
              if (data_1) {
                runInAction(function() {
                  _this.properties.forEach(function(property) {
                    var allowPropertyHydration = [
                      target_1.hasOwnProperty(property.key),
                      typeof data_1[property.key] !== "undefined"
                    ].every(Boolean);
                    if (allowPropertyHydration) {
                      var propertyData = data_1[property.key];
                      if (target_1[property.key] instanceof ObservableMap && isArrayForMap(propertyData)) {
                        target_1[property.key] = property.deserialize(new Map(propertyData));
                      } else {
                        target_1[property.key] = property.deserialize(propertyData);
                      }
                    }
                  });
                });
              }
              _a3.label = 2;
            case 2:
              runInAction(function() {
                _this.isHydrated = true;
                consoleDebug(_this.debugMode, "".concat(_this.storageName, " - isHydrated:"), _this.isHydrated);
              });
              if (isBeingWatched) {
                this.startPersisting();
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PersistStore2.prototype.startPersisting = function() {
      var _this = this;
      if (!this.storageAdapter || !this.target || this.cancelWatch) {
        return;
      }
      var target = this.target;
      this.cancelWatch = reaction(function() {
        var propertiesToWatch = {};
        _this.properties.forEach(function(property) {
          var isComputedProperty = isComputedProp(target, property.key);
          var isActionProperty = isAction(target[property.key]);
          computedPersistWarningIf(isComputedProperty, String(property.key));
          actionPersistWarningIf(isActionProperty, String(property.key));
          if (!isComputedProperty && !isActionProperty) {
            var propertyData = property.serialize(target[property.key]);
            if (propertyData instanceof ObservableMap) {
              var mapArray_1 = [];
              propertyData.forEach(function(v, k2) {
                mapArray_1.push([k2, toJS(v)]);
              });
              propertyData = mapArray_1;
            }
            propertiesToWatch[property.key] = toJS(propertyData);
          }
        });
        return propertiesToWatch;
      }, function(dataToSave) {
        return __awaiter$1(_this, void 0, void 0, function() {
          return __generator$1(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                if (!this.storageAdapter)
                  return [3, 2];
                return [4, this.storageAdapter.setItem(this.storageName, dataToSave)];
              case 1:
                _a3.sent();
                _a3.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, this.reactionOptions);
      this.isPersisting = true;
      consoleDebug(this.debugMode, "".concat(this.storageName, " - (startPersisting) isPersisting:"), this.isPersisting);
    };
    PersistStore2.prototype.pausePersisting = function() {
      this.isPersisting = false;
      consoleDebug(this.debugMode, "".concat(this.storageName, " - pausePersisting (isPersisting):"), this.isPersisting);
      if (this.cancelWatch) {
        this.cancelWatch();
        this.cancelWatch = null;
      }
    };
    PersistStore2.prototype.stopPersisting = function() {
      this.pausePersisting();
      consoleDebug(this.debugMode, "".concat(this.storageName, " - (stopPersisting)"));
      PersistStoreMap.delete(this.target);
      this.cancelWatch = null;
      this.properties = [];
      this.reactionOptions = {};
      this.storageAdapter = null;
      this.target = null;
    };
    PersistStore2.prototype.clearPersistedStore = function() {
      return __awaiter$1(this, void 0, void 0, function() {
        return __generator$1(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!this.storageAdapter)
                return [3, 2];
              consoleDebug(this.debugMode, "".concat(this.storageName, " - (clearPersistedStore)"));
              return [4, this.storageAdapter.removeItem(this.storageName)];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PersistStore2.prototype.getPersistedStore = function() {
      return __awaiter$1(this, void 0, void 0, function() {
        return __generator$1(this, function(_a3) {
          if (this.storageAdapter) {
            consoleDebug(this.debugMode, "".concat(this.storageName, " - (getPersistedStore)"));
            return [2, this.storageAdapter.getItem(this.storageName)];
          }
          return [2, null];
        });
      });
    };
    return PersistStore2;
  }()
);
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op2[1])).done)
          return t;
        if (y2 = 0, t)
          op2 = [op2[0] & 2, t.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t = op2;
            break;
          case 4:
            _.label++;
            return { value: op2[1], done: false };
          case 5:
            _.label++;
            y2 = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
              _.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op2;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op2);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _);
      } catch (e) {
        op2 = [6, e];
        y2 = 0;
      } finally {
        f2 = t = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
};
var makePersistable = function(target, storageOptions, reactionOptions) {
  return __awaiter(void 0, void 0, void 0, function() {
    var mobxPersistStore, hasPersistedStoreAlready;
    return __generator(this, function(_a3) {
      mobxPersistStore = new PersistStore(target, storageOptions, reactionOptions);
      hasPersistedStoreAlready = Array.from(PersistStoreMap.values()).map(function(item) {
        return item.storageName;
      }).includes(mobxPersistStore.storageName);
      duplicatedStoreWarningIf(hasPersistedStoreAlready, mobxPersistStore.storageName);
      PersistStoreMap.set(target, mobxPersistStore);
      return [2, mobxPersistStore.init()];
    });
  });
};
var F = Object.defineProperty;
var u = (o, e) => F(o, "name", { value: e, configurable: true });
function p() {
  let o = false;
  return typeof window !== void 0 && typeof window == "object" && "document" in window && typeof window.document == "object" && (o = true), o;
}
u(p, "isBrowser");
var J = u((o) => {
  if (typeof window == null)
    throw new Error("Cannot access window for simple btoa conversion.");
  for (var e = "", t = new Uint8Array(o), i = t.byteLength, n = 0; n < i; n++)
    e += String.fromCharCode(t[n]);
  return window.btoa(e);
}, "arrayBufferToBase64"), l = { enabled: false, log(...o) {
  this.enabled && console.log(...o);
}, warn(...o) {
  this.enabled && console.warn(...o);
}, debug(...o) {
  this.enabled && console.debug(...o);
} };
var d = { PERA: "pera", INKEY: "inkey", MYALGO: "myalgo", ALGOSIGNER: "algosigner", EXODUS: "exodus", DEFLY: "defly", MNEMONIC: "mnemonic" };
var y = (_a2 = class {
  constructor(e) {
  }
}, u(_a2, "BaseClient"), __publicField(_a2, "metadata"), __publicField(_a2, "init"), _a2);
var K = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzcgMTg3Ij48cmVjdCB4PSItMTEuMzgiIHk9Ii0yNS45NyIgd2lkdGg9IjIwMC4wMiIgaGVpZ2h0PSIyMzEuNTMiIHN0eWxlPSJmaWxsOiNmZTU7Ii8+PHBhdGggZD0iTTk0LjA1LDU5LjYxYzIuMDUsOC40OCwxLjM2LDE1Ljk0LTEuNTUsMTYuNjYtMi45LC43Mi02LjkxLTUuNTctOC45Ni0xNC4wNS0yLjA1LTguNDgtMS4zNi0xNS45NCwxLjU1LTE2LjY2LDIuOS0uNzIsNi45MSw1LjU3LDguOTYsMTQuMDVaIiBzdHlsZT0iZmlsbDojMWMxYzFjOyIvPjxwYXRoIGQ9Ik0xMjcuODUsNjYuOWMtNC41My00LjgxLTEzLjU1LTMuNS0yMC4xNSwyLjkxLTYuNTksNi40MS04LjI2LDE1LjUtMy43MywyMC4zMSw0LjUzLDQuOCwxMy41NSwzLjUsMjAuMTUtMi45MXM4LjI2LTE1LjUsMy43My0yMC4zMVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTkxLjc5LDE0MC40N2MyLjktLjcyLDMuNDktOC42LDEuMzItMTcuNjEtMi4xNy05LTYuMjktMTUuNzEtOS4xOS0xNC45OS0yLjksLjcyLTMuNDksOC42LTEuMzIsMTcuNjEsMi4xNyw5LDYuMjksMTUuNzEsOS4xOSwxNC45OVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTYyLjIyLDcxLjNjOC4zNywyLjQ3LDE0LjQ4LDYuOCwxMy42Niw5LjY3LS44MywyLjg3LTguMjgsMy4yLTE2LjY1LC43My04LjM3LTIuNDctMTQuNDgtNi44LTEzLjY2LTkuNjcsLjgzLTIuODcsOC4yOC0zLjIsMTYuNjUtLjczWiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48cGF0aCBkPSJNMTE2LjU0LDEwMy43NGM4Ljg4LDIuNjIsMTUuNDEsNy4wNywxNC41OSw5Ljk0LS44MywyLjg3LTguNywzLjA4LTE3LjU4LC40Ni04Ljg4LTIuNjItMTUuNDEtNy4wNy0xNC41OS05Ljk0LC44My0yLjg3LDguNy0zLjA4LDE3LjU4LS40NloiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTcxLjY0LDk3LjcxYy0yLjA4LTIuMTUtOC44OCwuOTgtMTUuMiw2Ljk5LTYuMzIsNi4wMS05Ljc2LDEyLjYzLTcuNjksMTQuNzgsMi4wOCwyLjE1LDguODgtLjk4LDE1LjItNi45OSw2LjMyLTYuMDEsOS43Ni0xMi42Myw3LjY5LTE0Ljc4WiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48L3N2Zz4=", N = { id: d.PERA, chain: "algorand", name: "Pera Wallet", icon: K, pkg: "@perawallet/connect" };
var k = (_b = class extends y {
  constructor({ sdk: e }) {
    super();
    __publicField(this, "sdk");
    this.sdk = e;
  }
  static async init(e) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let t;
      if (e && e.sdk)
        t = e.sdk;
      else {
        let i, n = { shouldShowSignTxnToast: false };
        i = (e == null ? void 0 : e.config) || n;
        let r = await __vitePreload(() => import("./index-f2512945.js").then((n2) => n2.i), true ? ["./index-f2512945.js","./qr-code-styling-87721598.js","./algosdk.min-e134c54c.js","./index-9c89cd5b.js"] : void 0, import.meta.url), a = r.PeraWalletConnect || r.default.PeraWalletConnect;
        t = new a(i);
      }
      return t = t, new _b({ sdk: t });
    } catch (t) {
      return console.error(`[${N.id}] Error initializing...`, t), null;
    }
  }
  async connect(e) {
    var _a3;
    let t = await this.sdk.connect();
    if ((_a3 = this.sdk.connector) == null ? void 0 : _a3.on("disconnect", e), t.length === 0)
      throw new Error(`No accounts found for ${N.id}`);
    return t.map((i, n) => ({ name: `Pera Account ${n + 1}`, address: i, walletId: N.id, chain: N.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(e) {
    var _a3;
    let t = await this.sdk.reconnectSession().catch(console.info);
    return (_a3 = this.sdk.connector) == null ? void 0 : _a3.on("disconnect", e), t ? t.map((i, n) => ({ name: `Pera Account ${n + 1}`, address: i, walletId: N.id, chain: N.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() })) : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(e, t) {
    let i = t.map((s) => decodeObj(s)), n = i.reduce((s, g, M) => {
      let c = e.map((I) => I.address);
      return !("txn" in g) && c.includes(encodeAddress(g.snd)) ? s.push({ txn: decodeUnsignedTransaction(t[M]) }) : s.push({ txn: decodeSignedTransaction(t[M]).txn, signers: [] }), s;
    }, []), r = await this.sdk.signTransaction([n]);
    return i.reduce((s, g, M) => {
      if ("txn" in g)
        s.push(t[M]);
      else {
        let c = r.shift();
        c && s.push(c);
      }
      return s;
    }, []);
  }
}, u(_b, "PeraClient"), __publicField(_b, "metadata", N), _b);
var te = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTIiIGhlaWdodD0iNTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cmVjdCB3aWR0aD0iNTIiIGhlaWdodD0iNTIiIHJ4PSIxMiIgZmlsbD0iI2ZmZiIvPjxjaXJjbGUgY3g9IjI2LjI1MSIgY3k9IjE3Ljg5MSIgcj0iMTMuODkxIiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTkuNzc2IiBjeT0iMTcuODkxIiBmaWxsPSIjZmZmIiByPSIyLjY0MyIvPjxjaXJjbGUgY3g9IjMxLjYzOCIgY3k9IjE3Ljg5MSIgZmlsbD0iI2ZmZiIgcj0iMi42NDMiLz48cGF0aCBkPSJNMjEgMjQuMmMxLjAyIDQuNjU5LTIuNzUgMTQuNTg4LTkuNTE0IDE1LjI5OU0zMC43NCAyNi44MDFjMS43NjQgMS44MzcgMy44ODUgMTQuMzIxLTEuNTgyIDIwLjE5OU0yNS4zMjMgMjkuMDA0YzEuMDExIDQuNjYxIDEuNDA2IDEzLjYyMi04LjQ1IDE3LjgxNiIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjUuMzk5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48Y2lyY2xlIGN4PSIxOS43NzYiIGN5PSIxNy44ODciIHI9IjEuNDE2IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMzEuNjM4IiBjeT0iMTcuODg3IiByPSIxLjQxNiIgZmlsbD0iIzAwMCIvPjwvZz48ZGVmcz48Y2xpcFBhdGggaWQ9ImEiPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0wIDBoNTJ2NTJIMHoiLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4=", L = { id: d.INKEY, chain: "algorand", name: "Inkey Microwallet", icon: te, pkg: "@thencc/inkey-client-js" };
var E = (_c = class extends y {
  constructor({ sdk: e }) {
    super();
    __publicField(this, "sdk");
    this.sdk = e;
  }
  static async init(e) {
    try {
      let t;
      if (e && e.sdk)
        t = e.sdk;
      else {
        let i, n = { src: "https://inkey.app", align: "center" };
        i = (e == null ? void 0 : e.config) || n;
        let r = await __vitePreload(() => import("./index.esm-144aec08.js"), true ? [] : void 0, import.meta.url);
        t = await (r.createClient || r.default.createClient)(i);
      }
      return await new Promise((i) => setTimeout(i, 600)), new _c({ sdk: t });
    } catch (t) {
      return console.warn(`[${L.id}] Error initializing...`, t), null;
    }
  }
  async connect(e) {
    let t = await this.sdk.connect(e);
    if (!t)
      throw new Error("no inkeyAccounts");
    if (t.length === 0)
      throw new Error(`No accounts found for ${L.id}`);
    return (e == null ? void 0 : e.onDisconnect) && this.sdk.frameBus.setOnDisconnect(e.onDisconnect), t.map((i) => ({ name: i.name, address: i.address, walletId: L.id, chain: L.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(e, t) {
    let i = t.map((M) => decodeObj(M)), r = i.reduce((M, c, I) => {
      let w = e.map((T) => T.address);
      return !("txn" in c) && w.includes(encodeAddress(c.snd)) && M.push(t[I]), M;
    }, []).map((M) => J(M)), a = await this.sdk.signTxns(r, e);
    if (!a.success)
      throw new Error("Error signing transactions");
    let s = a.signedTxns;
    return i.reduce((M, c, I) => {
      if ("txn" in c)
        M.push(t[I]);
      else {
        let w = s.shift();
        w && M.push(w);
      }
      return M;
    }, []);
  }
}, u(_c, "InkeyClient"), __publicField(_c, "metadata", L), _c);
var oe$1 = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHBhdGggZmlsbD0iIzI0NUVDNiIgZD0iTTE2LDMyYy0zLjIsMC02LjItMC45LTguOS0yLjdjLTIuNi0xLjgtNC43LTQuMy01LjktNy4yQzAsMTkuMi0wLjMsMTYsMC4zLDEyLjlDMC45LDkuOCwyLjQsNyw0LjcsNC43IEM2LjIsMy4yLDcuOSwyLDkuOSwxLjJDMTEuOCwwLjQsMTMuOSwwLDE2LDBzNC4yLDAuNCw2LjEsMS4yYzEuOSwwLjgsMy43LDIsNS4yLDMuNXMyLjcsMy4zLDMuNSw1LjJjMC44LDEuOSwxLjIsNCwxLjIsNi4xIHMtMC40LDQuMi0xLjIsNi4xYy0wLjgsMS45LTIsMy43LTMuNSw1LjJjLTEuNSwxLjUtMy4yLDIuNy01LjIsMy41QzIwLjIsMzEuNiwxOC4xLDMyLDE2LDMyTDE2LDMyeiBNMjAuMiwxMS4ybDAuMSwwLjVsMi42LDkuNWgyLjEgTDIxLjUsOC45bC0wLjEtMC4zaC0xLjlsMCwwLjFsLTEuNywzLjFMMTYsMTQuOWwwLDAuMWwwLTAuMWwtMC4yLTAuOGwtMC42LTIuNGwtMC4xLTAuMmwtMC43LTIuNmwtMC4xLTAuM2gtMS45bDAsMC4xbC0xLjcsMy4xIGwtMS44LDMuMkw3LjEsMThsLTEuOCwzLjJoMi4xTDkuMiwxOGwxLjgtMy4ybDEuOC0zLjJsMC4zLTAuNWwwLjEsMC41bDAuNSwyLjFsMC43LDIuNmwwLjIsMC45TDE0LjIsMThsLTEuOCwzLjJoMi4xbDAuOC0xLjMgbDEuMy0yLjNsMS41LTIuN2wxLjgtMy4yTDIwLjIsMTEuMkwyMC4yLDExLjJ6Ii8+Cjwvc3ZnPgo=", f = { id: d.MYALGO, chain: "algorand", name: "MyAlgo", icon: oe$1, pkg: "@randlabs/myalgo-connect" };
var S = (_d = class extends y {
  constructor({ sdk: e }) {
    super();
    __publicField(this, "sdk");
    this.sdk = e;
  }
  static async init(e) {
    try {
      let t;
      if (e && e.sdk)
        t = e.sdk;
      else {
        let i, n = { disableLedgerNano: false };
        i = (e == null ? void 0 : e.config) || n;
        let r = await __vitePreload(() => Promise.resolve().then(() => index$1), true ? void 0 : void 0, import.meta.url);
        window.Buffer || (window.Buffer = r.Buffer || r.default.Buffer);
        let s = (await __vitePreload(() => import("./index-35f2ef62.js").then((n2) => n2.i), true ? [] : void 0, import.meta.url)).default;
        t = new s(i);
      }
      return t = t, new _d({ sdk: t });
    } catch (t) {
      return console.error(`[${f.id}] Error initializing...`, t), null;
    }
  }
  async connect() {
    let e = await this.sdk.connect();
    if (e.length === 0)
      throw new Error(`No accounts found for ${f.id}`);
    return e.map((t) => ({ ...t, walletId: f.id, chain: f.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
  }
  async signTransactions(e, t) {
    let i = t.map((s) => decodeObj(s)), n = i.reduce((s, g, M) => {
      let c = e.map((I) => I.address);
      return !("txn" in g) && c.includes(encodeAddress(g.snd)) && s.push(t[M]), s;
    }, []), r = await this.sdk.signTransaction(n);
    return i.reduce((s, g, M) => {
      var _a3;
      if ("txn" in g)
        s.push(t[M]);
      else {
        let c = (_a3 = r.shift()) == null ? void 0 : _a3.blob;
        c && s.push(c);
      }
      return s;
    }, []);
  }
}, u(_d, "MyAlgoClient"), __publicField(_d, "metadata", f), _d);
var re = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjM4IiBoZWlnaHQ9IjIzOCIgdmlld0JveD0iMCAwIDIzOCAyMzgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01MS43MDUgMTQ1LjA0MkgxMTYuNzA1TDEwNy43MDUgMTU1LjA0Mkg1MS43MDVWMTQ1LjA0MloiIGZpbGw9IiNENjQ1MDAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNDcuNTE5IDE5MS41NTdMMTI5LjU3NyAxNDQuMzk0TDE0Mi40MDQgMTI3LjExMkwxNjcuODc1IDE5MS41NTdIMTQ3LjUxOVpNMTEwLjkzNiA5NS4zOTMyTDEyMC42MTMgMTIwLjgzMUwxMzMuMzU5IDEwNC4yMjhMMTE3LjQ3NSA2NC4wNDIyQzExNS45MjggNjAuMTI4IDExMi4xNDYgNTcuNTU2NSAxMDcuOTM4IDU3LjU1NjVDMTAzLjcyOSA1Ny41NTY1IDk5Ljk0NzQgNjAuMTI4IDk4LjQwMDMgNjQuMDQyMkw2Ny45NjU5IDE0MS4wNDJIODcuNzgwN0M5NS40MTUzIDEyMS4wMTEgMTAyLjg5MyAxMDEuMzk5IDEwNS4xOTggOTUuMzU0MUMxMDUuNjQxIDk0LjE5MTIgMTA2Ljc0MyA5My40NTk5IDEwNy45ODcgOTMuNDU5OUgxMDguMTMyQzEwOS4zNzggOTMuNDU5OSAxMTAuNDkzIDk0LjIyOTMgMTEwLjkzNiA5NS4zOTMyWk04MC45MjEgMTU5LjA0MkM3NC45Mjg5IDE3NC43NjggNjkuODY2MSAxODguMDYzIDY4LjU0NDcgMTkxLjU1N0g0OEw2MC44NTE0IDE1OS4wNDJIODAuOTIxWiIgZmlsbD0iIzIyMkI2MCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3Ni4wMjYgNTQuNzUwOUMxNzcuOTk3IDUyLjA4NzIgMTgxLjc1NCA1MS41MjU3IDE4NC40MTggNTMuNDk2N0MxODcuMDgyIDU1LjQ2NzggMTg3LjY0MyA1OS4yMjUxIDE4NS42NzIgNjEuODg4OEwxMzAuMDEzIDEzNy4xMDdDMTI5LjcxNCAxMzcuNTEyIDEyOS4zNDEgMTM3Ljg1NyAxMjguOTEzIDEzOC4xMjNMMTE3Ljg1NiAxNDUuMDEzQzExNy4wODcgMTQ1LjQ5MyAxMTYuMTI4IDE0NC43ODMgMTE2LjM2MSAxNDMuOTA3TDExOS43MTggMTMxLjMxOEMxMTkuODQ3IDEzMC44MzIgMTIwLjA2OCAxMzAuMzc0IDEyMC4zNjcgMTI5Ljk3TDE3MC42NyA2MS45ODlMMTY5LjkyOSA2MS40NDA1QzE2OS40ODUgNjEuMTEyIDE2OC44NTkgNjEuMjA1NiAxNjguNTMgNjEuNjQ5NkwxNTIuMzExIDgzLjU2ODhDMTUyLjU4NiA4NC4yMDIzIDE1Mi41MjQgODQuOTYxMiAxNTIuMDg0IDg1LjU1NjJMMTQ5LjExIDg5LjU3NTVDMTQ4LjQ1MyA5MC40NjM0IDE0Ny4yMDEgOTAuNjUwNiAxNDYuMzEzIDg5Ljk5MzZDMTQ1LjQyNSA4OS4zMzY2IDE0NS4yMzggODguMDg0MSAxNDUuODk1IDg3LjE5NjJMMTQ3LjY3OSA4NC43ODQ3TDE0OC44NjkgODMuMTc2OUwxNjcuMzA4IDU4LjI1NzRDMTY4LjYyMiA1Ni40ODE1IDE3MS4xMjcgNTYuMTA3MiAxNzIuOTAzIDU3LjQyMTJMMTczLjY0NCA1Ny45Njk3TDE3Ni4wMjYgNTQuNzUwOVoiIGZpbGw9IiNENjQ1MDAiLz4KPC9zdmc+Cg==", C = { id: d.ALGOSIGNER, chain: "algorand", name: "AlgoSigner", icon: re, pkg: "" };
var ue = u((o) => o === "betanet" ? "BetaNet" : o === "testnet" ? "TestNet" : o === "mainnet" ? "MainNet" : o, "getNetwork"), z = (_e = class extends y {
  constructor({ sdk: e, network: t }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "network");
    this.sdk = e, this.network = t;
  }
  static async init(e) {
    var _a3;
    try {
      if (typeof window > "u" || window.AlgoSigner === void 0)
        throw new Error("AlgoSigner is not available.");
      let t = window.AlgoSigner, i = "mainnet";
      return ((_a3 = e == null ? void 0 : e.config) == null ? void 0 : _a3.network) && (e.config.network == "mainnet" || e.config.network == "testnet" || e.config.network == "betanet" ? i = e.config.network : console.warn(`invalid network in ${C.id} config`)), new _e({ sdk: t, network: i });
    } catch (t) {
      return console.error("Error initializing...", t), null;
    }
  }
  async connect() {
    await this.sdk.connect();
    let e = await this.sdk.accounts({ ledger: ue(this.network) });
    if (e.length === 0)
      throw new Error(`No accounts found for ${C.id}`);
    return e.map(({ address: i }, n) => ({ name: `AlgoSigner Account ${n + 1}`, address: i, walletId: C.id, chain: C.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(e) {
    return (window === void 0 || window.AlgoSigner === void 0) && e(), null;
  }
  async disconnect() {
  }
  async signTransactions(e, t) {
    let n = t.map((s) => decodeObj(s)).reduce((s, g, M) => {
      let c = { txn: this.sdk.encoding.msgpackToBase64(t[M]) }, I = e.map((w) => w.address);
      return ("txn" in g || !I.includes(encodeAddress(g.snd))) && (c.txn = this.sdk.encoding.msgpackToBase64(decodeSignedTransaction(t[M]).txn.toByte()), c.signers = []), s.push(c), s;
    }, []);
    return (await this.sdk.signTxn(n)).reduce((s, g, M) => (g ? s.push(new Uint8Array(buffer.Buffer.from(g.blob, "base64"))) : s.push(t[M]), s), []);
  }
}, u(_e, "AlgoSignerClient"), __publicField(_e, "metadata", C), _e);
var ge = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMDAgMzAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMDAgMzAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6dXJsKCNTVkdJRF8xXyk7fQoJLnN0MXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNDM0MjYxNjcxNDAxMDY1ODIyNzAwMDAwMDIxMzA3Njg5MDYwNzMxMTM0ODRfKTt9Cgkuc3Qye2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEwMjUxOTMxNjAxNTI3NjU4MTY0MDAwMDAxNjI3NDExMjM4MzE3NTY0MTc1OV8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTt9Cgkuc3Qze2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEzODU2MzM4MjQ2MjA4NjAyMDM1MDAwMDAxNDg3ODQ5MDI3MDc4MjA3MTIwN18pO30KCS5zdDR7bWFzazp1cmwoI21hc2swXzE2NjFfMjk1XzAwMDAwMDg4MTMyMjUxNTk3NDQxNTczNDkwMDAwMDExNjkzNjEyMDE4NTA2NjgxNDgxXyk7fQoJLnN0NXtmaWxsOnVybCgjU1ZHSURfMDAwMDAxMDYxMjA2MzI0NjE3OTI4NzExNjAwMDAwMDc0MzM5MTMwMzgzMzc3NjY1NzZfKTt9Cjwvc3R5bGU+CjxnPgoJCgkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDYuNjAzIiB5MT0iOS4yMjEyIiB4Mj0iMTc0LjE1OCIgeTI9IjMwOC41NDI2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xCgkJTDI3NC43LDkzLjl6Ii8+CgkKCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMjkuMzUxNiIgeTE9Ii0xOS4xNTczIiB4Mj0iNTYuOTA2NiIgeTI9IjI4MC4xNjQxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1Xyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCWw2OS4yLTQ1LjFWMjNMMjUuMyw5My45TDQzLDE1MC4xbC0xNy43LDU2LjJMMTMzLjcsMjc3di0zOS42bC02OS40LTQ1LjFMNzIuNSwxNjYuNHoiLz4KCTxkZWZzPgoJCTxmaWx0ZXIgaWQ9IkFkb2JlX09wYWNpdHlNYXNrRmlsdGVyIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ij4KCQkJPGZlQ29sb3JNYXRyaXggIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIxIDAgMCAwIDAgIDAgMSAwIDAgMCAgMCAwIDEgMCAwICAwIDAgMCAxIDAiLz4KCQk8L2ZpbHRlcj4KCTwvZGVmcz4KCQoJCTxtYXNrIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0IiBpZD0ibWFzazBfMTY2MV8yOTVfMDAwMDAwODgxMzIyNTE1OTc0NDE1NzM0OTAwMDAwMTE2OTM2MTIwMTg1MDY2ODE0ODFfIj4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjQ2LjYwMzgiIHkxPSI5LjIyMTQiIHgyPSIxNzQuMTU4OCIgeTI9IjMwOC41NDI4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwQjQ2RjkiLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JCRkJFMCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJPHBhdGggc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTsiIGQ9IgoJCQlNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xTDI3NC43LDkzLjl6Ii8+CgkJCgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMTk4MTE3MDc2MjE0NzI4MTQyNzAwMDAwMTA4Mjk2NTkzODM4NTEyMDI0OTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyOS4zNTIxIiB5MT0iLTE5LjE1NzEiIHgyPSI1Ni45MDcxIiB5Mj0iMjgwLjE2NDIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAzMDIpIj4KCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQkJGQkUwIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCQk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTE5ODExNzA3NjIxNDcyODE0MjcwMDAwMDEwODI5NjU5MzgzODUxMjAyNDkxXyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCQlsNjkuMi00NS4xVjIzTDI1LjMsOTMuOUw0MywxNTAuMWwtMTcuNyw1Ni4yTDEzMy43LDI3N3YtMzkuNmwtNjkuNC00NS4xTDcyLjUsMTY2LjR6Ii8+Cgk8L21hc2s+Cgk8ZyBjbGFzcz0ic3Q0Ij4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDEwOTAxOTkxODU1Nzc3MzA1MzQyMDAwMDAxNzYwMjQwNTkwODA2NzEyMDMwMF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDYuNDY2MiIgeTE9IjIyOC43NTU0IiB4Mj0iMTcxLjg2MzgiIHkyPSIxMzUuMTAzOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDMwMikiPgoJCQk8c3RvcCAgb2Zmc2V0PSIwLjExOTgiIHN0eWxlPSJzdG9wLWNvbG9yOiM4OTUyRkY7c3RvcC1vcGFjaXR5OjAuODciLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0RBQkRGRjtzdG9wLW9wYWNpdHk6MCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJCgkJCTxyZWN0IHg9IjI1LjQiIHk9IjIzIiBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTA5MDE5OTE4NTU3NzczMDUzNDIwMDAwMDE3NjAyNDA1OTA4MDY3MTIwMzAwXyk7IiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ii8+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", x = { id: d.EXODUS, chain: "algorand", name: "Exodus", icon: ge, pkg: "" };
var h = (_f = class extends y {
  constructor({ sdk: e, onlyIfTrusted: t }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "onlyIfTrusted");
    this.sdk = e, this.onlyIfTrusted = t;
  }
  static async init(e) {
    var _a3, _b2;
    try {
      if (typeof window > "u" || window.exodus === void 0)
        throw new Error("Exodus is not available. Do you have the browser extension installed?");
      let t = window.exodus.algorand, i = false;
      return ((_a3 = e == null ? void 0 : e.config) == null ? void 0 : _a3.onlyIfTrusted) && (i = (_b2 = e == null ? void 0 : e.config) == null ? void 0 : _b2.onlyIfTrusted), new _f({ sdk: t, onlyIfTrusted: i });
    } catch (t) {
      return console.error("Error initializing...", t), null;
    }
  }
  async connect() {
    let e = "";
    try {
      let { address: t } = await window.exodus.algorand.connect({ onlyIfTrusted: this.onlyIfTrusted });
      e = t;
    } catch (t) {
      throw console.warn("err w exodus connect"), t;
    }
    if (!e)
      throw new Error(`No accounts found for ${x.id}`);
    return [{ name: `Exodus Account ${(/* @__PURE__ */ new Date()).getTime()}`, address: e, walletId: x.id, chain: x.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }];
  }
  async reconnect(e) {
    return (window === void 0 || window.exodus === void 0 || window.exodus.algorand.isConnected !== true) && e(), null;
  }
  async disconnect() {
    window.exodus.algorand.disconnect();
  }
  async signTransactions(e, t, i, n = true) {
    let r = t.map((c) => decodeObj(c)), a = [], s = r.reduce((c, I, w) => {
      let T = "txn" in I, Y = e.map((U) => U.address);
      return (i && i.length && i.includes(w) || !T && Y.includes(encodeAddress(I.snd))) && (a.push(w), c.push(t[w])), c;
    }, []), g = await window.exodus.algorand.signTransaction(s);
    return t.reduce((c, I, w) => {
      if (a.includes(w)) {
        let T = g.shift();
        T && c.push(T);
      } else
        n && c.push(t[w]);
      return c;
    }, []);
  }
}, u(_f, "ExodusClient"), __publicField(_f, "metadata", x), _f);
var ye = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiLz4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNjgyMDksMCwwLDEuNjgyMDksMjI2LjM2OCwyMTIuODE4KSI+CiAgICAgICAgPHBhdGggZD0iTTMyNy4wNDksMjgwLjE5MkwxNjkuNTI0LDEzTDEyLDI4MC4xOTJMMTY5LjUyNCwxODkuMDg0TDMyNy4wNDksMjgwLjE5MloiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvOyIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS42ODIwOSwwLDAsMS42ODIwOSwyMjYuMzY4LDIxMi44MTgpIj4KICAgICAgICA8cGF0aCBkPSJNMjk5LjU0NiwzMDdMMTY5LjUyNSwyMzguNDczTDM5LjUwNCwzMDdMMTY5LjUyNSwyNjQuNjdMMjk5LjU0NiwzMDdaIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybzsiLz4KICAgIDwvZz4KPC9zdmc+Cg==", j = { id: d.DEFLY, chain: "algorand", name: "Defly", icon: ye, pkg: "@blockshake/defly-connect" };
var b = (_g = class extends y {
  constructor({ sdk: e }) {
    super();
    __publicField(this, "sdk");
    this.sdk = e;
  }
  static async init(e) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let t;
      if (e && e.sdk)
        t = e.sdk;
      else {
        let i, n = { shouldShowSignTxnToast: false };
        i = (e == null ? void 0 : e.config) || n;
        let r = await __vitePreload(() => import("./index-4f27b3d8.js").then((n2) => n2.i), true ? ["./index-4f27b3d8.js","./qr-code-styling-87721598.js","./algosdk.min-e134c54c.js","./lottie-b035792e.js"] : void 0, import.meta.url), a = r.DeflyWalletConnect || r.default.DeflyWalletConnect;
        t = new a(i);
      }
      return new _g({ sdk: t });
    } catch (t) {
      return console.error("Error initializing...", t), null;
    }
  }
  async connect(e) {
    let t = await this.sdk.connect().catch(console.info);
    if (this.sdk.connector.on("disconnect", e), !t || t.length === 0)
      throw new Error(`No accounts found for ${j.id}`);
    return t.map((i, n) => ({ name: `Defly Account ${n + 1}`, address: i, walletId: j.id, chain: j.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(e) {
    var _a3;
    let t = await this.sdk.reconnectSession().catch(console.info);
    return (_a3 = this.sdk.connector) == null ? void 0 : _a3.on("disconnect", e), t ? t.map((i, n) => ({ name: `Defly Account ${n + 1}`, address: i, walletId: j.id, chain: j.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() })) : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(e, t) {
    let i = t.map((s) => decodeObj(s)), n = i.reduce((s, g, M) => {
      let c = e.map((I) => I.address);
      return !("txn" in g) && c.includes(encodeAddress(g.snd)) ? s.push({ txn: decodeUnsignedTransaction(t[M]) }) : s.push({ txn: decodeSignedTransaction(t[M]).txn, signers: [] }), s;
    }, []), r = await this.sdk.signTransaction([n]);
    return i.reduce((s, g, M) => {
      if ("txn" in g)
        s.push(t[M]);
      else {
        let c = r.shift();
        c && s.push(c);
      }
      return s;
    }, []);
  }
}, u(_g, "DeflyClient"), __publicField(_g, "metadata", j), _g);
var Ae = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e %3c!-- Generated by Pixelmator Pro 3.2.2 --%3e %3csvg width='409' height='210' viewBox='0 0 409 210' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctext id='MNEMONIC' xml:space='preserve' x='0' y='129' font-family='Helvetica' font-size='72' fill='black'%3eMNEMONIC%3c/text%3e%3c/svg%3e", O = { id: d.MNEMONIC, name: "Mnemonic", icon: Ae, chain: "algorand", pkg: "" };
var W = (_h = class extends y {
  constructor({ sdk: e }) {
    super();
    __publicField(this, "sdk");
    this.sdk = e;
  }
  static async init(e) {
    try {
      let t;
      if (e)
        if (typeof e == "string")
          t = mnemonicToSecretKey(e);
        else if (typeof e == "object") {
          if (e.sdk)
            t = e.sdk;
          else if (e.config && e.config.mnemonic) {
            let i = e.config.mnemonic;
            t = mnemonicToSecretKey(i);
          }
        } else
          throw new Error("bad initParams for mnemonic client");
      else
        console.error("mnemonic wallet needs to be inited w a mnemonic - none provided.");
      return new _h({ sdk: t });
    } catch (t) {
      return console.error("Error initializing...", t), null;
    }
  }
  async connect() {
    var _a3;
    return this.sdk == null && console.warn("mnemonic client wasnt initialized properly... no mnemonic passed in so cannot connect."), [{ name: `Mnemonic Account ${(/* @__PURE__ */ new Date()).getTime()}`, address: ((_a3 = this.sdk) == null ? void 0 : _a3.addr) || "", walletId: O.id, chain: O.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }];
  }
  async disconnect() {
    this.sdk = void 0;
  }
  async reconnect() {
    return null;
  }
  async signTransactions(e, t, i, n = true) {
    if (this.sdk || await this.connect(), !this.sdk)
      throw new Error("Client could not init");
    let r = t.map((c) => decodeObj(c)), a = [], s = [];
    for (let c in r) {
      let I = r[c], w = "txn" in I, T = e.map((X) => X.address);
      if (a.push(t[c]), w)
        continue;
      if (i && i.length && !i.includes(Number(c)))
        continue;
      if (!T.includes(encodeAddress(I.snd)))
        continue;
      a[c] = new Uint8Array();
      let U = Transaction$1.from_obj_for_encoding(I).signTxn(this.sdk.sk);
      s.push(U);
    }
    let g = 0, M = a.reduce((c, I, w) => (I.length === 0 ? (c.push(s[g]), g += 1) : n && c.push(I), c), []);
    return Promise.resolve(M);
  }
}, u(_h, "MnemonicClient"), __publicField(_h, "metadata", O), _h);
var m = { [d.PERA]: { client: k }, [d.INKEY]: { client: E }, [d.MYALGO]: { client: S }, [d.ALGOSIGNER]: { client: z }, [d.EXODUS]: { client: h }, [d.DEFLY]: { client: b }, [d.MNEMONIC]: { client: W } };
Object.values(m).map((o) => o.client.metadata.id);
Object.values(m).map((o) => o.client.metadata.pkg).filter((o) => o !== "");
u((o) => {
  let e = [];
  for (let t of o)
    e.push(m[t].client.metadata.pkg);
  return e;
}, "excludeClients");
var D = u((o, e, t = true) => {
  l.debug("createWallet", o, e);
  const _i3 = class _i3 {
    constructor() {
      __publicField(this, "id", e);
      __publicField(this, "metadata", m[e].client.metadata);
      __publicField(this, "client", null);
      __publicField(this, "initParams", t);
      __publicField(this, "inited", false);
      __publicField(this, "initing", false);
      __publicField(this, "signing", false);
      __publicField(this, "connecting", false);
      __publicField(this, "loadClient", async () => (l.debug("loadClient:", e), n.inited ? (l.debug("aw already inited client"), true) : (n.initing = true, typeof n.initParams == "string" ? n.client = await m[e].client.init(n.initParams) : typeof n.initParams == "object" && (n.initParams.config || n.initParams.sdk) ? n.client = await m[e].client.init(n.initParams) : t == true ? n.client = await m[e].client.init() : console.warn("Bad/incomplete init params for wallet:", e), n.initing = false, n.inited = true, true)));
      __publicField(this, "unloadClient", async () => {
        var _a3;
        await ((_a3 = n.client) == null ? void 0 : _a3.disconnect()), n.inited = false;
      });
      __publicField(this, "connect", async (a) => {
        n.connecting = true;
        try {
          if (await n.loadClient(), n.accounts) {
            a == null && (a = {});
            let g = toJS(n.accounts);
            a.connectedAccounts = [...g];
          }
          let s = await n.client.connect(a);
          return o.addConnectedAccounts(s), o.setAsActiveAccount(s[0]), s;
        } catch (s) {
          throw s;
        } finally {
          n.connecting = false;
        }
      });
      __publicField(this, "disconnect", async () => {
        l.debug("disconnect", n.id), n.removeAccounts(), await n.loadClient();
        try {
          await n.unloadClient();
        } catch (a) {
          console.warn(a);
        }
      });
      __publicField(this, "reconnect", async () => {
        await n.loadClient(), await n.client.reconnect(() => {
        });
      });
      __publicField(this, "setAsActiveWallet", () => {
        let a = o.getAccountsByWalletId(e);
        if (a)
          o.setAsActiveAccount(a[0]);
        else
          throw new Error("No accounts for this provider to set as active");
      });
      __publicField(this, "removeAccounts", () => {
        o.removeAccountsByWalletId(e);
      });
      __publicField(this, "signTransactions", async (a) => {
        await n.loadClient();
        let s = toJS(n.accounts);
        s.length || (s = await n.connect(), await new Promise((M) => setTimeout(M, 1e3))), n.signing = true;
        try {
          return await n.client.signTransactions(s, a);
        } catch (g) {
          throw g;
        } finally {
          n.signing = false;
        }
      });
      makeAutoObservable(this);
    }
    get accounts() {
      return o.getAccountsByWalletId(e);
    }
    get isConnected() {
      return o.connectedAccounts.some((a) => a.walletId === e);
    }
    get isActive() {
      var _a3;
      return ((_a3 = o.activeAccount) == null ? void 0 : _a3.walletId) === e;
    }
  };
  u(_i3, "AWallet");
  let i = _i3;
  let n = new i();
  return n;
}, "createWallet"), R = u(async (o, e) => {
  if (l.log("signTransactions", e), !o.activeAccount)
    throw new Error("No active account to sign txns with.");
  let t = o.activeWallet;
  if (!t)
    throw new Error("No active wallet... how'd you get here.");
  return await t.signTransactions(e);
}, "signTransactions");
u((o) => {
  l.enabled = o;
}, "setLogsEnabled");
var P = false, H = (_i2 = class {
  constructor(e) {
    __publicField(this, "allWallets", { [d.PERA]: D(this, d.PERA), [d.INKEY]: D(this, d.INKEY), [d.MYALGO]: D(this, d.MYALGO), [d.ALGOSIGNER]: D(this, d.ALGOSIGNER), [d.EXODUS]: D(this, d.EXODUS), [d.DEFLY]: D(this, d.DEFLY), [d.MNEMONIC]: D(this, d.MNEMONIC) });
    __publicField(this, "activeAccount");
    __publicField(this, "connectedAccounts");
    __publicField(this, "changedAccountHandlers", /* @__PURE__ */ new Set());
    __publicField(this, "arr", observable.array([]));
    __publicField(this, "selfId", `${Math.random()}_${(/* @__PURE__ */ new Date()).getTime()}`);
    __publicField(this, "storageKey");
    __publicField(this, "storageController");
    __publicField(this, "emitSyncStates", () => {
      if (l.log("emitSyncStates"), p()) {
        if (!P) {
          let e = new CustomEvent("aw-state-change", { detail: { from: this.selfId } });
          l.log("dispatching c evt", e), window.top.dispatchEvent(e);
        }
      } else
        console.warn("Not in browser, no access to Window. Will not dispatch custom event");
    });
    __publicField(this, "setAsActiveAccount", (e) => {
      l.debug("setAsActiveAccount", e), e.active = true, e.dateLastActive = (/* @__PURE__ */ new Date()).getTime(), this.activeAccount = e, this.connectedAccounts.forEach((t) => {
        t.walletId == e.walletId && t.address == e.address && t.name == e.name ? t.active = true : t.active = false;
      });
    });
    __publicField(this, "removeAccount", (e) => {
      if (this.activeAccount) {
        let n = this.connectedAccounts.filter((r) => r.walletId == e.walletId && r.name == e.name && r.address == e.address);
        for (let r of n)
          if (r.address == this.activeAccount.address && r.walletId == this.activeAccount.walletId) {
            this.activeAccount = null;
            break;
          }
      }
      let t = this.connectedAccounts, i = t.findIndex((n) => n.walletId == e.walletId && n.address == e.address && n.name == e.name);
      t.splice(i, 1), this.connectedAccounts = t;
    });
    __publicField(this, "removeAllAccounts", () => {
      this.activeAccount = null, this.connectedAccounts = [];
    });
    __publicField(this, "removeAccountsByWalletId", (e) => {
      if (l.debug("removeAccountsByWalletId", e), this.activeAccount) {
        let i = this.connectedAccounts.filter((n) => n.walletId == e);
        for (let n of i)
          if (n.address == this.activeAccount.address && n.walletId == this.activeAccount.walletId) {
            this.activeAccount = null;
            break;
          }
      }
      let t = this.connectedAccounts.filter((i) => i.walletId !== e);
      this.connectedAccounts = t;
    });
    __publicField(this, "getAccountsByWalletId", (e) => this.connectedAccounts.filter((t) => t.walletId === e));
    __publicField(this, "initWallet", (e, t) => {
      let i = this.allWallets[e];
      if (!i)
        throw new Error(`Unknown wallet: ${e}`);
      return t !== void 0 ? i.initParams = t : l.log("didnt update wallet's init params... kept whatever existed before"), i;
    });
    __publicField(this, "initWallets", (e) => {
      l.log("initWallets started", e);
      for (let [t, i] of Object.entries(e)) {
        let n = t;
        this.initWallet(n, i);
      }
      return this.allWallets;
    });
    __publicField(this, "connectWallet", async (e, t) => {
      t !== void 0 && this.initWallet(e, t);
      let i = this.allWallets[e];
      if (!i)
        throw new Error(`Unknown wallet: ${e}`);
      return await i.connect();
    });
    __publicField(this, "disconnectWallet", async (e) => {
      let t = this.allWallets[e];
      if (!t)
        throw new Error(`Unknown wallet: ${e}`);
      if (t.isConnected)
        return await t.disconnect();
      l.debug("disconnectWallet > wallet not connected:", e);
    });
    __publicField(this, "disconnectAllWallets", async () => {
      l.debug("disconnectAllWallets"), Object.values(this.allWallets).forEach(async (e) => {
        await this.disconnectWallet(e.id);
      });
    });
    __publicField(this, "signTransactions", async (e) => await R(this, e));
    __publicField(this, "subscribeToAccountChanges", (e, t = { callOnSet: true }) => (this.changedAccountHandlers.add(e), t.callOnSet && e(this.activeAccount), u(() => {
      this.changedAccountHandlers.delete(e);
    }, "unsubscribe")));
    this.initVars(), makeAutoObservable(this, { arr: observable.deep, connectedAccounts: observable.deep, activeAccount: observable, allWallets: false, changedAccountHandlers: false }, { deep: true }), e && (ke(this), e.storageKey && (this.storageKey = e.storageKey, e.storageController ? this.storageController = e.storageController : e.storageKey && (p() ? this.storageController = window.localStorage : console.warn("Provide a storageController if you want to persist state outside browser.")), makePersistable(this, { name: this.storageKey, properties: [{ key: "activeAccount", serialize: (t) => toJS(t), deserialize: (t) => observable(t) }, { key: "connectedAccounts", serialize: (t) => toJS(t), deserialize: (t) => observable.array(t) }, { key: "arr", serialize: (t) => toJS(t), deserialize: (t) => observable.array(t) }], storage: this.storageController }).then((t) => {
      l.log("pStore inited", t), Ee(this, t);
    })));
  }
  initVars() {
    l.log("initVars"), this.activeAccount = null, this.connectedAccounts = [], this.arr = observable.array([]);
  }
  addConnectedAccounts(e) {
    l.log("addConnectedAccounts", e);
    for (let t of e) {
      let i = false;
      for (let n of this.connectedAccounts)
        t.walletId == n.walletId && t.address == n.address && (i = true);
      i || this.connectedAccounts.push(t);
    }
  }
  get activeAddress() {
    let e = "";
    return this.activeAccount && (e = this.activeAccount.address), e;
  }
  get activeWalletId() {
    let e = null;
    return this.activeAccount && (e = this.activeAccount.walletId), e;
  }
  get activeWallet() {
    let e;
    return this.activeWalletId !== null && (e = this.allWallets[this.activeWalletId]), e;
  }
  get isSigning() {
    let e = false;
    for (let [t, i] of Object.entries(this.allWallets))
      if (i.signing) {
        e = true;
        break;
      }
    return e;
  }
  get isIniting() {
    let e = false;
    for (let [t, i] of Object.entries(this.allWallets))
      if (i.initing) {
        e = true;
        break;
      }
    return e;
  }
}, u(_i2, "AnyWalletState"), _i2), V = u((o, e) => {
  l.log("resetStore", o.selfId), e.pausePersisting(), o.initVars(), setTimeout(() => {
    e.startPersisting();
  }, 100);
}, "resetStore"), ke = u((o) => {
  l.log("initWatchers", o.selfId), observe(o, () => {
    l.log("observed"), o.emitSyncStates();
  }), reaction(() => o.activeAccount, async (e) => {
    l.log("activeAccount changed", e), o.changedAccountHandlers.forEach((t) => t(e)), o.emitSyncStates();
  }), observe(o.connectedAccounts, (e) => {
    l.log("connectedAccounts observed", e), o.emitSyncStates();
  }), reaction(() => o.connectedAccounts.length, async (e) => {
    l.log("connectedAccounts length change"), o.emitSyncStates();
  }), observe(o.arr, (e) => {
    l.log("arr observed", e), o.emitSyncStates();
  }), reaction(() => o.arr.length, async (e) => {
    l.log("arr length change"), o.emitSyncStates();
  });
}, "initWatchers"), Ee = u((o, e) => {
  l.log("initListeners", o.selfId), p() ? (window.top.addEventListener("aw-state-change", async (t) => {
    l.log("caught aw-state-change evt", t), t.detail.from !== o.selfId && (P = true, setTimeout(async () => {
      l.log("timeout hyd store"), await e.hydrateStore(), setTimeout(() => {
        P = false;
      }, 10);
    }, 10));
  }, false), window.addEventListener("storage", (t) => {
    if (l.log("storage evt", t), t.key == null)
      V(o, e);
    else if (t.key == o.storageKey)
      if (t.newValue == null)
        V(o, e);
      else {
        let i = t.newValue, n = JSON.parse(i);
        l.log("newVObj", n), l.log("pausingPersist"), e.pausePersisting();
        for (let r in n) {
          let a = n[r];
          l.log(`${r}: ${a}`), o[r] = a;
        }
        setTimeout(() => {
          l.log("startPersist"), e.startPersisting();
        }, 10);
      }
  }, false)) : console.warn("No attaching Window event listeners (aw-state-change, dom storage)");
}, "initListeners");
var $p = Object.create;
var Fc = Object.defineProperty, Vp = Object.defineProperties, Gp = Object.getOwnPropertyDescriptor, Wp = Object.getOwnPropertyDescriptors, Kp = Object.getOwnPropertyNames, Sc = Object.getOwnPropertySymbols, Hp = Object.getPrototypeOf, Uu = Object.prototype.hasOwnProperty, hl = Object.prototype.propertyIsEnumerable;
var Lu = (r, e, t) => e in r ? Fc(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t, at = (r, e) => {
  for (var t in e || (e = {}))
    Uu.call(e, t) && Lu(r, t, e[t]);
  if (Sc)
    for (var t of Sc(e))
      hl.call(e, t) && Lu(r, t, e[t]);
  return r;
}, Er = (r, e) => Vp(r, Wp(e));
var pl = ((r) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, { get: (e, t) => (typeof require != "undefined" ? require : e)[t] }) : r)(function(r) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r + '" is not supported');
});
var gl = (r, e) => {
  var t = {};
  for (var n in r)
    Uu.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
  if (r != null && Sc)
    for (var n of Sc(r))
      e.indexOf(n) < 0 && hl.call(r, n) && (t[n] = r[n]);
  return t;
};
var dr = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), Pu = (r, e) => {
  for (var t in e)
    Fc(r, t, { get: e[t], enumerable: true });
}, Yp = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of Kp(e))
      !Uu.call(r, i) && i !== t && Fc(r, i, { get: () => e[i], enumerable: !(n = Gp(e, i)) || n.enumerable });
  return r;
};
var lt = (r, e, t) => (t = r != null ? $p(Hp(r)) : {}, Yp(e || !r || !r.__esModule ? Fc(t, "default", { value: r, enumerable: true }) : t, r));
var je = (r, e, t) => (Lu(r, typeof e != "symbol" ? e + "" : e, t), t);
var xl = dr((Nc) => {
  Nc.byteLength = Zp;
  Nc.toByteArray = Qp;
  Nc.fromByteArray = rg;
  var Dr = [], mr = [], Jp = typeof Uint8Array != "undefined" ? Uint8Array : Array, zu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (Mn = 0, ml = zu.length; Mn < ml; ++Mn)
    Dr[Mn] = zu[Mn], mr[zu.charCodeAt(Mn)] = Mn;
  var Mn, ml;
  mr["-".charCodeAt(0)] = 62;
  mr["_".charCodeAt(0)] = 63;
  function yl(r) {
    var e = r.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t = r.indexOf("=");
    t === -1 && (t = e);
    var n = t === e ? 0 : 4 - t % 4;
    return [t, n];
  }
  function Zp(r) {
    var e = yl(r), t = e[0], n = e[1];
    return (t + n) * 3 / 4 - n;
  }
  function Xp(r, e, t) {
    return (e + t) * 3 / 4 - t;
  }
  function Qp(r) {
    var e, t = yl(r), n = t[0], i = t[1], s = new Jp(Xp(r, n, i)), o = 0, c = i > 0 ? n - 4 : n, l2;
    for (l2 = 0; l2 < c; l2 += 4)
      e = mr[r.charCodeAt(l2)] << 18 | mr[r.charCodeAt(l2 + 1)] << 12 | mr[r.charCodeAt(l2 + 2)] << 6 | mr[r.charCodeAt(l2 + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
    return i === 2 && (e = mr[r.charCodeAt(l2)] << 2 | mr[r.charCodeAt(l2 + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = mr[r.charCodeAt(l2)] << 10 | mr[r.charCodeAt(l2 + 1)] << 4 | mr[r.charCodeAt(l2 + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
  }
  function eg(r) {
    return Dr[r >> 18 & 63] + Dr[r >> 12 & 63] + Dr[r >> 6 & 63] + Dr[r & 63];
  }
  function tg(r, e, t) {
    for (var n, i = [], s = e; s < t; s += 3)
      n = (r[s] << 16 & 16711680) + (r[s + 1] << 8 & 65280) + (r[s + 2] & 255), i.push(eg(n));
    return i.join("");
  }
  function rg(r) {
    for (var e, t = r.length, n = t % 3, i = [], s = 16383, o = 0, c = t - n; o < c; o += s)
      i.push(tg(r, o, o + s > c ? c : o + s));
    return n === 1 ? (e = r[t - 1], i.push(Dr[e >> 2] + Dr[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i.push(Dr[e >> 10] + Dr[e >> 4 & 63] + Dr[e << 2 & 63] + "=")), i.join("");
  }
});
var wl = dr((qu) => {
  qu.read = function(r, e, t, n, i) {
    var s, o, c = i * 8 - n - 1, l2 = (1 << c) - 1, f2 = l2 >> 1, h2 = -7, _ = t ? i - 1 : 0, j2 = t ? -1 : 1, ie = r[e + _];
    for (_ += j2, s = ie & (1 << -h2) - 1, ie >>= -h2, h2 += c; h2 > 0; s = s * 256 + r[e + _], _ += j2, h2 -= 8)
      ;
    for (o = s & (1 << -h2) - 1, s >>= -h2, h2 += n; h2 > 0; o = o * 256 + r[e + _], _ += j2, h2 -= 8)
      ;
    if (s === 0)
      s = 1 - f2;
    else {
      if (s === l2)
        return o ? NaN : (ie ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, n), s = s - f2;
    }
    return (ie ? -1 : 1) * o * Math.pow(2, s - n);
  };
  qu.write = function(r, e, t, n, i, s) {
    var o, c, l2, f2 = s * 8 - i - 1, h2 = (1 << f2) - 1, _ = h2 >> 1, j2 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ie = n ? 0 : s - 1, G = n ? 1 : -1, Q = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (c = isNaN(e) ? 1 : 0, o = h2) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l2 = Math.pow(2, -o)) < 1 && (o--, l2 *= 2), o + _ >= 1 ? e += j2 / l2 : e += j2 * Math.pow(2, 1 - _), e * l2 >= 2 && (o++, l2 /= 2), o + _ >= h2 ? (c = 0, o = h2) : o + _ >= 1 ? (c = (e * l2 - 1) * Math.pow(2, i), o = o + _) : (c = e * Math.pow(2, _ - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + ie] = c & 255, ie += G, c /= 256, i -= 8)
      ;
    for (o = o << i | c, f2 += i; f2 > 0; r[t + ie] = o & 255, ie += G, o /= 256, f2 -= 8)
      ;
    r[t + ie - G] |= Q * 128;
  };
});
var Tt = dr((ji) => {
  var $u = xl(), Ci = wl(), bl = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  ji.Buffer = ne;
  ji.SlowBuffer = cg;
  ji.INSPECT_MAX_BYTES = 50;
  var Oc = 2147483647;
  ji.kMaxLength = Oc;
  ne.TYPED_ARRAY_SUPPORT = ng();
  !ne.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function ng() {
    try {
      let r = new Uint8Array(1), e = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42;
    } catch (r) {
      return false;
    }
  }
  Object.defineProperty(ne.prototype, "parent", { enumerable: true, get: function() {
    if (ne.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(ne.prototype, "offset", { enumerable: true, get: function() {
    if (ne.isBuffer(this))
      return this.byteOffset;
  } });
  function Gr(r) {
    if (r > Oc)
      throw new RangeError('The value "' + r + '" is invalid for option "size"');
    let e = new Uint8Array(r);
    return Object.setPrototypeOf(e, ne.prototype), e;
  }
  function ne(r, e, t) {
    if (typeof r == "number") {
      if (typeof e == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return Ku(r);
    }
    return El(r, e, t);
  }
  ne.poolSize = 8192;
  function El(r, e, t) {
    if (typeof r == "string")
      return sg(r, e);
    if (ArrayBuffer.isView(r))
      return og(r);
    if (r == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
    if (Mr(r, ArrayBuffer) || r && Mr(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (Mr(r, SharedArrayBuffer) || r && Mr(r.buffer, SharedArrayBuffer)))
      return Gu(r, e, t);
    if (typeof r == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n = r.valueOf && r.valueOf();
    if (n != null && n !== r)
      return ne.from(n, e, t);
    let i = ag(r);
    if (i)
      return i;
    if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function")
      return ne.from(r[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
  }
  ne.from = function(r, e, t) {
    return El(r, e, t);
  };
  Object.setPrototypeOf(ne.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(ne, Uint8Array);
  function Il(r) {
    if (typeof r != "number")
      throw new TypeError('"size" argument must be of type number');
    if (r < 0)
      throw new RangeError('The value "' + r + '" is invalid for option "size"');
  }
  function ig(r, e, t) {
    return Il(r), r <= 0 ? Gr(r) : e !== void 0 ? typeof t == "string" ? Gr(r).fill(e, t) : Gr(r).fill(e) : Gr(r);
  }
  ne.alloc = function(r, e, t) {
    return ig(r, e, t);
  };
  function Ku(r) {
    return Il(r), Gr(r < 0 ? 0 : Hu(r) | 0);
  }
  ne.allocUnsafe = function(r) {
    return Ku(r);
  };
  ne.allocUnsafeSlow = function(r) {
    return Ku(r);
  };
  function sg(r, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !ne.isEncoding(e))
      throw new TypeError("Unknown encoding: " + e);
    let t = Tl(r, e) | 0, n = Gr(t), i = n.write(r, e);
    return i !== t && (n = n.slice(0, i)), n;
  }
  function Vu(r) {
    let e = r.length < 0 ? 0 : Hu(r.length) | 0, t = Gr(e);
    for (let n = 0; n < e; n += 1)
      t[n] = r[n] & 255;
    return t;
  }
  function og(r) {
    if (Mr(r, Uint8Array)) {
      let e = new Uint8Array(r);
      return Gu(e.buffer, e.byteOffset, e.byteLength);
    }
    return Vu(r);
  }
  function Gu(r, e, t) {
    if (e < 0 || r.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (r.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(r, e, t), Object.setPrototypeOf(n, ne.prototype), n;
  }
  function ag(r) {
    if (ne.isBuffer(r)) {
      let e = Hu(r.length) | 0, t = Gr(e);
      return t.length === 0 || r.copy(t, 0, 0, e), t;
    }
    if (r.length !== void 0)
      return typeof r.length != "number" || Ju(r.length) ? Gr(0) : Vu(r);
    if (r.type === "Buffer" && Array.isArray(r.data))
      return Vu(r.data);
  }
  function Hu(r) {
    if (r >= Oc)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Oc.toString(16) + " bytes");
    return r | 0;
  }
  function cg(r) {
    return +r != r && (r = 0), ne.alloc(+r);
  }
  ne.isBuffer = function(e) {
    return e != null && e._isBuffer === true && e !== ne.prototype;
  };
  ne.compare = function(e, t) {
    if (Mr(e, Uint8Array) && (e = ne.from(e, e.offset, e.byteLength)), Mr(t, Uint8Array) && (t = ne.from(t, t.offset, t.byteLength)), !ne.isBuffer(e) || !ne.isBuffer(t))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e === t)
      return 0;
    let n = e.length, i = t.length;
    for (let s = 0, o = Math.min(n, i); s < o; ++s)
      if (e[s] !== t[s]) {
        n = e[s], i = t[s];
        break;
      }
    return n < i ? -1 : i < n ? 1 : 0;
  };
  ne.isEncoding = function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  ne.concat = function(e, t) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0)
      return ne.alloc(0);
    let n;
    if (t === void 0)
      for (t = 0, n = 0; n < e.length; ++n)
        t += e[n].length;
    let i = ne.allocUnsafe(t), s = 0;
    for (n = 0; n < e.length; ++n) {
      let o = e[n];
      if (Mr(o, Uint8Array))
        s + o.length > i.length ? (ne.isBuffer(o) || (o = ne.from(o)), o.copy(i, s)) : Uint8Array.prototype.set.call(i, o, s);
      else if (ne.isBuffer(o))
        o.copy(i, s);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      s += o.length;
    }
    return i;
  };
  function Tl(r, e) {
    if (ne.isBuffer(r))
      return r.length;
    if (ArrayBuffer.isView(r) || Mr(r, ArrayBuffer))
      return r.byteLength;
    if (typeof r != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
    let t = r.length, n = arguments.length > 2 && arguments[2] === true;
    if (!n && t === 0)
      return 0;
    let i = false;
    for (; ; )
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return Wu(r).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return kl(r).length;
        default:
          if (i)
            return n ? -1 : Wu(r).length;
          e = ("" + e).toLowerCase(), i = true;
      }
  }
  ne.byteLength = Tl;
  function ug(r, e, t) {
    let n = false;
    if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
      return "";
    for (r || (r = "utf8"); ; )
      switch (r) {
        case "hex":
          return wg(this, e, t);
        case "utf8":
        case "utf-8":
          return Fl(this, e, t);
        case "ascii":
          return yg(this, e, t);
        case "latin1":
        case "binary":
          return xg(this, e, t);
        case "base64":
          return gg(this, e, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return bg(this, e, t);
        default:
          if (n)
            throw new TypeError("Unknown encoding: " + r);
          r = (r + "").toLowerCase(), n = true;
      }
  }
  ne.prototype._isBuffer = true;
  function Rn(r, e, t) {
    let n = r[e];
    r[e] = r[t], r[t] = n;
  }
  ne.prototype.swap16 = function() {
    let e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2)
      Rn(this, t, t + 1);
    return this;
  };
  ne.prototype.swap32 = function() {
    let e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4)
      Rn(this, t, t + 3), Rn(this, t + 1, t + 2);
    return this;
  };
  ne.prototype.swap64 = function() {
    let e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < e; t += 8)
      Rn(this, t, t + 7), Rn(this, t + 1, t + 6), Rn(this, t + 2, t + 5), Rn(this, t + 3, t + 4);
    return this;
  };
  ne.prototype.toString = function() {
    let e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? Fl(this, 0, e) : ug.apply(this, arguments);
  };
  ne.prototype.toLocaleString = ne.prototype.toString;
  ne.prototype.equals = function(e) {
    if (!ne.isBuffer(e))
      throw new TypeError("Argument must be a Buffer");
    return this === e ? true : ne.compare(this, e) === 0;
  };
  ne.prototype.inspect = function() {
    let e = "", t = ji.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">";
  };
  bl && (ne.prototype[bl] = ne.prototype.inspect);
  ne.prototype.compare = function(e, t, n, i, s) {
    if (Mr(e, Uint8Array) && (e = ne.from(e, e.offset, e.byteLength)), !ne.isBuffer(e))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
    if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), s === void 0 && (s = this.length), t < 0 || n > e.length || i < 0 || s > this.length)
      throw new RangeError("out of range index");
    if (i >= s && t >= n)
      return 0;
    if (i >= s)
      return -1;
    if (t >= n)
      return 1;
    if (t >>>= 0, n >>>= 0, i >>>= 0, s >>>= 0, this === e)
      return 0;
    let o = s - i, c = n - t, l2 = Math.min(o, c), f2 = this.slice(i, s), h2 = e.slice(t, n);
    for (let _ = 0; _ < l2; ++_)
      if (f2[_] !== h2[_]) {
        o = f2[_], c = h2[_];
        break;
      }
    return o < c ? -1 : c < o ? 1 : 0;
  };
  function Sl(r, e, t, n, i) {
    if (r.length === 0)
      return -1;
    if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, Ju(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
      if (i)
        return -1;
      t = r.length - 1;
    } else if (t < 0)
      if (i)
        t = 0;
      else
        return -1;
    if (typeof e == "string" && (e = ne.from(e, n)), ne.isBuffer(e))
      return e.length === 0 ? -1 : vl(r, e, t, n, i);
    if (typeof e == "number")
      return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : vl(r, [e], t, n, i);
    throw new TypeError("val must be string, number or Buffer");
  }
  function vl(r, e, t, n, i) {
    let s = 1, o = r.length, c = e.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (r.length < 2 || e.length < 2)
        return -1;
      s = 2, o /= 2, c /= 2, t /= 2;
    }
    function l2(h2, _) {
      return s === 1 ? h2[_] : h2.readUInt16BE(_ * s);
    }
    let f2;
    if (i) {
      let h2 = -1;
      for (f2 = t; f2 < o; f2++)
        if (l2(r, f2) === l2(e, h2 === -1 ? 0 : f2 - h2)) {
          if (h2 === -1 && (h2 = f2), f2 - h2 + 1 === c)
            return h2 * s;
        } else
          h2 !== -1 && (f2 -= f2 - h2), h2 = -1;
    } else
      for (t + c > o && (t = o - c), f2 = t; f2 >= 0; f2--) {
        let h2 = true;
        for (let _ = 0; _ < c; _++)
          if (l2(r, f2 + _) !== l2(e, _)) {
            h2 = false;
            break;
          }
        if (h2)
          return f2;
      }
    return -1;
  }
  ne.prototype.includes = function(e, t, n) {
    return this.indexOf(e, t, n) !== -1;
  };
  ne.prototype.indexOf = function(e, t, n) {
    return Sl(this, e, t, n, true);
  };
  ne.prototype.lastIndexOf = function(e, t, n) {
    return Sl(this, e, t, n, false);
  };
  function fg(r, e, t, n) {
    t = Number(t) || 0;
    let i = r.length - t;
    n ? (n = Number(n), n > i && (n = i)) : n = i;
    let s = e.length;
    n > s / 2 && (n = s / 2);
    let o;
    for (o = 0; o < n; ++o) {
      let c = parseInt(e.substr(o * 2, 2), 16);
      if (Ju(c))
        return o;
      r[t + o] = c;
    }
    return o;
  }
  function lg(r, e, t, n) {
    return Dc(Wu(e, r.length - t), r, t, n);
  }
  function dg(r, e, t, n) {
    return Dc(Eg(e), r, t, n);
  }
  function hg(r, e, t, n) {
    return Dc(kl(e), r, t, n);
  }
  function pg(r, e, t, n) {
    return Dc(Ig(e, r.length - t), r, t, n);
  }
  ne.prototype.write = function(e, t, n, i) {
    if (t === void 0)
      i = "utf8", n = this.length, t = 0;
    else if (n === void 0 && typeof t == "string")
      i = t, n = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let s = this.length - t;
    if ((n === void 0 || n > s) && (n = s), e.length > 0 && (n < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    let o = false;
    for (; ; )
      switch (i) {
        case "hex":
          return fg(this, e, t, n);
        case "utf8":
        case "utf-8":
          return lg(this, e, t, n);
        case "ascii":
        case "latin1":
        case "binary":
          return dg(this, e, t, n);
        case "base64":
          return hg(this, e, t, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return pg(this, e, t, n);
        default:
          if (o)
            throw new TypeError("Unknown encoding: " + i);
          i = ("" + i).toLowerCase(), o = true;
      }
  };
  ne.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function gg(r, e, t) {
    return e === 0 && t === r.length ? $u.fromByteArray(r) : $u.fromByteArray(r.slice(e, t));
  }
  function Fl(r, e, t) {
    t = Math.min(r.length, t);
    let n = [], i = e;
    for (; i < t; ) {
      let s = r[i], o = null, c = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (i + c <= t) {
        let l2, f2, h2, _;
        switch (c) {
          case 1:
            s < 128 && (o = s);
            break;
          case 2:
            l2 = r[i + 1], (l2 & 192) === 128 && (_ = (s & 31) << 6 | l2 & 63, _ > 127 && (o = _));
            break;
          case 3:
            l2 = r[i + 1], f2 = r[i + 2], (l2 & 192) === 128 && (f2 & 192) === 128 && (_ = (s & 15) << 12 | (l2 & 63) << 6 | f2 & 63, _ > 2047 && (_ < 55296 || _ > 57343) && (o = _));
            break;
          case 4:
            l2 = r[i + 1], f2 = r[i + 2], h2 = r[i + 3], (l2 & 192) === 128 && (f2 & 192) === 128 && (h2 & 192) === 128 && (_ = (s & 15) << 18 | (l2 & 63) << 12 | (f2 & 63) << 6 | h2 & 63, _ > 65535 && _ < 1114112 && (o = _));
        }
      }
      o === null ? (o = 65533, c = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n.push(o), i += c;
    }
    return mg(n);
  }
  var _l = 4096;
  function mg(r) {
    let e = r.length;
    if (e <= _l)
      return String.fromCharCode.apply(String, r);
    let t = "", n = 0;
    for (; n < e; )
      t += String.fromCharCode.apply(String, r.slice(n, n += _l));
    return t;
  }
  function yg(r, e, t) {
    let n = "";
    t = Math.min(r.length, t);
    for (let i = e; i < t; ++i)
      n += String.fromCharCode(r[i] & 127);
    return n;
  }
  function xg(r, e, t) {
    let n = "";
    t = Math.min(r.length, t);
    for (let i = e; i < t; ++i)
      n += String.fromCharCode(r[i]);
    return n;
  }
  function wg(r, e, t) {
    let n = r.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
    let i = "";
    for (let s = e; s < t; ++s)
      i += Tg[r[s]];
    return i;
  }
  function bg(r, e, t) {
    let n = r.slice(e, t), i = "";
    for (let s = 0; s < n.length - 1; s += 2)
      i += String.fromCharCode(n[s] + n[s + 1] * 256);
    return i;
  }
  ne.prototype.slice = function(e, t) {
    let n = this.length;
    e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
    let i = this.subarray(e, t);
    return Object.setPrototypeOf(i, ne.prototype), i;
  };
  function Kt(r, e, t) {
    if (r % 1 !== 0 || r < 0)
      throw new RangeError("offset is not uint");
    if (r + e > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  ne.prototype.readUintLE = ne.prototype.readUIntLE = function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || Kt(e, t, this.length);
    let i = this[e], s = 1, o = 0;
    for (; ++o < t && (s *= 256); )
      i += this[e + o] * s;
    return i;
  };
  ne.prototype.readUintBE = ne.prototype.readUIntBE = function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || Kt(e, t, this.length);
    let i = this[e + --t], s = 1;
    for (; t > 0 && (s *= 256); )
      i += this[e + --t] * s;
    return i;
  };
  ne.prototype.readUint8 = ne.prototype.readUInt8 = function(e, t) {
    return e = e >>> 0, t || Kt(e, 1, this.length), this[e];
  };
  ne.prototype.readUint16LE = ne.prototype.readUInt16LE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 2, this.length), this[e] | this[e + 1] << 8;
  };
  ne.prototype.readUint16BE = ne.prototype.readUInt16BE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 2, this.length), this[e] << 8 | this[e + 1];
  };
  ne.prototype.readUint32LE = ne.prototype.readUInt32LE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  };
  ne.prototype.readUint32BE = ne.prototype.readUInt32BE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  };
  ne.prototype.readBigUInt64LE = fn(function(e) {
    e = e >>> 0, ki(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && to(e, this.length - 8);
    let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
    return BigInt(i) + (BigInt(s) << BigInt(32));
  });
  ne.prototype.readBigUInt64BE = fn(function(e) {
    e = e >>> 0, ki(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && to(e, this.length - 8);
    let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
    return (BigInt(i) << BigInt(32)) + BigInt(s);
  });
  ne.prototype.readIntLE = function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || Kt(e, t, this.length);
    let i = this[e], s = 1, o = 0;
    for (; ++o < t && (s *= 256); )
      i += this[e + o] * s;
    return s *= 128, i >= s && (i -= Math.pow(2, 8 * t)), i;
  };
  ne.prototype.readIntBE = function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || Kt(e, t, this.length);
    let i = t, s = 1, o = this[e + --i];
    for (; i > 0 && (s *= 256); )
      o += this[e + --i] * s;
    return s *= 128, o >= s && (o -= Math.pow(2, 8 * t)), o;
  };
  ne.prototype.readInt8 = function(e, t) {
    return e = e >>> 0, t || Kt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  };
  ne.prototype.readInt16LE = function(e, t) {
    e = e >>> 0, t || Kt(e, 2, this.length);
    let n = this[e] | this[e + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  ne.prototype.readInt16BE = function(e, t) {
    e = e >>> 0, t || Kt(e, 2, this.length);
    let n = this[e + 1] | this[e] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  ne.prototype.readInt32LE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  };
  ne.prototype.readInt32BE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  };
  ne.prototype.readBigInt64LE = fn(function(e) {
    e = e >>> 0, ki(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && to(e, this.length - 8);
    let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
    return (BigInt(i) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
  });
  ne.prototype.readBigInt64BE = fn(function(e) {
    e = e >>> 0, ki(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && to(e, this.length - 8);
    let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (BigInt(i) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n);
  });
  ne.prototype.readFloatLE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 4, this.length), Ci.read(this, e, true, 23, 4);
  };
  ne.prototype.readFloatBE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 4, this.length), Ci.read(this, e, false, 23, 4);
  };
  ne.prototype.readDoubleLE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 8, this.length), Ci.read(this, e, true, 52, 8);
  };
  ne.prototype.readDoubleBE = function(e, t) {
    return e = e >>> 0, t || Kt(e, 8, this.length), Ci.read(this, e, false, 52, 8);
  };
  function or(r, e, t, n, i, s) {
    if (!ne.isBuffer(r))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s)
      throw new RangeError('"value" argument is out of bounds');
    if (t + n > r.length)
      throw new RangeError("Index out of range");
  }
  ne.prototype.writeUintLE = ne.prototype.writeUIntLE = function(e, t, n, i) {
    if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
      let c = Math.pow(2, 8 * n) - 1;
      or(this, e, t, n, c, 0);
    }
    let s = 1, o = 0;
    for (this[t] = e & 255; ++o < n && (s *= 256); )
      this[t + o] = e / s & 255;
    return t + n;
  };
  ne.prototype.writeUintBE = ne.prototype.writeUIntBE = function(e, t, n, i) {
    if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
      let c = Math.pow(2, 8 * n) - 1;
      or(this, e, t, n, c, 0);
    }
    let s = n - 1, o = 1;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      this[t + s] = e / o & 255;
    return t + n;
  };
  ne.prototype.writeUint8 = ne.prototype.writeUInt8 = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1;
  };
  ne.prototype.writeUint16LE = ne.prototype.writeUInt16LE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  };
  ne.prototype.writeUint16BE = ne.prototype.writeUInt16BE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  };
  ne.prototype.writeUint32LE = ne.prototype.writeUInt32LE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4;
  };
  ne.prototype.writeUint32BE = ne.prototype.writeUInt32BE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  };
  function Nl(r, e, t, n, i) {
    Cl(e, n, i, r, t, 7);
    let s = Number(e & BigInt(4294967295));
    r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s;
    let o = Number(e >> BigInt(32) & BigInt(4294967295));
    return r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, t;
  }
  function Ol(r, e, t, n, i) {
    Cl(e, n, i, r, t, 7);
    let s = Number(e & BigInt(4294967295));
    r[t + 7] = s, s = s >> 8, r[t + 6] = s, s = s >> 8, r[t + 5] = s, s = s >> 8, r[t + 4] = s;
    let o = Number(e >> BigInt(32) & BigInt(4294967295));
    return r[t + 3] = o, o = o >> 8, r[t + 2] = o, o = o >> 8, r[t + 1] = o, o = o >> 8, r[t] = o, t + 8;
  }
  ne.prototype.writeBigUInt64LE = fn(function(e, t = 0) {
    return Nl(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  ne.prototype.writeBigUInt64BE = fn(function(e, t = 0) {
    return Ol(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  ne.prototype.writeIntLE = function(e, t, n, i) {
    if (e = +e, t = t >>> 0, !i) {
      let l2 = Math.pow(2, 8 * n - 1);
      or(this, e, t, n, l2 - 1, -l2);
    }
    let s = 0, o = 1, c = 0;
    for (this[t] = e & 255; ++s < n && (o *= 256); )
      e < 0 && c === 0 && this[t + s - 1] !== 0 && (c = 1), this[t + s] = (e / o >> 0) - c & 255;
    return t + n;
  };
  ne.prototype.writeIntBE = function(e, t, n, i) {
    if (e = +e, t = t >>> 0, !i) {
      let l2 = Math.pow(2, 8 * n - 1);
      or(this, e, t, n, l2 - 1, -l2);
    }
    let s = n - 1, o = 1, c = 0;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      e < 0 && c === 0 && this[t + s + 1] !== 0 && (c = 1), this[t + s] = (e / o >> 0) - c & 255;
    return t + n;
  };
  ne.prototype.writeInt8 = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
  };
  ne.prototype.writeInt16LE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  };
  ne.prototype.writeInt16BE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  };
  ne.prototype.writeInt32LE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
  };
  ne.prototype.writeInt32BE = function(e, t, n) {
    return e = +e, t = t >>> 0, n || or(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  };
  ne.prototype.writeBigInt64LE = fn(function(e, t = 0) {
    return Nl(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  ne.prototype.writeBigInt64BE = fn(function(e, t = 0) {
    return Ol(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Dl(r, e, t, n, i, s) {
    if (t + n > r.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function Ml(r, e, t, n, i) {
    return e = +e, t = t >>> 0, i || Dl(r, e, t, 4), Ci.write(r, e, t, n, 23, 4), t + 4;
  }
  ne.prototype.writeFloatLE = function(e, t, n) {
    return Ml(this, e, t, true, n);
  };
  ne.prototype.writeFloatBE = function(e, t, n) {
    return Ml(this, e, t, false, n);
  };
  function Rl(r, e, t, n, i) {
    return e = +e, t = t >>> 0, i || Dl(r, e, t, 8), Ci.write(r, e, t, n, 52, 8), t + 8;
  }
  ne.prototype.writeDoubleLE = function(e, t, n) {
    return Rl(this, e, t, true, n);
  };
  ne.prototype.writeDoubleBE = function(e, t, n) {
    return Rl(this, e, t, false, n);
  };
  ne.prototype.copy = function(e, t, n, i) {
    if (!ne.isBuffer(e))
      throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length)
      throw new RangeError("Index out of range");
    if (i < 0)
      throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
    let s = i - n;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), s;
  };
  ne.prototype.fill = function(e, t, n, i) {
    if (typeof e == "string") {
      if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string")
        throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !ne.isEncoding(i))
        throw new TypeError("Unknown encoding: " + i);
      if (e.length === 1) {
        let o = e.charCodeAt(0);
        (i === "utf8" && o < 128 || i === "latin1") && (e = o);
      }
    } else
      typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < n)
      throw new RangeError("Out of range index");
    if (n <= t)
      return this;
    t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
    let s;
    if (typeof e == "number")
      for (s = t; s < n; ++s)
        this[s] = e;
    else {
      let o = ne.isBuffer(e) ? e : ne.from(e, i), c = o.length;
      if (c === 0)
        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (s = 0; s < n - t; ++s)
        this[s + t] = o[s % c];
    }
    return this;
  };
  var Ri = {};
  function Yu(r, e, t) {
    Ri[r] = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${r}]`, this.stack, delete this.name;
      }
      get code() {
        return r;
      }
      set code(i) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
      }
      toString() {
        return `${this.name} [${r}]: ${this.message}`;
      }
    };
  }
  Yu("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
    return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Yu("ERR_INVALID_ARG_TYPE", function(r, e) {
    return `The "${r}" argument must be of type number. Received type ${typeof e}`;
  }, TypeError);
  Yu("ERR_OUT_OF_RANGE", function(r, e, t) {
    let n = `The value of "${r}" is out of range.`, i = t;
    return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = Al(String(t)) : typeof t == "bigint" && (i = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = Al(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n;
  }, RangeError);
  function Al(r) {
    let e = "", t = r.length, n = r[0] === "-" ? 1 : 0;
    for (; t >= n + 4; t -= 3)
      e = `_${r.slice(t - 3, t)}${e}`;
    return `${r.slice(0, t)}${e}`;
  }
  function vg(r, e, t) {
    ki(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && to(e, r.length - (t + 1));
  }
  function Cl(r, e, t, n, i, s) {
    if (r > t || r < e) {
      let o = typeof e == "bigint" ? "n" : "", c;
      throw s > 3 ? e === 0 || e === BigInt(0) ? c = `>= 0${o} and < 2${o} ** ${(s + 1) * 8}${o}` : c = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${(s + 1) * 8 - 1}${o}` : c = `>= ${e}${o} and <= ${t}${o}`, new Ri.ERR_OUT_OF_RANGE("value", c, r);
    }
    vg(n, i, s);
  }
  function ki(r, e) {
    if (typeof r != "number")
      throw new Ri.ERR_INVALID_ARG_TYPE(e, "number", r);
  }
  function to(r, e, t) {
    throw Math.floor(r) !== r ? (ki(r, t), new Ri.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new Ri.ERR_BUFFER_OUT_OF_BOUNDS() : new Ri.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${e}`, r);
  }
  var _g2 = /[^+/0-9A-Za-z-_]/g;
  function Ag(r) {
    if (r = r.split("=")[0], r = r.trim().replace(_g2, ""), r.length < 2)
      return "";
    for (; r.length % 4 !== 0; )
      r = r + "=";
    return r;
  }
  function Wu(r, e) {
    e = e || 1 / 0;
    let t, n = r.length, i = null, s = [];
    for (let o = 0; o < n; ++o) {
      if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
        if (!i) {
          if (t > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (o + 1 === n) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && s.push(239, 191, 189), i = t;
          continue;
        }
        t = (i - 55296 << 10 | t - 56320) + 65536;
      } else
        i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (i = null, t < 128) {
        if ((e -= 1) < 0)
          break;
        s.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0)
          break;
        s.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((e -= 3) < 0)
          break;
        s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((e -= 4) < 0)
          break;
        s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return s;
  }
  function Eg(r) {
    let e = [];
    for (let t = 0; t < r.length; ++t)
      e.push(r.charCodeAt(t) & 255);
    return e;
  }
  function Ig(r, e) {
    let t, n, i, s = [];
    for (let o = 0; o < r.length && !((e -= 2) < 0); ++o)
      t = r.charCodeAt(o), n = t >> 8, i = t % 256, s.push(i), s.push(n);
    return s;
  }
  function kl(r) {
    return $u.toByteArray(Ag(r));
  }
  function Dc(r, e, t, n) {
    let i;
    for (i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i)
      e[i + t] = r[i];
    return i;
  }
  function Mr(r, e) {
    return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name;
  }
  function Ju(r) {
    return r !== r;
  }
  var Tg = function() {
    let r = "0123456789abcdef", e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let n = t * 16;
      for (let i = 0; i < 16; ++i)
        e[n + i] = r[t] + r[i];
    }
    return e;
  }();
  function fn(r) {
    return typeof BigInt == "undefined" ? Sg : r;
  }
  function Sg() {
    throw new Error("BigInt not supported");
  }
});
var jl = dr(() => {
});
var Bl = dr((fx, Mc) => {
  (function(r) {
    var e = function(d2) {
      var x2, y2 = new Float64Array(16);
      if (d2)
        for (x2 = 0; x2 < d2.length; x2++)
          y2[x2] = d2[x2];
      return y2;
    }, t = function() {
      throw new Error("no PRNG");
    }, n = new Uint8Array(16), i = new Uint8Array(32);
    i[0] = 9;
    var s = e(), o = e([1]), c = e([56129, 1]), l2 = e([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), f2 = e([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), h2 = e([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), _ = e([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), j2 = e([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ie(d2, x2, y2, a) {
      d2[x2] = y2 >> 24 & 255, d2[x2 + 1] = y2 >> 16 & 255, d2[x2 + 2] = y2 >> 8 & 255, d2[x2 + 3] = y2 & 255, d2[x2 + 4] = a >> 24 & 255, d2[x2 + 5] = a >> 16 & 255, d2[x2 + 6] = a >> 8 & 255, d2[x2 + 7] = a & 255;
    }
    function G(d2, x2, y2, a, v) {
      var L2, q = 0;
      for (L2 = 0; L2 < v; L2++)
        q |= d2[x2 + L2] ^ y2[a + L2];
      return (1 & q - 1 >>> 8) - 1;
    }
    function Q(d2, x2, y2, a) {
      return G(d2, x2, y2, a, 16);
    }
    function N2(d2, x2, y2, a) {
      return G(d2, x2, y2, a, 32);
    }
    function U(d2, x2, y2, a) {
      for (var v = a[0] & 255 | (a[1] & 255) << 8 | (a[2] & 255) << 16 | (a[3] & 255) << 24, L2 = y2[0] & 255 | (y2[1] & 255) << 8 | (y2[2] & 255) << 16 | (y2[3] & 255) << 24, q = y2[4] & 255 | (y2[5] & 255) << 8 | (y2[6] & 255) << 16 | (y2[7] & 255) << 24, ue2 = y2[8] & 255 | (y2[9] & 255) << 8 | (y2[10] & 255) << 16 | (y2[11] & 255) << 24, ye2 = y2[12] & 255 | (y2[13] & 255) << 8 | (y2[14] & 255) << 16 | (y2[15] & 255) << 24, Re = a[4] & 255 | (a[5] & 255) << 8 | (a[6] & 255) << 16 | (a[7] & 255) << 24, Ae2 = x2[0] & 255 | (x2[1] & 255) << 8 | (x2[2] & 255) << 16 | (x2[3] & 255) << 24, gt = x2[4] & 255 | (x2[5] & 255) << 8 | (x2[6] & 255) << 16 | (x2[7] & 255) << 24, Fe = x2[8] & 255 | (x2[9] & 255) << 8 | (x2[10] & 255) << 16 | (x2[11] & 255) << 24, $e = x2[12] & 255 | (x2[13] & 255) << 8 | (x2[14] & 255) << 16 | (x2[15] & 255) << 24, Ge = a[8] & 255 | (a[9] & 255) << 8 | (a[10] & 255) << 16 | (a[11] & 255) << 24, Qe = y2[16] & 255 | (y2[17] & 255) << 8 | (y2[18] & 255) << 16 | (y2[19] & 255) << 24, Xe = y2[20] & 255 | (y2[21] & 255) << 8 | (y2[22] & 255) << 16 | (y2[23] & 255) << 24, We = y2[24] & 255 | (y2[25] & 255) << 8 | (y2[26] & 255) << 16 | (y2[27] & 255) << 24, Ye = y2[28] & 255 | (y2[29] & 255) << 8 | (y2[30] & 255) << 16 | (y2[31] & 255) << 24, Ke = a[12] & 255 | (a[13] & 255) << 8 | (a[14] & 255) << 16 | (a[15] & 255) << 24, Ne = v, ke2 = L2, Ie = q, Oe = ue2, Me = ye2, _e2 = Re, J2 = Ae2, Z = gt, de = Fe, ae = $e, fe = Ge, ge2 = Qe, Le = Xe, et = We, rt = Ye, tt = Ke, S2, st = 0; st < 20; st += 2)
        S2 = Ne + Le | 0, Me ^= S2 << 7 | S2 >>> 32 - 7, S2 = Me + Ne | 0, de ^= S2 << 9 | S2 >>> 32 - 9, S2 = de + Me | 0, Le ^= S2 << 13 | S2 >>> 32 - 13, S2 = Le + de | 0, Ne ^= S2 << 18 | S2 >>> 32 - 18, S2 = _e2 + ke2 | 0, ae ^= S2 << 7 | S2 >>> 32 - 7, S2 = ae + _e2 | 0, et ^= S2 << 9 | S2 >>> 32 - 9, S2 = et + ae | 0, ke2 ^= S2 << 13 | S2 >>> 32 - 13, S2 = ke2 + et | 0, _e2 ^= S2 << 18 | S2 >>> 32 - 18, S2 = fe + J2 | 0, rt ^= S2 << 7 | S2 >>> 32 - 7, S2 = rt + fe | 0, Ie ^= S2 << 9 | S2 >>> 32 - 9, S2 = Ie + rt | 0, J2 ^= S2 << 13 | S2 >>> 32 - 13, S2 = J2 + Ie | 0, fe ^= S2 << 18 | S2 >>> 32 - 18, S2 = tt + ge2 | 0, Oe ^= S2 << 7 | S2 >>> 32 - 7, S2 = Oe + tt | 0, Z ^= S2 << 9 | S2 >>> 32 - 9, S2 = Z + Oe | 0, ge2 ^= S2 << 13 | S2 >>> 32 - 13, S2 = ge2 + Z | 0, tt ^= S2 << 18 | S2 >>> 32 - 18, S2 = Ne + Oe | 0, ke2 ^= S2 << 7 | S2 >>> 32 - 7, S2 = ke2 + Ne | 0, Ie ^= S2 << 9 | S2 >>> 32 - 9, S2 = Ie + ke2 | 0, Oe ^= S2 << 13 | S2 >>> 32 - 13, S2 = Oe + Ie | 0, Ne ^= S2 << 18 | S2 >>> 32 - 18, S2 = _e2 + Me | 0, J2 ^= S2 << 7 | S2 >>> 32 - 7, S2 = J2 + _e2 | 0, Z ^= S2 << 9 | S2 >>> 32 - 9, S2 = Z + J2 | 0, Me ^= S2 << 13 | S2 >>> 32 - 13, S2 = Me + Z | 0, _e2 ^= S2 << 18 | S2 >>> 32 - 18, S2 = fe + ae | 0, ge2 ^= S2 << 7 | S2 >>> 32 - 7, S2 = ge2 + fe | 0, de ^= S2 << 9 | S2 >>> 32 - 9, S2 = de + ge2 | 0, ae ^= S2 << 13 | S2 >>> 32 - 13, S2 = ae + de | 0, fe ^= S2 << 18 | S2 >>> 32 - 18, S2 = tt + rt | 0, Le ^= S2 << 7 | S2 >>> 32 - 7, S2 = Le + tt | 0, et ^= S2 << 9 | S2 >>> 32 - 9, S2 = et + Le | 0, rt ^= S2 << 13 | S2 >>> 32 - 13, S2 = rt + et | 0, tt ^= S2 << 18 | S2 >>> 32 - 18;
      Ne = Ne + v | 0, ke2 = ke2 + L2 | 0, Ie = Ie + q | 0, Oe = Oe + ue2 | 0, Me = Me + ye2 | 0, _e2 = _e2 + Re | 0, J2 = J2 + Ae2 | 0, Z = Z + gt | 0, de = de + Fe | 0, ae = ae + $e | 0, fe = fe + Ge | 0, ge2 = ge2 + Qe | 0, Le = Le + Xe | 0, et = et + We | 0, rt = rt + Ye | 0, tt = tt + Ke | 0, d2[0] = Ne >>> 0 & 255, d2[1] = Ne >>> 8 & 255, d2[2] = Ne >>> 16 & 255, d2[3] = Ne >>> 24 & 255, d2[4] = ke2 >>> 0 & 255, d2[5] = ke2 >>> 8 & 255, d2[6] = ke2 >>> 16 & 255, d2[7] = ke2 >>> 24 & 255, d2[8] = Ie >>> 0 & 255, d2[9] = Ie >>> 8 & 255, d2[10] = Ie >>> 16 & 255, d2[11] = Ie >>> 24 & 255, d2[12] = Oe >>> 0 & 255, d2[13] = Oe >>> 8 & 255, d2[14] = Oe >>> 16 & 255, d2[15] = Oe >>> 24 & 255, d2[16] = Me >>> 0 & 255, d2[17] = Me >>> 8 & 255, d2[18] = Me >>> 16 & 255, d2[19] = Me >>> 24 & 255, d2[20] = _e2 >>> 0 & 255, d2[21] = _e2 >>> 8 & 255, d2[22] = _e2 >>> 16 & 255, d2[23] = _e2 >>> 24 & 255, d2[24] = J2 >>> 0 & 255, d2[25] = J2 >>> 8 & 255, d2[26] = J2 >>> 16 & 255, d2[27] = J2 >>> 24 & 255, d2[28] = Z >>> 0 & 255, d2[29] = Z >>> 8 & 255, d2[30] = Z >>> 16 & 255, d2[31] = Z >>> 24 & 255, d2[32] = de >>> 0 & 255, d2[33] = de >>> 8 & 255, d2[34] = de >>> 16 & 255, d2[35] = de >>> 24 & 255, d2[36] = ae >>> 0 & 255, d2[37] = ae >>> 8 & 255, d2[38] = ae >>> 16 & 255, d2[39] = ae >>> 24 & 255, d2[40] = fe >>> 0 & 255, d2[41] = fe >>> 8 & 255, d2[42] = fe >>> 16 & 255, d2[43] = fe >>> 24 & 255, d2[44] = ge2 >>> 0 & 255, d2[45] = ge2 >>> 8 & 255, d2[46] = ge2 >>> 16 & 255, d2[47] = ge2 >>> 24 & 255, d2[48] = Le >>> 0 & 255, d2[49] = Le >>> 8 & 255, d2[50] = Le >>> 16 & 255, d2[51] = Le >>> 24 & 255, d2[52] = et >>> 0 & 255, d2[53] = et >>> 8 & 255, d2[54] = et >>> 16 & 255, d2[55] = et >>> 24 & 255, d2[56] = rt >>> 0 & 255, d2[57] = rt >>> 8 & 255, d2[58] = rt >>> 16 & 255, d2[59] = rt >>> 24 & 255, d2[60] = tt >>> 0 & 255, d2[61] = tt >>> 8 & 255, d2[62] = tt >>> 16 & 255, d2[63] = tt >>> 24 & 255;
    }
    function ee(d2, x2, y2, a) {
      for (var v = a[0] & 255 | (a[1] & 255) << 8 | (a[2] & 255) << 16 | (a[3] & 255) << 24, L2 = y2[0] & 255 | (y2[1] & 255) << 8 | (y2[2] & 255) << 16 | (y2[3] & 255) << 24, q = y2[4] & 255 | (y2[5] & 255) << 8 | (y2[6] & 255) << 16 | (y2[7] & 255) << 24, ue2 = y2[8] & 255 | (y2[9] & 255) << 8 | (y2[10] & 255) << 16 | (y2[11] & 255) << 24, ye2 = y2[12] & 255 | (y2[13] & 255) << 8 | (y2[14] & 255) << 16 | (y2[15] & 255) << 24, Re = a[4] & 255 | (a[5] & 255) << 8 | (a[6] & 255) << 16 | (a[7] & 255) << 24, Ae2 = x2[0] & 255 | (x2[1] & 255) << 8 | (x2[2] & 255) << 16 | (x2[3] & 255) << 24, gt = x2[4] & 255 | (x2[5] & 255) << 8 | (x2[6] & 255) << 16 | (x2[7] & 255) << 24, Fe = x2[8] & 255 | (x2[9] & 255) << 8 | (x2[10] & 255) << 16 | (x2[11] & 255) << 24, $e = x2[12] & 255 | (x2[13] & 255) << 8 | (x2[14] & 255) << 16 | (x2[15] & 255) << 24, Ge = a[8] & 255 | (a[9] & 255) << 8 | (a[10] & 255) << 16 | (a[11] & 255) << 24, Qe = y2[16] & 255 | (y2[17] & 255) << 8 | (y2[18] & 255) << 16 | (y2[19] & 255) << 24, Xe = y2[20] & 255 | (y2[21] & 255) << 8 | (y2[22] & 255) << 16 | (y2[23] & 255) << 24, We = y2[24] & 255 | (y2[25] & 255) << 8 | (y2[26] & 255) << 16 | (y2[27] & 255) << 24, Ye = y2[28] & 255 | (y2[29] & 255) << 8 | (y2[30] & 255) << 16 | (y2[31] & 255) << 24, Ke = a[12] & 255 | (a[13] & 255) << 8 | (a[14] & 255) << 16 | (a[15] & 255) << 24, Ne = v, ke2 = L2, Ie = q, Oe = ue2, Me = ye2, _e2 = Re, J2 = Ae2, Z = gt, de = Fe, ae = $e, fe = Ge, ge2 = Qe, Le = Xe, et = We, rt = Ye, tt = Ke, S2, st = 0; st < 20; st += 2)
        S2 = Ne + Le | 0, Me ^= S2 << 7 | S2 >>> 32 - 7, S2 = Me + Ne | 0, de ^= S2 << 9 | S2 >>> 32 - 9, S2 = de + Me | 0, Le ^= S2 << 13 | S2 >>> 32 - 13, S2 = Le + de | 0, Ne ^= S2 << 18 | S2 >>> 32 - 18, S2 = _e2 + ke2 | 0, ae ^= S2 << 7 | S2 >>> 32 - 7, S2 = ae + _e2 | 0, et ^= S2 << 9 | S2 >>> 32 - 9, S2 = et + ae | 0, ke2 ^= S2 << 13 | S2 >>> 32 - 13, S2 = ke2 + et | 0, _e2 ^= S2 << 18 | S2 >>> 32 - 18, S2 = fe + J2 | 0, rt ^= S2 << 7 | S2 >>> 32 - 7, S2 = rt + fe | 0, Ie ^= S2 << 9 | S2 >>> 32 - 9, S2 = Ie + rt | 0, J2 ^= S2 << 13 | S2 >>> 32 - 13, S2 = J2 + Ie | 0, fe ^= S2 << 18 | S2 >>> 32 - 18, S2 = tt + ge2 | 0, Oe ^= S2 << 7 | S2 >>> 32 - 7, S2 = Oe + tt | 0, Z ^= S2 << 9 | S2 >>> 32 - 9, S2 = Z + Oe | 0, ge2 ^= S2 << 13 | S2 >>> 32 - 13, S2 = ge2 + Z | 0, tt ^= S2 << 18 | S2 >>> 32 - 18, S2 = Ne + Oe | 0, ke2 ^= S2 << 7 | S2 >>> 32 - 7, S2 = ke2 + Ne | 0, Ie ^= S2 << 9 | S2 >>> 32 - 9, S2 = Ie + ke2 | 0, Oe ^= S2 << 13 | S2 >>> 32 - 13, S2 = Oe + Ie | 0, Ne ^= S2 << 18 | S2 >>> 32 - 18, S2 = _e2 + Me | 0, J2 ^= S2 << 7 | S2 >>> 32 - 7, S2 = J2 + _e2 | 0, Z ^= S2 << 9 | S2 >>> 32 - 9, S2 = Z + J2 | 0, Me ^= S2 << 13 | S2 >>> 32 - 13, S2 = Me + Z | 0, _e2 ^= S2 << 18 | S2 >>> 32 - 18, S2 = fe + ae | 0, ge2 ^= S2 << 7 | S2 >>> 32 - 7, S2 = ge2 + fe | 0, de ^= S2 << 9 | S2 >>> 32 - 9, S2 = de + ge2 | 0, ae ^= S2 << 13 | S2 >>> 32 - 13, S2 = ae + de | 0, fe ^= S2 << 18 | S2 >>> 32 - 18, S2 = tt + rt | 0, Le ^= S2 << 7 | S2 >>> 32 - 7, S2 = Le + tt | 0, et ^= S2 << 9 | S2 >>> 32 - 9, S2 = et + Le | 0, rt ^= S2 << 13 | S2 >>> 32 - 13, S2 = rt + et | 0, tt ^= S2 << 18 | S2 >>> 32 - 18;
      d2[0] = Ne >>> 0 & 255, d2[1] = Ne >>> 8 & 255, d2[2] = Ne >>> 16 & 255, d2[3] = Ne >>> 24 & 255, d2[4] = _e2 >>> 0 & 255, d2[5] = _e2 >>> 8 & 255, d2[6] = _e2 >>> 16 & 255, d2[7] = _e2 >>> 24 & 255, d2[8] = fe >>> 0 & 255, d2[9] = fe >>> 8 & 255, d2[10] = fe >>> 16 & 255, d2[11] = fe >>> 24 & 255, d2[12] = tt >>> 0 & 255, d2[13] = tt >>> 8 & 255, d2[14] = tt >>> 16 & 255, d2[15] = tt >>> 24 & 255, d2[16] = J2 >>> 0 & 255, d2[17] = J2 >>> 8 & 255, d2[18] = J2 >>> 16 & 255, d2[19] = J2 >>> 24 & 255, d2[20] = Z >>> 0 & 255, d2[21] = Z >>> 8 & 255, d2[22] = Z >>> 16 & 255, d2[23] = Z >>> 24 & 255, d2[24] = de >>> 0 & 255, d2[25] = de >>> 8 & 255, d2[26] = de >>> 16 & 255, d2[27] = de >>> 24 & 255, d2[28] = ae >>> 0 & 255, d2[29] = ae >>> 8 & 255, d2[30] = ae >>> 16 & 255, d2[31] = ae >>> 24 & 255;
    }
    function re2(d2, x2, y2, a) {
      U(d2, x2, y2, a);
    }
    function le(d2, x2, y2, a) {
      ee(d2, x2, y2, a);
    }
    var H2 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function I(d2, x2, y2, a, v, L2, q) {
      var ue2 = new Uint8Array(16), ye2 = new Uint8Array(64), Re, Ae2;
      for (Ae2 = 0; Ae2 < 16; Ae2++)
        ue2[Ae2] = 0;
      for (Ae2 = 0; Ae2 < 8; Ae2++)
        ue2[Ae2] = L2[Ae2];
      for (; v >= 64; ) {
        for (re2(ye2, ue2, q, H2), Ae2 = 0; Ae2 < 64; Ae2++)
          d2[x2 + Ae2] = y2[a + Ae2] ^ ye2[Ae2];
        for (Re = 1, Ae2 = 8; Ae2 < 16; Ae2++)
          Re = Re + (ue2[Ae2] & 255) | 0, ue2[Ae2] = Re & 255, Re >>>= 8;
        v -= 64, x2 += 64, a += 64;
      }
      if (v > 0)
        for (re2(ye2, ue2, q, H2), Ae2 = 0; Ae2 < v; Ae2++)
          d2[x2 + Ae2] = y2[a + Ae2] ^ ye2[Ae2];
      return 0;
    }
    function K2(d2, x2, y2, a, v) {
      var L2 = new Uint8Array(16), q = new Uint8Array(64), ue2, ye2;
      for (ye2 = 0; ye2 < 16; ye2++)
        L2[ye2] = 0;
      for (ye2 = 0; ye2 < 8; ye2++)
        L2[ye2] = a[ye2];
      for (; y2 >= 64; ) {
        for (re2(q, L2, v, H2), ye2 = 0; ye2 < 64; ye2++)
          d2[x2 + ye2] = q[ye2];
        for (ue2 = 1, ye2 = 8; ye2 < 16; ye2++)
          ue2 = ue2 + (L2[ye2] & 255) | 0, L2[ye2] = ue2 & 255, ue2 >>>= 8;
        y2 -= 64, x2 += 64;
      }
      if (y2 > 0)
        for (re2(q, L2, v, H2), ye2 = 0; ye2 < y2; ye2++)
          d2[x2 + ye2] = q[ye2];
      return 0;
    }
    function P2(d2, x2, y2, a, v) {
      var L2 = new Uint8Array(32);
      le(L2, a, v, H2);
      for (var q = new Uint8Array(8), ue2 = 0; ue2 < 8; ue2++)
        q[ue2] = a[ue2 + 16];
      return K2(d2, x2, y2, q, L2);
    }
    function k2(d2, x2, y2, a, v, L2, q) {
      var ue2 = new Uint8Array(32);
      le(ue2, L2, q, H2);
      for (var ye2 = new Uint8Array(8), Re = 0; Re < 8; Re++)
        ye2[Re] = L2[Re + 16];
      return I(d2, x2, y2, a, v, ye2, ue2);
    }
    var te2 = function(d2) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var x2, y2, a, v, L2, q, ue2, ye2;
      x2 = d2[0] & 255 | (d2[1] & 255) << 8, this.r[0] = x2 & 8191, y2 = d2[2] & 255 | (d2[3] & 255) << 8, this.r[1] = (x2 >>> 13 | y2 << 3) & 8191, a = d2[4] & 255 | (d2[5] & 255) << 8, this.r[2] = (y2 >>> 10 | a << 6) & 7939, v = d2[6] & 255 | (d2[7] & 255) << 8, this.r[3] = (a >>> 7 | v << 9) & 8191, L2 = d2[8] & 255 | (d2[9] & 255) << 8, this.r[4] = (v >>> 4 | L2 << 12) & 255, this.r[5] = L2 >>> 1 & 8190, q = d2[10] & 255 | (d2[11] & 255) << 8, this.r[6] = (L2 >>> 14 | q << 2) & 8191, ue2 = d2[12] & 255 | (d2[13] & 255) << 8, this.r[7] = (q >>> 11 | ue2 << 5) & 8065, ye2 = d2[14] & 255 | (d2[15] & 255) << 8, this.r[8] = (ue2 >>> 8 | ye2 << 8) & 8191, this.r[9] = ye2 >>> 5 & 127, this.pad[0] = d2[16] & 255 | (d2[17] & 255) << 8, this.pad[1] = d2[18] & 255 | (d2[19] & 255) << 8, this.pad[2] = d2[20] & 255 | (d2[21] & 255) << 8, this.pad[3] = d2[22] & 255 | (d2[23] & 255) << 8, this.pad[4] = d2[24] & 255 | (d2[25] & 255) << 8, this.pad[5] = d2[26] & 255 | (d2[27] & 255) << 8, this.pad[6] = d2[28] & 255 | (d2[29] & 255) << 8, this.pad[7] = d2[30] & 255 | (d2[31] & 255) << 8;
    };
    te2.prototype.blocks = function(d2, x2, y2) {
      for (var a = this.fin ? 0 : 2048, v, L2, q, ue2, ye2, Re, Ae2, gt, Fe, $e, Ge, Qe, Xe, We, Ye, Ke, Ne, ke2, Ie, Oe = this.h[0], Me = this.h[1], _e2 = this.h[2], J2 = this.h[3], Z = this.h[4], de = this.h[5], ae = this.h[6], fe = this.h[7], ge2 = this.h[8], Le = this.h[9], et = this.r[0], rt = this.r[1], tt = this.r[2], S2 = this.r[3], st = this.r[4], mt = this.r[5], yt = this.r[6], nt = this.r[7], dt = this.r[8], ht = this.r[9]; y2 >= 16; )
        v = d2[x2 + 0] & 255 | (d2[x2 + 1] & 255) << 8, Oe += v & 8191, L2 = d2[x2 + 2] & 255 | (d2[x2 + 3] & 255) << 8, Me += (v >>> 13 | L2 << 3) & 8191, q = d2[x2 + 4] & 255 | (d2[x2 + 5] & 255) << 8, _e2 += (L2 >>> 10 | q << 6) & 8191, ue2 = d2[x2 + 6] & 255 | (d2[x2 + 7] & 255) << 8, J2 += (q >>> 7 | ue2 << 9) & 8191, ye2 = d2[x2 + 8] & 255 | (d2[x2 + 9] & 255) << 8, Z += (ue2 >>> 4 | ye2 << 12) & 8191, de += ye2 >>> 1 & 8191, Re = d2[x2 + 10] & 255 | (d2[x2 + 11] & 255) << 8, ae += (ye2 >>> 14 | Re << 2) & 8191, Ae2 = d2[x2 + 12] & 255 | (d2[x2 + 13] & 255) << 8, fe += (Re >>> 11 | Ae2 << 5) & 8191, gt = d2[x2 + 14] & 255 | (d2[x2 + 15] & 255) << 8, ge2 += (Ae2 >>> 8 | gt << 8) & 8191, Le += gt >>> 5 | a, Fe = 0, $e = Fe, $e += Oe * et, $e += Me * (5 * ht), $e += _e2 * (5 * dt), $e += J2 * (5 * nt), $e += Z * (5 * yt), Fe = $e >>> 13, $e &= 8191, $e += de * (5 * mt), $e += ae * (5 * st), $e += fe * (5 * S2), $e += ge2 * (5 * tt), $e += Le * (5 * rt), Fe += $e >>> 13, $e &= 8191, Ge = Fe, Ge += Oe * rt, Ge += Me * et, Ge += _e2 * (5 * ht), Ge += J2 * (5 * dt), Ge += Z * (5 * nt), Fe = Ge >>> 13, Ge &= 8191, Ge += de * (5 * yt), Ge += ae * (5 * mt), Ge += fe * (5 * st), Ge += ge2 * (5 * S2), Ge += Le * (5 * tt), Fe += Ge >>> 13, Ge &= 8191, Qe = Fe, Qe += Oe * tt, Qe += Me * rt, Qe += _e2 * et, Qe += J2 * (5 * ht), Qe += Z * (5 * dt), Fe = Qe >>> 13, Qe &= 8191, Qe += de * (5 * nt), Qe += ae * (5 * yt), Qe += fe * (5 * mt), Qe += ge2 * (5 * st), Qe += Le * (5 * S2), Fe += Qe >>> 13, Qe &= 8191, Xe = Fe, Xe += Oe * S2, Xe += Me * tt, Xe += _e2 * rt, Xe += J2 * et, Xe += Z * (5 * ht), Fe = Xe >>> 13, Xe &= 8191, Xe += de * (5 * dt), Xe += ae * (5 * nt), Xe += fe * (5 * yt), Xe += ge2 * (5 * mt), Xe += Le * (5 * st), Fe += Xe >>> 13, Xe &= 8191, We = Fe, We += Oe * st, We += Me * S2, We += _e2 * tt, We += J2 * rt, We += Z * et, Fe = We >>> 13, We &= 8191, We += de * (5 * ht), We += ae * (5 * dt), We += fe * (5 * nt), We += ge2 * (5 * yt), We += Le * (5 * mt), Fe += We >>> 13, We &= 8191, Ye = Fe, Ye += Oe * mt, Ye += Me * st, Ye += _e2 * S2, Ye += J2 * tt, Ye += Z * rt, Fe = Ye >>> 13, Ye &= 8191, Ye += de * et, Ye += ae * (5 * ht), Ye += fe * (5 * dt), Ye += ge2 * (5 * nt), Ye += Le * (5 * yt), Fe += Ye >>> 13, Ye &= 8191, Ke = Fe, Ke += Oe * yt, Ke += Me * mt, Ke += _e2 * st, Ke += J2 * S2, Ke += Z * tt, Fe = Ke >>> 13, Ke &= 8191, Ke += de * rt, Ke += ae * et, Ke += fe * (5 * ht), Ke += ge2 * (5 * dt), Ke += Le * (5 * nt), Fe += Ke >>> 13, Ke &= 8191, Ne = Fe, Ne += Oe * nt, Ne += Me * yt, Ne += _e2 * mt, Ne += J2 * st, Ne += Z * S2, Fe = Ne >>> 13, Ne &= 8191, Ne += de * tt, Ne += ae * rt, Ne += fe * et, Ne += ge2 * (5 * ht), Ne += Le * (5 * dt), Fe += Ne >>> 13, Ne &= 8191, ke2 = Fe, ke2 += Oe * dt, ke2 += Me * nt, ke2 += _e2 * yt, ke2 += J2 * mt, ke2 += Z * st, Fe = ke2 >>> 13, ke2 &= 8191, ke2 += de * S2, ke2 += ae * tt, ke2 += fe * rt, ke2 += ge2 * et, ke2 += Le * (5 * ht), Fe += ke2 >>> 13, ke2 &= 8191, Ie = Fe, Ie += Oe * ht, Ie += Me * dt, Ie += _e2 * nt, Ie += J2 * yt, Ie += Z * mt, Fe = Ie >>> 13, Ie &= 8191, Ie += de * st, Ie += ae * S2, Ie += fe * tt, Ie += ge2 * rt, Ie += Le * et, Fe += Ie >>> 13, Ie &= 8191, Fe = (Fe << 2) + Fe | 0, Fe = Fe + $e | 0, $e = Fe & 8191, Fe = Fe >>> 13, Ge += Fe, Oe = $e, Me = Ge, _e2 = Qe, J2 = Xe, Z = We, de = Ye, ae = Ke, fe = Ne, ge2 = ke2, Le = Ie, x2 += 16, y2 -= 16;
      this.h[0] = Oe, this.h[1] = Me, this.h[2] = _e2, this.h[3] = J2, this.h[4] = Z, this.h[5] = de, this.h[6] = ae, this.h[7] = fe, this.h[8] = ge2, this.h[9] = Le;
    }, te2.prototype.finish = function(d2, x2) {
      var y2 = new Uint16Array(10), a, v, L2, q;
      if (this.leftover) {
        for (q = this.leftover, this.buffer[q++] = 1; q < 16; q++)
          this.buffer[q] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (a = this.h[1] >>> 13, this.h[1] &= 8191, q = 2; q < 10; q++)
        this.h[q] += a, a = this.h[q] >>> 13, this.h[q] &= 8191;
      for (this.h[0] += a * 5, a = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += a, a = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += a, y2[0] = this.h[0] + 5, a = y2[0] >>> 13, y2[0] &= 8191, q = 1; q < 10; q++)
        y2[q] = this.h[q] + a, a = y2[q] >>> 13, y2[q] &= 8191;
      for (y2[9] -= 8192, v = (a ^ 1) - 1, q = 0; q < 10; q++)
        y2[q] &= v;
      for (v = ~v, q = 0; q < 10; q++)
        this.h[q] = this.h[q] & v | y2[q];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, L2 = this.h[0] + this.pad[0], this.h[0] = L2 & 65535, q = 1; q < 8; q++)
        L2 = (this.h[q] + this.pad[q] | 0) + (L2 >>> 16) | 0, this.h[q] = L2 & 65535;
      d2[x2 + 0] = this.h[0] >>> 0 & 255, d2[x2 + 1] = this.h[0] >>> 8 & 255, d2[x2 + 2] = this.h[1] >>> 0 & 255, d2[x2 + 3] = this.h[1] >>> 8 & 255, d2[x2 + 4] = this.h[2] >>> 0 & 255, d2[x2 + 5] = this.h[2] >>> 8 & 255, d2[x2 + 6] = this.h[3] >>> 0 & 255, d2[x2 + 7] = this.h[3] >>> 8 & 255, d2[x2 + 8] = this.h[4] >>> 0 & 255, d2[x2 + 9] = this.h[4] >>> 8 & 255, d2[x2 + 10] = this.h[5] >>> 0 & 255, d2[x2 + 11] = this.h[5] >>> 8 & 255, d2[x2 + 12] = this.h[6] >>> 0 & 255, d2[x2 + 13] = this.h[6] >>> 8 & 255, d2[x2 + 14] = this.h[7] >>> 0 & 255, d2[x2 + 15] = this.h[7] >>> 8 & 255;
    }, te2.prototype.update = function(d2, x2, y2) {
      var a, v;
      if (this.leftover) {
        for (v = 16 - this.leftover, v > y2 && (v = y2), a = 0; a < v; a++)
          this.buffer[this.leftover + a] = d2[x2 + a];
        if (y2 -= v, x2 += v, this.leftover += v, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (y2 >= 16 && (v = y2 - y2 % 16, this.blocks(d2, x2, v), x2 += v, y2 -= v), y2) {
        for (a = 0; a < y2; a++)
          this.buffer[this.leftover + a] = d2[x2 + a];
        this.leftover += y2;
      }
    };
    function T(d2, x2, y2, a, v, L2) {
      var q = new te2(L2);
      return q.update(y2, a, v), q.finish(d2, x2), 0;
    }
    function D2(d2, x2, y2, a, v, L2) {
      var q = new Uint8Array(16);
      return T(q, 0, y2, a, v, L2), Q(d2, x2, q, 0);
    }
    function V2(d2, x2, y2, a, v) {
      var L2;
      if (y2 < 32)
        return -1;
      for (k2(d2, 0, x2, 0, y2, a, v), T(d2, 16, d2, 32, y2 - 32, d2), L2 = 0; L2 < 16; L2++)
        d2[L2] = 0;
      return 0;
    }
    function pe(d2, x2, y2, a, v) {
      var L2, q = new Uint8Array(32);
      if (y2 < 32 || (P2(q, 0, 32, a, v), D2(x2, 16, x2, 32, y2 - 32, q) !== 0))
        return -1;
      for (k2(d2, 0, x2, 0, y2, a, v), L2 = 0; L2 < 32; L2++)
        d2[L2] = 0;
      return 0;
    }
    function we(d2, x2) {
      var y2;
      for (y2 = 0; y2 < 16; y2++)
        d2[y2] = x2[y2] | 0;
    }
    function ve(d2) {
      var x2, y2, a = 1;
      for (x2 = 0; x2 < 16; x2++)
        y2 = d2[x2] + a + 65535, a = Math.floor(y2 / 65536), d2[x2] = y2 - a * 65536;
      d2[0] += a - 1 + 37 * (a - 1);
    }
    function qe(d2, x2, y2) {
      for (var a, v = ~(y2 - 1), L2 = 0; L2 < 16; L2++)
        a = v & (d2[L2] ^ x2[L2]), d2[L2] ^= a, x2[L2] ^= a;
    }
    function Ve(d2, x2) {
      var y2, a, v, L2 = e(), q = e();
      for (y2 = 0; y2 < 16; y2++)
        q[y2] = x2[y2];
      for (ve(q), ve(q), ve(q), a = 0; a < 2; a++) {
        for (L2[0] = q[0] - 65517, y2 = 1; y2 < 15; y2++)
          L2[y2] = q[y2] - 65535 - (L2[y2 - 1] >> 16 & 1), L2[y2 - 1] &= 65535;
        L2[15] = q[15] - 32767 - (L2[14] >> 16 & 1), v = L2[15] >> 16 & 1, L2[14] &= 65535, qe(q, L2, 1 - v);
      }
      for (y2 = 0; y2 < 16; y2++)
        d2[2 * y2] = q[y2] & 255, d2[2 * y2 + 1] = q[y2] >> 8;
    }
    function Te(d2, x2) {
      var y2 = new Uint8Array(32), a = new Uint8Array(32);
      return Ve(y2, d2), Ve(a, x2), N2(y2, 0, a, 0);
    }
    function ze(d2) {
      var x2 = new Uint8Array(32);
      return Ve(x2, d2), x2[0] & 1;
    }
    function Je(d2, x2) {
      var y2;
      for (y2 = 0; y2 < 16; y2++)
        d2[y2] = x2[2 * y2] + (x2[2 * y2 + 1] << 8);
      d2[15] &= 32767;
    }
    function Be(d2, x2, y2) {
      for (var a = 0; a < 16; a++)
        d2[a] = x2[a] + y2[a];
    }
    function W2(d2, x2, y2) {
      for (var a = 0; a < 16; a++)
        d2[a] = x2[a] - y2[a];
    }
    function Se(d2, x2, y2) {
      var a, v, L2 = 0, q = 0, ue2 = 0, ye2 = 0, Re = 0, Ae2 = 0, gt = 0, Fe = 0, $e = 0, Ge = 0, Qe = 0, Xe = 0, We = 0, Ye = 0, Ke = 0, Ne = 0, ke2 = 0, Ie = 0, Oe = 0, Me = 0, _e2 = 0, J2 = 0, Z = 0, de = 0, ae = 0, fe = 0, ge2 = 0, Le = 0, et = 0, rt = 0, tt = 0, S2 = y2[0], st = y2[1], mt = y2[2], yt = y2[3], nt = y2[4], dt = y2[5], ht = y2[6], Pt = y2[7], It = y2[8], kt = y2[9], jt = y2[10], Bt = y2[11], $t = y2[12], Xt = y2[13], Qt = y2[14], er = y2[15];
      a = x2[0], L2 += a * S2, q += a * st, ue2 += a * mt, ye2 += a * yt, Re += a * nt, Ae2 += a * dt, gt += a * ht, Fe += a * Pt, $e += a * It, Ge += a * kt, Qe += a * jt, Xe += a * Bt, We += a * $t, Ye += a * Xt, Ke += a * Qt, Ne += a * er, a = x2[1], q += a * S2, ue2 += a * st, ye2 += a * mt, Re += a * yt, Ae2 += a * nt, gt += a * dt, Fe += a * ht, $e += a * Pt, Ge += a * It, Qe += a * kt, Xe += a * jt, We += a * Bt, Ye += a * $t, Ke += a * Xt, Ne += a * Qt, ke2 += a * er, a = x2[2], ue2 += a * S2, ye2 += a * st, Re += a * mt, Ae2 += a * yt, gt += a * nt, Fe += a * dt, $e += a * ht, Ge += a * Pt, Qe += a * It, Xe += a * kt, We += a * jt, Ye += a * Bt, Ke += a * $t, Ne += a * Xt, ke2 += a * Qt, Ie += a * er, a = x2[3], ye2 += a * S2, Re += a * st, Ae2 += a * mt, gt += a * yt, Fe += a * nt, $e += a * dt, Ge += a * ht, Qe += a * Pt, Xe += a * It, We += a * kt, Ye += a * jt, Ke += a * Bt, Ne += a * $t, ke2 += a * Xt, Ie += a * Qt, Oe += a * er, a = x2[4], Re += a * S2, Ae2 += a * st, gt += a * mt, Fe += a * yt, $e += a * nt, Ge += a * dt, Qe += a * ht, Xe += a * Pt, We += a * It, Ye += a * kt, Ke += a * jt, Ne += a * Bt, ke2 += a * $t, Ie += a * Xt, Oe += a * Qt, Me += a * er, a = x2[5], Ae2 += a * S2, gt += a * st, Fe += a * mt, $e += a * yt, Ge += a * nt, Qe += a * dt, Xe += a * ht, We += a * Pt, Ye += a * It, Ke += a * kt, Ne += a * jt, ke2 += a * Bt, Ie += a * $t, Oe += a * Xt, Me += a * Qt, _e2 += a * er, a = x2[6], gt += a * S2, Fe += a * st, $e += a * mt, Ge += a * yt, Qe += a * nt, Xe += a * dt, We += a * ht, Ye += a * Pt, Ke += a * It, Ne += a * kt, ke2 += a * jt, Ie += a * Bt, Oe += a * $t, Me += a * Xt, _e2 += a * Qt, J2 += a * er, a = x2[7], Fe += a * S2, $e += a * st, Ge += a * mt, Qe += a * yt, Xe += a * nt, We += a * dt, Ye += a * ht, Ke += a * Pt, Ne += a * It, ke2 += a * kt, Ie += a * jt, Oe += a * Bt, Me += a * $t, _e2 += a * Xt, J2 += a * Qt, Z += a * er, a = x2[8], $e += a * S2, Ge += a * st, Qe += a * mt, Xe += a * yt, We += a * nt, Ye += a * dt, Ke += a * ht, Ne += a * Pt, ke2 += a * It, Ie += a * kt, Oe += a * jt, Me += a * Bt, _e2 += a * $t, J2 += a * Xt, Z += a * Qt, de += a * er, a = x2[9], Ge += a * S2, Qe += a * st, Xe += a * mt, We += a * yt, Ye += a * nt, Ke += a * dt, Ne += a * ht, ke2 += a * Pt, Ie += a * It, Oe += a * kt, Me += a * jt, _e2 += a * Bt, J2 += a * $t, Z += a * Xt, de += a * Qt, ae += a * er, a = x2[10], Qe += a * S2, Xe += a * st, We += a * mt, Ye += a * yt, Ke += a * nt, Ne += a * dt, ke2 += a * ht, Ie += a * Pt, Oe += a * It, Me += a * kt, _e2 += a * jt, J2 += a * Bt, Z += a * $t, de += a * Xt, ae += a * Qt, fe += a * er, a = x2[11], Xe += a * S2, We += a * st, Ye += a * mt, Ke += a * yt, Ne += a * nt, ke2 += a * dt, Ie += a * ht, Oe += a * Pt, Me += a * It, _e2 += a * kt, J2 += a * jt, Z += a * Bt, de += a * $t, ae += a * Xt, fe += a * Qt, ge2 += a * er, a = x2[12], We += a * S2, Ye += a * st, Ke += a * mt, Ne += a * yt, ke2 += a * nt, Ie += a * dt, Oe += a * ht, Me += a * Pt, _e2 += a * It, J2 += a * kt, Z += a * jt, de += a * Bt, ae += a * $t, fe += a * Xt, ge2 += a * Qt, Le += a * er, a = x2[13], Ye += a * S2, Ke += a * st, Ne += a * mt, ke2 += a * yt, Ie += a * nt, Oe += a * dt, Me += a * ht, _e2 += a * Pt, J2 += a * It, Z += a * kt, de += a * jt, ae += a * Bt, fe += a * $t, ge2 += a * Xt, Le += a * Qt, et += a * er, a = x2[14], Ke += a * S2, Ne += a * st, ke2 += a * mt, Ie += a * yt, Oe += a * nt, Me += a * dt, _e2 += a * ht, J2 += a * Pt, Z += a * It, de += a * kt, ae += a * jt, fe += a * Bt, ge2 += a * $t, Le += a * Xt, et += a * Qt, rt += a * er, a = x2[15], Ne += a * S2, ke2 += a * st, Ie += a * mt, Oe += a * yt, Me += a * nt, _e2 += a * dt, J2 += a * ht, Z += a * Pt, de += a * It, ae += a * kt, fe += a * jt, ge2 += a * Bt, Le += a * $t, et += a * Xt, rt += a * Qt, tt += a * er, L2 += 38 * ke2, q += 38 * Ie, ue2 += 38 * Oe, ye2 += 38 * Me, Re += 38 * _e2, Ae2 += 38 * J2, gt += 38 * Z, Fe += 38 * de, $e += 38 * ae, Ge += 38 * fe, Qe += 38 * ge2, Xe += 38 * Le, We += 38 * et, Ye += 38 * rt, Ke += 38 * tt, v = 1, a = L2 + v + 65535, v = Math.floor(a / 65536), L2 = a - v * 65536, a = q + v + 65535, v = Math.floor(a / 65536), q = a - v * 65536, a = ue2 + v + 65535, v = Math.floor(a / 65536), ue2 = a - v * 65536, a = ye2 + v + 65535, v = Math.floor(a / 65536), ye2 = a - v * 65536, a = Re + v + 65535, v = Math.floor(a / 65536), Re = a - v * 65536, a = Ae2 + v + 65535, v = Math.floor(a / 65536), Ae2 = a - v * 65536, a = gt + v + 65535, v = Math.floor(a / 65536), gt = a - v * 65536, a = Fe + v + 65535, v = Math.floor(a / 65536), Fe = a - v * 65536, a = $e + v + 65535, v = Math.floor(a / 65536), $e = a - v * 65536, a = Ge + v + 65535, v = Math.floor(a / 65536), Ge = a - v * 65536, a = Qe + v + 65535, v = Math.floor(a / 65536), Qe = a - v * 65536, a = Xe + v + 65535, v = Math.floor(a / 65536), Xe = a - v * 65536, a = We + v + 65535, v = Math.floor(a / 65536), We = a - v * 65536, a = Ye + v + 65535, v = Math.floor(a / 65536), Ye = a - v * 65536, a = Ke + v + 65535, v = Math.floor(a / 65536), Ke = a - v * 65536, a = Ne + v + 65535, v = Math.floor(a / 65536), Ne = a - v * 65536, L2 += v - 1 + 37 * (v - 1), v = 1, a = L2 + v + 65535, v = Math.floor(a / 65536), L2 = a - v * 65536, a = q + v + 65535, v = Math.floor(a / 65536), q = a - v * 65536, a = ue2 + v + 65535, v = Math.floor(a / 65536), ue2 = a - v * 65536, a = ye2 + v + 65535, v = Math.floor(a / 65536), ye2 = a - v * 65536, a = Re + v + 65535, v = Math.floor(a / 65536), Re = a - v * 65536, a = Ae2 + v + 65535, v = Math.floor(a / 65536), Ae2 = a - v * 65536, a = gt + v + 65535, v = Math.floor(a / 65536), gt = a - v * 65536, a = Fe + v + 65535, v = Math.floor(a / 65536), Fe = a - v * 65536, a = $e + v + 65535, v = Math.floor(a / 65536), $e = a - v * 65536, a = Ge + v + 65535, v = Math.floor(a / 65536), Ge = a - v * 65536, a = Qe + v + 65535, v = Math.floor(a / 65536), Qe = a - v * 65536, a = Xe + v + 65535, v = Math.floor(a / 65536), Xe = a - v * 65536, a = We + v + 65535, v = Math.floor(a / 65536), We = a - v * 65536, a = Ye + v + 65535, v = Math.floor(a / 65536), Ye = a - v * 65536, a = Ke + v + 65535, v = Math.floor(a / 65536), Ke = a - v * 65536, a = Ne + v + 65535, v = Math.floor(a / 65536), Ne = a - v * 65536, L2 += v - 1 + 37 * (v - 1), d2[0] = L2, d2[1] = q, d2[2] = ue2, d2[3] = ye2, d2[4] = Re, d2[5] = Ae2, d2[6] = gt, d2[7] = Fe, d2[8] = $e, d2[9] = Ge, d2[10] = Qe, d2[11] = Xe, d2[12] = We, d2[13] = Ye, d2[14] = Ke, d2[15] = Ne;
    }
    function ct(d2, x2) {
      Se(d2, x2, x2);
    }
    function Ot(d2, x2) {
      var y2 = e(), a;
      for (a = 0; a < 16; a++)
        y2[a] = x2[a];
      for (a = 253; a >= 0; a--)
        ct(y2, y2), a !== 2 && a !== 4 && Se(y2, y2, x2);
      for (a = 0; a < 16; a++)
        d2[a] = y2[a];
    }
    function pt(d2, x2) {
      var y2 = e(), a;
      for (a = 0; a < 16; a++)
        y2[a] = x2[a];
      for (a = 250; a >= 0; a--)
        ct(y2, y2), a !== 1 && Se(y2, y2, x2);
      for (a = 0; a < 16; a++)
        d2[a] = y2[a];
    }
    function me(d2, x2, y2) {
      var a = new Uint8Array(32), v = new Float64Array(80), L2, q, ue2 = e(), ye2 = e(), Re = e(), Ae2 = e(), gt = e(), Fe = e();
      for (q = 0; q < 31; q++)
        a[q] = x2[q];
      for (a[31] = x2[31] & 127 | 64, a[0] &= 248, Je(v, y2), q = 0; q < 16; q++)
        ye2[q] = v[q], Ae2[q] = ue2[q] = Re[q] = 0;
      for (ue2[0] = Ae2[0] = 1, q = 254; q >= 0; --q)
        L2 = a[q >>> 3] >>> (q & 7) & 1, qe(ue2, ye2, L2), qe(Re, Ae2, L2), Be(gt, ue2, Re), W2(ue2, ue2, Re), Be(Re, ye2, Ae2), W2(ye2, ye2, Ae2), ct(Ae2, gt), ct(Fe, ue2), Se(ue2, Re, ue2), Se(Re, ye2, gt), Be(gt, ue2, Re), W2(ue2, ue2, Re), ct(ye2, ue2), W2(Re, Ae2, Fe), Se(ue2, Re, c), Be(ue2, ue2, Ae2), Se(Re, Re, ue2), Se(ue2, Ae2, Fe), Se(Ae2, ye2, v), ct(ye2, gt), qe(ue2, ye2, L2), qe(Re, Ae2, L2);
      for (q = 0; q < 16; q++)
        v[q + 16] = ue2[q], v[q + 32] = Re[q], v[q + 48] = ye2[q], v[q + 64] = Ae2[q];
      var $e = v.subarray(32), Ge = v.subarray(16);
      return Ot($e, $e), Se(Ge, Ge, $e), Ve(d2, Ge), 0;
    }
    function p2(d2, x2) {
      return me(d2, x2, i);
    }
    function b2(d2, x2) {
      return t(x2, 32), p2(d2, x2);
    }
    function E2(d2, x2, y2) {
      var a = new Uint8Array(32);
      return me(a, y2, x2), le(d2, n, a, H2);
    }
    var $ = V2, R2 = pe;
    function z2(d2, x2, y2, a, v, L2) {
      var q = new Uint8Array(32);
      return E2(q, v, L2), $(d2, x2, y2, a, q);
    }
    function Y(d2, x2, y2, a, v, L2) {
      var q = new Uint8Array(32);
      return E2(q, v, L2), R2(d2, x2, y2, a, q);
    }
    var M = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function B(d2, x2, y2, a) {
      for (var v = new Int32Array(16), L2 = new Int32Array(16), q, ue2, ye2, Re, Ae2, gt, Fe, $e, Ge, Qe, Xe, We, Ye, Ke, Ne, ke2, Ie, Oe, Me, _e2, J2, Z, de, ae, fe, ge2, Le = d2[0], et = d2[1], rt = d2[2], tt = d2[3], S2 = d2[4], st = d2[5], mt = d2[6], yt = d2[7], nt = x2[0], dt = x2[1], ht = x2[2], Pt = x2[3], It = x2[4], kt = x2[5], jt = x2[6], Bt = x2[7], $t = 0; a >= 128; ) {
        for (Me = 0; Me < 16; Me++)
          _e2 = 8 * Me + $t, v[Me] = y2[_e2 + 0] << 24 | y2[_e2 + 1] << 16 | y2[_e2 + 2] << 8 | y2[_e2 + 3], L2[Me] = y2[_e2 + 4] << 24 | y2[_e2 + 5] << 16 | y2[_e2 + 6] << 8 | y2[_e2 + 7];
        for (Me = 0; Me < 80; Me++)
          if (q = Le, ue2 = et, ye2 = rt, Re = tt, Ae2 = S2, gt = st, Fe = mt, $e = yt, Ge = nt, Qe = dt, Xe = ht, We = Pt, Ye = It, Ke = kt, Ne = jt, ke2 = Bt, J2 = yt, Z = Bt, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = (S2 >>> 14 | It << 32 - 14) ^ (S2 >>> 18 | It << 32 - 18) ^ (It >>> 41 - 32 | S2 << 32 - (41 - 32)), Z = (It >>> 14 | S2 << 32 - 14) ^ (It >>> 18 | S2 << 32 - 18) ^ (S2 >>> 41 - 32 | It << 32 - (41 - 32)), de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, J2 = S2 & st ^ ~S2 & mt, Z = It & kt ^ ~It & jt, de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, J2 = M[Me * 2], Z = M[Me * 2 + 1], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, J2 = v[Me % 16], Z = L2[Me % 16], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, Ie = fe & 65535 | ge2 << 16, Oe = de & 65535 | ae << 16, J2 = Ie, Z = Oe, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = (Le >>> 28 | nt << 32 - 28) ^ (nt >>> 34 - 32 | Le << 32 - (34 - 32)) ^ (nt >>> 39 - 32 | Le << 32 - (39 - 32)), Z = (nt >>> 28 | Le << 32 - 28) ^ (Le >>> 34 - 32 | nt << 32 - (34 - 32)) ^ (Le >>> 39 - 32 | nt << 32 - (39 - 32)), de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, J2 = Le & et ^ Le & rt ^ et & rt, Z = nt & dt ^ nt & ht ^ dt & ht, de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, $e = fe & 65535 | ge2 << 16, ke2 = de & 65535 | ae << 16, J2 = Re, Z = We, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = Ie, Z = Oe, de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, Re = fe & 65535 | ge2 << 16, We = de & 65535 | ae << 16, et = q, rt = ue2, tt = ye2, S2 = Re, st = Ae2, mt = gt, yt = Fe, Le = $e, dt = Ge, ht = Qe, Pt = Xe, It = We, kt = Ye, jt = Ke, Bt = Ne, nt = ke2, Me % 16 === 15)
            for (_e2 = 0; _e2 < 16; _e2++)
              J2 = v[_e2], Z = L2[_e2], de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = v[(_e2 + 9) % 16], Z = L2[(_e2 + 9) % 16], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, Ie = v[(_e2 + 1) % 16], Oe = L2[(_e2 + 1) % 16], J2 = (Ie >>> 1 | Oe << 32 - 1) ^ (Ie >>> 8 | Oe << 32 - 8) ^ Ie >>> 7, Z = (Oe >>> 1 | Ie << 32 - 1) ^ (Oe >>> 8 | Ie << 32 - 8) ^ (Oe >>> 7 | Ie << 32 - 7), de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, Ie = v[(_e2 + 14) % 16], Oe = L2[(_e2 + 14) % 16], J2 = (Ie >>> 19 | Oe << 32 - 19) ^ (Oe >>> 61 - 32 | Ie << 32 - (61 - 32)) ^ Ie >>> 6, Z = (Oe >>> 19 | Ie << 32 - 19) ^ (Ie >>> 61 - 32 | Oe << 32 - (61 - 32)) ^ (Oe >>> 6 | Ie << 32 - 6), de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, v[_e2] = fe & 65535 | ge2 << 16, L2[_e2] = de & 65535 | ae << 16;
        J2 = Le, Z = nt, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[0], Z = x2[0], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[0] = Le = fe & 65535 | ge2 << 16, x2[0] = nt = de & 65535 | ae << 16, J2 = et, Z = dt, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[1], Z = x2[1], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[1] = et = fe & 65535 | ge2 << 16, x2[1] = dt = de & 65535 | ae << 16, J2 = rt, Z = ht, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[2], Z = x2[2], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[2] = rt = fe & 65535 | ge2 << 16, x2[2] = ht = de & 65535 | ae << 16, J2 = tt, Z = Pt, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[3], Z = x2[3], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[3] = tt = fe & 65535 | ge2 << 16, x2[3] = Pt = de & 65535 | ae << 16, J2 = S2, Z = It, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[4], Z = x2[4], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[4] = S2 = fe & 65535 | ge2 << 16, x2[4] = It = de & 65535 | ae << 16, J2 = st, Z = kt, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[5], Z = x2[5], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[5] = st = fe & 65535 | ge2 << 16, x2[5] = kt = de & 65535 | ae << 16, J2 = mt, Z = jt, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[6], Z = x2[6], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[6] = mt = fe & 65535 | ge2 << 16, x2[6] = jt = de & 65535 | ae << 16, J2 = yt, Z = Bt, de = Z & 65535, ae = Z >>> 16, fe = J2 & 65535, ge2 = J2 >>> 16, J2 = d2[7], Z = x2[7], de += Z & 65535, ae += Z >>> 16, fe += J2 & 65535, ge2 += J2 >>> 16, ae += de >>> 16, fe += ae >>> 16, ge2 += fe >>> 16, d2[7] = yt = fe & 65535 | ge2 << 16, x2[7] = Bt = de & 65535 | ae << 16, $t += 128, a -= 128;
      }
      return a;
    }
    function m2(d2, x2, y2) {
      var a = new Int32Array(8), v = new Int32Array(8), L2 = new Uint8Array(256), q, ue2 = y2;
      for (a[0] = 1779033703, a[1] = 3144134277, a[2] = 1013904242, a[3] = 2773480762, a[4] = 1359893119, a[5] = 2600822924, a[6] = 528734635, a[7] = 1541459225, v[0] = 4089235720, v[1] = 2227873595, v[2] = 4271175723, v[3] = 1595750129, v[4] = 2917565137, v[5] = 725511199, v[6] = 4215389547, v[7] = 327033209, B(a, v, x2, y2), y2 %= 128, q = 0; q < y2; q++)
        L2[q] = x2[ue2 - y2 + q];
      for (L2[y2] = 128, y2 = 256 - 128 * (y2 < 112 ? 1 : 0), L2[y2 - 9] = 0, ie(L2, y2 - 8, ue2 / 536870912 | 0, ue2 << 3), B(a, v, L2, y2), q = 0; q < 8; q++)
        ie(d2, 8 * q, a[q], v[q]);
      return 0;
    }
    function u2(d2, x2) {
      var y2 = e(), a = e(), v = e(), L2 = e(), q = e(), ue2 = e(), ye2 = e(), Re = e(), Ae2 = e();
      W2(y2, d2[1], d2[0]), W2(Ae2, x2[1], x2[0]), Se(y2, y2, Ae2), Be(a, d2[0], d2[1]), Be(Ae2, x2[0], x2[1]), Se(a, a, Ae2), Se(v, d2[3], x2[3]), Se(v, v, f2), Se(L2, d2[2], x2[2]), Be(L2, L2, L2), W2(q, a, y2), W2(ue2, L2, v), Be(ye2, L2, v), Be(Re, a, y2), Se(d2[0], q, ue2), Se(d2[1], Re, ye2), Se(d2[2], ye2, ue2), Se(d2[3], q, Re);
    }
    function g(d2, x2, y2) {
      var a;
      for (a = 0; a < 4; a++)
        qe(d2[a], x2[a], y2);
    }
    function A(d2, x2) {
      var y2 = e(), a = e(), v = e();
      Ot(v, x2[2]), Se(y2, x2[0], v), Se(a, x2[1], v), Ve(d2, a), d2[31] ^= ze(y2) << 7;
    }
    function w(d2, x2, y2) {
      var a, v;
      for (we(d2[0], s), we(d2[1], o), we(d2[2], o), we(d2[3], s), v = 255; v >= 0; --v)
        a = y2[v / 8 | 0] >> (v & 7) & 1, g(d2, x2, a), u2(x2, d2), u2(d2, d2), g(d2, x2, a);
    }
    function F2(d2, x2) {
      var y2 = [e(), e(), e(), e()];
      we(y2[0], h2), we(y2[1], _), we(y2[2], o), Se(y2[3], h2, _), w(d2, y2, x2);
    }
    function O2(d2, x2, y2) {
      var a = new Uint8Array(64), v = [e(), e(), e(), e()], L2;
      for (y2 || t(x2, 32), m2(a, x2, 32), a[0] &= 248, a[31] &= 127, a[31] |= 64, F2(v, a), A(d2, v), L2 = 0; L2 < 32; L2++)
        x2[L2 + 32] = d2[L2];
      return 0;
    }
    var X = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function ce(d2, x2) {
      var y2, a, v, L2;
      for (a = 63; a >= 32; --a) {
        for (y2 = 0, v = a - 32, L2 = a - 12; v < L2; ++v)
          x2[v] += y2 - 16 * x2[a] * X[v - (a - 32)], y2 = Math.floor((x2[v] + 128) / 256), x2[v] -= y2 * 256;
        x2[v] += y2, x2[a] = 0;
      }
      for (y2 = 0, v = 0; v < 32; v++)
        x2[v] += y2 - (x2[31] >> 4) * X[v], y2 = x2[v] >> 8, x2[v] &= 255;
      for (v = 0; v < 32; v++)
        x2[v] -= y2 * X[v];
      for (a = 0; a < 32; a++)
        x2[a + 1] += x2[a] >> 8, d2[a] = x2[a] & 255;
    }
    function he(d2) {
      var x2 = new Float64Array(64), y2;
      for (y2 = 0; y2 < 64; y2++)
        x2[y2] = d2[y2];
      for (y2 = 0; y2 < 64; y2++)
        d2[y2] = 0;
      ce(d2, x2);
    }
    function C2(d2, x2, y2, a) {
      var v = new Uint8Array(64), L2 = new Uint8Array(64), q = new Uint8Array(64), ue2, ye2, Re = new Float64Array(64), Ae2 = [e(), e(), e(), e()];
      m2(v, a, 32), v[0] &= 248, v[31] &= 127, v[31] |= 64;
      var gt = y2 + 64;
      for (ue2 = 0; ue2 < y2; ue2++)
        d2[64 + ue2] = x2[ue2];
      for (ue2 = 0; ue2 < 32; ue2++)
        d2[32 + ue2] = v[32 + ue2];
      for (m2(q, d2.subarray(32), y2 + 32), he(q), F2(Ae2, q), A(d2, Ae2), ue2 = 32; ue2 < 64; ue2++)
        d2[ue2] = a[ue2];
      for (m2(L2, d2, y2 + 64), he(L2), ue2 = 0; ue2 < 64; ue2++)
        Re[ue2] = 0;
      for (ue2 = 0; ue2 < 32; ue2++)
        Re[ue2] = q[ue2];
      for (ue2 = 0; ue2 < 32; ue2++)
        for (ye2 = 0; ye2 < 32; ye2++)
          Re[ue2 + ye2] += L2[ue2] * v[ye2];
      return ce(d2.subarray(32), Re), gt;
    }
    function Ee2(d2, x2) {
      var y2 = e(), a = e(), v = e(), L2 = e(), q = e(), ue2 = e(), ye2 = e();
      return we(d2[2], o), Je(d2[1], x2), ct(v, d2[1]), Se(L2, v, l2), W2(v, v, d2[2]), Be(L2, d2[2], L2), ct(q, L2), ct(ue2, q), Se(ye2, ue2, q), Se(y2, ye2, v), Se(y2, y2, L2), pt(y2, y2), Se(y2, y2, v), Se(y2, y2, L2), Se(y2, y2, L2), Se(d2[0], y2, L2), ct(a, d2[0]), Se(a, a, L2), Te(a, v) && Se(d2[0], d2[0], j2), ct(a, d2[0]), Se(a, a, L2), Te(a, v) ? -1 : (ze(d2[0]) === x2[31] >> 7 && W2(d2[0], s, d2[0]), Se(d2[3], d2[0], d2[1]), 0);
    }
    function Ce(d2, x2, y2, a) {
      var v, L2 = new Uint8Array(32), q = new Uint8Array(64), ue2 = [e(), e(), e(), e()], ye2 = [e(), e(), e(), e()];
      if (y2 < 64 || Ee2(ye2, a))
        return -1;
      for (v = 0; v < y2; v++)
        d2[v] = x2[v];
      for (v = 0; v < 32; v++)
        d2[v + 32] = a[v];
      if (m2(q, d2, y2), he(q), w(ue2, ye2, q), F2(ye2, x2.subarray(32)), u2(ue2, ye2), A(L2, ue2), y2 -= 64, N2(x2, 0, L2, 0)) {
        for (v = 0; v < y2; v++)
          d2[v] = 0;
        return -1;
      }
      for (v = 0; v < y2; v++)
        d2[v] = x2[v + 64];
      return y2;
    }
    var it = 32, Pe = 24, _t = 32, ft = 16, ut = 32, Ze = 32, Lt = 32, Ut = 32, qt = 32, Wt = Pe, Yt = _t, Jt = ft, Dt = 64, Dn = 32, Mi = 64, ju = 32, Bu = 64;
    r.lowlevel = { crypto_core_hsalsa20: le, crypto_stream_xor: k2, crypto_stream: P2, crypto_stream_salsa20_xor: I, crypto_stream_salsa20: K2, crypto_onetimeauth: T, crypto_onetimeauth_verify: D2, crypto_verify_16: Q, crypto_verify_32: N2, crypto_secretbox: V2, crypto_secretbox_open: pe, crypto_scalarmult: me, crypto_scalarmult_base: p2, crypto_box_beforenm: E2, crypto_box_afternm: $, crypto_box: z2, crypto_box_open: Y, crypto_box_keypair: b2, crypto_hash: m2, crypto_sign: C2, crypto_sign_keypair: O2, crypto_sign_open: Ce, crypto_secretbox_KEYBYTES: it, crypto_secretbox_NONCEBYTES: Pe, crypto_secretbox_ZEROBYTES: _t, crypto_secretbox_BOXZEROBYTES: ft, crypto_scalarmult_BYTES: ut, crypto_scalarmult_SCALARBYTES: Ze, crypto_box_PUBLICKEYBYTES: Lt, crypto_box_SECRETKEYBYTES: Ut, crypto_box_BEFORENMBYTES: qt, crypto_box_NONCEBYTES: Wt, crypto_box_ZEROBYTES: Yt, crypto_box_BOXZEROBYTES: Jt, crypto_sign_BYTES: Dt, crypto_sign_PUBLICKEYBYTES: Dn, crypto_sign_SECRETKEYBYTES: Mi, crypto_sign_SEEDBYTES: ju, crypto_hash_BYTES: Bu, gf: e, D: l2, L: X, pack25519: Ve, unpack25519: Je, M: Se, A: Be, S: ct, Z: W2, pow2523: pt, add: u2, set25519: we, modL: ce, scalarmult: w, scalarbase: F2 };
    function ll(d2, x2) {
      if (d2.length !== it)
        throw new Error("bad key size");
      if (x2.length !== Pe)
        throw new Error("bad nonce size");
    }
    function qp(d2, x2) {
      if (d2.length !== Lt)
        throw new Error("bad public key size");
      if (x2.length !== Ut)
        throw new Error("bad secret key size");
    }
    function lr() {
      for (var d2 = 0; d2 < arguments.length; d2++)
        if (!(arguments[d2] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function dl(d2) {
      for (var x2 = 0; x2 < d2.length; x2++)
        d2[x2] = 0;
    }
    r.randomBytes = function(d2) {
      var x2 = new Uint8Array(d2);
      return t(x2, d2), x2;
    }, r.secretbox = function(d2, x2, y2) {
      lr(d2, x2, y2), ll(y2, x2);
      for (var a = new Uint8Array(_t + d2.length), v = new Uint8Array(a.length), L2 = 0; L2 < d2.length; L2++)
        a[L2 + _t] = d2[L2];
      return V2(v, a, a.length, x2, y2), v.subarray(ft);
    }, r.secretbox.open = function(d2, x2, y2) {
      lr(d2, x2, y2), ll(y2, x2);
      for (var a = new Uint8Array(ft + d2.length), v = new Uint8Array(a.length), L2 = 0; L2 < d2.length; L2++)
        a[L2 + ft] = d2[L2];
      return a.length < 32 || pe(v, a, a.length, x2, y2) !== 0 ? null : v.subarray(_t);
    }, r.secretbox.keyLength = it, r.secretbox.nonceLength = Pe, r.secretbox.overheadLength = ft, r.scalarMult = function(d2, x2) {
      if (lr(d2, x2), d2.length !== Ze)
        throw new Error("bad n size");
      if (x2.length !== ut)
        throw new Error("bad p size");
      var y2 = new Uint8Array(ut);
      return me(y2, d2, x2), y2;
    }, r.scalarMult.base = function(d2) {
      if (lr(d2), d2.length !== Ze)
        throw new Error("bad n size");
      var x2 = new Uint8Array(ut);
      return p2(x2, d2), x2;
    }, r.scalarMult.scalarLength = Ze, r.scalarMult.groupElementLength = ut, r.box = function(d2, x2, y2, a) {
      var v = r.box.before(y2, a);
      return r.secretbox(d2, x2, v);
    }, r.box.before = function(d2, x2) {
      lr(d2, x2), qp(d2, x2);
      var y2 = new Uint8Array(qt);
      return E2(y2, d2, x2), y2;
    }, r.box.after = r.secretbox, r.box.open = function(d2, x2, y2, a) {
      var v = r.box.before(y2, a);
      return r.secretbox.open(d2, x2, v);
    }, r.box.open.after = r.secretbox.open, r.box.keyPair = function() {
      var d2 = new Uint8Array(Lt), x2 = new Uint8Array(Ut);
      return b2(d2, x2), { publicKey: d2, secretKey: x2 };
    }, r.box.keyPair.fromSecretKey = function(d2) {
      if (lr(d2), d2.length !== Ut)
        throw new Error("bad secret key size");
      var x2 = new Uint8Array(Lt);
      return p2(x2, d2), { publicKey: x2, secretKey: new Uint8Array(d2) };
    }, r.box.publicKeyLength = Lt, r.box.secretKeyLength = Ut, r.box.sharedKeyLength = qt, r.box.nonceLength = Wt, r.box.overheadLength = r.secretbox.overheadLength, r.sign = function(d2, x2) {
      if (lr(d2, x2), x2.length !== Mi)
        throw new Error("bad secret key size");
      var y2 = new Uint8Array(Dt + d2.length);
      return C2(y2, d2, d2.length, x2), y2;
    }, r.sign.open = function(d2, x2) {
      if (lr(d2, x2), x2.length !== Dn)
        throw new Error("bad public key size");
      var y2 = new Uint8Array(d2.length), a = Ce(y2, d2, d2.length, x2);
      if (a < 0)
        return null;
      for (var v = new Uint8Array(a), L2 = 0; L2 < v.length; L2++)
        v[L2] = y2[L2];
      return v;
    }, r.sign.detached = function(d2, x2) {
      for (var y2 = r.sign(d2, x2), a = new Uint8Array(Dt), v = 0; v < a.length; v++)
        a[v] = y2[v];
      return a;
    }, r.sign.detached.verify = function(d2, x2, y2) {
      if (lr(d2, x2, y2), x2.length !== Dt)
        throw new Error("bad signature size");
      if (y2.length !== Dn)
        throw new Error("bad public key size");
      var a = new Uint8Array(Dt + d2.length), v = new Uint8Array(Dt + d2.length), L2;
      for (L2 = 0; L2 < Dt; L2++)
        a[L2] = x2[L2];
      for (L2 = 0; L2 < d2.length; L2++)
        a[L2 + Dt] = d2[L2];
      return Ce(v, a, a.length, y2) >= 0;
    }, r.sign.keyPair = function() {
      var d2 = new Uint8Array(Dn), x2 = new Uint8Array(Mi);
      return O2(d2, x2), { publicKey: d2, secretKey: x2 };
    }, r.sign.keyPair.fromSecretKey = function(d2) {
      if (lr(d2), d2.length !== Mi)
        throw new Error("bad secret key size");
      for (var x2 = new Uint8Array(Dn), y2 = 0; y2 < x2.length; y2++)
        x2[y2] = d2[32 + y2];
      return { publicKey: x2, secretKey: new Uint8Array(d2) };
    }, r.sign.keyPair.fromSeed = function(d2) {
      if (lr(d2), d2.length !== ju)
        throw new Error("bad seed size");
      for (var x2 = new Uint8Array(Dn), y2 = new Uint8Array(Mi), a = 0; a < 32; a++)
        y2[a] = d2[a];
      return O2(x2, y2, true), { publicKey: x2, secretKey: y2 };
    }, r.sign.publicKeyLength = Dn, r.sign.secretKeyLength = Mi, r.sign.seedLength = ju, r.sign.signatureLength = Dt, r.hash = function(d2) {
      lr(d2);
      var x2 = new Uint8Array(Bu);
      return m2(x2, d2, d2.length), x2;
    }, r.hash.hashLength = Bu, r.verify = function(d2, x2) {
      return lr(d2, x2), d2.length === 0 || x2.length === 0 || d2.length !== x2.length ? false : G(d2, 0, x2, 0, d2.length) === 0;
    }, r.setPRNG = function(d2) {
      t = d2;
    }, function() {
      var d2 = typeof self != "undefined" ? self.crypto || self.msCrypto : null;
      if (d2 && d2.getRandomValues) {
        var x2 = 65536;
        r.setPRNG(function(y2, a) {
          var v, L2 = new Uint8Array(a);
          for (v = 0; v < a; v += x2)
            d2.getRandomValues(L2.subarray(v, v + Math.min(a - v, x2)));
          for (v = 0; v < a; v++)
            y2[v] = L2[v];
          dl(L2);
        });
      } else
        typeof pl != "undefined" && (d2 = jl(), d2 && d2.randomBytes && r.setPRNG(function(y2, a) {
          var v, L2 = d2.randomBytes(a);
          for (v = 0; v < a; v++)
            y2[v] = L2[v];
          dl(L2);
        }));
    }();
  })(typeof Mc != "undefined" && Mc.exports ? Mc.exports : self.nacl = self.nacl || {});
});
var Ll = dr((dx, Rc) => {
  (function() {
    var r = "input is invalid type", e = "finalize already called", t = typeof window == "object", n = t ? window : {};
    n.JS_SHA512_NO_WINDOW && (t = false);
    var i = !t && typeof self == "object", s = !n.JS_SHA512_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    s ? n = global : i && (n = self);
    var o = !n.JS_SHA512_NO_COMMON_JS && typeof Rc == "object" && Rc.exports, c = typeof define == "function" && define.amd, l2 = !n.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined", f2 = "0123456789abcdef".split(""), h2 = [-2147483648, 8388608, 32768, 128], _ = [24, 16, 8, 0], j2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], ie = ["hex", "array", "digest", "arrayBuffer"], G = [];
    (n.JS_SHA512_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(I) {
      return Object.prototype.toString.call(I) === "[object Array]";
    }), l2 && (n.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(I) {
      return typeof I == "object" && I.buffer && I.buffer.constructor === ArrayBuffer;
    });
    var Q = function(I, K2) {
      return function(P2) {
        return new re2(K2, true).update(P2)[I]();
      };
    }, N2 = function(I) {
      var K2 = Q("hex", I);
      K2.create = function() {
        return new re2(I);
      }, K2.update = function(te2) {
        return K2.create().update(te2);
      };
      for (var P2 = 0; P2 < ie.length; ++P2) {
        var k2 = ie[P2];
        K2[k2] = Q(k2, I);
      }
      return K2;
    }, U = function(I, K2) {
      return function(P2, k2) {
        return new le(P2, K2, true).update(k2)[I]();
      };
    }, ee = function(I) {
      var K2 = U("hex", I);
      K2.create = function(te2) {
        return new le(te2, I);
      }, K2.update = function(te2, T) {
        return K2.create(te2).update(T);
      };
      for (var P2 = 0; P2 < ie.length; ++P2) {
        var k2 = ie[P2];
        K2[k2] = U(k2, I);
      }
      return K2;
    };
    function re2(I, K2) {
      K2 ? (G[0] = G[1] = G[2] = G[3] = G[4] = G[5] = G[6] = G[7] = G[8] = G[9] = G[10] = G[11] = G[12] = G[13] = G[14] = G[15] = G[16] = G[17] = G[18] = G[19] = G[20] = G[21] = G[22] = G[23] = G[24] = G[25] = G[26] = G[27] = G[28] = G[29] = G[30] = G[31] = G[32] = 0, this.blocks = G) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], I == 384 ? (this.h0h = 3418070365, this.h0l = 3238371032, this.h1h = 1654270250, this.h1l = 914150663, this.h2h = 2438529370, this.h2l = 812702999, this.h3h = 355462360, this.h3l = 4144912697, this.h4h = 1731405415, this.h4l = 4290775857, this.h5h = 2394180231, this.h5l = 1750603025, this.h6h = 3675008525, this.h6l = 1694076839, this.h7h = 1203062813, this.h7l = 3204075428) : I == 256 ? (this.h0h = 573645204, this.h0l = 4230739756, this.h1h = 2673172387, this.h1l = 3360449730, this.h2h = 596883563, this.h2l = 1867755857, this.h3h = 2520282905, this.h3l = 1497426621, this.h4h = 2519219938, this.h4l = 2827943907, this.h5h = 3193839141, this.h5l = 1401305490, this.h6h = 721525244, this.h6l = 746961066, this.h7h = 246885852, this.h7l = 2177182882) : I == 224 ? (this.h0h = 2352822216, this.h0l = 424955298, this.h1h = 1944164710, this.h1l = 2312950998, this.h2h = 502970286, this.h2l = 855612546, this.h3h = 1738396948, this.h3l = 1479516111, this.h4h = 258812777, this.h4l = 2077511080, this.h5h = 2011393907, this.h5l = 79989058, this.h6h = 1067287976, this.h6l = 1780299464, this.h7h = 286451373, this.h7l = 2446758561) : (this.h0h = 1779033703, this.h0l = 4089235720, this.h1h = 3144134277, this.h1l = 2227873595, this.h2h = 1013904242, this.h2l = 4271175723, this.h3h = 2773480762, this.h3l = 1595750129, this.h4h = 1359893119, this.h4l = 2917565137, this.h5h = 2600822924, this.h5l = 725511199, this.h6h = 528734635, this.h6l = 4215389547, this.h7h = 1541459225, this.h7l = 327033209), this.bits = I, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false;
    }
    re2.prototype.update = function(I) {
      if (this.finalized)
        throw new Error(e);
      var K2, P2 = typeof I;
      if (P2 !== "string") {
        if (P2 === "object") {
          if (I === null)
            throw new Error(r);
          if (l2 && I.constructor === ArrayBuffer)
            I = new Uint8Array(I);
          else if (!Array.isArray(I) && (!l2 || !ArrayBuffer.isView(I)))
            throw new Error(r);
        } else
          throw new Error(r);
        K2 = true;
      }
      for (var k2, te2 = 0, T, D2 = I.length, V2 = this.blocks; te2 < D2; ) {
        if (this.hashed && (this.hashed = false, V2[0] = this.block, V2[1] = V2[2] = V2[3] = V2[4] = V2[5] = V2[6] = V2[7] = V2[8] = V2[9] = V2[10] = V2[11] = V2[12] = V2[13] = V2[14] = V2[15] = V2[16] = V2[17] = V2[18] = V2[19] = V2[20] = V2[21] = V2[22] = V2[23] = V2[24] = V2[25] = V2[26] = V2[27] = V2[28] = V2[29] = V2[30] = V2[31] = V2[32] = 0), K2)
          for (T = this.start; te2 < D2 && T < 128; ++te2)
            V2[T >> 2] |= I[te2] << _[T++ & 3];
        else
          for (T = this.start; te2 < D2 && T < 128; ++te2)
            k2 = I.charCodeAt(te2), k2 < 128 ? V2[T >> 2] |= k2 << _[T++ & 3] : k2 < 2048 ? (V2[T >> 2] |= (192 | k2 >> 6) << _[T++ & 3], V2[T >> 2] |= (128 | k2 & 63) << _[T++ & 3]) : k2 < 55296 || k2 >= 57344 ? (V2[T >> 2] |= (224 | k2 >> 12) << _[T++ & 3], V2[T >> 2] |= (128 | k2 >> 6 & 63) << _[T++ & 3], V2[T >> 2] |= (128 | k2 & 63) << _[T++ & 3]) : (k2 = 65536 + ((k2 & 1023) << 10 | I.charCodeAt(++te2) & 1023), V2[T >> 2] |= (240 | k2 >> 18) << _[T++ & 3], V2[T >> 2] |= (128 | k2 >> 12 & 63) << _[T++ & 3], V2[T >> 2] |= (128 | k2 >> 6 & 63) << _[T++ & 3], V2[T >> 2] |= (128 | k2 & 63) << _[T++ & 3]);
        this.lastByteIndex = T, this.bytes += T - this.start, T >= 128 ? (this.block = V2[32], this.start = T - 128, this.hash(), this.hashed = true) : this.start = T;
      }
      return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
    }, re2.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var I = this.blocks, K2 = this.lastByteIndex;
        I[32] = this.block, I[K2 >> 2] |= h2[K2 & 3], this.block = I[32], K2 >= 112 && (this.hashed || this.hash(), I[0] = this.block, I[1] = I[2] = I[3] = I[4] = I[5] = I[6] = I[7] = I[8] = I[9] = I[10] = I[11] = I[12] = I[13] = I[14] = I[15] = I[16] = I[17] = I[18] = I[19] = I[20] = I[21] = I[22] = I[23] = I[24] = I[25] = I[26] = I[27] = I[28] = I[29] = I[30] = I[31] = I[32] = 0), I[30] = this.hBytes << 3 | this.bytes >>> 29, I[31] = this.bytes << 3, this.hash();
      }
    }, re2.prototype.hash = function() {
      var I = this.h0h, K2 = this.h0l, P2 = this.h1h, k2 = this.h1l, te2 = this.h2h, T = this.h2l, D2 = this.h3h, V2 = this.h3l, pe = this.h4h, we = this.h4l, ve = this.h5h, qe = this.h5l, Ve = this.h6h, Te = this.h6l, ze = this.h7h, Je = this.h7l, Be = this.blocks, W2, Se, ct, Ot, pt, me, p2, b2, E2, $, R2, z2, Y, M, B, m2, u2, g, A, w, F2, O2, X, ce, he;
      for (W2 = 32; W2 < 160; W2 += 2)
        w = Be[W2 - 30], F2 = Be[W2 - 29], Se = (w >>> 1 | F2 << 31) ^ (w >>> 8 | F2 << 24) ^ w >>> 7, ct = (F2 >>> 1 | w << 31) ^ (F2 >>> 8 | w << 24) ^ (F2 >>> 7 | w << 25), w = Be[W2 - 4], F2 = Be[W2 - 3], Ot = (w >>> 19 | F2 << 13) ^ (F2 >>> 29 | w << 3) ^ w >>> 6, pt = (F2 >>> 19 | w << 13) ^ (w >>> 29 | F2 << 3) ^ (F2 >>> 6 | w << 26), w = Be[W2 - 32], F2 = Be[W2 - 31], O2 = Be[W2 - 14], X = Be[W2 - 13], me = (X & 65535) + (F2 & 65535) + (ct & 65535) + (pt & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (ct >>> 16) + (pt >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (Se & 65535) + (Ot & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (Se >>> 16) + (Ot >>> 16) + (b2 >>> 16), Be[W2] = E2 << 16 | b2 & 65535, Be[W2 + 1] = p2 << 16 | me & 65535;
      var C2 = I, Ee2 = K2, Ce = P2, it = k2, Pe = te2, _t = T, ft = D2, ut = V2, Ze = pe, Lt = we, Ut = ve, qt = qe, Wt = Ve, Yt = Te, Jt = ze, Dt = Je;
      for (m2 = Ce & Pe, u2 = it & _t, W2 = 0; W2 < 160; W2 += 8)
        Se = (C2 >>> 28 | Ee2 << 4) ^ (Ee2 >>> 2 | C2 << 30) ^ (Ee2 >>> 7 | C2 << 25), ct = (Ee2 >>> 28 | C2 << 4) ^ (C2 >>> 2 | Ee2 << 30) ^ (C2 >>> 7 | Ee2 << 25), Ot = (Ze >>> 14 | Lt << 18) ^ (Ze >>> 18 | Lt << 14) ^ (Lt >>> 9 | Ze << 23), pt = (Lt >>> 14 | Ze << 18) ^ (Lt >>> 18 | Ze << 14) ^ (Ze >>> 9 | Lt << 23), $ = C2 & Ce, R2 = Ee2 & it, g = $ ^ C2 & Pe ^ m2, A = R2 ^ Ee2 & _t ^ u2, ce = Ze & Ut ^ ~Ze & Wt, he = Lt & qt ^ ~Lt & Yt, w = Be[W2], F2 = Be[W2 + 1], O2 = j2[W2], X = j2[W2 + 1], me = (X & 65535) + (F2 & 65535) + (he & 65535) + (pt & 65535) + (Dt & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (he >>> 16) + (pt >>> 16) + (Dt >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (ce & 65535) + (Ot & 65535) + (Jt & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (ce >>> 16) + (Ot >>> 16) + (Jt >>> 16) + (b2 >>> 16), w = E2 << 16 | b2 & 65535, F2 = p2 << 16 | me & 65535, me = (A & 65535) + (ct & 65535), p2 = (A >>> 16) + (ct >>> 16) + (me >>> 16), b2 = (g & 65535) + (Se & 65535) + (p2 >>> 16), E2 = (g >>> 16) + (Se >>> 16) + (b2 >>> 16), O2 = E2 << 16 | b2 & 65535, X = p2 << 16 | me & 65535, me = (ut & 65535) + (F2 & 65535), p2 = (ut >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (ft & 65535) + (w & 65535) + (p2 >>> 16), E2 = (ft >>> 16) + (w >>> 16) + (b2 >>> 16), Jt = E2 << 16 | b2 & 65535, Dt = p2 << 16 | me & 65535, me = (X & 65535) + (F2 & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (b2 >>> 16), ft = E2 << 16 | b2 & 65535, ut = p2 << 16 | me & 65535, Se = (ft >>> 28 | ut << 4) ^ (ut >>> 2 | ft << 30) ^ (ut >>> 7 | ft << 25), ct = (ut >>> 28 | ft << 4) ^ (ft >>> 2 | ut << 30) ^ (ft >>> 7 | ut << 25), Ot = (Jt >>> 14 | Dt << 18) ^ (Jt >>> 18 | Dt << 14) ^ (Dt >>> 9 | Jt << 23), pt = (Dt >>> 14 | Jt << 18) ^ (Dt >>> 18 | Jt << 14) ^ (Jt >>> 9 | Dt << 23), z2 = ft & C2, Y = ut & Ee2, g = z2 ^ ft & Ce ^ $, A = Y ^ ut & it ^ R2, ce = Jt & Ze ^ ~Jt & Ut, he = Dt & Lt ^ ~Dt & qt, w = Be[W2 + 2], F2 = Be[W2 + 3], O2 = j2[W2 + 2], X = j2[W2 + 3], me = (X & 65535) + (F2 & 65535) + (he & 65535) + (pt & 65535) + (Yt & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (he >>> 16) + (pt >>> 16) + (Yt >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (ce & 65535) + (Ot & 65535) + (Wt & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (ce >>> 16) + (Ot >>> 16) + (Wt >>> 16) + (b2 >>> 16), w = E2 << 16 | b2 & 65535, F2 = p2 << 16 | me & 65535, me = (A & 65535) + (ct & 65535), p2 = (A >>> 16) + (ct >>> 16) + (me >>> 16), b2 = (g & 65535) + (Se & 65535) + (p2 >>> 16), E2 = (g >>> 16) + (Se >>> 16) + (b2 >>> 16), O2 = E2 << 16 | b2 & 65535, X = p2 << 16 | me & 65535, me = (_t & 65535) + (F2 & 65535), p2 = (_t >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (Pe & 65535) + (w & 65535) + (p2 >>> 16), E2 = (Pe >>> 16) + (w >>> 16) + (b2 >>> 16), Wt = E2 << 16 | b2 & 65535, Yt = p2 << 16 | me & 65535, me = (X & 65535) + (F2 & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (b2 >>> 16), Pe = E2 << 16 | b2 & 65535, _t = p2 << 16 | me & 65535, Se = (Pe >>> 28 | _t << 4) ^ (_t >>> 2 | Pe << 30) ^ (_t >>> 7 | Pe << 25), ct = (_t >>> 28 | Pe << 4) ^ (Pe >>> 2 | _t << 30) ^ (Pe >>> 7 | _t << 25), Ot = (Wt >>> 14 | Yt << 18) ^ (Wt >>> 18 | Yt << 14) ^ (Yt >>> 9 | Wt << 23), pt = (Yt >>> 14 | Wt << 18) ^ (Yt >>> 18 | Wt << 14) ^ (Wt >>> 9 | Yt << 23), M = Pe & ft, B = _t & ut, g = M ^ Pe & C2 ^ z2, A = B ^ _t & Ee2 ^ Y, ce = Wt & Jt ^ ~Wt & Ze, he = Yt & Dt ^ ~Yt & Lt, w = Be[W2 + 4], F2 = Be[W2 + 5], O2 = j2[W2 + 4], X = j2[W2 + 5], me = (X & 65535) + (F2 & 65535) + (he & 65535) + (pt & 65535) + (qt & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (he >>> 16) + (pt >>> 16) + (qt >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (ce & 65535) + (Ot & 65535) + (Ut & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (ce >>> 16) + (Ot >>> 16) + (Ut >>> 16) + (b2 >>> 16), w = E2 << 16 | b2 & 65535, F2 = p2 << 16 | me & 65535, me = (A & 65535) + (ct & 65535), p2 = (A >>> 16) + (ct >>> 16) + (me >>> 16), b2 = (g & 65535) + (Se & 65535) + (p2 >>> 16), E2 = (g >>> 16) + (Se >>> 16) + (b2 >>> 16), O2 = E2 << 16 | b2 & 65535, X = p2 << 16 | me & 65535, me = (it & 65535) + (F2 & 65535), p2 = (it >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (Ce & 65535) + (w & 65535) + (p2 >>> 16), E2 = (Ce >>> 16) + (w >>> 16) + (b2 >>> 16), Ut = E2 << 16 | b2 & 65535, qt = p2 << 16 | me & 65535, me = (X & 65535) + (F2 & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (b2 >>> 16), Ce = E2 << 16 | b2 & 65535, it = p2 << 16 | me & 65535, Se = (Ce >>> 28 | it << 4) ^ (it >>> 2 | Ce << 30) ^ (it >>> 7 | Ce << 25), ct = (it >>> 28 | Ce << 4) ^ (Ce >>> 2 | it << 30) ^ (Ce >>> 7 | it << 25), Ot = (Ut >>> 14 | qt << 18) ^ (Ut >>> 18 | qt << 14) ^ (qt >>> 9 | Ut << 23), pt = (qt >>> 14 | Ut << 18) ^ (qt >>> 18 | Ut << 14) ^ (Ut >>> 9 | qt << 23), m2 = Ce & Pe, u2 = it & _t, g = m2 ^ Ce & ft ^ M, A = u2 ^ it & ut ^ B, ce = Ut & Wt ^ ~Ut & Jt, he = qt & Yt ^ ~qt & Dt, w = Be[W2 + 6], F2 = Be[W2 + 7], O2 = j2[W2 + 6], X = j2[W2 + 7], me = (X & 65535) + (F2 & 65535) + (he & 65535) + (pt & 65535) + (Lt & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (he >>> 16) + (pt >>> 16) + (Lt >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (ce & 65535) + (Ot & 65535) + (Ze & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (ce >>> 16) + (Ot >>> 16) + (Ze >>> 16) + (b2 >>> 16), w = E2 << 16 | b2 & 65535, F2 = p2 << 16 | me & 65535, me = (A & 65535) + (ct & 65535), p2 = (A >>> 16) + (ct >>> 16) + (me >>> 16), b2 = (g & 65535) + (Se & 65535) + (p2 >>> 16), E2 = (g >>> 16) + (Se >>> 16) + (b2 >>> 16), O2 = E2 << 16 | b2 & 65535, X = p2 << 16 | me & 65535, me = (Ee2 & 65535) + (F2 & 65535), p2 = (Ee2 >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (C2 & 65535) + (w & 65535) + (p2 >>> 16), E2 = (C2 >>> 16) + (w >>> 16) + (b2 >>> 16), Ze = E2 << 16 | b2 & 65535, Lt = p2 << 16 | me & 65535, me = (X & 65535) + (F2 & 65535), p2 = (X >>> 16) + (F2 >>> 16) + (me >>> 16), b2 = (O2 & 65535) + (w & 65535) + (p2 >>> 16), E2 = (O2 >>> 16) + (w >>> 16) + (b2 >>> 16), C2 = E2 << 16 | b2 & 65535, Ee2 = p2 << 16 | me & 65535;
      me = (K2 & 65535) + (Ee2 & 65535), p2 = (K2 >>> 16) + (Ee2 >>> 16) + (me >>> 16), b2 = (I & 65535) + (C2 & 65535) + (p2 >>> 16), E2 = (I >>> 16) + (C2 >>> 16) + (b2 >>> 16), this.h0h = E2 << 16 | b2 & 65535, this.h0l = p2 << 16 | me & 65535, me = (k2 & 65535) + (it & 65535), p2 = (k2 >>> 16) + (it >>> 16) + (me >>> 16), b2 = (P2 & 65535) + (Ce & 65535) + (p2 >>> 16), E2 = (P2 >>> 16) + (Ce >>> 16) + (b2 >>> 16), this.h1h = E2 << 16 | b2 & 65535, this.h1l = p2 << 16 | me & 65535, me = (T & 65535) + (_t & 65535), p2 = (T >>> 16) + (_t >>> 16) + (me >>> 16), b2 = (te2 & 65535) + (Pe & 65535) + (p2 >>> 16), E2 = (te2 >>> 16) + (Pe >>> 16) + (b2 >>> 16), this.h2h = E2 << 16 | b2 & 65535, this.h2l = p2 << 16 | me & 65535, me = (V2 & 65535) + (ut & 65535), p2 = (V2 >>> 16) + (ut >>> 16) + (me >>> 16), b2 = (D2 & 65535) + (ft & 65535) + (p2 >>> 16), E2 = (D2 >>> 16) + (ft >>> 16) + (b2 >>> 16), this.h3h = E2 << 16 | b2 & 65535, this.h3l = p2 << 16 | me & 65535, me = (we & 65535) + (Lt & 65535), p2 = (we >>> 16) + (Lt >>> 16) + (me >>> 16), b2 = (pe & 65535) + (Ze & 65535) + (p2 >>> 16), E2 = (pe >>> 16) + (Ze >>> 16) + (b2 >>> 16), this.h4h = E2 << 16 | b2 & 65535, this.h4l = p2 << 16 | me & 65535, me = (qe & 65535) + (qt & 65535), p2 = (qe >>> 16) + (qt >>> 16) + (me >>> 16), b2 = (ve & 65535) + (Ut & 65535) + (p2 >>> 16), E2 = (ve >>> 16) + (Ut >>> 16) + (b2 >>> 16), this.h5h = E2 << 16 | b2 & 65535, this.h5l = p2 << 16 | me & 65535, me = (Te & 65535) + (Yt & 65535), p2 = (Te >>> 16) + (Yt >>> 16) + (me >>> 16), b2 = (Ve & 65535) + (Wt & 65535) + (p2 >>> 16), E2 = (Ve >>> 16) + (Wt >>> 16) + (b2 >>> 16), this.h6h = E2 << 16 | b2 & 65535, this.h6l = p2 << 16 | me & 65535, me = (Je & 65535) + (Dt & 65535), p2 = (Je >>> 16) + (Dt >>> 16) + (me >>> 16), b2 = (ze & 65535) + (Jt & 65535) + (p2 >>> 16), E2 = (ze >>> 16) + (Jt >>> 16) + (b2 >>> 16), this.h7h = E2 << 16 | b2 & 65535, this.h7l = p2 << 16 | me & 65535;
    }, re2.prototype.hex = function() {
      this.finalize();
      var I = this.h0h, K2 = this.h0l, P2 = this.h1h, k2 = this.h1l, te2 = this.h2h, T = this.h2l, D2 = this.h3h, V2 = this.h3l, pe = this.h4h, we = this.h4l, ve = this.h5h, qe = this.h5l, Ve = this.h6h, Te = this.h6l, ze = this.h7h, Je = this.h7l, Be = this.bits, W2 = f2[I >> 28 & 15] + f2[I >> 24 & 15] + f2[I >> 20 & 15] + f2[I >> 16 & 15] + f2[I >> 12 & 15] + f2[I >> 8 & 15] + f2[I >> 4 & 15] + f2[I & 15] + f2[K2 >> 28 & 15] + f2[K2 >> 24 & 15] + f2[K2 >> 20 & 15] + f2[K2 >> 16 & 15] + f2[K2 >> 12 & 15] + f2[K2 >> 8 & 15] + f2[K2 >> 4 & 15] + f2[K2 & 15] + f2[P2 >> 28 & 15] + f2[P2 >> 24 & 15] + f2[P2 >> 20 & 15] + f2[P2 >> 16 & 15] + f2[P2 >> 12 & 15] + f2[P2 >> 8 & 15] + f2[P2 >> 4 & 15] + f2[P2 & 15] + f2[k2 >> 28 & 15] + f2[k2 >> 24 & 15] + f2[k2 >> 20 & 15] + f2[k2 >> 16 & 15] + f2[k2 >> 12 & 15] + f2[k2 >> 8 & 15] + f2[k2 >> 4 & 15] + f2[k2 & 15] + f2[te2 >> 28 & 15] + f2[te2 >> 24 & 15] + f2[te2 >> 20 & 15] + f2[te2 >> 16 & 15] + f2[te2 >> 12 & 15] + f2[te2 >> 8 & 15] + f2[te2 >> 4 & 15] + f2[te2 & 15] + f2[T >> 28 & 15] + f2[T >> 24 & 15] + f2[T >> 20 & 15] + f2[T >> 16 & 15] + f2[T >> 12 & 15] + f2[T >> 8 & 15] + f2[T >> 4 & 15] + f2[T & 15] + f2[D2 >> 28 & 15] + f2[D2 >> 24 & 15] + f2[D2 >> 20 & 15] + f2[D2 >> 16 & 15] + f2[D2 >> 12 & 15] + f2[D2 >> 8 & 15] + f2[D2 >> 4 & 15] + f2[D2 & 15];
      return Be >= 256 && (W2 += f2[V2 >> 28 & 15] + f2[V2 >> 24 & 15] + f2[V2 >> 20 & 15] + f2[V2 >> 16 & 15] + f2[V2 >> 12 & 15] + f2[V2 >> 8 & 15] + f2[V2 >> 4 & 15] + f2[V2 & 15]), Be >= 384 && (W2 += f2[pe >> 28 & 15] + f2[pe >> 24 & 15] + f2[pe >> 20 & 15] + f2[pe >> 16 & 15] + f2[pe >> 12 & 15] + f2[pe >> 8 & 15] + f2[pe >> 4 & 15] + f2[pe & 15] + f2[we >> 28 & 15] + f2[we >> 24 & 15] + f2[we >> 20 & 15] + f2[we >> 16 & 15] + f2[we >> 12 & 15] + f2[we >> 8 & 15] + f2[we >> 4 & 15] + f2[we & 15] + f2[ve >> 28 & 15] + f2[ve >> 24 & 15] + f2[ve >> 20 & 15] + f2[ve >> 16 & 15] + f2[ve >> 12 & 15] + f2[ve >> 8 & 15] + f2[ve >> 4 & 15] + f2[ve & 15] + f2[qe >> 28 & 15] + f2[qe >> 24 & 15] + f2[qe >> 20 & 15] + f2[qe >> 16 & 15] + f2[qe >> 12 & 15] + f2[qe >> 8 & 15] + f2[qe >> 4 & 15] + f2[qe & 15]), Be == 512 && (W2 += f2[Ve >> 28 & 15] + f2[Ve >> 24 & 15] + f2[Ve >> 20 & 15] + f2[Ve >> 16 & 15] + f2[Ve >> 12 & 15] + f2[Ve >> 8 & 15] + f2[Ve >> 4 & 15] + f2[Ve & 15] + f2[Te >> 28 & 15] + f2[Te >> 24 & 15] + f2[Te >> 20 & 15] + f2[Te >> 16 & 15] + f2[Te >> 12 & 15] + f2[Te >> 8 & 15] + f2[Te >> 4 & 15] + f2[Te & 15] + f2[ze >> 28 & 15] + f2[ze >> 24 & 15] + f2[ze >> 20 & 15] + f2[ze >> 16 & 15] + f2[ze >> 12 & 15] + f2[ze >> 8 & 15] + f2[ze >> 4 & 15] + f2[ze & 15] + f2[Je >> 28 & 15] + f2[Je >> 24 & 15] + f2[Je >> 20 & 15] + f2[Je >> 16 & 15] + f2[Je >> 12 & 15] + f2[Je >> 8 & 15] + f2[Je >> 4 & 15] + f2[Je & 15]), W2;
    }, re2.prototype.toString = re2.prototype.hex, re2.prototype.digest = function() {
      this.finalize();
      var I = this.h0h, K2 = this.h0l, P2 = this.h1h, k2 = this.h1l, te2 = this.h2h, T = this.h2l, D2 = this.h3h, V2 = this.h3l, pe = this.h4h, we = this.h4l, ve = this.h5h, qe = this.h5l, Ve = this.h6h, Te = this.h6l, ze = this.h7h, Je = this.h7l, Be = this.bits, W2 = [I >> 24 & 255, I >> 16 & 255, I >> 8 & 255, I & 255, K2 >> 24 & 255, K2 >> 16 & 255, K2 >> 8 & 255, K2 & 255, P2 >> 24 & 255, P2 >> 16 & 255, P2 >> 8 & 255, P2 & 255, k2 >> 24 & 255, k2 >> 16 & 255, k2 >> 8 & 255, k2 & 255, te2 >> 24 & 255, te2 >> 16 & 255, te2 >> 8 & 255, te2 & 255, T >> 24 & 255, T >> 16 & 255, T >> 8 & 255, T & 255, D2 >> 24 & 255, D2 >> 16 & 255, D2 >> 8 & 255, D2 & 255];
      return Be >= 256 && W2.push(V2 >> 24 & 255, V2 >> 16 & 255, V2 >> 8 & 255, V2 & 255), Be >= 384 && W2.push(pe >> 24 & 255, pe >> 16 & 255, pe >> 8 & 255, pe & 255, we >> 24 & 255, we >> 16 & 255, we >> 8 & 255, we & 255, ve >> 24 & 255, ve >> 16 & 255, ve >> 8 & 255, ve & 255, qe >> 24 & 255, qe >> 16 & 255, qe >> 8 & 255, qe & 255), Be == 512 && W2.push(Ve >> 24 & 255, Ve >> 16 & 255, Ve >> 8 & 255, Ve & 255, Te >> 24 & 255, Te >> 16 & 255, Te >> 8 & 255, Te & 255, ze >> 24 & 255, ze >> 16 & 255, ze >> 8 & 255, ze & 255, Je >> 24 & 255, Je >> 16 & 255, Je >> 8 & 255, Je & 255), W2;
    }, re2.prototype.array = re2.prototype.digest, re2.prototype.arrayBuffer = function() {
      this.finalize();
      var I = this.bits, K2 = new ArrayBuffer(I / 8), P2 = new DataView(K2);
      return P2.setUint32(0, this.h0h), P2.setUint32(4, this.h0l), P2.setUint32(8, this.h1h), P2.setUint32(12, this.h1l), P2.setUint32(16, this.h2h), P2.setUint32(20, this.h2l), P2.setUint32(24, this.h3h), I >= 256 && P2.setUint32(28, this.h3l), I >= 384 && (P2.setUint32(32, this.h4h), P2.setUint32(36, this.h4l), P2.setUint32(40, this.h5h), P2.setUint32(44, this.h5l)), I == 512 && (P2.setUint32(48, this.h6h), P2.setUint32(52, this.h6l), P2.setUint32(56, this.h7h), P2.setUint32(60, this.h7l)), K2;
    }, re2.prototype.clone = function() {
      var I = new re2(this.bits, false);
      return this.copyTo(I), I;
    }, re2.prototype.copyTo = function(I) {
      var K2 = 0, P2 = ["h0h", "h0l", "h1h", "h1l", "h2h", "h2l", "h3h", "h3l", "h4h", "h4l", "h5h", "h5l", "h6h", "h6l", "h7h", "h7l", "start", "bytes", "hBytes", "finalized", "hashed", "lastByteIndex"];
      for (K2 = 0; K2 < P2.length; ++K2)
        I[P2[K2]] = this[P2[K2]];
      for (K2 = 0; K2 < this.blocks.length; ++K2)
        I.blocks[K2] = this.blocks[K2];
    };
    function le(I, K2, P2) {
      var k2, te2 = typeof I;
      if (te2 !== "string") {
        if (te2 === "object") {
          if (I === null)
            throw new Error(r);
          if (l2 && I.constructor === ArrayBuffer)
            I = new Uint8Array(I);
          else if (!Array.isArray(I) && (!l2 || !ArrayBuffer.isView(I)))
            throw new Error(r);
        } else
          throw new Error(r);
        k2 = true;
      }
      var T = I.length;
      if (!k2) {
        for (var D2 = [], T = I.length, V2 = 0, pe, we = 0; we < T; ++we)
          pe = I.charCodeAt(we), pe < 128 ? D2[V2++] = pe : pe < 2048 ? (D2[V2++] = 192 | pe >> 6, D2[V2++] = 128 | pe & 63) : pe < 55296 || pe >= 57344 ? (D2[V2++] = 224 | pe >> 12, D2[V2++] = 128 | pe >> 6 & 63, D2[V2++] = 128 | pe & 63) : (pe = 65536 + ((pe & 1023) << 10 | I.charCodeAt(++we) & 1023), D2[V2++] = 240 | pe >> 18, D2[V2++] = 128 | pe >> 12 & 63, D2[V2++] = 128 | pe >> 6 & 63, D2[V2++] = 128 | pe & 63);
        I = D2;
      }
      I.length > 128 && (I = new re2(K2, true).update(I).array());
      for (var ve = [], qe = [], we = 0; we < 128; ++we) {
        var Ve = I[we] || 0;
        ve[we] = 92 ^ Ve, qe[we] = 54 ^ Ve;
      }
      re2.call(this, K2, P2), this.update(qe), this.oKeyPad = ve, this.inner = true, this.sharedMemory = P2;
    }
    le.prototype = new re2(), le.prototype.finalize = function() {
      if (re2.prototype.finalize.call(this), this.inner) {
        this.inner = false;
        var I = this.array();
        re2.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(I), re2.prototype.finalize.call(this);
      }
    }, le.prototype.clone = function() {
      var I = new le([], this.bits, false);
      this.copyTo(I), I.inner = this.inner;
      for (var K2 = 0; K2 < this.oKeyPad.length; ++K2)
        I.oKeyPad[K2] = this.oKeyPad[K2];
      return I;
    };
    var H2 = N2(512);
    H2.sha512 = H2, H2.sha384 = N2(384), H2.sha512_256 = N2(256), H2.sha512_224 = N2(224), H2.sha512.hmac = ee(512), H2.sha384.hmac = ee(384), H2.sha512_256.hmac = ee(256), H2.sha512_224.hmac = ee(224), o ? Rc.exports = H2 : (n.sha512 = H2.sha512, n.sha384 = H2.sha384, n.sha512_256 = H2.sha512_256, n.sha512_224 = H2.sha512_224, c && define(function() {
      return H2;
    }));
  })();
});
var Qu = dr((px, Bc) => {
  (function() {
    var r = typeof window == "object" ? window : {}, e = !r.HI_BASE32_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    e && (r = global);
    var t = !r.HI_BASE32_NO_COMMON_JS && typeof Bc == "object" && Bc.exports, n = typeof define == "function" && define.amd, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""), s = { A: 0, B: 1, C: 2, D: 3, E: 4, F: 5, G: 6, H: 7, I: 8, J: 9, K: 10, L: 11, M: 12, N: 13, O: 14, P: 15, Q: 16, R: 17, S: 18, T: 19, U: 20, V: 21, W: 22, X: 23, Y: 24, Z: 25, 2: 26, 3: 27, 4: 28, 5: 29, 6: 30, 7: 31 }, o = [0, 0, 0, 0, 0, 0, 0, 0], c = function(N2, U) {
      U.length > 10 && (U = "..." + U.substr(-10));
      var ee = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + N2 + " bytes: " + U + " <-");
      throw ee.position = N2, ee;
    }, l2 = function(N2) {
      for (var U = "", ee = N2.length, re2 = 0, le = 0, H2, I; re2 < ee; ) {
        if (H2 = N2[re2++], H2 <= 127) {
          U += String.fromCharCode(H2);
          continue;
        } else
          H2 > 191 && H2 <= 223 ? (I = H2 & 31, le = 1) : H2 <= 239 ? (I = H2 & 15, le = 2) : H2 <= 247 ? (I = H2 & 7, le = 3) : c(re2, U);
        for (var K2 = 0; K2 < le; ++K2)
          H2 = N2[re2++], (H2 < 128 || H2 > 191) && c(re2, U), I <<= 6, I += H2 & 63;
        I >= 55296 && I <= 57343 && c(re2, U), I > 1114111 && c(re2, U), I <= 65535 ? U += String.fromCharCode(I) : (I -= 65536, U += String.fromCharCode((I >> 10) + 55296), U += String.fromCharCode((I & 1023) + 56320));
      }
      return U;
    }, f2 = function(N2) {
      if (N2 === "")
        return [];
      if (!/^[A-Z2-7=]+$/.test(N2))
        throw new Error("Invalid base32 characters");
      N2 = N2.replace(/=/g, "");
      for (var U, ee, re2, le, H2, I, K2, P2, k2 = [], te2 = 0, T = N2.length, D2 = 0, V2 = T >> 3 << 3; D2 < V2; )
        U = s[N2.charAt(D2++)], ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], H2 = s[N2.charAt(D2++)], I = s[N2.charAt(D2++)], K2 = s[N2.charAt(D2++)], P2 = s[N2.charAt(D2++)], k2[te2++] = (U << 3 | ee >>> 2) & 255, k2[te2++] = (ee << 6 | re2 << 1 | le >>> 4) & 255, k2[te2++] = (le << 4 | H2 >>> 1) & 255, k2[te2++] = (H2 << 7 | I << 2 | K2 >>> 3) & 255, k2[te2++] = (K2 << 5 | P2) & 255;
      var pe = T - V2;
      return pe === 2 ? (U = s[N2.charAt(D2++)], ee = s[N2.charAt(D2++)], k2[te2++] = (U << 3 | ee >>> 2) & 255) : pe === 4 ? (U = s[N2.charAt(D2++)], ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], k2[te2++] = (U << 3 | ee >>> 2) & 255, k2[te2++] = (ee << 6 | re2 << 1 | le >>> 4) & 255) : pe === 5 ? (U = s[N2.charAt(D2++)], ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], H2 = s[N2.charAt(D2++)], k2[te2++] = (U << 3 | ee >>> 2) & 255, k2[te2++] = (ee << 6 | re2 << 1 | le >>> 4) & 255, k2[te2++] = (le << 4 | H2 >>> 1) & 255) : pe === 7 && (U = s[N2.charAt(D2++)], ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], H2 = s[N2.charAt(D2++)], I = s[N2.charAt(D2++)], K2 = s[N2.charAt(D2++)], k2[te2++] = (U << 3 | ee >>> 2) & 255, k2[te2++] = (ee << 6 | re2 << 1 | le >>> 4) & 255, k2[te2++] = (le << 4 | H2 >>> 1) & 255, k2[te2++] = (H2 << 7 | I << 2 | K2 >>> 3) & 255), k2;
    }, h2 = function(N2) {
      for (var U, ee, re2, le, H2, I = "", K2 = N2.length, P2 = 0, k2 = parseInt(K2 / 5) * 5; P2 < k2; )
        U = N2.charCodeAt(P2++), ee = N2.charCodeAt(P2++), re2 = N2.charCodeAt(P2++), le = N2.charCodeAt(P2++), H2 = N2.charCodeAt(P2++), I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[(re2 << 1 | le >>> 7) & 31] + i[le >>> 2 & 31] + i[(le << 3 | H2 >>> 5) & 31] + i[H2 & 31];
      var te2 = K2 - k2;
      return te2 === 1 ? (U = N2.charCodeAt(P2), I += i[U >>> 3] + i[U << 2 & 31] + "======") : te2 === 2 ? (U = N2.charCodeAt(P2++), ee = N2.charCodeAt(P2), I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[ee << 4 & 31] + "====") : te2 === 3 ? (U = N2.charCodeAt(P2++), ee = N2.charCodeAt(P2++), re2 = N2.charCodeAt(P2), I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[re2 << 1 & 31] + "===") : te2 === 4 && (U = N2.charCodeAt(P2++), ee = N2.charCodeAt(P2++), re2 = N2.charCodeAt(P2++), le = N2.charCodeAt(P2), I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[(re2 << 1 | le >>> 7) & 31] + i[le >>> 2 & 31] + i[le << 3 & 31] + "="), I;
    }, _ = function(N2) {
      var U, ee, re2, le, H2, I, K2 = false, P2 = "", k2 = 0, te2, T = 0, V2 = N2.length;
      if (N2 === "")
        return P2;
      do {
        for (o[0] = o[5], o[1] = o[6], o[2] = o[7], te2 = T; k2 < V2 && te2 < 5; ++k2)
          I = N2.charCodeAt(k2), I < 128 ? o[te2++] = I : I < 2048 ? (o[te2++] = 192 | I >> 6, o[te2++] = 128 | I & 63) : I < 55296 || I >= 57344 ? (o[te2++] = 224 | I >> 12, o[te2++] = 128 | I >> 6 & 63, o[te2++] = 128 | I & 63) : (I = 65536 + ((I & 1023) << 10 | N2.charCodeAt(++k2) & 1023), o[te2++] = 240 | I >> 18, o[te2++] = 128 | I >> 12 & 63, o[te2++] = 128 | I >> 6 & 63, o[te2++] = 128 | I & 63);
        T = te2 - 5, k2 === V2 && ++k2, k2 > V2 && te2 < 6 && (K2 = true), U = o[0], te2 > 4 ? (ee = o[1], re2 = o[2], le = o[3], H2 = o[4], P2 += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[(re2 << 1 | le >>> 7) & 31] + i[le >>> 2 & 31] + i[(le << 3 | H2 >>> 5) & 31] + i[H2 & 31]) : te2 === 1 ? P2 += i[U >>> 3] + i[U << 2 & 31] + "======" : te2 === 2 ? (ee = o[1], P2 += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[ee << 4 & 31] + "====") : te2 === 3 ? (ee = o[1], re2 = o[2], P2 += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[re2 << 1 & 31] + "===") : (ee = o[1], re2 = o[2], le = o[3], P2 += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[(re2 << 1 | le >>> 7) & 31] + i[le >>> 2 & 31] + i[le << 3 & 31] + "=");
      } while (!K2);
      return P2;
    }, j2 = function(N2) {
      for (var U, ee, re2, le, H2, I = "", K2 = N2.length, P2 = 0, k2 = parseInt(K2 / 5) * 5; P2 < k2; )
        U = N2[P2++], ee = N2[P2++], re2 = N2[P2++], le = N2[P2++], H2 = N2[P2++], I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[(re2 << 1 | le >>> 7) & 31] + i[le >>> 2 & 31] + i[(le << 3 | H2 >>> 5) & 31] + i[H2 & 31];
      var te2 = K2 - k2;
      return te2 === 1 ? (U = N2[P2], I += i[U >>> 3] + i[U << 2 & 31] + "======") : te2 === 2 ? (U = N2[P2++], ee = N2[P2], I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[ee << 4 & 31] + "====") : te2 === 3 ? (U = N2[P2++], ee = N2[P2++], re2 = N2[P2], I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[re2 << 1 & 31] + "===") : te2 === 4 && (U = N2[P2++], ee = N2[P2++], re2 = N2[P2++], le = N2[P2], I += i[U >>> 3] + i[(U << 2 | ee >>> 6) & 31] + i[ee >>> 1 & 31] + i[(ee << 4 | re2 >>> 4) & 31] + i[(re2 << 1 | le >>> 7) & 31] + i[le >>> 2 & 31] + i[le << 3 & 31] + "="), I;
    }, ie = function(N2, U) {
      var ee = typeof N2 != "string";
      return ee && N2.constructor === ArrayBuffer && (N2 = new Uint8Array(N2)), ee ? j2(N2) : U ? h2(N2) : _(N2);
    }, G = function(N2, U) {
      if (!U)
        return l2(f2(N2));
      if (N2 === "")
        return "";
      if (!/^[A-Z2-7=]+$/.test(N2))
        throw new Error("Invalid base32 characters");
      var ee, re2, le, H2, I, K2, P2, k2, te2 = "", T = N2.indexOf("=");
      T === -1 && (T = N2.length);
      for (var D2 = 0, V2 = T >> 3 << 3; D2 < V2; )
        ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], H2 = s[N2.charAt(D2++)], I = s[N2.charAt(D2++)], K2 = s[N2.charAt(D2++)], P2 = s[N2.charAt(D2++)], k2 = s[N2.charAt(D2++)], te2 += String.fromCharCode((ee << 3 | re2 >>> 2) & 255) + String.fromCharCode((re2 << 6 | le << 1 | H2 >>> 4) & 255) + String.fromCharCode((H2 << 4 | I >>> 1) & 255) + String.fromCharCode((I << 7 | K2 << 2 | P2 >>> 3) & 255) + String.fromCharCode((P2 << 5 | k2) & 255);
      var pe = T - V2;
      return pe === 2 ? (ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], te2 += String.fromCharCode((ee << 3 | re2 >>> 2) & 255)) : pe === 4 ? (ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], H2 = s[N2.charAt(D2++)], te2 += String.fromCharCode((ee << 3 | re2 >>> 2) & 255) + String.fromCharCode((re2 << 6 | le << 1 | H2 >>> 4) & 255)) : pe === 5 ? (ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], H2 = s[N2.charAt(D2++)], I = s[N2.charAt(D2++)], te2 += String.fromCharCode((ee << 3 | re2 >>> 2) & 255) + String.fromCharCode((re2 << 6 | le << 1 | H2 >>> 4) & 255) + String.fromCharCode((H2 << 4 | I >>> 1) & 255)) : pe === 7 && (ee = s[N2.charAt(D2++)], re2 = s[N2.charAt(D2++)], le = s[N2.charAt(D2++)], H2 = s[N2.charAt(D2++)], I = s[N2.charAt(D2++)], K2 = s[N2.charAt(D2++)], P2 = s[N2.charAt(D2++)], te2 += String.fromCharCode((ee << 3 | re2 >>> 2) & 255) + String.fromCharCode((re2 << 6 | le << 1 | H2 >>> 4) & 255) + String.fromCharCode((H2 << 4 | I >>> 1) & 255) + String.fromCharCode((I << 7 | K2 << 2 | P2 >>> 3) & 255)), te2;
    }, Q = { encode: ie, decode: G };
    G.asBytes = f2, t ? Bc.exports = Q : (r.base32 = Q, n && define(function() {
      return Q;
    }));
  })();
});
var ef = dr((zl, Lc) => {
  (function(r) {
    var e, t = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, n = Math.ceil, i = Math.floor, s = "[BigNumber Error] ", o = s + "Number primitive has more than 15 significant digits: ", c = 1e14, l2 = 14, f2 = 9007199254740991, h2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], _ = 1e7, j2 = 1e9;
    function ie(H2) {
      var I, K2, P2, k2 = W2.prototype = { constructor: W2, toString: null, valueOf: null }, te2 = new W2(1), T = 20, D2 = 4, V2 = -7, pe = 21, we = -1e7, ve = 1e7, qe = false, Ve = 1, Te = 0, ze = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, Je = "0123456789abcdefghijklmnopqrstuvwxyz", Be = true;
      function W2(p2, b2) {
        var E2, $, R2, z2, Y, M, B, m2, u2 = this;
        if (!(u2 instanceof W2))
          return new W2(p2, b2);
        if (b2 == null) {
          if (p2 && p2._isBigNumber === true) {
            u2.s = p2.s, !p2.c || p2.e > ve ? u2.c = u2.e = null : p2.e < we ? u2.c = [u2.e = 0] : (u2.e = p2.e, u2.c = p2.c.slice());
            return;
          }
          if ((M = typeof p2 == "number") && p2 * 0 == 0) {
            if (u2.s = 1 / p2 < 0 ? (p2 = -p2, -1) : 1, p2 === ~~p2) {
              for (z2 = 0, Y = p2; Y >= 10; Y /= 10, z2++)
                ;
              z2 > ve ? u2.c = u2.e = null : (u2.e = z2, u2.c = [p2]);
              return;
            }
            m2 = String(p2);
          } else {
            if (!t.test(m2 = String(p2)))
              return P2(u2, m2, M);
            u2.s = m2.charCodeAt(0) == 45 ? (m2 = m2.slice(1), -1) : 1;
          }
          (z2 = m2.indexOf(".")) > -1 && (m2 = m2.replace(".", "")), (Y = m2.search(/e/i)) > 0 ? (z2 < 0 && (z2 = Y), z2 += +m2.slice(Y + 1), m2 = m2.substring(0, Y)) : z2 < 0 && (z2 = m2.length);
        } else {
          if (U(b2, 2, Je.length, "Base"), b2 == 10 && Be)
            return u2 = new W2(p2), pt(u2, T + u2.e + 1, D2);
          if (m2 = String(p2), M = typeof p2 == "number") {
            if (p2 * 0 != 0)
              return P2(u2, m2, M, b2);
            if (u2.s = 1 / p2 < 0 ? (m2 = m2.slice(1), -1) : 1, W2.DEBUG && m2.replace(/^0\.0*|\./, "").length > 15)
              throw Error(o + p2);
          } else
            u2.s = m2.charCodeAt(0) === 45 ? (m2 = m2.slice(1), -1) : 1;
          for (E2 = Je.slice(0, b2), z2 = Y = 0, B = m2.length; Y < B; Y++)
            if (E2.indexOf($ = m2.charAt(Y)) < 0) {
              if ($ == ".") {
                if (Y > z2) {
                  z2 = B;
                  continue;
                }
              } else if (!R2 && (m2 == m2.toUpperCase() && (m2 = m2.toLowerCase()) || m2 == m2.toLowerCase() && (m2 = m2.toUpperCase()))) {
                R2 = true, Y = -1, z2 = 0;
                continue;
              }
              return P2(u2, String(p2), M, b2);
            }
          M = false, m2 = K2(m2, b2, 10, u2.s), (z2 = m2.indexOf(".")) > -1 ? m2 = m2.replace(".", "") : z2 = m2.length;
        }
        for (Y = 0; m2.charCodeAt(Y) === 48; Y++)
          ;
        for (B = m2.length; m2.charCodeAt(--B) === 48; )
          ;
        if (m2 = m2.slice(Y, ++B)) {
          if (B -= Y, M && W2.DEBUG && B > 15 && (p2 > f2 || p2 !== i(p2)))
            throw Error(o + u2.s * p2);
          if ((z2 = z2 - Y - 1) > ve)
            u2.c = u2.e = null;
          else if (z2 < we)
            u2.c = [u2.e = 0];
          else {
            if (u2.e = z2, u2.c = [], Y = (z2 + 1) % l2, z2 < 0 && (Y += l2), Y < B) {
              for (Y && u2.c.push(+m2.slice(0, Y)), B -= l2; Y < B; )
                u2.c.push(+m2.slice(Y, Y += l2));
              Y = l2 - (m2 = m2.slice(Y)).length;
            } else
              Y -= B;
            for (; Y--; m2 += "0")
              ;
            u2.c.push(+m2);
          }
        } else
          u2.c = [u2.e = 0];
      }
      W2.clone = ie, W2.ROUND_UP = 0, W2.ROUND_DOWN = 1, W2.ROUND_CEIL = 2, W2.ROUND_FLOOR = 3, W2.ROUND_HALF_UP = 4, W2.ROUND_HALF_DOWN = 5, W2.ROUND_HALF_EVEN = 6, W2.ROUND_HALF_CEIL = 7, W2.ROUND_HALF_FLOOR = 8, W2.EUCLID = 9, W2.config = W2.set = function(p2) {
        var b2, E2;
        if (p2 != null)
          if (typeof p2 == "object") {
            if (p2.hasOwnProperty(b2 = "DECIMAL_PLACES") && (E2 = p2[b2], U(E2, 0, j2, b2), T = E2), p2.hasOwnProperty(b2 = "ROUNDING_MODE") && (E2 = p2[b2], U(E2, 0, 8, b2), D2 = E2), p2.hasOwnProperty(b2 = "EXPONENTIAL_AT") && (E2 = p2[b2], E2 && E2.pop ? (U(E2[0], -j2, 0, b2), U(E2[1], 0, j2, b2), V2 = E2[0], pe = E2[1]) : (U(E2, -j2, j2, b2), V2 = -(pe = E2 < 0 ? -E2 : E2))), p2.hasOwnProperty(b2 = "RANGE"))
              if (E2 = p2[b2], E2 && E2.pop)
                U(E2[0], -j2, -1, b2), U(E2[1], 1, j2, b2), we = E2[0], ve = E2[1];
              else if (U(E2, -j2, j2, b2), E2)
                we = -(ve = E2 < 0 ? -E2 : E2);
              else
                throw Error(s + b2 + " cannot be zero: " + E2);
            if (p2.hasOwnProperty(b2 = "CRYPTO"))
              if (E2 = p2[b2], E2 === !!E2)
                if (E2)
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    qe = E2;
                  else
                    throw qe = !E2, Error(s + "crypto unavailable");
                else
                  qe = E2;
              else
                throw Error(s + b2 + " not true or false: " + E2);
            if (p2.hasOwnProperty(b2 = "MODULO_MODE") && (E2 = p2[b2], U(E2, 0, 9, b2), Ve = E2), p2.hasOwnProperty(b2 = "POW_PRECISION") && (E2 = p2[b2], U(E2, 0, j2, b2), Te = E2), p2.hasOwnProperty(b2 = "FORMAT"))
              if (E2 = p2[b2], typeof E2 == "object")
                ze = E2;
              else
                throw Error(s + b2 + " not an object: " + E2);
            if (p2.hasOwnProperty(b2 = "ALPHABET"))
              if (E2 = p2[b2], typeof E2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(E2))
                Be = E2.slice(0, 10) == "0123456789", Je = E2;
              else
                throw Error(s + b2 + " invalid: " + E2);
          } else
            throw Error(s + "Object expected: " + p2);
        return { DECIMAL_PLACES: T, ROUNDING_MODE: D2, EXPONENTIAL_AT: [V2, pe], RANGE: [we, ve], CRYPTO: qe, MODULO_MODE: Ve, POW_PRECISION: Te, FORMAT: ze, ALPHABET: Je };
      }, W2.isBigNumber = function(p2) {
        if (!p2 || p2._isBigNumber !== true)
          return false;
        if (!W2.DEBUG)
          return true;
        var b2, E2, $ = p2.c, R2 = p2.e, z2 = p2.s;
        e:
          if ({}.toString.call($) == "[object Array]") {
            if ((z2 === 1 || z2 === -1) && R2 >= -j2 && R2 <= j2 && R2 === i(R2)) {
              if ($[0] === 0) {
                if (R2 === 0 && $.length === 1)
                  return true;
                break e;
              }
              if (b2 = (R2 + 1) % l2, b2 < 1 && (b2 += l2), String($[0]).length == b2) {
                for (b2 = 0; b2 < $.length; b2++)
                  if (E2 = $[b2], E2 < 0 || E2 >= c || E2 !== i(E2))
                    break e;
                if (E2 !== 0)
                  return true;
              }
            }
          } else if ($ === null && R2 === null && (z2 === null || z2 === 1 || z2 === -1))
            return true;
        throw Error(s + "Invalid BigNumber: " + p2);
      }, W2.maximum = W2.max = function() {
        return ct(arguments, k2.lt);
      }, W2.minimum = W2.min = function() {
        return ct(arguments, k2.gt);
      }, W2.random = function() {
        var p2 = 9007199254740992, b2 = Math.random() * p2 & 2097151 ? function() {
          return i(Math.random() * p2);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(E2) {
          var $, R2, z2, Y, M, B = 0, m2 = [], u2 = new W2(te2);
          if (E2 == null ? E2 = T : U(E2, 0, j2), Y = n(E2 / l2), qe)
            if (crypto.getRandomValues) {
              for ($ = crypto.getRandomValues(new Uint32Array(Y *= 2)); B < Y; )
                M = $[B] * 131072 + ($[B + 1] >>> 11), M >= 9e15 ? (R2 = crypto.getRandomValues(new Uint32Array(2)), $[B] = R2[0], $[B + 1] = R2[1]) : (m2.push(M % 1e14), B += 2);
              B = Y / 2;
            } else if (crypto.randomBytes) {
              for ($ = crypto.randomBytes(Y *= 7); B < Y; )
                M = ($[B] & 31) * 281474976710656 + $[B + 1] * 1099511627776 + $[B + 2] * 4294967296 + $[B + 3] * 16777216 + ($[B + 4] << 16) + ($[B + 5] << 8) + $[B + 6], M >= 9e15 ? crypto.randomBytes(7).copy($, B) : (m2.push(M % 1e14), B += 7);
              B = Y / 7;
            } else
              throw qe = false, Error(s + "crypto unavailable");
          if (!qe)
            for (; B < Y; )
              M = b2(), M < 9e15 && (m2[B++] = M % 1e14);
          for (Y = m2[--B], E2 %= l2, Y && E2 && (M = h2[l2 - E2], m2[B] = i(Y / M) * M); m2[B] === 0; m2.pop(), B--)
            ;
          if (B < 0)
            m2 = [z2 = 0];
          else {
            for (z2 = -1; m2[0] === 0; m2.splice(0, 1), z2 -= l2)
              ;
            for (B = 1, M = m2[0]; M >= 10; M /= 10, B++)
              ;
            B < l2 && (z2 -= l2 - B);
          }
          return u2.e = z2, u2.c = m2, u2;
        };
      }(), W2.sum = function() {
        for (var p2 = 1, b2 = arguments, E2 = new W2(b2[0]); p2 < b2.length; )
          E2 = E2.plus(b2[p2++]);
        return E2;
      }, K2 = function() {
        var p2 = "0123456789";
        function b2(E2, $, R2, z2) {
          for (var Y, M = [0], B, m2 = 0, u2 = E2.length; m2 < u2; ) {
            for (B = M.length; B--; M[B] *= $)
              ;
            for (M[0] += z2.indexOf(E2.charAt(m2++)), Y = 0; Y < M.length; Y++)
              M[Y] > R2 - 1 && (M[Y + 1] == null && (M[Y + 1] = 0), M[Y + 1] += M[Y] / R2 | 0, M[Y] %= R2);
          }
          return M.reverse();
        }
        return function(E2, $, R2, z2, Y) {
          var M, B, m2, u2, g, A, w, F2, O2 = E2.indexOf("."), X = T, ce = D2;
          for (O2 >= 0 && (u2 = Te, Te = 0, E2 = E2.replace(".", ""), F2 = new W2($), A = F2.pow(E2.length - O2), Te = u2, F2.c = b2(le(Q(A.c), A.e, "0"), 10, R2, p2), F2.e = F2.c.length), w = b2(E2, $, R2, Y ? (M = Je, p2) : (M = p2, Je)), m2 = u2 = w.length; w[--u2] == 0; w.pop())
            ;
          if (!w[0])
            return M.charAt(0);
          if (O2 < 0 ? --m2 : (A.c = w, A.e = m2, A.s = z2, A = I(A, F2, X, ce, R2), w = A.c, g = A.r, m2 = A.e), B = m2 + X + 1, O2 = w[B], u2 = R2 / 2, g = g || B < 0 || w[B + 1] != null, g = ce < 4 ? (O2 != null || g) && (ce == 0 || ce == (A.s < 0 ? 3 : 2)) : O2 > u2 || O2 == u2 && (ce == 4 || g || ce == 6 && w[B - 1] & 1 || ce == (A.s < 0 ? 8 : 7)), B < 1 || !w[0])
            E2 = g ? le(M.charAt(1), -X, M.charAt(0)) : M.charAt(0);
          else {
            if (w.length = B, g)
              for (--R2; ++w[--B] > R2; )
                w[B] = 0, B || (++m2, w = [1].concat(w));
            for (u2 = w.length; !w[--u2]; )
              ;
            for (O2 = 0, E2 = ""; O2 <= u2; E2 += M.charAt(w[O2++]))
              ;
            E2 = le(E2, m2, M.charAt(0));
          }
          return E2;
        };
      }(), I = function() {
        function p2($, R2, z2) {
          var Y, M, B, m2, u2 = 0, g = $.length, A = R2 % _, w = R2 / _ | 0;
          for ($ = $.slice(); g--; )
            B = $[g] % _, m2 = $[g] / _ | 0, Y = w * B + m2 * A, M = A * B + Y % _ * _ + u2, u2 = (M / z2 | 0) + (Y / _ | 0) + w * m2, $[g] = M % z2;
          return u2 && ($ = [u2].concat($)), $;
        }
        function b2($, R2, z2, Y) {
          var M, B;
          if (z2 != Y)
            B = z2 > Y ? 1 : -1;
          else
            for (M = B = 0; M < z2; M++)
              if ($[M] != R2[M]) {
                B = $[M] > R2[M] ? 1 : -1;
                break;
              }
          return B;
        }
        function E2($, R2, z2, Y) {
          for (var M = 0; z2--; )
            $[z2] -= M, M = $[z2] < R2[z2] ? 1 : 0, $[z2] = M * Y + $[z2] - R2[z2];
          for (; !$[0] && $.length > 1; $.splice(0, 1))
            ;
        }
        return function($, R2, z2, Y, M) {
          var B, m2, u2, g, A, w, F2, O2, X, ce, he, C2, Ee2, Ce, it, Pe, _t, ft = $.s == R2.s ? 1 : -1, ut = $.c, Ze = R2.c;
          if (!ut || !ut[0] || !Ze || !Ze[0])
            return new W2(!$.s || !R2.s || (ut ? Ze && ut[0] == Ze[0] : !Ze) ? NaN : ut && ut[0] == 0 || !Ze ? ft * 0 : ft / 0);
          for (O2 = new W2(ft), X = O2.c = [], m2 = $.e - R2.e, ft = z2 + m2 + 1, M || (M = c, m2 = G($.e / l2) - G(R2.e / l2), ft = ft / l2 | 0), u2 = 0; Ze[u2] == (ut[u2] || 0); u2++)
            ;
          if (Ze[u2] > (ut[u2] || 0) && m2--, ft < 0)
            X.push(1), g = true;
          else {
            for (Ce = ut.length, Pe = Ze.length, u2 = 0, ft += 2, A = i(M / (Ze[0] + 1)), A > 1 && (Ze = p2(Ze, A, M), ut = p2(ut, A, M), Pe = Ze.length, Ce = ut.length), Ee2 = Pe, ce = ut.slice(0, Pe), he = ce.length; he < Pe; ce[he++] = 0)
              ;
            _t = Ze.slice(), _t = [0].concat(_t), it = Ze[0], Ze[1] >= M / 2 && it++;
            do {
              if (A = 0, B = b2(Ze, ce, Pe, he), B < 0) {
                if (C2 = ce[0], Pe != he && (C2 = C2 * M + (ce[1] || 0)), A = i(C2 / it), A > 1)
                  for (A >= M && (A = M - 1), w = p2(Ze, A, M), F2 = w.length, he = ce.length; b2(w, ce, F2, he) == 1; )
                    A--, E2(w, Pe < F2 ? _t : Ze, F2, M), F2 = w.length, B = 1;
                else
                  A == 0 && (B = A = 1), w = Ze.slice(), F2 = w.length;
                if (F2 < he && (w = [0].concat(w)), E2(ce, w, he, M), he = ce.length, B == -1)
                  for (; b2(Ze, ce, Pe, he) < 1; )
                    A++, E2(ce, Pe < he ? _t : Ze, he, M), he = ce.length;
              } else
                B === 0 && (A++, ce = [0]);
              X[u2++] = A, ce[0] ? ce[he++] = ut[Ee2] || 0 : (ce = [ut[Ee2]], he = 1);
            } while ((Ee2++ < Ce || ce[0] != null) && ft--);
            g = ce[0] != null, X[0] || X.splice(0, 1);
          }
          if (M == c) {
            for (u2 = 1, ft = X[0]; ft >= 10; ft /= 10, u2++)
              ;
            pt(O2, z2 + (O2.e = u2 + m2 * l2 - 1) + 1, Y, g);
          } else
            O2.e = m2, O2.r = +g;
          return O2;
        };
      }();
      function Se(p2, b2, E2, $) {
        var R2, z2, Y, M, B;
        if (E2 == null ? E2 = D2 : U(E2, 0, 8), !p2.c)
          return p2.toString();
        if (R2 = p2.c[0], Y = p2.e, b2 == null)
          B = Q(p2.c), B = $ == 1 || $ == 2 && (Y <= V2 || Y >= pe) ? re2(B, Y) : le(B, Y, "0");
        else if (p2 = pt(new W2(p2), b2, E2), z2 = p2.e, B = Q(p2.c), M = B.length, $ == 1 || $ == 2 && (b2 <= z2 || z2 <= V2)) {
          for (; M < b2; B += "0", M++)
            ;
          B = re2(B, z2);
        } else if (b2 -= Y, B = le(B, z2, "0"), z2 + 1 > M) {
          if (--b2 > 0)
            for (B += "."; b2--; B += "0")
              ;
        } else if (b2 += z2 - M, b2 > 0)
          for (z2 + 1 == M && (B += "."); b2--; B += "0")
            ;
        return p2.s < 0 && R2 ? "-" + B : B;
      }
      function ct(p2, b2) {
        for (var E2, $ = 1, R2 = new W2(p2[0]); $ < p2.length; $++)
          if (E2 = new W2(p2[$]), E2.s)
            b2.call(R2, E2) && (R2 = E2);
          else {
            R2 = E2;
            break;
          }
        return R2;
      }
      function Ot(p2, b2, E2) {
        for (var $ = 1, R2 = b2.length; !b2[--R2]; b2.pop())
          ;
        for (R2 = b2[0]; R2 >= 10; R2 /= 10, $++)
          ;
        return (E2 = $ + E2 * l2 - 1) > ve ? p2.c = p2.e = null : E2 < we ? p2.c = [p2.e = 0] : (p2.e = E2, p2.c = b2), p2;
      }
      P2 = function() {
        var p2 = /^(-?)0([xbo])(?=\w[\w.]*$)/i, b2 = /^([^.]+)\.$/, E2 = /^\.([^.]+)$/, $ = /^-?(Infinity|NaN)$/, R2 = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(z2, Y, M, B) {
          var m2, u2 = M ? Y : Y.replace(R2, "");
          if ($.test(u2))
            z2.s = isNaN(u2) ? null : u2 < 0 ? -1 : 1;
          else {
            if (!M && (u2 = u2.replace(p2, function(g, A, w) {
              return m2 = (w = w.toLowerCase()) == "x" ? 16 : w == "b" ? 2 : 8, !B || B == m2 ? A : g;
            }), B && (m2 = B, u2 = u2.replace(b2, "$1").replace(E2, "0.$1")), Y != u2))
              return new W2(u2, m2);
            if (W2.DEBUG)
              throw Error(s + "Not a" + (B ? " base " + B : "") + " number: " + Y);
            z2.s = null;
          }
          z2.c = z2.e = null;
        };
      }();
      function pt(p2, b2, E2, $) {
        var R2, z2, Y, M, B, m2, u2, g = p2.c, A = h2;
        if (g) {
          e: {
            for (R2 = 1, M = g[0]; M >= 10; M /= 10, R2++)
              ;
            if (z2 = b2 - R2, z2 < 0)
              z2 += l2, Y = b2, B = g[m2 = 0], u2 = B / A[R2 - Y - 1] % 10 | 0;
            else if (m2 = n((z2 + 1) / l2), m2 >= g.length)
              if ($) {
                for (; g.length <= m2; g.push(0))
                  ;
                B = u2 = 0, R2 = 1, z2 %= l2, Y = z2 - l2 + 1;
              } else
                break e;
            else {
              for (B = M = g[m2], R2 = 1; M >= 10; M /= 10, R2++)
                ;
              z2 %= l2, Y = z2 - l2 + R2, u2 = Y < 0 ? 0 : B / A[R2 - Y - 1] % 10 | 0;
            }
            if ($ = $ || b2 < 0 || g[m2 + 1] != null || (Y < 0 ? B : B % A[R2 - Y - 1]), $ = E2 < 4 ? (u2 || $) && (E2 == 0 || E2 == (p2.s < 0 ? 3 : 2)) : u2 > 5 || u2 == 5 && (E2 == 4 || $ || E2 == 6 && (z2 > 0 ? Y > 0 ? B / A[R2 - Y] : 0 : g[m2 - 1]) % 10 & 1 || E2 == (p2.s < 0 ? 8 : 7)), b2 < 1 || !g[0])
              return g.length = 0, $ ? (b2 -= p2.e + 1, g[0] = A[(l2 - b2 % l2) % l2], p2.e = -b2 || 0) : g[0] = p2.e = 0, p2;
            if (z2 == 0 ? (g.length = m2, M = 1, m2--) : (g.length = m2 + 1, M = A[l2 - z2], g[m2] = Y > 0 ? i(B / A[R2 - Y] % A[Y]) * M : 0), $)
              for (; ; )
                if (m2 == 0) {
                  for (z2 = 1, Y = g[0]; Y >= 10; Y /= 10, z2++)
                    ;
                  for (Y = g[0] += M, M = 1; Y >= 10; Y /= 10, M++)
                    ;
                  z2 != M && (p2.e++, g[0] == c && (g[0] = 1));
                  break;
                } else {
                  if (g[m2] += M, g[m2] != c)
                    break;
                  g[m2--] = 0, M = 1;
                }
            for (z2 = g.length; g[--z2] === 0; g.pop())
              ;
          }
          p2.e > ve ? p2.c = p2.e = null : p2.e < we && (p2.c = [p2.e = 0]);
        }
        return p2;
      }
      function me(p2) {
        var b2, E2 = p2.e;
        return E2 === null ? p2.toString() : (b2 = Q(p2.c), b2 = E2 <= V2 || E2 >= pe ? re2(b2, E2) : le(b2, E2, "0"), p2.s < 0 ? "-" + b2 : b2);
      }
      return k2.absoluteValue = k2.abs = function() {
        var p2 = new W2(this);
        return p2.s < 0 && (p2.s = 1), p2;
      }, k2.comparedTo = function(p2, b2) {
        return N2(this, new W2(p2, b2));
      }, k2.decimalPlaces = k2.dp = function(p2, b2) {
        var E2, $, R2, z2 = this;
        if (p2 != null)
          return U(p2, 0, j2), b2 == null ? b2 = D2 : U(b2, 0, 8), pt(new W2(z2), p2 + z2.e + 1, b2);
        if (!(E2 = z2.c))
          return null;
        if ($ = ((R2 = E2.length - 1) - G(this.e / l2)) * l2, R2 = E2[R2])
          for (; R2 % 10 == 0; R2 /= 10, $--)
            ;
        return $ < 0 && ($ = 0), $;
      }, k2.dividedBy = k2.div = function(p2, b2) {
        return I(this, new W2(p2, b2), T, D2);
      }, k2.dividedToIntegerBy = k2.idiv = function(p2, b2) {
        return I(this, new W2(p2, b2), 0, 1);
      }, k2.exponentiatedBy = k2.pow = function(p2, b2) {
        var E2, $, R2, z2, Y, M, B, m2, u2, g = this;
        if (p2 = new W2(p2), p2.c && !p2.isInteger())
          throw Error(s + "Exponent not an integer: " + me(p2));
        if (b2 != null && (b2 = new W2(b2)), M = p2.e > 14, !g.c || !g.c[0] || g.c[0] == 1 && !g.e && g.c.length == 1 || !p2.c || !p2.c[0])
          return u2 = new W2(Math.pow(+me(g), M ? p2.s * (2 - ee(p2)) : +me(p2))), b2 ? u2.mod(b2) : u2;
        if (B = p2.s < 0, b2) {
          if (b2.c ? !b2.c[0] : !b2.s)
            return new W2(NaN);
          $ = !B && g.isInteger() && b2.isInteger(), $ && (g = g.mod(b2));
        } else {
          if (p2.e > 9 && (g.e > 0 || g.e < -1 || (g.e == 0 ? g.c[0] > 1 || M && g.c[1] >= 24e7 : g.c[0] < 8e13 || M && g.c[0] <= 9999975e7)))
            return z2 = g.s < 0 && ee(p2) ? -0 : 0, g.e > -1 && (z2 = 1 / z2), new W2(B ? 1 / z2 : z2);
          Te && (z2 = n(Te / l2 + 2));
        }
        for (M ? (E2 = new W2(0.5), B && (p2.s = 1), m2 = ee(p2)) : (R2 = Math.abs(+me(p2)), m2 = R2 % 2), u2 = new W2(te2); ; ) {
          if (m2) {
            if (u2 = u2.times(g), !u2.c)
              break;
            z2 ? u2.c.length > z2 && (u2.c.length = z2) : $ && (u2 = u2.mod(b2));
          }
          if (R2) {
            if (R2 = i(R2 / 2), R2 === 0)
              break;
            m2 = R2 % 2;
          } else if (p2 = p2.times(E2), pt(p2, p2.e + 1, 1), p2.e > 14)
            m2 = ee(p2);
          else {
            if (R2 = +me(p2), R2 === 0)
              break;
            m2 = R2 % 2;
          }
          g = g.times(g), z2 ? g.c && g.c.length > z2 && (g.c.length = z2) : $ && (g = g.mod(b2));
        }
        return $ ? u2 : (B && (u2 = te2.div(u2)), b2 ? u2.mod(b2) : z2 ? pt(u2, Te, D2, Y) : u2);
      }, k2.integerValue = function(p2) {
        var b2 = new W2(this);
        return p2 == null ? p2 = D2 : U(p2, 0, 8), pt(b2, b2.e + 1, p2);
      }, k2.isEqualTo = k2.eq = function(p2, b2) {
        return N2(this, new W2(p2, b2)) === 0;
      }, k2.isFinite = function() {
        return !!this.c;
      }, k2.isGreaterThan = k2.gt = function(p2, b2) {
        return N2(this, new W2(p2, b2)) > 0;
      }, k2.isGreaterThanOrEqualTo = k2.gte = function(p2, b2) {
        return (b2 = N2(this, new W2(p2, b2))) === 1 || b2 === 0;
      }, k2.isInteger = function() {
        return !!this.c && G(this.e / l2) > this.c.length - 2;
      }, k2.isLessThan = k2.lt = function(p2, b2) {
        return N2(this, new W2(p2, b2)) < 0;
      }, k2.isLessThanOrEqualTo = k2.lte = function(p2, b2) {
        return (b2 = N2(this, new W2(p2, b2))) === -1 || b2 === 0;
      }, k2.isNaN = function() {
        return !this.s;
      }, k2.isNegative = function() {
        return this.s < 0;
      }, k2.isPositive = function() {
        return this.s > 0;
      }, k2.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, k2.minus = function(p2, b2) {
        var E2, $, R2, z2, Y = this, M = Y.s;
        if (p2 = new W2(p2, b2), b2 = p2.s, !M || !b2)
          return new W2(NaN);
        if (M != b2)
          return p2.s = -b2, Y.plus(p2);
        var B = Y.e / l2, m2 = p2.e / l2, u2 = Y.c, g = p2.c;
        if (!B || !m2) {
          if (!u2 || !g)
            return u2 ? (p2.s = -b2, p2) : new W2(g ? Y : NaN);
          if (!u2[0] || !g[0])
            return g[0] ? (p2.s = -b2, p2) : new W2(u2[0] ? Y : D2 == 3 ? -0 : 0);
        }
        if (B = G(B), m2 = G(m2), u2 = u2.slice(), M = B - m2) {
          for ((z2 = M < 0) ? (M = -M, R2 = u2) : (m2 = B, R2 = g), R2.reverse(), b2 = M; b2--; R2.push(0))
            ;
          R2.reverse();
        } else
          for ($ = (z2 = (M = u2.length) < (b2 = g.length)) ? M : b2, M = b2 = 0; b2 < $; b2++)
            if (u2[b2] != g[b2]) {
              z2 = u2[b2] < g[b2];
              break;
            }
        if (z2 && (R2 = u2, u2 = g, g = R2, p2.s = -p2.s), b2 = ($ = g.length) - (E2 = u2.length), b2 > 0)
          for (; b2--; u2[E2++] = 0)
            ;
        for (b2 = c - 1; $ > M; ) {
          if (u2[--$] < g[$]) {
            for (E2 = $; E2 && !u2[--E2]; u2[E2] = b2)
              ;
            --u2[E2], u2[$] += c;
          }
          u2[$] -= g[$];
        }
        for (; u2[0] == 0; u2.splice(0, 1), --m2)
          ;
        return u2[0] ? Ot(p2, u2, m2) : (p2.s = D2 == 3 ? -1 : 1, p2.c = [p2.e = 0], p2);
      }, k2.modulo = k2.mod = function(p2, b2) {
        var E2, $, R2 = this;
        return p2 = new W2(p2, b2), !R2.c || !p2.s || p2.c && !p2.c[0] ? new W2(NaN) : !p2.c || R2.c && !R2.c[0] ? new W2(R2) : (Ve == 9 ? ($ = p2.s, p2.s = 1, E2 = I(R2, p2, 0, 3), p2.s = $, E2.s *= $) : E2 = I(R2, p2, 0, Ve), p2 = R2.minus(E2.times(p2)), !p2.c[0] && Ve == 1 && (p2.s = R2.s), p2);
      }, k2.multipliedBy = k2.times = function(p2, b2) {
        var E2, $, R2, z2, Y, M, B, m2, u2, g, A, w, F2, O2, X, ce = this, he = ce.c, C2 = (p2 = new W2(p2, b2)).c;
        if (!he || !C2 || !he[0] || !C2[0])
          return !ce.s || !p2.s || he && !he[0] && !C2 || C2 && !C2[0] && !he ? p2.c = p2.e = p2.s = null : (p2.s *= ce.s, !he || !C2 ? p2.c = p2.e = null : (p2.c = [0], p2.e = 0)), p2;
        for ($ = G(ce.e / l2) + G(p2.e / l2), p2.s *= ce.s, B = he.length, g = C2.length, B < g && (F2 = he, he = C2, C2 = F2, R2 = B, B = g, g = R2), R2 = B + g, F2 = []; R2--; F2.push(0))
          ;
        for (O2 = c, X = _, R2 = g; --R2 >= 0; ) {
          for (E2 = 0, A = C2[R2] % X, w = C2[R2] / X | 0, Y = B, z2 = R2 + Y; z2 > R2; )
            m2 = he[--Y] % X, u2 = he[Y] / X | 0, M = w * m2 + u2 * A, m2 = A * m2 + M % X * X + F2[z2] + E2, E2 = (m2 / O2 | 0) + (M / X | 0) + w * u2, F2[z2--] = m2 % O2;
          F2[z2] = E2;
        }
        return E2 ? ++$ : F2.splice(0, 1), Ot(p2, F2, $);
      }, k2.negated = function() {
        var p2 = new W2(this);
        return p2.s = -p2.s || null, p2;
      }, k2.plus = function(p2, b2) {
        var E2, $ = this, R2 = $.s;
        if (p2 = new W2(p2, b2), b2 = p2.s, !R2 || !b2)
          return new W2(NaN);
        if (R2 != b2)
          return p2.s = -b2, $.minus(p2);
        var z2 = $.e / l2, Y = p2.e / l2, M = $.c, B = p2.c;
        if (!z2 || !Y) {
          if (!M || !B)
            return new W2(R2 / 0);
          if (!M[0] || !B[0])
            return B[0] ? p2 : new W2(M[0] ? $ : R2 * 0);
        }
        if (z2 = G(z2), Y = G(Y), M = M.slice(), R2 = z2 - Y) {
          for (R2 > 0 ? (Y = z2, E2 = B) : (R2 = -R2, E2 = M), E2.reverse(); R2--; E2.push(0))
            ;
          E2.reverse();
        }
        for (R2 = M.length, b2 = B.length, R2 - b2 < 0 && (E2 = B, B = M, M = E2, b2 = R2), R2 = 0; b2; )
          R2 = (M[--b2] = M[b2] + B[b2] + R2) / c | 0, M[b2] = c === M[b2] ? 0 : M[b2] % c;
        return R2 && (M = [R2].concat(M), ++Y), Ot(p2, M, Y);
      }, k2.precision = k2.sd = function(p2, b2) {
        var E2, $, R2, z2 = this;
        if (p2 != null && p2 !== !!p2)
          return U(p2, 1, j2), b2 == null ? b2 = D2 : U(b2, 0, 8), pt(new W2(z2), p2, b2);
        if (!(E2 = z2.c))
          return null;
        if (R2 = E2.length - 1, $ = R2 * l2 + 1, R2 = E2[R2]) {
          for (; R2 % 10 == 0; R2 /= 10, $--)
            ;
          for (R2 = E2[0]; R2 >= 10; R2 /= 10, $++)
            ;
        }
        return p2 && z2.e + 1 > $ && ($ = z2.e + 1), $;
      }, k2.shiftedBy = function(p2) {
        return U(p2, -f2, f2), this.times("1e" + p2);
      }, k2.squareRoot = k2.sqrt = function() {
        var p2, b2, E2, $, R2, z2 = this, Y = z2.c, M = z2.s, B = z2.e, m2 = T + 4, u2 = new W2("0.5");
        if (M !== 1 || !Y || !Y[0])
          return new W2(!M || M < 0 && (!Y || Y[0]) ? NaN : Y ? z2 : 1 / 0);
        if (M = Math.sqrt(+me(z2)), M == 0 || M == 1 / 0 ? (b2 = Q(Y), (b2.length + B) % 2 == 0 && (b2 += "0"), M = Math.sqrt(+b2), B = G((B + 1) / 2) - (B < 0 || B % 2), M == 1 / 0 ? b2 = "5e" + B : (b2 = M.toExponential(), b2 = b2.slice(0, b2.indexOf("e") + 1) + B), E2 = new W2(b2)) : E2 = new W2(M + ""), E2.c[0]) {
          for (B = E2.e, M = B + m2, M < 3 && (M = 0); ; )
            if (R2 = E2, E2 = u2.times(R2.plus(I(z2, R2, m2, 1))), Q(R2.c).slice(0, M) === (b2 = Q(E2.c)).slice(0, M))
              if (E2.e < B && --M, b2 = b2.slice(M - 3, M + 1), b2 == "9999" || !$ && b2 == "4999") {
                if (!$ && (pt(R2, R2.e + T + 2, 0), R2.times(R2).eq(z2))) {
                  E2 = R2;
                  break;
                }
                m2 += 4, M += 4, $ = 1;
              } else {
                (!+b2 || !+b2.slice(1) && b2.charAt(0) == "5") && (pt(E2, E2.e + T + 2, 1), p2 = !E2.times(E2).eq(z2));
                break;
              }
        }
        return pt(E2, E2.e + T + 1, D2, p2);
      }, k2.toExponential = function(p2, b2) {
        return p2 != null && (U(p2, 0, j2), p2++), Se(this, p2, b2, 1);
      }, k2.toFixed = function(p2, b2) {
        return p2 != null && (U(p2, 0, j2), p2 = p2 + this.e + 1), Se(this, p2, b2);
      }, k2.toFormat = function(p2, b2, E2) {
        var $, R2 = this;
        if (E2 == null)
          p2 != null && b2 && typeof b2 == "object" ? (E2 = b2, b2 = null) : p2 && typeof p2 == "object" ? (E2 = p2, p2 = b2 = null) : E2 = ze;
        else if (typeof E2 != "object")
          throw Error(s + "Argument not an object: " + E2);
        if ($ = R2.toFixed(p2, b2), R2.c) {
          var z2, Y = $.split("."), M = +E2.groupSize, B = +E2.secondaryGroupSize, m2 = E2.groupSeparator || "", u2 = Y[0], g = Y[1], A = R2.s < 0, w = A ? u2.slice(1) : u2, F2 = w.length;
          if (B && (z2 = M, M = B, B = z2, F2 -= z2), M > 0 && F2 > 0) {
            for (z2 = F2 % M || M, u2 = w.substr(0, z2); z2 < F2; z2 += M)
              u2 += m2 + w.substr(z2, M);
            B > 0 && (u2 += m2 + w.slice(z2)), A && (u2 = "-" + u2);
          }
          $ = g ? u2 + (E2.decimalSeparator || "") + ((B = +E2.fractionGroupSize) ? g.replace(new RegExp("\\d{" + B + "}\\B", "g"), "$&" + (E2.fractionGroupSeparator || "")) : g) : u2;
        }
        return (E2.prefix || "") + $ + (E2.suffix || "");
      }, k2.toFraction = function(p2) {
        var b2, E2, $, R2, z2, Y, M, B, m2, u2, g, A, w = this, F2 = w.c;
        if (p2 != null && (M = new W2(p2), !M.isInteger() && (M.c || M.s !== 1) || M.lt(te2)))
          throw Error(s + "Argument " + (M.isInteger() ? "out of range: " : "not an integer: ") + me(M));
        if (!F2)
          return new W2(w);
        for (b2 = new W2(te2), m2 = E2 = new W2(te2), $ = B = new W2(te2), A = Q(F2), z2 = b2.e = A.length - w.e - 1, b2.c[0] = h2[(Y = z2 % l2) < 0 ? l2 + Y : Y], p2 = !p2 || M.comparedTo(b2) > 0 ? z2 > 0 ? b2 : m2 : M, Y = ve, ve = 1 / 0, M = new W2(A), B.c[0] = 0; u2 = I(M, b2, 0, 1), R2 = E2.plus(u2.times($)), R2.comparedTo(p2) != 1; )
          E2 = $, $ = R2, m2 = B.plus(u2.times(R2 = m2)), B = R2, b2 = M.minus(u2.times(R2 = b2)), M = R2;
        return R2 = I(p2.minus(E2), $, 0, 1), B = B.plus(R2.times(m2)), E2 = E2.plus(R2.times($)), B.s = m2.s = w.s, z2 = z2 * 2, g = I(m2, $, z2, D2).minus(w).abs().comparedTo(I(B, E2, z2, D2).minus(w).abs()) < 1 ? [m2, $] : [B, E2], ve = Y, g;
      }, k2.toNumber = function() {
        return +me(this);
      }, k2.toPrecision = function(p2, b2) {
        return p2 != null && U(p2, 1, j2), Se(this, p2, b2, 2);
      }, k2.toString = function(p2) {
        var b2, E2 = this, $ = E2.s, R2 = E2.e;
        return R2 === null ? $ ? (b2 = "Infinity", $ < 0 && (b2 = "-" + b2)) : b2 = "NaN" : (p2 == null ? b2 = R2 <= V2 || R2 >= pe ? re2(Q(E2.c), R2) : le(Q(E2.c), R2, "0") : p2 === 10 && Be ? (E2 = pt(new W2(E2), T + R2 + 1, D2), b2 = le(Q(E2.c), E2.e, "0")) : (U(p2, 2, Je.length, "Base"), b2 = K2(le(Q(E2.c), R2, "0"), 10, p2, $, true)), $ < 0 && E2.c[0] && (b2 = "-" + b2)), b2;
      }, k2.valueOf = k2.toJSON = function() {
        return me(this);
      }, k2._isBigNumber = true, H2 != null && W2.set(H2), W2;
    }
    function G(H2) {
      var I = H2 | 0;
      return H2 > 0 || H2 === I ? I : I - 1;
    }
    function Q(H2) {
      for (var I, K2, P2 = 1, k2 = H2.length, te2 = H2[0] + ""; P2 < k2; ) {
        for (I = H2[P2++] + "", K2 = l2 - I.length; K2--; I = "0" + I)
          ;
        te2 += I;
      }
      for (k2 = te2.length; te2.charCodeAt(--k2) === 48; )
        ;
      return te2.slice(0, k2 + 1 || 1);
    }
    function N2(H2, I) {
      var K2, P2, k2 = H2.c, te2 = I.c, T = H2.s, D2 = I.s, V2 = H2.e, pe = I.e;
      if (!T || !D2)
        return null;
      if (K2 = k2 && !k2[0], P2 = te2 && !te2[0], K2 || P2)
        return K2 ? P2 ? 0 : -D2 : T;
      if (T != D2)
        return T;
      if (K2 = T < 0, P2 = V2 == pe, !k2 || !te2)
        return P2 ? 0 : !k2 ^ K2 ? 1 : -1;
      if (!P2)
        return V2 > pe ^ K2 ? 1 : -1;
      for (D2 = (V2 = k2.length) < (pe = te2.length) ? V2 : pe, T = 0; T < D2; T++)
        if (k2[T] != te2[T])
          return k2[T] > te2[T] ^ K2 ? 1 : -1;
      return V2 == pe ? 0 : V2 > pe ^ K2 ? 1 : -1;
    }
    function U(H2, I, K2, P2) {
      if (H2 < I || H2 > K2 || H2 !== i(H2))
        throw Error(s + (P2 || "Argument") + (typeof H2 == "number" ? H2 < I || H2 > K2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(H2));
    }
    function ee(H2) {
      var I = H2.c.length - 1;
      return G(H2.e / l2) == I && H2.c[I] % 2 != 0;
    }
    function re2(H2, I) {
      return (H2.length > 1 ? H2.charAt(0) + "." + H2.slice(1) : H2) + (I < 0 ? "e" : "e+") + I;
    }
    function le(H2, I, K2) {
      var P2, k2;
      if (I < 0) {
        for (k2 = K2 + "."; ++I; k2 += K2)
          ;
        H2 = k2 + H2;
      } else if (P2 = H2.length, ++I > P2) {
        for (k2 = K2, I -= P2; --I; k2 += K2)
          ;
        H2 += k2;
      } else
        I < P2 && (H2 = H2.slice(0, I) + "." + H2.slice(I));
      return H2;
    }
    e = ie(), e.default = e.BigNumber = e, typeof define == "function" && define.amd ? define(function() {
      return e;
    }) : typeof Lc != "undefined" && Lc.exports ? Lc.exports = e : (r || (r = typeof self != "undefined" && self ? self : window), r.BigNumber = e);
  })(zl);
});
var Gl = dr((gx, Vl) => {
  var ql = ef(), $l = Vl.exports;
  (function() {
    var t = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, n, i, s = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, o;
    function c(f2) {
      return t.lastIndex = 0, t.test(f2) ? '"' + f2.replace(t, function(h2) {
        var _ = s[h2];
        return typeof _ == "string" ? _ : "\\u" + ("0000" + h2.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + f2 + '"';
    }
    function l2(f2, h2) {
      var _, j2, ie, G, Q = n, N2, U = h2[f2], ee = U != null && (U instanceof ql || ql.isBigNumber(U));
      switch (U && typeof U == "object" && typeof U.toJSON == "function" && (U = U.toJSON(f2)), typeof o == "function" && (U = o.call(h2, f2, U)), typeof U) {
        case "string":
          return ee ? U : c(U);
        case "number":
          return isFinite(U) ? String(U) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(U);
        case "object":
          if (!U)
            return "null";
          if (n += i, N2 = [], Object.prototype.toString.apply(U) === "[object Array]") {
            for (G = U.length, _ = 0; _ < G; _ += 1)
              N2[_] = l2(_, U) || "null";
            return ie = N2.length === 0 ? "[]" : n ? `[
` + n + N2.join(`,
` + n) + `
` + Q + "]" : "[" + N2.join(",") + "]", n = Q, ie;
          }
          if (o && typeof o == "object")
            for (G = o.length, _ = 0; _ < G; _ += 1)
              typeof o[_] == "string" && (j2 = o[_], ie = l2(j2, U), ie && N2.push(c(j2) + (n ? ": " : ":") + ie));
          else
            Object.keys(U).forEach(function(re2) {
              var le = l2(re2, U);
              le && N2.push(c(re2) + (n ? ": " : ":") + le);
            });
          return ie = N2.length === 0 ? "{}" : n ? `{
` + n + N2.join(`,
` + n) + `
` + Q + "}" : "{" + N2.join(",") + "}", n = Q, ie;
      }
    }
    typeof $l.stringify != "function" && ($l.stringify = function(f2, h2, _) {
      var j2;
      if (n = "", i = "", typeof _ == "number")
        for (j2 = 0; j2 < _; j2 += 1)
          i += " ";
      else
        typeof _ == "string" && (i = _);
      if (o = h2, h2 && typeof h2 != "function" && (typeof h2 != "object" || typeof h2.length != "number"))
        throw new Error("JSON.stringify");
      return l2("", { "": f2 });
    });
  })();
});
var Kl = dr((mx, Wl) => {
  var Uc = null, Ng = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, Og = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/, Dg = function(r) {
    var e = { strict: false, storeAsString: false, alwaysParseAsBig: false, useNativeBigInt: false, protoAction: "error", constructorAction: "error" };
    if (r != null) {
      if (r.strict === true && (e.strict = true), r.storeAsString === true && (e.storeAsString = true), e.alwaysParseAsBig = r.alwaysParseAsBig === true ? r.alwaysParseAsBig : false, e.useNativeBigInt = r.useNativeBigInt === true ? r.useNativeBigInt : false, typeof r.constructorAction != "undefined")
        if (r.constructorAction === "error" || r.constructorAction === "ignore" || r.constructorAction === "preserve")
          e.constructorAction = r.constructorAction;
        else
          throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${r.constructorAction}`);
      if (typeof r.protoAction != "undefined")
        if (r.protoAction === "error" || r.protoAction === "ignore" || r.protoAction === "preserve")
          e.protoAction = r.protoAction;
        else
          throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${r.protoAction}`);
    }
    var t, n, i = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: `
`, r: "\r", t: "	" }, s, o = function(Q) {
      throw { name: "SyntaxError", message: Q, at: t, text: s };
    }, c = function(Q) {
      return Q && Q !== n && o("Expected '" + Q + "' instead of '" + n + "'"), n = s.charAt(t), t += 1, n;
    }, l2 = function() {
      var Q, N2 = "";
      for (n === "-" && (N2 = "-", c("-")); n >= "0" && n <= "9"; )
        N2 += n, c();
      if (n === ".")
        for (N2 += "."; c() && n >= "0" && n <= "9"; )
          N2 += n;
      if (n === "e" || n === "E")
        for (N2 += n, c(), (n === "-" || n === "+") && (N2 += n, c()); n >= "0" && n <= "9"; )
          N2 += n, c();
      if (Q = +N2, !isFinite(Q))
        o("Bad number");
      else
        return Uc == null && (Uc = ef()), N2.length > 15 ? e.storeAsString ? N2 : e.useNativeBigInt ? BigInt(N2) : new Uc(N2) : e.alwaysParseAsBig ? e.useNativeBigInt ? BigInt(Q) : new Uc(Q) : Q;
    }, f2 = function() {
      var Q, N2, U = "", ee;
      if (n === '"')
        for (var re2 = t; c(); ) {
          if (n === '"')
            return t - 1 > re2 && (U += s.substring(re2, t - 1)), c(), U;
          if (n === "\\") {
            if (t - 1 > re2 && (U += s.substring(re2, t - 1)), c(), n === "u") {
              for (ee = 0, N2 = 0; N2 < 4 && (Q = parseInt(c(), 16), !!isFinite(Q)); N2 += 1)
                ee = ee * 16 + Q;
              U += String.fromCharCode(ee);
            } else if (typeof i[n] == "string")
              U += i[n];
            else
              break;
            re2 = t;
          }
        }
      o("Bad string");
    }, h2 = function() {
      for (; n && n <= " "; )
        c();
    }, _ = function() {
      switch (n) {
        case "t":
          return c("t"), c("r"), c("u"), c("e"), true;
        case "f":
          return c("f"), c("a"), c("l"), c("s"), c("e"), false;
        case "n":
          return c("n"), c("u"), c("l"), c("l"), null;
      }
      o("Unexpected '" + n + "'");
    }, j2, ie = function() {
      var Q = [];
      if (n === "[") {
        if (c("["), h2(), n === "]")
          return c("]"), Q;
        for (; n; ) {
          if (Q.push(j2()), h2(), n === "]")
            return c("]"), Q;
          c(","), h2();
        }
      }
      o("Bad array");
    }, G = function() {
      var Q, N2 = /* @__PURE__ */ Object.create(null);
      if (n === "{") {
        if (c("{"), h2(), n === "}")
          return c("}"), N2;
        for (; n; ) {
          if (Q = f2(), h2(), c(":"), e.strict === true && Object.hasOwnProperty.call(N2, Q) && o('Duplicate key "' + Q + '"'), Ng.test(Q) === true ? e.protoAction === "error" ? o("Object contains forbidden prototype property") : e.protoAction === "ignore" ? j2() : N2[Q] = j2() : Og.test(Q) === true ? e.constructorAction === "error" ? o("Object contains forbidden constructor property") : e.constructorAction === "ignore" ? j2() : N2[Q] = j2() : N2[Q] = j2(), h2(), n === "}")
            return c("}"), N2;
          c(","), h2();
        }
      }
      o("Bad object");
    };
    return j2 = function() {
      switch (h2(), n) {
        case "{":
          return G();
        case "[":
          return ie();
        case '"':
          return f2();
        case "-":
          return l2();
        default:
          return n >= "0" && n <= "9" ? l2() : _();
      }
    }, function(Q, N2) {
      var U;
      return s = Q + "", t = 0, n = " ", U = j2(), h2(), n && o("Syntax error"), typeof N2 == "function" ? function ee(re2, le) {
        var I, K2 = re2[le];
        return K2 && typeof K2 == "object" && Object.keys(K2).forEach(function(P2) {
          I = ee(K2, P2), I !== void 0 ? K2[P2] = I : delete K2[P2];
        }), N2.call(re2, le, K2);
      }({ "": U }, "") : U;
    };
  };
  Wl.exports = Dg;
});
var Jl = dr((yx, Pc) => {
  var Hl = Gl().stringify, Yl = Kl();
  Pc.exports = function(r) {
    return { parse: Yl(r), stringify: Hl };
  };
  Pc.exports.parse = Yl();
  Pc.exports.stringify = Hl;
});
var sd = dr((io, sf) => {
  (function(r, e) {
    typeof io == "object" && typeof sf == "object" ? sf.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof io == "object" ? io.MessagePack = e() : r.MessagePack = e();
  })(io, function() {
    return function(r) {
      var e = {};
      function t(n) {
        if (e[n])
          return e[n].exports;
        var i = e[n] = { i: n, l: false, exports: {} };
        return r[n].call(i.exports, i, i.exports, t), i.l = true, i.exports;
      }
      return t.m = r, t.c = e, t.d = function(n, i, s) {
        t.o(n, i) || Object.defineProperty(n, i, { enumerable: true, get: s });
      }, t.r = function(n) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n, "__esModule", { value: true });
      }, t.t = function(n, i) {
        if (1 & i && (n = t(n)), 8 & i || 4 & i && typeof n == "object" && n && n.__esModule)
          return n;
        var s = /* @__PURE__ */ Object.create(null);
        if (t.r(s), Object.defineProperty(s, "default", { enumerable: true, value: n }), 2 & i && typeof n != "string")
          for (var o in n)
            t.d(s, o, (function(c) {
              return n[c];
            }).bind(null, o));
        return s;
      }, t.n = function(n) {
        var i = n && n.__esModule ? function() {
          return n.default;
        } : function() {
          return n;
        };
        return t.d(i, "a", i), i;
      }, t.o = function(n, i) {
        return Object.prototype.hasOwnProperty.call(n, i);
      }, t.p = "", t(t.s = 0);
    }([function(r, e, t) {
      t.r(e), t.d(e, "encode", function() {
        return D2;
      }), t.d(e, "decode", function() {
        return pt;
      }), t.d(e, "decodeAsync", function() {
        return Y;
      }), t.d(e, "decodeArrayStream", function() {
        return M;
      }), t.d(e, "decodeStream", function() {
        return B;
      }), t.d(e, "Decoder", function() {
        return ct;
      }), t.d(e, "Encoder", function() {
        return te2;
      }), t.d(e, "ExtensionCodec", function() {
        return K2;
      }), t.d(e, "ExtData", function() {
        return ie;
      }), t.d(e, "EXT_TIMESTAMP", function() {
        return N2;
      }), t.d(e, "encodeDateToTimeSpec", function() {
        return ee;
      }), t.d(e, "encodeTimeSpecToTimestamp", function() {
        return U;
      }), t.d(e, "decodeTimestampToTimeSpec", function() {
        return le;
      }), t.d(e, "encodeTimestampExtension", function() {
        return re2;
      }), t.d(e, "decodeTimestampExtension", function() {
        return H2;
      });
      var n = function(m2, u2) {
        var g = typeof Symbol == "function" && m2[Symbol.iterator];
        if (!g)
          return m2;
        var A, w, F2 = g.call(m2), O2 = [];
        try {
          for (; (u2 === void 0 || u2-- > 0) && !(A = F2.next()).done; )
            O2.push(A.value);
        } catch (X) {
          w = { error: X };
        } finally {
          try {
            A && !A.done && (g = F2.return) && g.call(F2);
          } finally {
            if (w)
              throw w.error;
          }
        }
        return O2;
      }, i = function() {
        for (var m2 = [], u2 = 0; u2 < arguments.length; u2++)
          m2 = m2.concat(n(arguments[u2]));
        return m2;
      }, s = typeof process != "undefined" && typeof TextEncoder != "undefined" && typeof TextDecoder != "undefined";
      function o(m2) {
        for (var u2 = m2.length, g = 0, A = 0; A < u2; ) {
          var w = m2.charCodeAt(A++);
          if (4294967168 & w)
            if (!(4294965248 & w))
              g += 2;
            else {
              if (w >= 55296 && w <= 56319 && A < u2) {
                var F2 = m2.charCodeAt(A);
                (64512 & F2) == 56320 && (++A, w = ((1023 & w) << 10) + (1023 & F2) + 65536);
              }
              g += 4294901760 & w ? 4 : 3;
            }
          else
            g++;
        }
        return g;
      }
      var c = s ? new TextEncoder() : void 0, l2 = typeof process != "undefined" ? 200 : 0, f2 = c != null && c.encodeInto ? function(m2, u2, g) {
        c.encodeInto(m2, u2.subarray(g));
      } : function(m2, u2, g) {
        u2.set(c.encode(m2), g);
      };
      function h2(m2, u2, g) {
        for (var A = u2, w = A + g, F2 = [], O2 = ""; A < w; ) {
          var X = m2[A++];
          if (!(128 & X))
            F2.push(X);
          else if ((224 & X) == 192) {
            var ce = 63 & m2[A++];
            F2.push((31 & X) << 6 | ce);
          } else if ((240 & X) == 224) {
            ce = 63 & m2[A++];
            var he = 63 & m2[A++];
            F2.push((31 & X) << 12 | ce << 6 | he);
          } else if ((248 & X) == 240) {
            var C2 = (7 & X) << 18 | (ce = 63 & m2[A++]) << 12 | (he = 63 & m2[A++]) << 6 | 63 & m2[A++];
            C2 > 65535 && (C2 -= 65536, F2.push(C2 >>> 10 & 1023 | 55296), C2 = 56320 | 1023 & C2), F2.push(C2);
          } else
            F2.push(X);
          F2.length >= 4096 && (O2 += String.fromCharCode.apply(String, i(F2)), F2.length = 0);
        }
        return F2.length > 0 && (O2 += String.fromCharCode.apply(String, i(F2))), O2;
      }
      var _ = s ? new TextDecoder() : null, j2 = typeof process != "undefined" ? 200 : 0, ie = function(m2, u2) {
        this.type = m2, this.data = u2;
      };
      function G(m2, u2, g) {
        var A = Math.floor(g / 4294967296), w = g;
        m2.setUint32(u2, A), m2.setUint32(u2 + 4, w);
      }
      function Q(m2, u2) {
        var g = m2.getInt32(u2), A = m2.getUint32(u2 + 4), w = g < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || g === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && A === 0, F2 = g > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        return w || F2 ? BigInt(g) * BigInt(4294967296) + BigInt(A) : 4294967296 * g + A;
      }
      var N2 = -1;
      function U(m2) {
        var u2 = m2.sec, g = m2.nsec;
        if (u2 >= 0 && g >= 0 && u2 <= 17179869183) {
          if (g === 0 && u2 <= 4294967295) {
            var A = new Uint8Array(4);
            return (O2 = new DataView(A.buffer)).setUint32(0, u2), A;
          }
          var w = u2 / 4294967296, F2 = 4294967295 & u2;
          return A = new Uint8Array(8), (O2 = new DataView(A.buffer)).setUint32(0, g << 2 | 3 & w), O2.setUint32(4, F2), A;
        }
        var O2;
        return A = new Uint8Array(12), (O2 = new DataView(A.buffer)).setUint32(0, g), G(O2, 4, u2), A;
      }
      function ee(m2) {
        var u2 = m2.getTime(), g = Math.floor(u2 / 1e3), A = 1e6 * (u2 - 1e3 * g), w = Math.floor(A / 1e9);
        return { sec: g + w, nsec: A - 1e9 * w };
      }
      function re2(m2) {
        return m2 instanceof Date ? U(ee(m2)) : null;
      }
      function le(m2) {
        var u2 = new DataView(m2.buffer, m2.byteOffset, m2.byteLength);
        switch (m2.byteLength) {
          case 4:
            return { sec: u2.getUint32(0), nsec: 0 };
          case 8:
            var g = u2.getUint32(0);
            return { sec: 4294967296 * (3 & g) + u2.getUint32(4), nsec: g >>> 2 };
          case 12:
            return { sec: Q(u2, 4), nsec: u2.getUint32(0) };
          default:
            throw new Error("Unrecognized data size for timestamp: " + m2.length);
        }
      }
      function H2(m2) {
        var u2 = le(m2);
        return new Date(1e3 * u2.sec + u2.nsec / 1e6);
      }
      var I = { type: N2, encode: re2, decode: H2 }, K2 = function() {
        function m2() {
          this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(I);
        }
        return m2.prototype.register = function(u2) {
          var g = u2.type, A = u2.encode, w = u2.decode;
          if (g >= 0)
            this.encoders[g] = A, this.decoders[g] = w;
          else {
            var F2 = 1 + g;
            this.builtInEncoders[F2] = A, this.builtInDecoders[F2] = w;
          }
        }, m2.prototype.tryToEncode = function(u2, g) {
          for (var A = 0; A < this.builtInEncoders.length; A++)
            if ((w = this.builtInEncoders[A]) != null && (F2 = w(u2, g)) != null)
              return new ie(-1 - A, F2);
          for (A = 0; A < this.encoders.length; A++) {
            var w, F2;
            if ((w = this.encoders[A]) != null && (F2 = w(u2, g)) != null)
              return new ie(A, F2);
          }
          return u2 instanceof ie ? u2 : null;
        }, m2.prototype.decode = function(u2, g, A) {
          var w = g < 0 ? this.builtInDecoders[-1 - g] : this.decoders[g];
          return w ? w(u2, g, A) : new ie(g, u2);
        }, m2.defaultCodec = new m2(), m2;
      }();
      function P2(m2) {
        return m2 instanceof Uint8Array ? m2 : ArrayBuffer.isView(m2) ? new Uint8Array(m2.buffer, m2.byteOffset, m2.byteLength) : m2 instanceof ArrayBuffer ? new Uint8Array(m2) : Uint8Array.from(m2);
      }
      var k2 = function(m2) {
        var u2 = typeof Symbol == "function" && Symbol.iterator, g = u2 && m2[u2], A = 0;
        if (g)
          return g.call(m2);
        if (m2 && typeof m2.length == "number")
          return { next: function() {
            return m2 && A >= m2.length && (m2 = void 0), { value: m2 && m2[A++], done: !m2 };
          } };
        throw new TypeError(u2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, te2 = function() {
        function m2(u2, g, A, w, F2, O2, X, ce) {
          u2 === void 0 && (u2 = K2.defaultCodec), g === void 0 && (g = void 0), A === void 0 && (A = 100), w === void 0 && (w = 2048), F2 === void 0 && (F2 = false), O2 === void 0 && (O2 = false), X === void 0 && (X = false), ce === void 0 && (ce = false), this.extensionCodec = u2, this.context = g, this.maxDepth = A, this.initialBufferSize = w, this.sortKeys = F2, this.forceFloat32 = O2, this.ignoreUndefined = X, this.forceIntegerToFloat = ce, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
        }
        return m2.prototype.getUint8Array = function() {
          return this.bytes.subarray(0, this.pos);
        }, m2.prototype.reinitializeState = function() {
          this.pos = 0;
        }, m2.prototype.encode = function(u2) {
          return this.reinitializeState(), this.doEncode(u2, 1), this.getUint8Array();
        }, m2.prototype.doEncode = function(u2, g) {
          if (g > this.maxDepth)
            throw new Error("Too deep objects in depth " + g);
          u2 == null ? this.encodeNil() : typeof u2 == "boolean" ? this.encodeBoolean(u2) : typeof u2 == "number" ? this.encodeNumber(u2) : typeof u2 == "string" ? this.encodeString(u2) : typeof u2 == "bigint" ? this.encodebigint(u2) : this.encodeObject(u2, g);
        }, m2.prototype.ensureBufferSizeToWrite = function(u2) {
          var g = this.pos + u2;
          this.view.byteLength < g && this.resizeBuffer(2 * g);
        }, m2.prototype.resizeBuffer = function(u2) {
          var g = new ArrayBuffer(u2), A = new Uint8Array(g), w = new DataView(g);
          A.set(this.bytes), this.view = w, this.bytes = A;
        }, m2.prototype.encodeNil = function() {
          this.writeU8(192);
        }, m2.prototype.encodeBoolean = function(u2) {
          u2 === false ? this.writeU8(194) : this.writeU8(195);
        }, m2.prototype.encodeNumber = function(u2) {
          Number.isSafeInteger(u2) && !this.forceIntegerToFloat ? u2 >= 0 ? u2 < 128 ? this.writeU8(u2) : u2 < 256 ? (this.writeU8(204), this.writeU8(u2)) : u2 < 65536 ? (this.writeU8(205), this.writeU16(u2)) : u2 < 4294967296 ? (this.writeU8(206), this.writeU32(u2)) : (this.writeU8(207), this.writeU64(u2)) : u2 >= -32 ? this.writeU8(224 | u2 + 32) : u2 >= -128 ? (this.writeU8(208), this.writeI8(u2)) : u2 >= -32768 ? (this.writeU8(209), this.writeI16(u2)) : u2 >= -2147483648 ? (this.writeU8(210), this.writeI32(u2)) : (this.writeU8(211), this.writeI64(u2)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(u2)) : (this.writeU8(203), this.writeF64(u2));
        }, m2.prototype.encodebigint = function(u2) {
          u2 >= BigInt(0) ? u2 < BigInt(128) ? this.writeU8(Number(u2)) : u2 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(u2))) : u2 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(u2))) : u2 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(u2))) : (this.writeU8(207), this.writeBig64(u2)) : u2 >= BigInt(-32) ? this.writeU8(224 | Number(u2) + 32) : u2 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(u2))) : u2 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(u2))) : u2 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(u2))) : (this.writeU8(211), this.writeBig64(u2));
        }, m2.prototype.writeStringHeader = function(u2) {
          if (u2 < 32)
            this.writeU8(160 + u2);
          else if (u2 < 256)
            this.writeU8(217), this.writeU8(u2);
          else if (u2 < 65536)
            this.writeU8(218), this.writeU16(u2);
          else {
            if (!(u2 < 4294967296))
              throw new Error("Too long string: " + u2 + " bytes in UTF-8");
            this.writeU8(219), this.writeU32(u2);
          }
        }, m2.prototype.encodeString = function(u2) {
          var g = u2.length;
          if (s && g > l2) {
            var A = o(u2);
            this.ensureBufferSizeToWrite(5 + A), this.writeStringHeader(A), f2(u2, this.bytes, this.pos), this.pos += A;
          } else
            A = o(u2), this.ensureBufferSizeToWrite(5 + A), this.writeStringHeader(A), function(w, F2, O2) {
              for (var X = w.length, ce = O2, he = 0; he < X; ) {
                var C2 = w.charCodeAt(he++);
                if (4294967168 & C2) {
                  if (!(4294965248 & C2))
                    F2[ce++] = C2 >> 6 & 31 | 192;
                  else {
                    if (C2 >= 55296 && C2 <= 56319 && he < X) {
                      var Ee2 = w.charCodeAt(he);
                      (64512 & Ee2) == 56320 && (++he, C2 = ((1023 & C2) << 10) + (1023 & Ee2) + 65536);
                    }
                    4294901760 & C2 ? (F2[ce++] = C2 >> 18 & 7 | 240, F2[ce++] = C2 >> 12 & 63 | 128, F2[ce++] = C2 >> 6 & 63 | 128) : (F2[ce++] = C2 >> 12 & 15 | 224, F2[ce++] = C2 >> 6 & 63 | 128);
                  }
                  F2[ce++] = 63 & C2 | 128;
                } else
                  F2[ce++] = C2;
              }
            }(u2, this.bytes, this.pos), this.pos += A;
        }, m2.prototype.encodeObject = function(u2, g) {
          var A = this.extensionCodec.tryToEncode(u2, this.context);
          if (A != null)
            this.encodeExtension(A);
          else if (Array.isArray(u2))
            this.encodeArray(u2, g);
          else if (ArrayBuffer.isView(u2))
            this.encodeBinary(u2);
          else {
            if (typeof u2 != "object")
              throw new Error("Unrecognized object: " + Object.prototype.toString.apply(u2));
            this.encodeMap(u2, g);
          }
        }, m2.prototype.encodeBinary = function(u2) {
          var g = u2.byteLength;
          if (g < 256)
            this.writeU8(196), this.writeU8(g);
          else if (g < 65536)
            this.writeU8(197), this.writeU16(g);
          else {
            if (!(g < 4294967296))
              throw new Error("Too large binary: " + g);
            this.writeU8(198), this.writeU32(g);
          }
          var A = P2(u2);
          this.writeU8a(A);
        }, m2.prototype.encodeArray = function(u2, g) {
          var A, w, F2 = u2.length;
          if (F2 < 16)
            this.writeU8(144 + F2);
          else if (F2 < 65536)
            this.writeU8(220), this.writeU16(F2);
          else {
            if (!(F2 < 4294967296))
              throw new Error("Too large array: " + F2);
            this.writeU8(221), this.writeU32(F2);
          }
          try {
            for (var O2 = k2(u2), X = O2.next(); !X.done; X = O2.next()) {
              var ce = X.value;
              this.doEncode(ce, g + 1);
            }
          } catch (he) {
            A = { error: he };
          } finally {
            try {
              X && !X.done && (w = O2.return) && w.call(O2);
            } finally {
              if (A)
                throw A.error;
            }
          }
        }, m2.prototype.countWithoutUndefined = function(u2, g) {
          var A, w, F2 = 0;
          try {
            for (var O2 = k2(g), X = O2.next(); !X.done; X = O2.next())
              u2[X.value] !== void 0 && F2++;
          } catch (ce) {
            A = { error: ce };
          } finally {
            try {
              X && !X.done && (w = O2.return) && w.call(O2);
            } finally {
              if (A)
                throw A.error;
            }
          }
          return F2;
        }, m2.prototype.encodeMap = function(u2, g) {
          var A, w, F2 = Object.keys(u2);
          this.sortKeys && F2.sort();
          var O2 = this.ignoreUndefined ? this.countWithoutUndefined(u2, F2) : F2.length;
          if (O2 < 16)
            this.writeU8(128 + O2);
          else if (O2 < 65536)
            this.writeU8(222), this.writeU16(O2);
          else {
            if (!(O2 < 4294967296))
              throw new Error("Too large map object: " + O2);
            this.writeU8(223), this.writeU32(O2);
          }
          try {
            for (var X = k2(F2), ce = X.next(); !ce.done; ce = X.next()) {
              var he = ce.value, C2 = u2[he];
              this.ignoreUndefined && C2 === void 0 || (this.encodeString(he), this.doEncode(C2, g + 1));
            }
          } catch (Ee2) {
            A = { error: Ee2 };
          } finally {
            try {
              ce && !ce.done && (w = X.return) && w.call(X);
            } finally {
              if (A)
                throw A.error;
            }
          }
        }, m2.prototype.encodeExtension = function(u2) {
          var g = u2.data.length;
          if (g === 1)
            this.writeU8(212);
          else if (g === 2)
            this.writeU8(213);
          else if (g === 4)
            this.writeU8(214);
          else if (g === 8)
            this.writeU8(215);
          else if (g === 16)
            this.writeU8(216);
          else if (g < 256)
            this.writeU8(199), this.writeU8(g);
          else if (g < 65536)
            this.writeU8(200), this.writeU16(g);
          else {
            if (!(g < 4294967296))
              throw new Error("Too large extension object: " + g);
            this.writeU8(201), this.writeU32(g);
          }
          this.writeI8(u2.type), this.writeU8a(u2.data);
        }, m2.prototype.writeU8 = function(u2) {
          this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, u2), this.pos++;
        }, m2.prototype.writeU8a = function(u2) {
          var g = u2.length;
          this.ensureBufferSizeToWrite(g), this.bytes.set(u2, this.pos), this.pos += g;
        }, m2.prototype.writeI8 = function(u2) {
          this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, u2), this.pos++;
        }, m2.prototype.writeU16 = function(u2) {
          this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, u2), this.pos += 2;
        }, m2.prototype.writeI16 = function(u2) {
          this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, u2), this.pos += 2;
        }, m2.prototype.writeU32 = function(u2) {
          this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, u2), this.pos += 4;
        }, m2.prototype.writeI32 = function(u2) {
          this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, u2), this.pos += 4;
        }, m2.prototype.writeF32 = function(u2) {
          this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, u2), this.pos += 4;
        }, m2.prototype.writeF64 = function(u2) {
          this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, u2), this.pos += 8;
        }, m2.prototype.writeU64 = function(u2) {
          this.ensureBufferSizeToWrite(8), function(g, A, w) {
            var F2 = w / 4294967296, O2 = w;
            g.setUint32(A, F2), g.setUint32(A + 4, O2);
          }(this.view, this.pos, u2), this.pos += 8;
        }, m2.prototype.writeI64 = function(u2) {
          this.ensureBufferSizeToWrite(8), G(this.view, this.pos, u2), this.pos += 8;
        }, m2.prototype.writeBig64 = function(u2) {
          this.ensureBufferSizeToWrite(8), function(g, A, w) {
            var F2 = Number(w / BigInt(4294967296)), O2 = Number(w % BigInt(4294967296));
            F2 < 0 && O2 !== 0 && (F2 -= 1), g.setUint32(A, F2), g.setUint32(A + 4, O2);
          }(this.view, this.pos, u2), this.pos += 8;
        }, m2;
      }(), T = {};
      function D2(m2, u2) {
        return u2 === void 0 && (u2 = T), new te2(u2.extensionCodec, u2.context, u2.maxDepth, u2.initialBufferSize, u2.sortKeys, u2.forceFloat32, u2.ignoreUndefined, u2.forceIntegerToFloat).encode(m2);
      }
      function V2(m2) {
        return (m2 < 0 ? "-" : "") + "0x" + Math.abs(m2).toString(16).padStart(2, "0");
      }
      var pe = function() {
        function m2(u2, g) {
          u2 === void 0 && (u2 = 16), g === void 0 && (g = 16), this.maxKeyLength = u2, this.maxLengthPerKey = g, this.hit = 0, this.miss = 0, this.caches = [];
          for (var A = 0; A < this.maxKeyLength; A++)
            this.caches.push([]);
        }
        return m2.prototype.canBeCached = function(u2) {
          return u2 > 0 && u2 <= this.maxKeyLength;
        }, m2.prototype.get = function(u2, g, A) {
          var w = this.caches[A - 1], F2 = w.length;
          e:
            for (var O2 = 0; O2 < F2; O2++) {
              for (var X = w[O2], ce = X.bytes, he = 0; he < A; he++)
                if (ce[he] !== u2[g + he])
                  continue e;
              return X.value;
            }
          return null;
        }, m2.prototype.store = function(u2, g) {
          var A = this.caches[u2.length - 1], w = { bytes: u2, value: g };
          A.length >= this.maxLengthPerKey ? A[Math.random() * A.length | 0] = w : A.push(w);
        }, m2.prototype.decode = function(u2, g, A) {
          var w = this.get(u2, g, A);
          if (w != null)
            return this.hit++, w;
          this.miss++;
          var F2 = h2(u2, g, A), O2 = Uint8Array.prototype.slice.call(u2, g, g + A);
          return this.store(O2, F2), F2;
        }, m2;
      }(), we = function(m2, u2, g, A) {
        return new (g || (g = Promise))(function(w, F2) {
          function O2(he) {
            try {
              ce(A.next(he));
            } catch (C2) {
              F2(C2);
            }
          }
          function X(he) {
            try {
              ce(A.throw(he));
            } catch (C2) {
              F2(C2);
            }
          }
          function ce(he) {
            var C2;
            he.done ? w(he.value) : (C2 = he.value, C2 instanceof g ? C2 : new g(function(Ee2) {
              Ee2(C2);
            })).then(O2, X);
          }
          ce((A = A.apply(m2, u2 || [])).next());
        });
      }, ve = function(m2, u2) {
        var g, A, w, F2, O2 = { label: 0, sent: function() {
          if (1 & w[0])
            throw w[1];
          return w[1];
        }, trys: [], ops: [] };
        return F2 = { next: X(0), throw: X(1), return: X(2) }, typeof Symbol == "function" && (F2[Symbol.iterator] = function() {
          return this;
        }), F2;
        function X(ce) {
          return function(he) {
            return function(C2) {
              if (g)
                throw new TypeError("Generator is already executing.");
              for (; O2; )
                try {
                  if (g = 1, A && (w = 2 & C2[0] ? A.return : C2[0] ? A.throw || ((w = A.return) && w.call(A), 0) : A.next) && !(w = w.call(A, C2[1])).done)
                    return w;
                  switch (A = 0, w && (C2 = [2 & C2[0], w.value]), C2[0]) {
                    case 0:
                    case 1:
                      w = C2;
                      break;
                    case 4:
                      return O2.label++, { value: C2[1], done: false };
                    case 5:
                      O2.label++, A = C2[1], C2 = [0];
                      continue;
                    case 7:
                      C2 = O2.ops.pop(), O2.trys.pop();
                      continue;
                    default:
                      if (w = O2.trys, !((w = w.length > 0 && w[w.length - 1]) || C2[0] !== 6 && C2[0] !== 2)) {
                        O2 = 0;
                        continue;
                      }
                      if (C2[0] === 3 && (!w || C2[1] > w[0] && C2[1] < w[3])) {
                        O2.label = C2[1];
                        break;
                      }
                      if (C2[0] === 6 && O2.label < w[1]) {
                        O2.label = w[1], w = C2;
                        break;
                      }
                      if (w && O2.label < w[2]) {
                        O2.label = w[2], O2.ops.push(C2);
                        break;
                      }
                      w[2] && O2.ops.pop(), O2.trys.pop();
                      continue;
                  }
                  C2 = u2.call(m2, O2);
                } catch (Ee2) {
                  C2 = [6, Ee2], A = 0;
                } finally {
                  g = w = 0;
                }
              if (5 & C2[0])
                throw C2[1];
              return { value: C2[0] ? C2[1] : void 0, done: true };
            }([ce, he]);
          };
        }
      }, qe = function(m2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var u2, g = m2[Symbol.asyncIterator];
        return g ? g.call(m2) : (m2 = typeof __values == "function" ? __values(m2) : m2[Symbol.iterator](), u2 = {}, A("next"), A("throw"), A("return"), u2[Symbol.asyncIterator] = function() {
          return this;
        }, u2);
        function A(w) {
          u2[w] = m2[w] && function(F2) {
            return new Promise(function(O2, X) {
              (function(ce, he, C2, Ee2) {
                Promise.resolve(Ee2).then(function(Ce) {
                  ce({ value: Ce, done: C2 });
                }, he);
              })(O2, X, (F2 = m2[w](F2)).done, F2.value);
            });
          };
        }
      }, Ve = function(m2) {
        return this instanceof Ve ? (this.v = m2, this) : new Ve(m2);
      }, Te = function(m2, u2, g) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var A, w = g.apply(m2, u2 || []), F2 = [];
        return A = {}, O2("next"), O2("throw"), O2("return"), A[Symbol.asyncIterator] = function() {
          return this;
        }, A;
        function O2(Ee2) {
          w[Ee2] && (A[Ee2] = function(Ce) {
            return new Promise(function(it, Pe) {
              F2.push([Ee2, Ce, it, Pe]) > 1 || X(Ee2, Ce);
            });
          });
        }
        function X(Ee2, Ce) {
          try {
            (it = w[Ee2](Ce)).value instanceof Ve ? Promise.resolve(it.value.v).then(ce, he) : C2(F2[0][2], it);
          } catch (Pe) {
            C2(F2[0][3], Pe);
          }
          var it;
        }
        function ce(Ee2) {
          X("next", Ee2);
        }
        function he(Ee2) {
          X("throw", Ee2);
        }
        function C2(Ee2, Ce) {
          Ee2(Ce), F2.shift(), F2.length && X(F2[0][0], F2[0][1]);
        }
      }, ze = new DataView(new ArrayBuffer(0)), Je = new Uint8Array(ze.buffer), Be = function() {
        try {
          ze.getInt8(0);
        } catch (m2) {
          return m2.constructor;
        }
        throw new Error("never reached");
      }(), W2 = new Be("Insufficient data"), Se = new pe(), ct = function() {
        function m2(u2, g, A, w, F2, O2, X, ce) {
          u2 === void 0 && (u2 = K2.defaultCodec), g === void 0 && (g = void 0), A === void 0 && (A = 4294967295), w === void 0 && (w = 4294967295), F2 === void 0 && (F2 = 4294967295), O2 === void 0 && (O2 = 4294967295), X === void 0 && (X = 4294967295), ce === void 0 && (ce = Se), this.extensionCodec = u2, this.context = g, this.maxStrLength = A, this.maxBinLength = w, this.maxArrayLength = F2, this.maxMapLength = O2, this.maxExtLength = X, this.keyDecoder = ce, this.totalPos = 0, this.pos = 0, this.view = ze, this.bytes = Je, this.headByte = -1, this.stack = [];
        }
        return m2.prototype.reinitializeState = function() {
          this.totalPos = 0, this.headByte = -1;
        }, m2.prototype.setBuffer = function(u2) {
          this.bytes = P2(u2), this.view = function(g) {
            if (g instanceof ArrayBuffer)
              return new DataView(g);
            var A = P2(g);
            return new DataView(A.buffer, A.byteOffset, A.byteLength);
          }(this.bytes), this.pos = 0;
        }, m2.prototype.appendBuffer = function(u2) {
          if (this.headByte !== -1 || this.hasRemaining()) {
            var g = this.bytes.subarray(this.pos), A = P2(u2), w = new Uint8Array(g.length + A.length);
            w.set(g), w.set(A, g.length), this.setBuffer(w);
          } else
            this.setBuffer(u2);
        }, m2.prototype.hasRemaining = function(u2) {
          return u2 === void 0 && (u2 = 1), this.view.byteLength - this.pos >= u2;
        }, m2.prototype.createNoExtraBytesError = function(u2) {
          var g = this.view, A = this.pos;
          return new RangeError("Extra " + (g.byteLength - A) + " of " + g.byteLength + " byte(s) found at buffer[" + u2 + "]");
        }, m2.prototype.decode = function(u2) {
          return this.reinitializeState(), this.setBuffer(u2), this.doDecodeSingleSync();
        }, m2.prototype.doDecodeSingleSync = function() {
          var u2 = this.doDecodeSync();
          if (this.hasRemaining())
            throw this.createNoExtraBytesError(this.pos);
          return u2;
        }, m2.prototype.decodeAsync = function(u2) {
          var g, A, w, F2;
          return we(this, void 0, void 0, function() {
            var O2, X, ce, he, C2, Ee2, Ce, it;
            return ve(this, function(Pe) {
              switch (Pe.label) {
                case 0:
                  O2 = false, Pe.label = 1;
                case 1:
                  Pe.trys.push([1, 6, 7, 12]), g = qe(u2), Pe.label = 2;
                case 2:
                  return [4, g.next()];
                case 3:
                  if ((A = Pe.sent()).done)
                    return [3, 5];
                  if (ce = A.value, O2)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(ce);
                  try {
                    X = this.doDecodeSync(), O2 = true;
                  } catch (_t) {
                    if (!(_t instanceof Be))
                      throw _t;
                  }
                  this.totalPos += this.pos, Pe.label = 4;
                case 4:
                  return [3, 2];
                case 5:
                  return [3, 12];
                case 6:
                  return he = Pe.sent(), w = { error: he }, [3, 12];
                case 7:
                  return Pe.trys.push([7, , 10, 11]), A && !A.done && (F2 = g.return) ? [4, F2.call(g)] : [3, 9];
                case 8:
                  Pe.sent(), Pe.label = 9;
                case 9:
                  return [3, 11];
                case 10:
                  if (w)
                    throw w.error;
                  return [7];
                case 11:
                  return [7];
                case 12:
                  if (O2) {
                    if (this.hasRemaining())
                      throw this.createNoExtraBytesError(this.totalPos);
                    return [2, X];
                  }
                  throw Ee2 = (C2 = this).headByte, Ce = C2.pos, it = C2.totalPos, new RangeError("Insufficient data in parcing " + V2(Ee2) + " at " + it + " (" + Ce + " in the current buffer)");
              }
            });
          });
        }, m2.prototype.decodeArrayStream = function(u2) {
          return this.decodeMultiAsync(u2, true);
        }, m2.prototype.decodeStream = function(u2) {
          return this.decodeMultiAsync(u2, false);
        }, m2.prototype.decodeMultiAsync = function(u2, g) {
          return Te(this, arguments, function() {
            var A, w, F2, O2, X, ce, he, C2, Ee2;
            return ve(this, function(Ce) {
              switch (Ce.label) {
                case 0:
                  A = g, w = -1, Ce.label = 1;
                case 1:
                  Ce.trys.push([1, 13, 14, 19]), F2 = qe(u2), Ce.label = 2;
                case 2:
                  return [4, Ve(F2.next())];
                case 3:
                  if ((O2 = Ce.sent()).done)
                    return [3, 12];
                  if (X = O2.value, g && w === 0)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(X), A && (w = this.readArraySize(), A = false, this.complete()), Ce.label = 4;
                case 4:
                  Ce.trys.push([4, 9, , 10]), Ce.label = 5;
                case 5:
                  return [4, Ve(this.doDecodeSync())];
                case 6:
                  return [4, Ce.sent()];
                case 7:
                  return Ce.sent(), --w == 0 ? [3, 8] : [3, 5];
                case 8:
                  return [3, 10];
                case 9:
                  if (!((ce = Ce.sent()) instanceof Be))
                    throw ce;
                  return [3, 10];
                case 10:
                  this.totalPos += this.pos, Ce.label = 11;
                case 11:
                  return [3, 2];
                case 12:
                  return [3, 19];
                case 13:
                  return he = Ce.sent(), C2 = { error: he }, [3, 19];
                case 14:
                  return Ce.trys.push([14, , 17, 18]), O2 && !O2.done && (Ee2 = F2.return) ? [4, Ve(Ee2.call(F2))] : [3, 16];
                case 15:
                  Ce.sent(), Ce.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  if (C2)
                    throw C2.error;
                  return [7];
                case 18:
                  return [7];
                case 19:
                  return [2];
              }
            });
          });
        }, m2.prototype.doDecodeSync = function() {
          e:
            for (; ; ) {
              var u2 = this.readHeadByte(), g = void 0;
              if (u2 >= 224)
                g = u2 - 256;
              else if (u2 < 192)
                if (u2 < 128)
                  g = u2;
                else if (u2 < 144) {
                  if ((w = u2 - 128) !== 0) {
                    this.pushMapState(w), this.complete();
                    continue e;
                  }
                  g = {};
                } else if (u2 < 160) {
                  if ((w = u2 - 144) !== 0) {
                    this.pushArrayState(w), this.complete();
                    continue e;
                  }
                  g = [];
                } else {
                  var A = u2 - 160;
                  g = this.decodeUtf8String(A, 0);
                }
              else if (u2 === 192)
                g = null;
              else if (u2 === 194)
                g = false;
              else if (u2 === 195)
                g = true;
              else if (u2 === 202)
                g = this.readF32();
              else if (u2 === 203)
                g = this.readF64();
              else if (u2 === 204)
                g = this.readU8();
              else if (u2 === 205)
                g = this.readU16();
              else if (u2 === 206)
                g = this.readU32();
              else if (u2 === 207)
                g = this.readU64();
              else if (u2 === 208)
                g = this.readI8();
              else if (u2 === 209)
                g = this.readI16();
              else if (u2 === 210)
                g = this.readI32();
              else if (u2 === 211)
                g = this.readI64();
              else if (u2 === 217)
                A = this.lookU8(), g = this.decodeUtf8String(A, 1);
              else if (u2 === 218)
                A = this.lookU16(), g = this.decodeUtf8String(A, 2);
              else if (u2 === 219)
                A = this.lookU32(), g = this.decodeUtf8String(A, 4);
              else if (u2 === 220) {
                if ((w = this.readU16()) !== 0) {
                  this.pushArrayState(w), this.complete();
                  continue e;
                }
                g = [];
              } else if (u2 === 221) {
                if ((w = this.readU32()) !== 0) {
                  this.pushArrayState(w), this.complete();
                  continue e;
                }
                g = [];
              } else if (u2 === 222) {
                if ((w = this.readU16()) !== 0) {
                  this.pushMapState(w), this.complete();
                  continue e;
                }
                g = {};
              } else if (u2 === 223) {
                if ((w = this.readU32()) !== 0) {
                  this.pushMapState(w), this.complete();
                  continue e;
                }
                g = {};
              } else if (u2 === 196) {
                var w = this.lookU8();
                g = this.decodeBinary(w, 1);
              } else if (u2 === 197)
                w = this.lookU16(), g = this.decodeBinary(w, 2);
              else if (u2 === 198)
                w = this.lookU32(), g = this.decodeBinary(w, 4);
              else if (u2 === 212)
                g = this.decodeExtension(1, 0);
              else if (u2 === 213)
                g = this.decodeExtension(2, 0);
              else if (u2 === 214)
                g = this.decodeExtension(4, 0);
              else if (u2 === 215)
                g = this.decodeExtension(8, 0);
              else if (u2 === 216)
                g = this.decodeExtension(16, 0);
              else if (u2 === 199)
                w = this.lookU8(), g = this.decodeExtension(w, 1);
              else if (u2 === 200)
                w = this.lookU16(), g = this.decodeExtension(w, 2);
              else {
                if (u2 !== 201)
                  throw new Error("Unrecognized type byte: " + V2(u2));
                w = this.lookU32(), g = this.decodeExtension(w, 4);
              }
              this.complete();
              for (var F2 = this.stack; F2.length > 0; ) {
                var O2 = F2[F2.length - 1];
                if (O2.type === 0) {
                  if (O2.array[O2.position] = g, O2.position++, O2.position !== O2.size)
                    continue e;
                  F2.pop(), g = O2.array;
                } else {
                  if (O2.type === 1) {
                    if (X = void 0, (X = typeof g) != "string" && X !== "number")
                      throw new Error("The type of key must be string or number but " + typeof g);
                    O2.key = g, O2.type = 2;
                    continue e;
                  }
                  if (O2.map[O2.key] = g, O2.readCount++, O2.readCount !== O2.size) {
                    O2.key = null, O2.type = 1;
                    continue e;
                  }
                  F2.pop(), g = O2.map;
                }
              }
              return g;
            }
          var X;
        }, m2.prototype.readHeadByte = function() {
          return this.headByte === -1 && (this.headByte = this.readU8()), this.headByte;
        }, m2.prototype.complete = function() {
          this.headByte = -1;
        }, m2.prototype.readArraySize = function() {
          var u2 = this.readHeadByte();
          switch (u2) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default:
              if (u2 < 160)
                return u2 - 144;
              throw new Error("Unrecognized array type byte: " + V2(u2));
          }
        }, m2.prototype.pushMapState = function(u2) {
          if (u2 > this.maxMapLength)
            throw new Error("Max length exceeded: map length (" + u2 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
          this.stack.push({ type: 1, size: u2, key: null, readCount: 0, map: {} });
        }, m2.prototype.pushArrayState = function(u2) {
          if (u2 > this.maxArrayLength)
            throw new Error("Max length exceeded: array length (" + u2 + ") > maxArrayLength (" + this.maxArrayLength + ")");
          this.stack.push({ type: 0, size: u2, array: new Array(u2), position: 0 });
        }, m2.prototype.decodeUtf8String = function(u2, g) {
          var A;
          if (u2 > this.maxStrLength)
            throw new Error("Max length exceeded: UTF-8 byte length (" + u2 + ") > maxStrLength (" + this.maxStrLength + ")");
          if (this.bytes.byteLength < this.pos + g + u2)
            throw W2;
          var w, F2 = this.pos + g;
          return w = this.stateIsMapKey() && (!((A = this.keyDecoder) === null || A === void 0) && A.canBeCached(u2)) ? this.keyDecoder.decode(this.bytes, F2, u2) : s && u2 > j2 ? function(O2, X, ce) {
            var he = O2.subarray(X, X + ce);
            return _.decode(he);
          }(this.bytes, F2, u2) : h2(this.bytes, F2, u2), this.pos += g + u2, w;
        }, m2.prototype.stateIsMapKey = function() {
          return this.stack.length > 0 && this.stack[this.stack.length - 1].type === 1;
        }, m2.prototype.decodeBinary = function(u2, g) {
          if (u2 > this.maxBinLength)
            throw new Error("Max length exceeded: bin length (" + u2 + ") > maxBinLength (" + this.maxBinLength + ")");
          if (!this.hasRemaining(u2 + g))
            throw W2;
          var A = this.pos + g, w = this.bytes.subarray(A, A + u2);
          return this.pos += g + u2, w;
        }, m2.prototype.decodeExtension = function(u2, g) {
          if (u2 > this.maxExtLength)
            throw new Error("Max length exceeded: ext length (" + u2 + ") > maxExtLength (" + this.maxExtLength + ")");
          var A = this.view.getInt8(this.pos + g), w = this.decodeBinary(u2, g + 1);
          return this.extensionCodec.decode(w, A, this.context);
        }, m2.prototype.lookU8 = function() {
          return this.view.getUint8(this.pos);
        }, m2.prototype.lookU16 = function() {
          return this.view.getUint16(this.pos);
        }, m2.prototype.lookU32 = function() {
          return this.view.getUint32(this.pos);
        }, m2.prototype.readU8 = function() {
          var u2 = this.view.getUint8(this.pos);
          return this.pos++, u2;
        }, m2.prototype.readI8 = function() {
          var u2 = this.view.getInt8(this.pos);
          return this.pos++, u2;
        }, m2.prototype.readU16 = function() {
          var u2 = this.view.getUint16(this.pos);
          return this.pos += 2, u2;
        }, m2.prototype.readI16 = function() {
          var u2 = this.view.getInt16(this.pos);
          return this.pos += 2, u2;
        }, m2.prototype.readU32 = function() {
          var u2 = this.view.getUint32(this.pos);
          return this.pos += 4, u2;
        }, m2.prototype.readI32 = function() {
          var u2 = this.view.getInt32(this.pos);
          return this.pos += 4, u2;
        }, m2.prototype.readU64 = function() {
          var u2, g, A, w, F2 = (u2 = this.view, g = this.pos, A = u2.getUint32(g), w = u2.getUint32(g + 4), A > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(A) * BigInt(4294967296) + BigInt(w) : 4294967296 * A + w);
          return this.pos += 8, F2;
        }, m2.prototype.readI64 = function() {
          var u2 = Q(this.view, this.pos);
          return this.pos += 8, u2;
        }, m2.prototype.readF32 = function() {
          var u2 = this.view.getFloat32(this.pos);
          return this.pos += 4, u2;
        }, m2.prototype.readF64 = function() {
          var u2 = this.view.getFloat64(this.pos);
          return this.pos += 8, u2;
        }, m2;
      }(), Ot = {};
      function pt(m2, u2) {
        return u2 === void 0 && (u2 = Ot), new ct(u2.extensionCodec, u2.context, u2.maxStrLength, u2.maxBinLength, u2.maxArrayLength, u2.maxMapLength, u2.maxExtLength).decode(m2);
      }
      var me = function(m2, u2) {
        var g, A, w, F2, O2 = { label: 0, sent: function() {
          if (1 & w[0])
            throw w[1];
          return w[1];
        }, trys: [], ops: [] };
        return F2 = { next: X(0), throw: X(1), return: X(2) }, typeof Symbol == "function" && (F2[Symbol.iterator] = function() {
          return this;
        }), F2;
        function X(ce) {
          return function(he) {
            return function(C2) {
              if (g)
                throw new TypeError("Generator is already executing.");
              for (; O2; )
                try {
                  if (g = 1, A && (w = 2 & C2[0] ? A.return : C2[0] ? A.throw || ((w = A.return) && w.call(A), 0) : A.next) && !(w = w.call(A, C2[1])).done)
                    return w;
                  switch (A = 0, w && (C2 = [2 & C2[0], w.value]), C2[0]) {
                    case 0:
                    case 1:
                      w = C2;
                      break;
                    case 4:
                      return O2.label++, { value: C2[1], done: false };
                    case 5:
                      O2.label++, A = C2[1], C2 = [0];
                      continue;
                    case 7:
                      C2 = O2.ops.pop(), O2.trys.pop();
                      continue;
                    default:
                      if (w = O2.trys, !((w = w.length > 0 && w[w.length - 1]) || C2[0] !== 6 && C2[0] !== 2)) {
                        O2 = 0;
                        continue;
                      }
                      if (C2[0] === 3 && (!w || C2[1] > w[0] && C2[1] < w[3])) {
                        O2.label = C2[1];
                        break;
                      }
                      if (C2[0] === 6 && O2.label < w[1]) {
                        O2.label = w[1], w = C2;
                        break;
                      }
                      if (w && O2.label < w[2]) {
                        O2.label = w[2], O2.ops.push(C2);
                        break;
                      }
                      w[2] && O2.ops.pop(), O2.trys.pop();
                      continue;
                  }
                  C2 = u2.call(m2, O2);
                } catch (Ee2) {
                  C2 = [6, Ee2], A = 0;
                } finally {
                  g = w = 0;
                }
              if (5 & C2[0])
                throw C2[1];
              return { value: C2[0] ? C2[1] : void 0, done: true };
            }([ce, he]);
          };
        }
      }, p2 = function(m2) {
        return this instanceof p2 ? (this.v = m2, this) : new p2(m2);
      }, b2 = function(m2, u2, g) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var A, w = g.apply(m2, u2 || []), F2 = [];
        return A = {}, O2("next"), O2("throw"), O2("return"), A[Symbol.asyncIterator] = function() {
          return this;
        }, A;
        function O2(Ee2) {
          w[Ee2] && (A[Ee2] = function(Ce) {
            return new Promise(function(it, Pe) {
              F2.push([Ee2, Ce, it, Pe]) > 1 || X(Ee2, Ce);
            });
          });
        }
        function X(Ee2, Ce) {
          try {
            (it = w[Ee2](Ce)).value instanceof p2 ? Promise.resolve(it.value.v).then(ce, he) : C2(F2[0][2], it);
          } catch (Pe) {
            C2(F2[0][3], Pe);
          }
          var it;
        }
        function ce(Ee2) {
          X("next", Ee2);
        }
        function he(Ee2) {
          X("throw", Ee2);
        }
        function C2(Ee2, Ce) {
          Ee2(Ce), F2.shift(), F2.length && X(F2[0][0], F2[0][1]);
        }
      };
      function E2(m2) {
        if (m2 == null)
          throw new Error("Assertion Failure: value must not be null nor undefined");
      }
      function $(m2) {
        return m2[Symbol.asyncIterator] != null ? m2 : function(u2) {
          return b2(this, arguments, function() {
            var g, A, w, F2;
            return me(this, function(O2) {
              switch (O2.label) {
                case 0:
                  g = u2.getReader(), O2.label = 1;
                case 1:
                  O2.trys.push([1, , 9, 10]), O2.label = 2;
                case 2:
                  return [4, p2(g.read())];
                case 3:
                  return A = O2.sent(), w = A.done, F2 = A.value, w ? [4, p2(void 0)] : [3, 5];
                case 4:
                  return [2, O2.sent()];
                case 5:
                  return E2(F2), [4, p2(F2)];
                case 6:
                  return [4, O2.sent()];
                case 7:
                  return O2.sent(), [3, 2];
                case 8:
                  return [3, 10];
                case 9:
                  return g.releaseLock(), [7];
                case 10:
                  return [2];
              }
            });
          });
        }(m2);
      }
      var R2 = function(m2, u2, g, A) {
        return new (g || (g = Promise))(function(w, F2) {
          function O2(he) {
            try {
              ce(A.next(he));
            } catch (C2) {
              F2(C2);
            }
          }
          function X(he) {
            try {
              ce(A.throw(he));
            } catch (C2) {
              F2(C2);
            }
          }
          function ce(he) {
            var C2;
            he.done ? w(he.value) : (C2 = he.value, C2 instanceof g ? C2 : new g(function(Ee2) {
              Ee2(C2);
            })).then(O2, X);
          }
          ce((A = A.apply(m2, u2 || [])).next());
        });
      }, z2 = function(m2, u2) {
        var g, A, w, F2, O2 = { label: 0, sent: function() {
          if (1 & w[0])
            throw w[1];
          return w[1];
        }, trys: [], ops: [] };
        return F2 = { next: X(0), throw: X(1), return: X(2) }, typeof Symbol == "function" && (F2[Symbol.iterator] = function() {
          return this;
        }), F2;
        function X(ce) {
          return function(he) {
            return function(C2) {
              if (g)
                throw new TypeError("Generator is already executing.");
              for (; O2; )
                try {
                  if (g = 1, A && (w = 2 & C2[0] ? A.return : C2[0] ? A.throw || ((w = A.return) && w.call(A), 0) : A.next) && !(w = w.call(A, C2[1])).done)
                    return w;
                  switch (A = 0, w && (C2 = [2 & C2[0], w.value]), C2[0]) {
                    case 0:
                    case 1:
                      w = C2;
                      break;
                    case 4:
                      return O2.label++, { value: C2[1], done: false };
                    case 5:
                      O2.label++, A = C2[1], C2 = [0];
                      continue;
                    case 7:
                      C2 = O2.ops.pop(), O2.trys.pop();
                      continue;
                    default:
                      if (w = O2.trys, !((w = w.length > 0 && w[w.length - 1]) || C2[0] !== 6 && C2[0] !== 2)) {
                        O2 = 0;
                        continue;
                      }
                      if (C2[0] === 3 && (!w || C2[1] > w[0] && C2[1] < w[3])) {
                        O2.label = C2[1];
                        break;
                      }
                      if (C2[0] === 6 && O2.label < w[1]) {
                        O2.label = w[1], w = C2;
                        break;
                      }
                      if (w && O2.label < w[2]) {
                        O2.label = w[2], O2.ops.push(C2);
                        break;
                      }
                      w[2] && O2.ops.pop(), O2.trys.pop();
                      continue;
                  }
                  C2 = u2.call(m2, O2);
                } catch (Ee2) {
                  C2 = [6, Ee2], A = 0;
                } finally {
                  g = w = 0;
                }
              if (5 & C2[0])
                throw C2[1];
              return { value: C2[0] ? C2[1] : void 0, done: true };
            }([ce, he]);
          };
        }
      };
      function Y(m2, u2) {
        return u2 === void 0 && (u2 = Ot), R2(this, void 0, void 0, function() {
          var g;
          return z2(this, function(A) {
            return g = $(m2), [2, new ct(u2.extensionCodec, u2.context, u2.maxStrLength, u2.maxBinLength, u2.maxArrayLength, u2.maxMapLength, u2.maxExtLength).decodeAsync(g)];
          });
        });
      }
      function M(m2, u2) {
        u2 === void 0 && (u2 = Ot);
        var g = $(m2);
        return new ct(u2.extensionCodec, u2.context, u2.maxStrLength, u2.maxBinLength, u2.maxArrayLength, u2.maxMapLength, u2.maxExtLength).decodeArrayStream(g);
      }
      function B(m2, u2) {
        u2 === void 0 && (u2 = Ot);
        var g = $(m2);
        return new ct(u2.extensionCodec, u2.context, u2.maxStrLength, u2.maxBinLength, u2.maxArrayLength, u2.maxMapLength, u2.maxExtLength).decodeStream(g);
      }
    }]);
  });
});
var hd = dr((gn, dd) => {
  var Gc = typeof globalThis != "undefined" && globalThis || typeof self != "undefined" && self || typeof global != "undefined" && global, Wc = function() {
    function r() {
      this.fetch = false, this.DOMException = Gc.DOMException;
    }
    return r.prototype = Gc, new r();
  }();
  (function(r) {
    (function(t) {
      var n = typeof r != "undefined" && r || typeof self != "undefined" && self || typeof n != "undefined" && n, i = { searchParams: "URLSearchParams" in n, iterable: "Symbol" in n && "iterator" in Symbol, blob: "FileReader" in n && "Blob" in n && function() {
        try {
          return new Blob(), true;
        } catch (T) {
          return false;
        }
      }(), formData: "FormData" in n, arrayBuffer: "ArrayBuffer" in n };
      function s(T) {
        return T && DataView.prototype.isPrototypeOf(T);
      }
      if (i.arrayBuffer)
        var o = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], c = ArrayBuffer.isView || function(T) {
          return T && o.indexOf(Object.prototype.toString.call(T)) > -1;
        };
      function l2(T) {
        if (typeof T != "string" && (T = String(T)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(T) || T === "")
          throw new TypeError('Invalid character in header field name: "' + T + '"');
        return T.toLowerCase();
      }
      function f2(T) {
        return typeof T != "string" && (T = String(T)), T;
      }
      function h2(T) {
        var D2 = { next: function() {
          var V2 = T.shift();
          return { done: V2 === void 0, value: V2 };
        } };
        return i.iterable && (D2[Symbol.iterator] = function() {
          return D2;
        }), D2;
      }
      function _(T) {
        this.map = {}, T instanceof _ ? T.forEach(function(D2, V2) {
          this.append(V2, D2);
        }, this) : Array.isArray(T) ? T.forEach(function(D2) {
          this.append(D2[0], D2[1]);
        }, this) : T && Object.getOwnPropertyNames(T).forEach(function(D2) {
          this.append(D2, T[D2]);
        }, this);
      }
      _.prototype.append = function(T, D2) {
        T = l2(T), D2 = f2(D2);
        var V2 = this.map[T];
        this.map[T] = V2 ? V2 + ", " + D2 : D2;
      }, _.prototype.delete = function(T) {
        delete this.map[l2(T)];
      }, _.prototype.get = function(T) {
        return T = l2(T), this.has(T) ? this.map[T] : null;
      }, _.prototype.has = function(T) {
        return this.map.hasOwnProperty(l2(T));
      }, _.prototype.set = function(T, D2) {
        this.map[l2(T)] = f2(D2);
      }, _.prototype.forEach = function(T, D2) {
        for (var V2 in this.map)
          this.map.hasOwnProperty(V2) && T.call(D2, this.map[V2], V2, this);
      }, _.prototype.keys = function() {
        var T = [];
        return this.forEach(function(D2, V2) {
          T.push(V2);
        }), h2(T);
      }, _.prototype.values = function() {
        var T = [];
        return this.forEach(function(D2) {
          T.push(D2);
        }), h2(T);
      }, _.prototype.entries = function() {
        var T = [];
        return this.forEach(function(D2, V2) {
          T.push([V2, D2]);
        }), h2(T);
      }, i.iterable && (_.prototype[Symbol.iterator] = _.prototype.entries);
      function j2(T) {
        if (T.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        T.bodyUsed = true;
      }
      function ie(T) {
        return new Promise(function(D2, V2) {
          T.onload = function() {
            D2(T.result);
          }, T.onerror = function() {
            V2(T.error);
          };
        });
      }
      function G(T) {
        var D2 = new FileReader(), V2 = ie(D2);
        return D2.readAsArrayBuffer(T), V2;
      }
      function Q(T) {
        var D2 = new FileReader(), V2 = ie(D2);
        return D2.readAsText(T), V2;
      }
      function N2(T) {
        for (var D2 = new Uint8Array(T), V2 = new Array(D2.length), pe = 0; pe < D2.length; pe++)
          V2[pe] = String.fromCharCode(D2[pe]);
        return V2.join("");
      }
      function U(T) {
        if (T.slice)
          return T.slice(0);
        var D2 = new Uint8Array(T.byteLength);
        return D2.set(new Uint8Array(T)), D2.buffer;
      }
      function ee() {
        return this.bodyUsed = false, this._initBody = function(T) {
          this.bodyUsed = this.bodyUsed, this._bodyInit = T, T ? typeof T == "string" ? this._bodyText = T : i.blob && Blob.prototype.isPrototypeOf(T) ? this._bodyBlob = T : i.formData && FormData.prototype.isPrototypeOf(T) ? this._bodyFormData = T : i.searchParams && URLSearchParams.prototype.isPrototypeOf(T) ? this._bodyText = T.toString() : i.arrayBuffer && i.blob && s(T) ? (this._bodyArrayBuffer = U(T.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : i.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(T) || c(T)) ? this._bodyArrayBuffer = U(T) : this._bodyText = T = Object.prototype.toString.call(T) : this._bodyText = "", this.headers.get("content-type") || (typeof T == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : i.searchParams && URLSearchParams.prototype.isPrototypeOf(T) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, i.blob && (this.blob = function() {
          var T = j2(this);
          if (T)
            return T;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            var T = j2(this);
            return T || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer));
          } else
            return this.blob().then(G);
        }), this.text = function() {
          var T = j2(this);
          if (T)
            return T;
          if (this._bodyBlob)
            return Q(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(N2(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, i.formData && (this.formData = function() {
          return this.text().then(I);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var re2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function le(T) {
        var D2 = T.toUpperCase();
        return re2.indexOf(D2) > -1 ? D2 : T;
      }
      function H2(T, D2) {
        if (!(this instanceof H2))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        D2 = D2 || {};
        var V2 = D2.body;
        if (T instanceof H2) {
          if (T.bodyUsed)
            throw new TypeError("Already read");
          this.url = T.url, this.credentials = T.credentials, D2.headers || (this.headers = new _(T.headers)), this.method = T.method, this.mode = T.mode, this.signal = T.signal, !V2 && T._bodyInit != null && (V2 = T._bodyInit, T.bodyUsed = true);
        } else
          this.url = String(T);
        if (this.credentials = D2.credentials || this.credentials || "same-origin", (D2.headers || !this.headers) && (this.headers = new _(D2.headers)), this.method = le(D2.method || this.method || "GET"), this.mode = D2.mode || this.mode || null, this.signal = D2.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && V2)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(V2), (this.method === "GET" || this.method === "HEAD") && (D2.cache === "no-store" || D2.cache === "no-cache")) {
          var pe = /([?&])_=[^&]*/;
          if (pe.test(this.url))
            this.url = this.url.replace(pe, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
          else {
            var we = /\?/;
            this.url += (we.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
          }
        }
      }
      H2.prototype.clone = function() {
        return new H2(this, { body: this._bodyInit });
      };
      function I(T) {
        var D2 = new FormData();
        return T.trim().split("&").forEach(function(V2) {
          if (V2) {
            var pe = V2.split("="), we = pe.shift().replace(/\+/g, " "), ve = pe.join("=").replace(/\+/g, " ");
            D2.append(decodeURIComponent(we), decodeURIComponent(ve));
          }
        }), D2;
      }
      function K2(T) {
        var D2 = new _(), V2 = T.replace(/\r?\n[\t ]+/g, " ");
        return V2.split("\r").map(function(pe) {
          return pe.indexOf(`
`) === 0 ? pe.substr(1, pe.length) : pe;
        }).forEach(function(pe) {
          var we = pe.split(":"), ve = we.shift().trim();
          if (ve) {
            var qe = we.join(":").trim();
            D2.append(ve, qe);
          }
        }), D2;
      }
      ee.call(H2.prototype);
      function P2(T, D2) {
        if (!(this instanceof P2))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        D2 || (D2 = {}), this.type = "default", this.status = D2.status === void 0 ? 200 : D2.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = D2.statusText === void 0 ? "" : "" + D2.statusText, this.headers = new _(D2.headers), this.url = D2.url || "", this._initBody(T);
      }
      ee.call(P2.prototype), P2.prototype.clone = function() {
        return new P2(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new _(this.headers), url: this.url });
      }, P2.error = function() {
        var T = new P2(null, { status: 0, statusText: "" });
        return T.type = "error", T;
      };
      var k2 = [301, 302, 303, 307, 308];
      P2.redirect = function(T, D2) {
        if (k2.indexOf(D2) === -1)
          throw new RangeError("Invalid status code");
        return new P2(null, { status: D2, headers: { location: T } });
      }, t.DOMException = n.DOMException;
      try {
        new t.DOMException();
      } catch (T) {
        t.DOMException = function(D2, V2) {
          this.message = D2, this.name = V2;
          var pe = Error(D2);
          this.stack = pe.stack;
        }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException;
      }
      function te2(T, D2) {
        return new Promise(function(V2, pe) {
          var we = new H2(T, D2);
          if (we.signal && we.signal.aborted)
            return pe(new t.DOMException("Aborted", "AbortError"));
          var ve = new XMLHttpRequest();
          function qe() {
            ve.abort();
          }
          ve.onload = function() {
            var Te = { status: ve.status, statusText: ve.statusText, headers: K2(ve.getAllResponseHeaders() || "") };
            Te.url = "responseURL" in ve ? ve.responseURL : Te.headers.get("X-Request-URL");
            var ze = "response" in ve ? ve.response : ve.responseText;
            setTimeout(function() {
              V2(new P2(ze, Te));
            }, 0);
          }, ve.onerror = function() {
            setTimeout(function() {
              pe(new TypeError("Network request failed"));
            }, 0);
          }, ve.ontimeout = function() {
            setTimeout(function() {
              pe(new TypeError("Network request failed"));
            }, 0);
          }, ve.onabort = function() {
            setTimeout(function() {
              pe(new t.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function Ve(Te) {
            try {
              return Te === "" && n.location.href ? n.location.href : Te;
            } catch (ze) {
              return Te;
            }
          }
          ve.open(we.method, Ve(we.url), true), we.credentials === "include" ? ve.withCredentials = true : we.credentials === "omit" && (ve.withCredentials = false), "responseType" in ve && (i.blob ? ve.responseType = "blob" : i.arrayBuffer && we.headers.get("Content-Type") && we.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (ve.responseType = "arraybuffer")), D2 && typeof D2.headers == "object" && !(D2.headers instanceof _) ? Object.getOwnPropertyNames(D2.headers).forEach(function(Te) {
            ve.setRequestHeader(Te, f2(D2.headers[Te]));
          }) : we.headers.forEach(function(Te, ze) {
            ve.setRequestHeader(ze, Te);
          }), we.signal && (we.signal.addEventListener("abort", qe), ve.onreadystatechange = function() {
            ve.readyState === 4 && we.signal.removeEventListener("abort", qe);
          }), ve.send(typeof we._bodyInit == "undefined" ? null : we._bodyInit);
        });
      }
      return te2.polyfill = true, n.fetch || (n.fetch = te2, n.Headers = _, n.Request = H2, n.Response = P2), t.Headers = _, t.Request = H2, t.Response = P2, t.fetch = te2, t;
    })({});
  })(Wc);
  Wc.fetch.ponyfill = true;
  delete Wc.fetch.polyfill;
  var Ui = Gc.fetch ? Gc : Wc;
  gn = Ui.fetch;
  gn.default = Ui.fetch;
  gn.fetch = Ui.fetch;
  gn.Headers = Ui.Headers;
  gn.Request = Ui.Request;
  gn.Response = Ui.Response;
  dd.exports = gn;
});
var fr = lt(Tt(), 1);
var Rf = {};
Pu(Rf, { ABIAddressType: () => An, ABIArrayDynamicType: () => Us, ABIArrayStaticType: () => Ls, ABIBoolType: () => Sr, ABIByteType: () => js, ABIContract: () => Nf, ABIInterface: () => Of, ABIMethod: () => Ur, ABIReferenceType: () => Lr, ABIStringType: () => Bs, ABITransactionType: () => Fr, ABITupleType: () => hr, ABIType: () => Vt, ABIUfixedType: () => ks, ABIUintType: () => Br, ADDR_BYTE_SIZE: () => nh, ALGORAND_MIN_TX_FEE: () => cf, Algodv2: () => Qn, AtomicTransactionComposer: () => br, AtomicTransactionComposerStatus: () => nr, DryrunResult: () => Af, ERROR_INVALID_MICROALGOS: () => Wm, ERROR_MULTISIG_BAD_SENDER: () => Gm, INVALID_MICROALGOS_ERROR_MSG: () => ao, Indexer: () => fi, IntDecoding: () => ln, Kmd: () => ua, LENGTH_ENCODE_BYTE_SIZE: () => ir, LogicSig: () => Tr, LogicSigAccount: () => jr, MAX_LEN: () => hi, MULTISIG_BAD_SENDER_ERROR_MSG: () => ah, OnApplicationComplete: () => Ht, SINGLE_BOOL_SIZE: () => sh, SINGLE_BYTE_SIZE: () => ih, SourceMap: () => iu, Transaction: () => At, TransactionType: () => wt, abiCheckTransactionType: () => Ff, abiTypeIsReference: () => Za, abiTypeIsTransaction: () => Ps, algosToMicroalgos: () => ld, appendSignMultisigTransaction: () => jd, appendSignRawMultisigSignature: () => Bd, assignGroupID: () => tu, bigIntToBytes: () => rn, bytesToBigInt: () => Wa, computeGroupID: () => mf, createDryrun: () => bm, createMultisigTransaction: () => yf, decodeAddress: () => Ue, decodeObj: () => sr, decodeSignedTransaction: () => Yr, decodeUint64: () => ed, decodeUnsignedTransaction: () => Ln, encodeAddress: () => xe, encodeObj: () => Vm, encodeUint64: () => jn, encodeUnsignedSimulateTransaction: () => uf, encodeUnsignedTransaction: () => Jg, generateAccount: () => Ka, getApplicationAddress: () => Bn, getMethodByName: () => Xa, indexerModels: () => hf, instantiateTxnIfNeeded: () => yr, isTransactionWithSigner: () => du, isValidAddress: () => hn, logicSigFromByte: () => zd, makeApplicationCallTxnFromObject: () => Sf, makeApplicationClearStateTxn: () => th, makeApplicationClearStateTxnFromObject: () => Om, makeApplicationCloseOutTxn: () => eh, makeApplicationCloseOutTxnFromObject: () => Tf, makeApplicationCreateTxn: () => Ya, makeApplicationCreateTxnFromObject: () => Ef, makeApplicationDeleteTxn: () => fu, makeApplicationDeleteTxnFromObject: () => Nm, makeApplicationNoOpTxn: () => rh, makeApplicationNoOpTxnFromObject: () => lu, makeApplicationOptInTxn: () => Qd, makeApplicationOptInTxnFromObject: () => If, makeApplicationUpdateTxn: () => uu, makeApplicationUpdateTxnFromObject: () => Fm, makeAssetConfigTxnWithSuggestedParams: () => Jd, makeAssetConfigTxnWithSuggestedParamsFromObject: () => Im, makeAssetCreateTxnWithSuggestedParams: () => au, makeAssetCreateTxnWithSuggestedParamsFromObject: () => Em, makeAssetDestroyTxnWithSuggestedParams: () => cu, makeAssetDestroyTxnWithSuggestedParamsFromObject: () => Tm, makeAssetFreezeTxnWithSuggestedParams: () => Zd, makeAssetFreezeTxnWithSuggestedParamsFromObject: () => Sm, makeAssetTransferTxnWithSuggestedParams: () => Xd, makeAssetTransferTxnWithSuggestedParamsFromObject: () => Ha, makeBasicAccountTransactionSigner: () => Dm, makeEmptyTransactionSigner: () => Cm, makeKeyRegistrationTxnWithSuggestedParams: () => Yd, makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => Am, makeLogicSigAccountTransactionSigner: () => Mm, makeMultiSigAccountTransactionSigner: () => Rm, makePaymentTxnWithSuggestedParams: () => Hd, makePaymentTxnWithSuggestedParamsFromObject: () => ou, masterDerivationKeyToMnemonic: () => Dd, mergeMultisigTransactions: () => Ds, microalgosToAlgos: () => Vc, mnemonicFromSeed: () => Xc, mnemonicToMasterDerivationKey: () => Od, mnemonicToSecretKey: () => li, modelsv2: () => Yc, multisigAddress: () => Ld, secretKeyToMnemonic: () => eu, seedFromMnemonic: () => Qc, signBid: () => zm, signBytes: () => qm, signLogicSigTransaction: () => Pd, signLogicSigTransactionObject: () => di, signMultisigTransaction: () => nu, signTransaction: () => Pm, tealSign: () => xf, tealSignFromProgram: () => Vd, verifyBytes: () => $m, verifyMultisig: () => ru, verifyTealSign: () => $d, waitForConfirmation: () => Jc });
var hu = lt(Tt());
var Ir = lt(Bl()), Ul = lt(Ll());
function tr(r) {
  return Ul.default.sha512_256.array(r);
}
function Fg(r) {
  return Ir.default.randomBytes(r);
}
function Zu(r) {
  return Ir.default.sign.keyPair.fromSeed(r);
}
function Pl() {
  let r = Fg(Ir.default.box.secretKeyLength);
  return Zu(r);
}
function Cc(r) {
  return r === Ir.default.sign.signatureLength;
}
function Wr(r) {
  return Ir.default.sign.keyPair.fromSecretKey(r);
}
function Kr(r, e) {
  return Ir.default.sign.detached(r, e);
}
function kc(r, e) {
  return Ir.default.verify(r, e);
}
function Cn(r, e, t) {
  return Ir.default.sign.detached.verify(r, e, t);
}
var ro = Ir.default.sign.publicKeyLength;
Ir.default.sign.secretKeyLength;
var Xu = 32, jc = 32;
var rd = lt(Tt()), rf = lt(Qu());
var Zl = lt(Jl());
var tf;
(function(r) {
  r.DEFAULT = "default", r.SAFE = "safe", r.MIXED = "mixed", r.BIGINT = "bigint";
})(tf || (tf = {}));
var ln = tf;
var Mg = (0, Zl.default)({ useNativeBigInt: true, strict: true });
function Xl(r, e) {
  let t = e && e.intDecoding ? e.intDecoding : ln.DEFAULT;
  return Mg.parse(r, (n, i) => {
    if (i != null && typeof i == "object" && Object.getPrototypeOf(i) == null && Object.setPrototypeOf(i, Object.prototype), typeof i == "bigint") {
      if (t === "safe" && i > Number.MAX_SAFE_INTEGER)
        throw new Error(`Integer exceeds maximum safe integer: ${i.toString()}. Try parsing with a different intDecoding option.`);
      return t === "bigint" || t === "mixed" && i > Number.MAX_SAFE_INTEGER ? i : Number(i);
    }
    return typeof i == "number" && t === "bigint" && Number.isInteger(i) ? BigInt(i) : i;
  });
}
function kn(r, e) {
  return r.length !== e.length ? false : Array.from(r).every((t, n) => t === e[n]);
}
function Nt(...r) {
  let e = r.reduce((i, s) => i + s.length, 0), t = new Uint8Array(e), n = 0;
  for (let i = 0; i < r.length; i++)
    t.set(r[i], n), n += r[i].length;
  return t;
}
function Ql(r) {
  let e = at({}, r);
  return Object.keys(e).forEach((t) => {
    typeof e[t] == "undefined" && delete e[t];
  }), e;
}
function jn(r) {
  if (!(typeof r == "bigint" || Number.isInteger(r)) || r < 0 || r > BigInt("0xffffffffffffffff"))
    throw new Error("Input is not a 64-bit unsigned integer");
  let t = new Uint8Array(8);
  return new DataView(t.buffer).setBigUint64(0, BigInt(r)), t;
}
function ed(r, e = "safe") {
  if (e !== "safe" && e !== "mixed" && e !== "bigint")
    throw new Error(`Unknown decodingMode option: ${e}`);
  if (r.byteLength === 0 || r.byteLength > 8)
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${r.byteLength}`);
  let t = new Uint8Array(8 - r.byteLength), n = Nt(t, r), s = new DataView(n.buffer).getBigUint64(0), o = s > BigInt(Number.MAX_SAFE_INTEGER);
  if (e === "safe") {
    if (o)
      throw new Error(`Integer exceeds maximum safe integer: ${s.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    return Number(s);
  }
  return e === "mixed" && !o ? Number(s) : s;
}
var zc = 36, qc = 4, nd = 58, id = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ", no = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]), Rg = rd.Buffer.from("appID"), td = "address seems to be malformed", Cg = "wrong checksum for address", kg = "invalid multisig version", jg = "bad multisig threshold", Bg = "bad multisig public key - wrong length", Lg = "nacl public key length is not 32 bytes";
function Ue(r) {
  if (typeof r != "string" || r.length !== nd)
    throw new Error(td);
  let e = rf.default.decode.asBytes(r.toString());
  if (e.length !== zc)
    throw new Error(td);
  let t = new Uint8Array(e.slice(0, zc - qc)), n = new Uint8Array(e.slice(ro, zc)), i = tr(t).slice(Xu - qc, Xu);
  if (!kn(i, n))
    throw new Error(Cg);
  return { publicKey: t, checksum: n };
}
function hn(r) {
  try {
    Ue(r);
  } catch (e) {
    return false;
  }
  return true;
}
function xe(r) {
  let e = tr(r).slice(ro - qc, ro);
  return rf.default.encode(Nt(r, e)).toString().slice(0, nd);
}
function Rr({ version: r, threshold: e, pks: t }) {
  if (r !== 1 || r > 255 || r < 0)
    throw new Error(kg);
  if (e === 0 || t.length === 0 || e > t.length || e > 255)
    throw new Error(jg);
  let n = zc - qc;
  if (n !== ro)
    throw new Error(Lg);
  let i = new Uint8Array(no.length + 2 + n * t.length);
  i.set(no, 0), i.set([r], no.length), i.set([e], no.length + 1);
  for (let s = 0; s < t.length; s++) {
    if (t[s].length !== n)
      throw new Error(Bg);
    i.set(t[s], no.length + 2 + s * n);
  }
  return new Uint8Array(tr(i));
}
function nf({ version: r, threshold: e, addrs: t }) {
  let n = t.map((i) => Ue(i).publicKey);
  return xe(Rr({ version: r, threshold: e, pks: n }));
}
function Bn(r) {
  let e = Nt(Rg, jn(r)), t = tr(e);
  return xe(new Uint8Array(t));
}
var $c = lt(sd()), Ug = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function Pg(r) {
  for (let e in r)
    if (Object.prototype.hasOwnProperty.call(r, e) && (!r[e] || r[e].length === 0))
      return { containsEmpty: true, firstEmptyKey: e };
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function of(r) {
  return $c.encode(r, { sortKeys: true });
}
function Mt(r) {
  let e = Pg(r);
  if (e.containsEmpty)
    throw new Error(Ug + e.firstEmptyKey);
  return of(r);
}
function St(r) {
  return $c.decode(r);
}
var De = lt(Tt()), fd = lt(Qu());
function zg(r, e, t) {
  let n = r.appIndex, i = r.name, s = n === 0 || n === t, o = 0;
  if (e != null && (o = e.indexOf(n) + 1), o === 0 && !s)
    throw new Error(`Box ref with appId ${n} not in foreign-apps`);
  return { i: o, n: i };
}
function od(r, e, t) {
  return r == null ? [] : r.map((n) => zg(n, e, t));
}
var wt;
(function(r) {
  r.pay = "pay", r.keyreg = "keyreg", r.acfg = "acfg", r.axfer = "axfer", r.afrz = "afrz", r.appl = "appl", r.stpf = "stpf";
})(wt || (wt = {}));
function ad(r) {
  return r === wt.pay || r === wt.keyreg || r === wt.acfg || r === wt.axfer || r === wt.afrz || r === wt.appl || r === wt.stpf;
}
var Ht;
(function(r) {
  r[r.NoOpOC = 0] = "NoOpOC", r[r.OptInOC = 1] = "OptInOC", r[r.CloseOutOC = 2] = "CloseOutOC", r[r.ClearStateOC = 3] = "ClearStateOC", r[r.UpdateApplicationOC = 4] = "UpdateApplicationOC", r[r.DeleteApplicationOC = 5] = "DeleteApplicationOC";
})(Ht || (Ht = {}));
var qg = 52, cf = 1e3, so = 32, cd = 19, $g = 75, Vg = 5, Gg = 32, Wg = 5, ud = 32, Kg = 32, Hg = 32, Yg = 64;
function af(r, e, t) {
  if (r == null)
    return;
  let n;
  if (typeof r == "string" ? n = De.Buffer.from(r, "base64") : r.constructor === Uint8Array ? n = De.Buffer.from(r) : De.Buffer.isBuffer(r) && (n = r), n == null || n.byteLength !== t)
    throw Error(`${e} must be a ${t} byte Uint8Array or Buffer or base64 string.`);
  return n;
}
var At = class {
  constructor(t) {
    var e = gl(t, []);
    this.name = "Transaction", this.tag = De.Buffer.from("TX");
    let n = { type: wt.pay, flatFee: false, nonParticipation: false };
    if (typeof e.type == "undefined" && (e.type = n.type), typeof e.flatFee == "undefined" && (e.flatFee = n.flatFee), e.type === wt.keyreg && typeof e.voteKey != "undefined" && typeof e.nonParticipation == "undefined" && (e.nonParticipation = n.nonParticipation), e.suggestedParams !== void 0) {
      let s = e;
      s.genesisHash = s.suggestedParams.genesisHash, s.fee = s.suggestedParams.fee, s.suggestedParams.flatFee !== void 0 && (s.flatFee = s.suggestedParams.flatFee), s.firstRound = s.suggestedParams.firstRound, s.lastRound = s.suggestedParams.lastRound, s.genesisID = s.suggestedParams.genesisID;
    }
    let i = e;
    if (i.from = Ue(i.from), i.to !== void 0 && (i.to = Ue(i.to)), i.closeRemainderTo !== void 0 && (i.closeRemainderTo = Ue(i.closeRemainderTo)), i.assetManager !== void 0 && (i.assetManager = Ue(i.assetManager)), i.assetReserve !== void 0 && (i.assetReserve = Ue(i.assetReserve)), i.assetFreeze !== void 0 && (i.assetFreeze = Ue(i.assetFreeze)), i.assetClawback !== void 0 && (i.assetClawback = Ue(i.assetClawback)), i.assetRevocationTarget !== void 0 && (i.assetRevocationTarget = Ue(i.assetRevocationTarget)), i.freezeAccount !== void 0 && (i.freezeAccount = Ue(i.freezeAccount)), i.reKeyTo !== void 0 && (i.reKeyTo = Ue(i.reKeyTo)), i.genesisHash === void 0)
      throw Error("genesis hash must be specified and in a base64 string.");
    if (i.genesisHash = De.Buffer.from(i.genesisHash, "base64"), i.amount !== void 0 && (!(Number.isSafeInteger(i.amount) || typeof i.amount == "bigint" && i.amount <= BigInt("0xffffffffffffffff")) || i.amount < 0))
      throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (!Number.isSafeInteger(i.fee) || i.fee < 0)
      throw Error("fee must be a positive number and smaller than 2^53-1");
    if (!Number.isSafeInteger(i.firstRound) || i.firstRound < 0)
      throw Error("firstRound must be a positive number");
    if (!Number.isSafeInteger(i.lastRound) || i.lastRound < 0)
      throw Error("lastRound must be a positive number");
    if (i.extraPages !== void 0 && (!Number.isInteger(i.extraPages) || i.extraPages < 0 || i.extraPages > 3))
      throw Error("extraPages must be an Integer between and including 0 to 3");
    if (i.assetTotal !== void 0 && (!(Number.isSafeInteger(i.assetTotal) || typeof i.assetTotal == "bigint" && i.assetTotal <= BigInt("0xffffffffffffffff")) || i.assetTotal < 0))
      throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (i.assetDecimals !== void 0 && (!Number.isSafeInteger(i.assetDecimals) || i.assetDecimals < 0 || i.assetDecimals > cd))
      throw Error(`assetDecimals must be a positive number and smaller than ${cd.toString()}`);
    if (i.assetIndex !== void 0 && (!Number.isSafeInteger(i.assetIndex) || i.assetIndex < 0))
      throw Error("Asset index must be a positive number and smaller than 2^53-1");
    if (i.appIndex !== void 0 && (!Number.isSafeInteger(i.appIndex) || i.appIndex < 0))
      throw Error("Application index must be a positive number and smaller than 2^53-1");
    if (i.appLocalInts !== void 0 && (!Number.isSafeInteger(i.appLocalInts) || i.appLocalInts < 0))
      throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
    if (i.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(i.appLocalByteSlices) || i.appLocalByteSlices < 0))
      throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
    if (i.appGlobalInts !== void 0 && (!Number.isSafeInteger(i.appGlobalInts) || i.appGlobalInts < 0))
      throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
    if (i.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(i.appGlobalByteSlices) || i.appGlobalByteSlices < 0))
      throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
    if (i.appApprovalProgram !== void 0 && i.appApprovalProgram.constructor !== Uint8Array)
      throw Error("appApprovalProgram must be a Uint8Array.");
    if (i.appClearProgram !== void 0 && i.appClearProgram.constructor !== Uint8Array)
      throw Error("appClearProgram must be a Uint8Array.");
    if (i.appArgs !== void 0) {
      if (!Array.isArray(i.appArgs))
        throw Error("appArgs must be an Array of Uint8Array.");
      i.appArgs = i.appArgs.slice(), i.appArgs.forEach((s) => {
        if (s.constructor !== Uint8Array)
          throw Error("each element of AppArgs must be a Uint8Array.");
      });
    } else
      i.appArgs = [];
    if (i.appAccounts !== void 0) {
      if (!Array.isArray(i.appAccounts))
        throw Error("appAccounts must be an Array of addresses.");
      i.appAccounts = i.appAccounts.map((s) => Ue(s));
    }
    if (i.appForeignApps !== void 0) {
      if (!Array.isArray(i.appForeignApps))
        throw Error("appForeignApps must be an Array of integers.");
      i.appForeignApps = i.appForeignApps.slice(), i.appForeignApps.forEach((s) => {
        if (!Number.isSafeInteger(s) || s < 0)
          throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
      });
    }
    if (i.appForeignAssets !== void 0) {
      if (!Array.isArray(i.appForeignAssets))
        throw Error("appForeignAssets must be an Array of integers.");
      i.appForeignAssets = i.appForeignAssets.slice(), i.appForeignAssets.forEach((s) => {
        if (!Number.isSafeInteger(s) || s < 0)
          throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
      });
    }
    if (i.boxes !== void 0) {
      if (!Array.isArray(i.boxes))
        throw Error("boxes must be an Array of BoxReference.");
      i.boxes = i.boxes.slice(), i.boxes.forEach((s) => {
        if (!Number.isSafeInteger(s.appIndex) || s.name.constructor !== Uint8Array)
          throw Error("box app index must be a number and name must be an Uint8Array.");
      });
    }
    if (i.assetMetadataHash !== void 0 && i.assetMetadataHash.length !== 0) {
      if (typeof i.assetMetadataHash == "string" && (i.assetMetadataHash = new Uint8Array(De.Buffer.from(i.assetMetadataHash))), i.assetMetadataHash.constructor !== Uint8Array || i.assetMetadataHash.byteLength !== ud)
        throw Error(`assetMetadataHash must be a ${ud} byte Uint8Array or string.`);
      i.assetMetadataHash.every((s) => s === 0) && (i.assetMetadataHash = void 0);
    } else
      i.assetMetadataHash = void 0;
    if (i.note !== void 0) {
      if (i.note.constructor !== Uint8Array)
        throw Error("note must be a Uint8Array.");
    } else
      i.note = new Uint8Array(0);
    if (i.lease !== void 0) {
      if (i.lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (i.lease.length !== so)
        throw Error(`lease must be of length ${so.toString()}.`);
      i.lease.every((s) => s === 0) && (i.lease = new Uint8Array(0));
    } else
      i.lease = new Uint8Array(0);
    if (i.voteKey = af(i.voteKey, "voteKey", Kg), i.selectionKey = af(i.selectionKey, "selectionKey", Hg), i.stateProofKey = af(i.stateProofKey, "stateProofKey", Yg), i.nonParticipation && (i.voteKey || i.selectionKey || i.voteFirst || i.stateProofKey || i.voteLast || i.voteKeyDilution))
      throw new Error("nonParticipation is true but participation params are present.");
    if (!i.nonParticipation && (i.voteKey || i.selectionKey || i.stateProofKey || i.voteFirst || i.voteLast || i.voteKeyDilution) && !(i.voteKey && i.selectionKey && i.voteFirst && i.voteLast && i.voteKeyDilution))
      throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
    if (delete i.suggestedParams, Object.assign(this, Ql(i)), i.flatFee || (this.fee *= this.estimateSize(), this.fee < cf && (this.fee = cf)), this.group = void 0, i.stateProofType !== void 0 && (!Number.isSafeInteger(i.stateProofType) || i.stateProofType < 0))
      throw Error("State Proof type must be a positive number and smaller than 2^53-1");
    if (i.stateProofMessage !== void 0) {
      if (i.stateProofMessage.constructor !== Uint8Array)
        throw Error("stateProofMessage must be a Uint8Array.");
    } else
      i.stateProofMessage = new Uint8Array(0);
    if (i.stateProof !== void 0) {
      if (i.stateProof.constructor !== Uint8Array)
        throw Error("stateProof must be a Uint8Array.");
    } else
      i.stateProof = new Uint8Array(0);
  }
  get_obj_for_encoding() {
    if (this.type === "pay") {
      let e = { amt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: De.Buffer.from(this.note), snd: De.Buffer.from(this.from.publicKey), type: "pay", gen: this.genesisID, gh: this.genesisHash, lx: De.Buffer.from(this.lease), grp: this.group };
      return this.closeRemainderTo !== void 0 && xe(this.closeRemainderTo.publicKey) !== id && (e.close = De.Buffer.from(this.closeRemainderTo.publicKey)), this.reKeyTo !== void 0 && (e.rekey = De.Buffer.from(this.reKeyTo.publicKey)), this.to !== void 0 && (e.rcv = De.Buffer.from(this.to.publicKey)), e.note.length || delete e.note, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, e.lx.length || delete e.lx, e.rekey || delete e.rekey, e;
    }
    if (this.type === "keyreg") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: De.Buffer.from(this.note), snd: De.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: De.Buffer.from(this.lease), grp: this.group, votekey: this.voteKey, selkey: this.selectionKey, sprfkey: this.stateProofKey, votefst: this.voteFirst, votelst: this.voteLast, votekd: this.voteKeyDilution };
      return e.note.length || delete e.note, e.lx.length || delete e.lx, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, this.reKeyTo !== void 0 && (e.rekey = De.Buffer.from(this.reKeyTo.publicKey)), this.nonParticipation && (e.nonpart = true), e.selkey || delete e.selkey, e.votekey || delete e.votekey, e.sprfkey || delete e.sprfkey, e.votefst || delete e.votefst, e.votelst || delete e.votelst, e.votekd || delete e.votekd, e;
    }
    if (this.type === "acfg") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: De.Buffer.from(this.note), snd: De.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: De.Buffer.from(this.lease), grp: this.group, caid: this.assetIndex, apar: { t: this.assetTotal, df: this.assetDefaultFrozen, dc: this.assetDecimals } };
      return this.assetManager !== void 0 && (e.apar.m = De.Buffer.from(this.assetManager.publicKey)), this.assetReserve !== void 0 && (e.apar.r = De.Buffer.from(this.assetReserve.publicKey)), this.assetFreeze !== void 0 && (e.apar.f = De.Buffer.from(this.assetFreeze.publicKey)), this.assetClawback !== void 0 && (e.apar.c = De.Buffer.from(this.assetClawback.publicKey)), this.assetName !== void 0 && (e.apar.an = this.assetName), this.assetUnitName !== void 0 && (e.apar.un = this.assetUnitName), this.assetURL !== void 0 && (e.apar.au = this.assetURL), this.assetMetadataHash !== void 0 && (e.apar.am = De.Buffer.from(this.assetMetadataHash)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, this.reKeyTo !== void 0 && (e.rekey = De.Buffer.from(this.reKeyTo.publicKey)), e.caid || delete e.caid, !e.apar.t && !e.apar.un && !e.apar.an && !e.apar.df && !e.apar.m && !e.apar.r && !e.apar.f && !e.apar.c && !e.apar.au && !e.apar.am && !e.apar.dc ? delete e.apar : (e.apar.t || delete e.apar.t, e.apar.dc || delete e.apar.dc, e.apar.un || delete e.apar.un, e.apar.an || delete e.apar.an, e.apar.df || delete e.apar.df, e.apar.m || delete e.apar.m, e.apar.r || delete e.apar.r, e.apar.f || delete e.apar.f, e.apar.c || delete e.apar.c, e.apar.au || delete e.apar.au, e.apar.am || delete e.apar.am), e.grp === void 0 && delete e.grp, e;
    }
    if (this.type === "axfer") {
      let e = { aamt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: De.Buffer.from(this.note), snd: De.Buffer.from(this.from.publicKey), arcv: De.Buffer.from(this.to.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: De.Buffer.from(this.lease), grp: this.group, xaid: this.assetIndex };
      return this.closeRemainderTo !== void 0 && (e.aclose = De.Buffer.from(this.closeRemainderTo.publicKey)), this.assetRevocationTarget !== void 0 && (e.asnd = De.Buffer.from(this.assetRevocationTarget.publicKey)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.aamt || delete e.aamt, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, e.aclose || delete e.aclose, e.asnd || delete e.asnd, e.rekey || delete e.rekey, this.reKeyTo !== void 0 && (e.rekey = De.Buffer.from(this.reKeyTo.publicKey)), e;
    }
    if (this.type === "afrz") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: De.Buffer.from(this.note), snd: De.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: De.Buffer.from(this.lease), grp: this.group, faid: this.assetIndex, afrz: this.freezeState };
      return this.freezeAccount !== void 0 && (e.fadd = De.Buffer.from(this.freezeAccount.publicKey)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.afrz || delete e.afrz, e.grp === void 0 && delete e.grp, this.reKeyTo !== void 0 && (e.rekey = De.Buffer.from(this.reKeyTo.publicKey)), e;
    }
    if (this.type === "appl") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: De.Buffer.from(this.note), snd: De.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: De.Buffer.from(this.lease), grp: this.group, apid: this.appIndex, apan: this.appOnComplete, apls: { nui: this.appLocalInts, nbs: this.appLocalByteSlices }, apgs: { nui: this.appGlobalInts, nbs: this.appGlobalByteSlices }, apfa: this.appForeignApps, apas: this.appForeignAssets, apep: this.extraPages, apbx: od(this.boxes, this.appForeignApps, this.appIndex) };
      this.reKeyTo !== void 0 && (e.rekey = De.Buffer.from(this.reKeyTo.publicKey)), this.appApprovalProgram !== void 0 && (e.apap = De.Buffer.from(this.appApprovalProgram)), this.appClearProgram !== void 0 && (e.apsu = De.Buffer.from(this.appClearProgram)), this.appArgs !== void 0 && (e.apaa = this.appArgs.map((t) => De.Buffer.from(t))), this.appAccounts !== void 0 && (e.apat = this.appAccounts.map((t) => De.Buffer.from(t.publicKey))), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.apid || delete e.apid, e.apls.nui || delete e.apls.nui, e.apls.nbs || delete e.apls.nbs, !e.apls.nui && !e.apls.nbs && delete e.apls, e.apgs.nui || delete e.apgs.nui, e.apgs.nbs || delete e.apgs.nbs, (!e.apaa || !e.apaa.length) && delete e.apaa, !e.apgs.nui && !e.apgs.nbs && delete e.apgs, e.apap || delete e.apap, e.apsu || delete e.apsu, e.apan || delete e.apan, (!e.apfa || !e.apfa.length) && delete e.apfa, (!e.apas || !e.apas.length) && delete e.apas;
      for (let t of e.apbx)
        t.i || delete t.i, (!t.n || !t.n.length) && delete t.n;
      return (!e.apbx || !e.apbx.length) && delete e.apbx, (!e.apat || !e.apat.length) && delete e.apat, e.apep || delete e.apep, e.grp === void 0 && delete e.grp, e;
    }
    if (this.type === "stpf") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: De.Buffer.from(this.note), snd: De.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: De.Buffer.from(this.lease), sptype: this.stateProofType, spmsg: De.Buffer.from(this.stateProofMessage), sp: De.Buffer.from(this.stateProof) };
      return e.sptype || delete e.sptype, e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.apid || delete e.apid, (!e.apaa || !e.apaa.length) && delete e.apaa, e.apap || delete e.apap, e.apsu || delete e.apsu, e.apan || delete e.apan, (!e.apfa || !e.apfa.length) && delete e.apfa, (!e.apas || !e.apas.length) && delete e.apas, (!e.apat || !e.apat.length) && delete e.apat, e.apep || delete e.apep, e.grp === void 0 && delete e.grp, e;
    }
  }
  static from_obj_for_encoding(e) {
    let t = Object.create(this.prototype);
    if (t.name = "Transaction", t.tag = De.Buffer.from("TX"), t.genesisID = e.gen, t.genesisHash = De.Buffer.from(e.gh), !ad(e.type))
      throw new Error(`Unrecognized transaction type: ${e.type}`);
    return t.type = e.type, t.fee = e.fee, t.firstRound = e.fv, t.lastRound = e.lv, t.note = new Uint8Array(e.note), t.lease = new Uint8Array(e.lx), t.from = Ue(xe(new Uint8Array(e.snd))), e.grp !== void 0 && (t.group = De.Buffer.from(e.grp)), e.rekey !== void 0 && (t.reKeyTo = Ue(xe(new Uint8Array(e.rekey)))), e.type === "pay" ? (t.amount = e.amt, t.to = Ue(xe(new Uint8Array(e.rcv))), e.close !== void 0 && (t.closeRemainderTo = Ue(xe(e.close)))) : e.type === "keyreg" ? (e.votekey !== void 0 && (t.voteKey = De.Buffer.from(e.votekey)), e.selkey !== void 0 && (t.selectionKey = De.Buffer.from(e.selkey)), e.sprfkey !== void 0 && (t.stateProofKey = De.Buffer.from(e.sprfkey)), e.votekd !== void 0 && (t.voteKeyDilution = e.votekd), e.votefst !== void 0 && (t.voteFirst = e.votefst), e.votelst !== void 0 && (t.voteLast = e.votelst), e.nonpart !== void 0 && (t.nonParticipation = e.nonpart)) : e.type === "acfg" ? (e.caid !== void 0 && (t.assetIndex = e.caid), e.apar !== void 0 && (t.assetTotal = e.apar.t, t.assetDefaultFrozen = e.apar.df, e.apar.dc !== void 0 && (t.assetDecimals = e.apar.dc), e.apar.m !== void 0 && (t.assetManager = Ue(xe(new Uint8Array(e.apar.m)))), e.apar.r !== void 0 && (t.assetReserve = Ue(xe(new Uint8Array(e.apar.r)))), e.apar.f !== void 0 && (t.assetFreeze = Ue(xe(new Uint8Array(e.apar.f)))), e.apar.c !== void 0 && (t.assetClawback = Ue(xe(new Uint8Array(e.apar.c)))), e.apar.un !== void 0 && (t.assetUnitName = e.apar.un), e.apar.an !== void 0 && (t.assetName = e.apar.an), e.apar.au !== void 0 && (t.assetURL = e.apar.au), e.apar.am !== void 0 && (t.assetMetadataHash = e.apar.am))) : e.type === "axfer" ? (e.xaid !== void 0 && (t.assetIndex = e.xaid), e.aamt !== void 0 && (t.amount = e.aamt), e.aclose !== void 0 && (t.closeRemainderTo = Ue(xe(new Uint8Array(e.aclose)))), e.asnd !== void 0 && (t.assetRevocationTarget = Ue(xe(new Uint8Array(e.asnd)))), t.to = Ue(xe(new Uint8Array(e.arcv)))) : e.type === "afrz" ? (e.afrz !== void 0 && (t.freezeState = e.afrz), e.faid !== void 0 && (t.assetIndex = e.faid), t.freezeAccount = Ue(xe(new Uint8Array(e.fadd)))) : e.type === "appl" ? (e.apid !== void 0 && (t.appIndex = e.apid), e.apan !== void 0 && (t.appOnComplete = e.apan), e.apls !== void 0 && (e.apls.nui !== void 0 && (t.appLocalInts = e.apls.nui), e.apls.nbs !== void 0 && (t.appLocalByteSlices = e.apls.nbs)), e.apgs !== void 0 && (e.apgs.nui !== void 0 && (t.appGlobalInts = e.apgs.nui), e.apgs.nbs !== void 0 && (t.appGlobalByteSlices = e.apgs.nbs)), e.apep !== void 0 && (t.extraPages = e.apep), e.apap !== void 0 && (t.appApprovalProgram = new Uint8Array(e.apap)), e.apsu !== void 0 && (t.appClearProgram = new Uint8Array(e.apsu)), e.apaa !== void 0 && (t.appArgs = e.apaa.map((n) => new Uint8Array(n))), e.apat !== void 0 && (t.appAccounts = e.apat.map((n) => Ue(xe(new Uint8Array(n))))), e.apfa !== void 0 && (t.appForeignApps = e.apfa), e.apas !== void 0 && (t.appForeignAssets = e.apas), e.apbx !== void 0 && (t.boxes = e.apbx.map((n) => ({ appIndex: n.i ? t.appForeignApps[n.i - 1] : 0, name: n.n })))) : e.type === "stpf" && (e.sptype !== void 0 && (t.stateProofType = e.sptype), e.sp !== void 0 && (t.stateProof = e.sp), e.spmsg !== void 0 && (t.stateProofMessage = e.spmsg)), t;
  }
  estimateSize() {
    return this.toByte().length + $g;
  }
  bytesToSign() {
    let e = this.toByte();
    return De.Buffer.from(Nt(this.tag, e));
  }
  toByte() {
    return Mt(this.get_obj_for_encoding());
  }
  rawSignTxn(e) {
    let t = this.bytesToSign(), n = Kr(t, e);
    return De.Buffer.from(n);
  }
  signTxn(e) {
    let t = { sig: this.rawSignTxn(e), txn: this.get_obj_for_encoding() }, i = Wr(e).publicKey;
    return xe(i) !== xe(this.from.publicKey) && (t.sgnr = De.Buffer.from(i)), new Uint8Array(Mt(t));
  }
  attachSignature(e, t) {
    if (!Cc(t.length))
      throw new Error("Invalid signature length");
    let n = { sig: De.Buffer.from(t), txn: this.get_obj_for_encoding() };
    if (e !== xe(this.from.publicKey)) {
      let i = Ue(e).publicKey;
      n.sgnr = De.Buffer.from(i);
    }
    return new Uint8Array(Mt(n));
  }
  rawTxID() {
    let e = this.toByte(), t = De.Buffer.from(Nt(this.tag, e));
    return De.Buffer.from(tr(t));
  }
  txID() {
    let e = this.rawTxID();
    return fd.default.encode(e).slice(0, qg);
  }
  addLease(e, t = 0) {
    let n;
    if (e !== void 0) {
      if (e.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (e.length !== so)
        throw Error(`lease must be of length ${so.toString()}.`);
      n = new Uint8Array(e);
    } else
      n = new Uint8Array(0);
    this.lease = n, t !== 0 && (this.fee += (Vg + so) * t);
  }
  addRekey(e, t = 0) {
    e !== void 0 && (this.reKeyTo = Ue(e)), t !== 0 && (this.fee += (Wg + Gg) * t);
  }
  _getDictForDisplay() {
    let e = at({}, this);
    return e.tag = e.tag.toString(), e.from = xe(e.from.publicKey), e.to !== void 0 && (e.to = xe(e.to.publicKey)), e.freezeAccount !== void 0 && (e.freezeAccount = xe(e.freezeAccount.publicKey)), e.closeRemainderTo !== void 0 && (e.closeRemainderTo = xe(e.closeRemainderTo.publicKey)), e.assetManager !== void 0 && (e.assetManager = xe(e.assetManager.publicKey)), e.assetReserve !== void 0 && (e.assetReserve = xe(e.assetReserve.publicKey)), e.assetFreeze !== void 0 && (e.assetFreeze = xe(e.assetFreeze.publicKey)), e.assetClawback !== void 0 && (e.assetClawback = xe(e.assetClawback.publicKey)), e.assetRevocationTarget !== void 0 && (e.assetRevocationTarget = xe(e.assetRevocationTarget.publicKey)), e.reKeyTo !== void 0 && (e.reKeyTo = xe(e.reKeyTo.publicKey)), e.genesisHash = e.genesisHash.toString("base64"), e;
  }
  prettyPrint() {
    console.log(this._getDictForDisplay());
  }
  toString() {
    return JSON.stringify(this._getDictForDisplay());
  }
};
function uf(r) {
  let e = { txn: r.get_obj_for_encoding() };
  return Mt(e);
}
function Jg(r) {
  let e = r.get_obj_for_encoding();
  return Mt(e);
}
function Ln(r) {
  let e = St(r);
  return At.from_obj_for_encoding(e);
}
function Yr(r) {
  let e = St(r);
  return Er(at({}, e), { txn: At.from_obj_for_encoding(e.txn) });
}
function yr(r) {
  return r instanceof At ? r : new At(r);
}
var Li = lt(Tt());
var oo = class {
  constructor({ bidderKey: e, bidAmount: t, bidID: n, auctionKey: i, auctionID: s, maxPrice: o }) {
    this.name = "Bid", this.tag = Li.Buffer.from([97, 66]);
    let c = Ue(e), l2 = Ue(i);
    if (!Number.isSafeInteger(t) || t < 0)
      throw Error("Bid amount must be positive and 2^53-1");
    if (!Number.isSafeInteger(n) || n < 0)
      throw Error("BidID must be positive and 2^53-1");
    if (!Number.isSafeInteger(s) || s < 0)
      throw Error("auctionID must be positive");
    Object.assign(this, { bidderKey: c, bidAmount: t, bidID: n, auctionKey: l2, auctionID: s, maxPrice: o });
  }
  get_obj_for_encoding() {
    return { bidder: Li.Buffer.from(this.bidderKey.publicKey), cur: this.bidAmount, price: this.maxPrice, id: this.bidID, auc: Li.Buffer.from(this.auctionKey.publicKey), aid: this.auctionID };
  }
  signBid(e) {
    let t = Mt(this.get_obj_for_encoding()), n = Li.Buffer.from(Nt(this.tag, t)), i = Kr(n, e), o = { t: "b", b: { sig: Li.Buffer.from(i), bid: this.get_obj_for_encoding() } };
    return new Uint8Array(Mt(o));
  }
};
var ao = "Microalgos should be positive and less than 2^53 - 1.";
function Vc(r) {
  if (r < 0 || !Number.isSafeInteger(r))
    throw new Error(ao);
  return r / 1e6;
}
function ld(r) {
  let e = r * 1e6;
  return Math.round(e);
}
var Hc = lt(Tt());
var pd = lt(Tt()), Kc = lt(hd());
var ff = class extends Error {
  constructor(e, t) {
    super(e), this.response = t, this.name = "URLTokenBaseHTTPError", this.response = t;
  }
}, Cr = class {
  constructor(e, t, n, i = {}) {
    this.defaultHeaders = i;
    let s = t.endsWith("/") ? t : `${t}/`, o = new URL(s);
    if (typeof n != "undefined" && (o.port = n.toString()), o.protocol.length === 0)
      throw new Error("Invalid base server URL, protocol must be defined.");
    this.baseURL = o, this.tokenHeader = e;
  }
  getURL(e, t) {
    let n;
    e.startsWith("./") ? n = e : e.startsWith("/") ? n = `.${e}` : n = `./${e}`;
    let i = new URL(n, this.baseURL);
    if (t)
      for (let [s, o] of Object.entries(t))
        i.searchParams.set(s, o);
    return i.toString();
  }
  static formatFetchResponseHeaders(e) {
    let t = {};
    return e.forEach((n, i) => {
      t[n] = i;
    }), t;
  }
  static async checkHttpError(e) {
    if (e.ok)
      return;
    let t = null, n = null;
    try {
      t = new Uint8Array(await e.arrayBuffer());
      let s = JSON.parse(pd.Buffer.from(t).toString());
      s.message && (n = s.message);
    } catch (s) {
    }
    let i = `Network request error. Received status ${e.status} (${e.statusText})`;
    throw n && (i += `: ${n}`), new ff(i, { body: t, status: e.status, headers: Cr.formatFetchResponseHeaders(e.headers) });
  }
  static async formatFetchResponse(e) {
    return await this.checkHttpError(e), { body: new Uint8Array(await e.arrayBuffer()), status: e.status, headers: Cr.formatFetchResponseHeaders(e.headers) };
  }
  async get(e, t, n = {}) {
    let i = at(at(at({}, this.tokenHeader), this.defaultHeaders), n), s = await (0, Kc.fetch)(this.getURL(e, t), { headers: i });
    return Cr.formatFetchResponse(s);
  }
  async post(e, t, n, i = {}) {
    let s = at(at(at({}, this.tokenHeader), this.defaultHeaders), i), o = await (0, Kc.fetch)(this.getURL(e, n), { method: "POST", body: t, headers: s });
    return Cr.formatFetchResponse(o);
  }
  async delete(e, t, n, i = {}) {
    let s = at(at(at({}, this.tokenHeader), this.defaultHeaders), i), o = await (0, Kc.fetch)(this.getURL(e, n), { method: "DELETE", body: t, headers: s });
    return Cr.formatFetchResponse(o);
  }
};
function Xg(r) {
  for (let e in r)
    Object.prototype.hasOwnProperty.call(r, e) && (!r[e] || r[e].length === 0) && delete r[e];
  return r;
}
function gd(r) {
  return Object.keys(r).reduce((e, t) => (e[t.toLowerCase()] = r[t], e), {});
}
function Qg(r) {
  if (r !== void 0 && Object.prototype.hasOwnProperty.call(r, "format"))
    switch (r.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  else
    return "application/json";
}
var rr = class {
  constructor(e, t, n, i = {}) {
    t !== void 0 ? this.bc = new Cr(e, t, n, i) : this.bc = e;
  }
  static parseJSON(e, t, n = {}) {
    try {
      return Object.keys(n).length === 0 ? e && JSON.parse(e) : e && Xl(e, n);
    } catch (i) {
      let s = i;
      throw s.rawResponse = e || null, s.statusCode = t, s;
    }
  }
  static serializeData(e, t) {
    if (!e)
      return new Uint8Array(0);
    if (t["content-type"] === "application/json")
      return new Uint8Array(Hc.Buffer.from(JSON.stringify(e)));
    if (typeof e == "string")
      return new Uint8Array(Hc.Buffer.from(e));
    if (e instanceof Uint8Array)
      return e;
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  static prepareResponse(e, t, n, i = {}) {
    let { body: s } = e, o;
    return t !== "application/msgpack" && (o = s && Hc.Buffer.from(s).toString() || ""), n && t === "application/json" && (s = rr.parseJSON(o, e.status, i)), Er(at({}, e), { body: s, text: o, ok: Math.trunc(e.status / 100) === 2 });
  }
  static prepareResponseError(e) {
    return e.response && (e.response = rr.prepareResponse(e.response, "application/json", true), e.status = e.response.status), e;
  }
  async get(e, t, n = {}, i = {}, s = true) {
    let o = Qg(t), c = Er(at({}, n), { accept: o });
    try {
      let l2 = await this.bc.get(e, Xg(t), c);
      return rr.prepareResponse(l2, o, s, i);
    } catch (l2) {
      throw rr.prepareResponseError(l2);
    }
  }
  async post(e, t, n = {}, i, s = true) {
    let o = at({ "content-type": "application/json" }, gd(n));
    try {
      let c = await this.bc.post(e, rr.serializeData(t, o), i, o);
      return rr.prepareResponse(c, "application/json", s);
    } catch (c) {
      throw rr.prepareResponseError(c);
    }
  }
  async delete(e, t, n = {}, i = true) {
    let s = at({ "content-type": "application/json" }, gd(n)), o = await this.bc.delete(e, rr.serializeData(t, s), void 0, s);
    return rr.prepareResponse(o, "application/json", i);
  }
};
function em(r = "", e) {
  let t = {};
  return r === "" || (t[e] = r), t;
}
function tm(r) {
  return typeof r.get == "function";
}
var Jr = class {
  constructor(e, t, n, i, s = {}) {
    if (tm(t))
      this.c = new rr(t);
    else {
      let o;
      typeof t == "string" ? o = em(t, e) : o = t, this.c = new rr(o, n, i, s);
    }
    this.intDecoding = ln.DEFAULT;
  }
  setIntEncoding(e) {
    this.intDecoding = e;
  }
  getIntEncoding() {
    return this.intDecoding;
  }
};
var Yc = {};
Pu(Yc, { Account: () => Pi, AccountApplicationResponse: () => co, AccountAssetResponse: () => uo, AccountParticipation: () => zi, AccountStateDelta: () => Un, Application: () => Zr, ApplicationLocalState: () => Pn, ApplicationParams: () => Xr, ApplicationStateSchema: () => xr, Asset: () => qi, AssetHolding: () => zn, AssetParams: () => qn, BlockHashResponse: () => fo, BlockResponse: () => lo, Box: () => $n, BoxDescriptor: () => $i, BoxesResponse: () => Vn, BuildVersion: () => Vi, CompileResponse: () => ho, DisassembleResponse: () => po, DryrunRequest: () => Gn, DryrunResponse: () => go, DryrunSource: () => Gi, DryrunState: () => Wn, DryrunTxnResult: () => Wi, ErrorResponse: () => mo, EvalDelta: () => Ki, EvalDeltaKeyValue: () => mn, GetBlockTimeStampOffsetResponse: () => Kn, GetSyncRoundResponse: () => Hn, KvDelta: () => yo, LedgerStateDeltaForTransactionGroup: () => Hi, LightBlockHeaderProof: () => xo, NodeStatusResponse: () => wo, PendingTransactionResponse: () => Yn, PendingTransactionsResponse: () => bo, PostTransactionsResponse: () => vo, SimulateRequest: () => Qr, SimulateRequestTransactionGroup: () => kr, SimulateResponse: () => Jn, SimulateTransactionGroupResult: () => Yi, SimulateTransactionResult: () => Ji, SimulationEvalOverrides: () => Zi, StateProof: () => _o, StateProofMessage: () => Xi, SupplyResponse: () => Ao, TealKeyValue: () => Zn, TealValue: () => yn, TransactionGroupLedgerStateDeltasForRoundResponse: () => Xn, TransactionParametersResponse: () => Eo, TransactionProofResponse: () => Io, Version: () => To });
var Rt = lt(Tt());
var md = lt(Tt());
function rm(r) {
  return r === void 0 || r == null || typeof r != "object" && typeof r != "function";
}
function lf(r, e) {
  let t;
  if (r instanceof Uint8Array)
    t = e ? r : md.Buffer.from(r).toString("base64");
  else if (typeof r.get_obj_for_encoding == "function")
    t = r.get_obj_for_encoding(e);
  else if (Array.isArray(r)) {
    t = [];
    for (let n of r)
      t.push(lf(n, e));
  } else if (typeof r == "object") {
    let n = {};
    for (let i of Object.keys(r))
      n[i] = lf(r[i], e);
    t = n;
  } else if (rm(r))
    t = r;
  else
    throw new Error(`Unsupported value: ${String(r)}`);
  return t;
}
var se = class {
  get_obj_for_encoding(e = false) {
    let t = {};
    for (let n of Object.keys(this.attribute_map)) {
      let i = this.attribute_map[n], s = this[n];
      typeof s != "undefined" && (t[i] = s === null ? null : lf(s, e));
    }
    return t;
  }
};
var Pi = class extends se {
  constructor({ address: e, amount: t, amountWithoutPendingRewards: n, minBalance: i, pendingRewards: s, rewards: o, round: c, status: l2, totalAppsOptedIn: f2, totalAssetsOptedIn: h2, totalCreatedApps: _, totalCreatedAssets: j2, appsLocalState: ie, appsTotalExtraPages: G, appsTotalSchema: Q, assets: N2, authAddr: U, createdApps: ee, createdAssets: re2, participation: le, rewardBase: H2, sigType: I, totalBoxBytes: K2, totalBoxes: P2 }) {
    super(), this.address = e, this.amount = t, this.amountWithoutPendingRewards = n, this.minBalance = i, this.pendingRewards = s, this.rewards = o, this.round = c, this.status = l2, this.totalAppsOptedIn = f2, this.totalAssetsOptedIn = h2, this.totalCreatedApps = _, this.totalCreatedAssets = j2, this.appsLocalState = ie, this.appsTotalExtraPages = G, this.appsTotalSchema = Q, this.assets = N2, this.authAddr = U, this.createdApps = ee, this.createdAssets = re2, this.participation = le, this.rewardBase = H2, this.sigType = I, this.totalBoxBytes = K2, this.totalBoxes = P2, this.attribute_map = { address: "address", amount: "amount", amountWithoutPendingRewards: "amount-without-pending-rewards", minBalance: "min-balance", pendingRewards: "pending-rewards", rewards: "rewards", round: "round", status: "status", totalAppsOptedIn: "total-apps-opted-in", totalAssetsOptedIn: "total-assets-opted-in", totalCreatedApps: "total-created-apps", totalCreatedAssets: "total-created-assets", appsLocalState: "apps-local-state", appsTotalExtraPages: "apps-total-extra-pages", appsTotalSchema: "apps-total-schema", assets: "assets", authAddr: "auth-addr", createdApps: "created-apps", createdAssets: "created-assets", participation: "participation", rewardBase: "reward-base", sigType: "sig-type", totalBoxBytes: "total-box-bytes", totalBoxes: "total-boxes" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address == "undefined")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount == "undefined")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["amount-without-pending-rewards"] == "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${e}`);
    if (typeof e["min-balance"] == "undefined")
      throw new Error(`Response is missing required field 'min-balance': ${e}`);
    if (typeof e["pending-rewards"] == "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${e}`);
    if (typeof e.rewards == "undefined")
      throw new Error(`Response is missing required field 'rewards': ${e}`);
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.status == "undefined")
      throw new Error(`Response is missing required field 'status': ${e}`);
    if (typeof e["total-apps-opted-in"] == "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${e}`);
    if (typeof e["total-assets-opted-in"] == "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${e}`);
    if (typeof e["total-created-apps"] == "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${e}`);
    if (typeof e["total-created-assets"] == "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${e}`);
    return new Pi({ address: e.address, amount: e.amount, amountWithoutPendingRewards: e["amount-without-pending-rewards"], minBalance: e["min-balance"], pendingRewards: e["pending-rewards"], rewards: e.rewards, round: e.round, status: e.status, totalAppsOptedIn: e["total-apps-opted-in"], totalAssetsOptedIn: e["total-assets-opted-in"], totalCreatedApps: e["total-created-apps"], totalCreatedAssets: e["total-created-assets"], appsLocalState: typeof e["apps-local-state"] != "undefined" ? e["apps-local-state"].map(Pn.from_obj_for_encoding) : void 0, appsTotalExtraPages: e["apps-total-extra-pages"], appsTotalSchema: typeof e["apps-total-schema"] != "undefined" ? xr.from_obj_for_encoding(e["apps-total-schema"]) : void 0, assets: typeof e.assets != "undefined" ? e.assets.map(zn.from_obj_for_encoding) : void 0, authAddr: e["auth-addr"], createdApps: typeof e["created-apps"] != "undefined" ? e["created-apps"].map(Zr.from_obj_for_encoding) : void 0, createdAssets: typeof e["created-assets"] != "undefined" ? e["created-assets"].map(qi.from_obj_for_encoding) : void 0, participation: typeof e.participation != "undefined" ? zi.from_obj_for_encoding(e.participation) : void 0, rewardBase: e["reward-base"], sigType: e["sig-type"], totalBoxBytes: e["total-box-bytes"], totalBoxes: e["total-boxes"] });
  }
}, co = class extends se {
  constructor({ round: e, appLocalState: t, createdApp: n }) {
    super(), this.round = e, this.appLocalState = t, this.createdApp = n, this.attribute_map = { round: "round", appLocalState: "app-local-state", createdApp: "created-app" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new co({ round: e.round, appLocalState: typeof e["app-local-state"] != "undefined" ? Pn.from_obj_for_encoding(e["app-local-state"]) : void 0, createdApp: typeof e["created-app"] != "undefined" ? Xr.from_obj_for_encoding(e["created-app"]) : void 0 });
  }
}, uo = class extends se {
  constructor({ round: e, assetHolding: t, createdAsset: n }) {
    super(), this.round = e, this.assetHolding = t, this.createdAsset = n, this.attribute_map = { round: "round", assetHolding: "asset-holding", createdAsset: "created-asset" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new uo({ round: e.round, assetHolding: typeof e["asset-holding"] != "undefined" ? zn.from_obj_for_encoding(e["asset-holding"]) : void 0, createdAsset: typeof e["created-asset"] != "undefined" ? qn.from_obj_for_encoding(e["created-asset"]) : void 0 });
  }
}, zi = class extends se {
  constructor({ selectionParticipationKey: e, voteFirstValid: t, voteKeyDilution: n, voteLastValid: i, voteParticipationKey: s, stateProofKey: o }) {
    super(), this.selectionParticipationKey = typeof e == "string" ? new Uint8Array(Rt.Buffer.from(e, "base64")) : e, this.voteFirstValid = t, this.voteKeyDilution = n, this.voteLastValid = i, this.voteParticipationKey = typeof s == "string" ? new Uint8Array(Rt.Buffer.from(s, "base64")) : s, this.stateProofKey = typeof o == "string" ? new Uint8Array(Rt.Buffer.from(o, "base64")) : o, this.attribute_map = { selectionParticipationKey: "selection-participation-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key", stateProofKey: "state-proof-key" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["selection-participation-key"] == "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${e}`);
    if (typeof e["vote-first-valid"] == "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${e}`);
    if (typeof e["vote-key-dilution"] == "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${e}`);
    if (typeof e["vote-last-valid"] == "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${e}`);
    if (typeof e["vote-participation-key"] == "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${e}`);
    return new zi({ selectionParticipationKey: e["selection-participation-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"], stateProofKey: e["state-proof-key"] });
  }
}, Un = class extends se {
  constructor({ address: e, delta: t }) {
    super(), this.address = e, this.delta = t, this.attribute_map = { address: "address", delta: "delta" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address == "undefined")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (!Array.isArray(e.delta))
      throw new Error(`Response is missing required array field 'delta': ${e}`);
    return new Un({ address: e.address, delta: e.delta.map(mn.from_obj_for_encoding) });
  }
}, Zr = class extends se {
  constructor({ id: e, params: t }) {
    super(), this.id = e, this.params = t, this.attribute_map = { id: "id", params: "params" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id == "undefined")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.params == "undefined")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new Zr({ id: e.id, params: Xr.from_obj_for_encoding(e.params) });
  }
}, Pn = class extends se {
  constructor({ id: e, schema: t, keyValue: n }) {
    super(), this.id = e, this.schema = t, this.keyValue = n, this.attribute_map = { id: "id", schema: "schema", keyValue: "key-value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id == "undefined")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.schema == "undefined")
      throw new Error(`Response is missing required field 'schema': ${e}`);
    return new Pn({ id: e.id, schema: xr.from_obj_for_encoding(e.schema), keyValue: typeof e["key-value"] != "undefined" ? e["key-value"].map(Zn.from_obj_for_encoding) : void 0 });
  }
}, Xr = class extends se {
  constructor({ approvalProgram: e, clearStateProgram: t, creator: n, extraProgramPages: i, globalState: s, globalStateSchema: o, localStateSchema: c }) {
    super(), this.approvalProgram = typeof e == "string" ? new Uint8Array(Rt.Buffer.from(e, "base64")) : e, this.clearStateProgram = typeof t == "string" ? new Uint8Array(Rt.Buffer.from(t, "base64")) : t, this.creator = n, this.extraProgramPages = i, this.globalState = s, this.globalStateSchema = o, this.localStateSchema = c, this.attribute_map = { approvalProgram: "approval-program", clearStateProgram: "clear-state-program", creator: "creator", extraProgramPages: "extra-program-pages", globalState: "global-state", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["approval-program"] == "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${e}`);
    if (typeof e["clear-state-program"] == "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${e}`);
    if (typeof e.creator == "undefined")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    return new Xr({ approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], creator: e.creator, extraProgramPages: e["extra-program-pages"], globalState: typeof e["global-state"] != "undefined" ? e["global-state"].map(Zn.from_obj_for_encoding) : void 0, globalStateSchema: typeof e["global-state-schema"] != "undefined" ? xr.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] != "undefined" ? xr.from_obj_for_encoding(e["local-state-schema"]) : void 0 });
  }
}, xr = class extends se {
  constructor({ numUint: e, numByteSlice: t }) {
    super(), this.numUint = e, this.numByteSlice = t, this.attribute_map = { numUint: "num-uint", numByteSlice: "num-byte-slice" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-uint"] == "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    if (typeof e["num-byte-slice"] == "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    return new xr({ numUint: e["num-uint"], numByteSlice: e["num-byte-slice"] });
  }
}, qi = class extends se {
  constructor({ index: e, params: t }) {
    super(), this.index = e, this.params = t, this.attribute_map = { index: "index", params: "params" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index == "undefined")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.params == "undefined")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new qi({ index: e.index, params: qn.from_obj_for_encoding(e.params) });
  }
}, zn = class extends se {
  constructor({ amount: e, assetId: t, isFrozen: n }) {
    super(), this.amount = e, this.assetId = t, this.isFrozen = n, this.attribute_map = { amount: "amount", assetId: "asset-id", isFrozen: "is-frozen" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount == "undefined")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] == "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["is-frozen"] == "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new zn({ amount: e.amount, assetId: e["asset-id"], isFrozen: e["is-frozen"] });
  }
}, qn = class extends se {
  constructor({ creator: e, decimals: t, total: n, clawback: i, defaultFrozen: s, freeze: o, manager: c, metadataHash: l2, name: f2, nameB64: h2, reserve: _, unitName: j2, unitNameB64: ie, url: G, urlB64: Q }) {
    super(), this.creator = e, this.decimals = t, this.total = n, this.clawback = i, this.defaultFrozen = s, this.freeze = o, this.manager = c, this.metadataHash = typeof l2 == "string" ? new Uint8Array(Rt.Buffer.from(l2, "base64")) : l2, this.name = f2, this.nameB64 = typeof h2 == "string" ? new Uint8Array(Rt.Buffer.from(h2, "base64")) : h2, this.reserve = _, this.unitName = j2, this.unitNameB64 = typeof ie == "string" ? new Uint8Array(Rt.Buffer.from(ie, "base64")) : ie, this.url = G, this.urlB64 = typeof Q == "string" ? new Uint8Array(Rt.Buffer.from(Q, "base64")) : Q, this.attribute_map = { creator: "creator", decimals: "decimals", total: "total", clawback: "clawback", defaultFrozen: "default-frozen", freeze: "freeze", manager: "manager", metadataHash: "metadata-hash", name: "name", nameB64: "name-b64", reserve: "reserve", unitName: "unit-name", unitNameB64: "unit-name-b64", url: "url", urlB64: "url-b64" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.creator == "undefined")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    if (typeof e.decimals == "undefined")
      throw new Error(`Response is missing required field 'decimals': ${e}`);
    if (typeof e.total == "undefined")
      throw new Error(`Response is missing required field 'total': ${e}`);
    return new qn({ creator: e.creator, decimals: e.decimals, total: e.total, clawback: e.clawback, defaultFrozen: e["default-frozen"], freeze: e.freeze, manager: e.manager, metadataHash: e["metadata-hash"], name: e.name, nameB64: e["name-b64"], reserve: e.reserve, unitName: e["unit-name"], unitNameB64: e["unit-name-b64"], url: e.url, urlB64: e["url-b64"] });
  }
}, fo = class extends se {
  constructor({ blockhash: e }) {
    super(), this.blockhash = e, this.attribute_map = { blockhash: "blockHash" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.blockHash == "undefined")
      throw new Error(`Response is missing required field 'blockHash': ${e}`);
    return new fo({ blockhash: e.blockHash });
  }
}, lo = class extends se {
  constructor({ block: e, cert: t }) {
    super(), this.block = e, this.cert = t, this.attribute_map = { block: "block", cert: "cert" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.block == "undefined")
      throw new Error(`Response is missing required field 'block': ${e}`);
    return new lo({ block: e.block, cert: e.cert });
  }
}, $n = class extends se {
  constructor({ name: e, value: t }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(Rt.Buffer.from(e, "base64")) : e, this.value = typeof t == "string" ? new Uint8Array(Rt.Buffer.from(t, "base64")) : t, this.attribute_map = { name: "name", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name == "undefined")
      throw new Error(`Response is missing required field 'name': ${e}`);
    if (typeof e.value == "undefined")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new $n({ name: e.name, value: e.value });
  }
}, $i = class extends se {
  constructor({ name: e }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(Rt.Buffer.from(e, "base64")) : e, this.attribute_map = { name: "name" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name == "undefined")
      throw new Error(`Response is missing required field 'name': ${e}`);
    return new $i({ name: e.name });
  }
}, Vn = class extends se {
  constructor({ boxes: e }) {
    super(), this.boxes = e, this.attribute_map = { boxes: "boxes" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.boxes))
      throw new Error(`Response is missing required array field 'boxes': ${e}`);
    return new Vn({ boxes: e.boxes.map($i.from_obj_for_encoding) });
  }
}, Vi = class extends se {
  constructor({ branch: e, buildNumber: t, channel: n, commitHash: i, major: s, minor: o }) {
    super(), this.branch = e, this.buildNumber = t, this.channel = n, this.commitHash = i, this.major = s, this.minor = o, this.attribute_map = { branch: "branch", buildNumber: "build_number", channel: "channel", commitHash: "commit_hash", major: "major", minor: "minor" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.branch == "undefined")
      throw new Error(`Response is missing required field 'branch': ${e}`);
    if (typeof e.build_number == "undefined")
      throw new Error(`Response is missing required field 'build_number': ${e}`);
    if (typeof e.channel == "undefined")
      throw new Error(`Response is missing required field 'channel': ${e}`);
    if (typeof e.commit_hash == "undefined")
      throw new Error(`Response is missing required field 'commit_hash': ${e}`);
    if (typeof e.major == "undefined")
      throw new Error(`Response is missing required field 'major': ${e}`);
    if (typeof e.minor == "undefined")
      throw new Error(`Response is missing required field 'minor': ${e}`);
    return new Vi({ branch: e.branch, buildNumber: e.build_number, channel: e.channel, commitHash: e.commit_hash, major: e.major, minor: e.minor });
  }
}, ho = class extends se {
  constructor({ hash: e, result: t, sourcemap: n }) {
    super(), this.hash = e, this.result = t, this.sourcemap = n, this.attribute_map = { hash: "hash", result: "result", sourcemap: "sourcemap" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.hash == "undefined")
      throw new Error(`Response is missing required field 'hash': ${e}`);
    if (typeof e.result == "undefined")
      throw new Error(`Response is missing required field 'result': ${e}`);
    return new ho({ hash: e.hash, result: e.result, sourcemap: e.sourcemap });
  }
}, po = class extends se {
  constructor({ result: e }) {
    super(), this.result = e, this.attribute_map = { result: "result" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.result == "undefined")
      throw new Error(`Response is missing required field 'result': ${e}`);
    return new po({ result: e.result });
  }
}, Gn = class extends se {
  constructor({ accounts: e, apps: t, latestTimestamp: n, protocolVersion: i, round: s, sources: o, txns: c }) {
    super(), this.accounts = e, this.apps = t, this.latestTimestamp = n, this.protocolVersion = i, this.round = s, this.sources = o, this.txns = c, this.attribute_map = { accounts: "accounts", apps: "apps", latestTimestamp: "latest-timestamp", protocolVersion: "protocol-version", round: "round", sources: "sources", txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.accounts))
      throw new Error(`Response is missing required array field 'accounts': ${e}`);
    if (!Array.isArray(e.apps))
      throw new Error(`Response is missing required array field 'apps': ${e}`);
    if (typeof e["latest-timestamp"] == "undefined")
      throw new Error(`Response is missing required field 'latest-timestamp': ${e}`);
    if (typeof e["protocol-version"] == "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${e}`);
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (!Array.isArray(e.sources))
      throw new Error(`Response is missing required array field 'sources': ${e}`);
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new Gn({ accounts: e.accounts.map(Pi.from_obj_for_encoding), apps: e.apps.map(Zr.from_obj_for_encoding), latestTimestamp: e["latest-timestamp"], protocolVersion: e["protocol-version"], round: e.round, sources: e.sources.map(Gi.from_obj_for_encoding), txns: e.txns });
  }
}, go = class extends se {
  constructor({ error: e, protocolVersion: t, txns: n }) {
    super(), this.error = e, this.protocolVersion = t, this.txns = n, this.attribute_map = { error: "error", protocolVersion: "protocol-version", txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.error == "undefined")
      throw new Error(`Response is missing required field 'error': ${e}`);
    if (typeof e["protocol-version"] == "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${e}`);
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new go({ error: e.error, protocolVersion: e["protocol-version"], txns: e.txns.map(Wi.from_obj_for_encoding) });
  }
}, Gi = class extends se {
  constructor({ fieldName: e, source: t, txnIndex: n, appIndex: i }) {
    super(), this.fieldName = e, this.source = t, this.txnIndex = n, this.appIndex = i, this.attribute_map = { fieldName: "field-name", source: "source", txnIndex: "txn-index", appIndex: "app-index" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["field-name"] == "undefined")
      throw new Error(`Response is missing required field 'field-name': ${e}`);
    if (typeof e.source == "undefined")
      throw new Error(`Response is missing required field 'source': ${e}`);
    if (typeof e["txn-index"] == "undefined")
      throw new Error(`Response is missing required field 'txn-index': ${e}`);
    if (typeof e["app-index"] == "undefined")
      throw new Error(`Response is missing required field 'app-index': ${e}`);
    return new Gi({ fieldName: e["field-name"], source: e.source, txnIndex: e["txn-index"], appIndex: e["app-index"] });
  }
}, Wn = class extends se {
  constructor({ line: e, pc: t, stack: n, error: i, scratch: s }) {
    super(), this.line = e, this.pc = t, this.stack = n, this.error = i, this.scratch = s, this.attribute_map = { line: "line", pc: "pc", stack: "stack", error: "error", scratch: "scratch" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.line == "undefined")
      throw new Error(`Response is missing required field 'line': ${e}`);
    if (typeof e.pc == "undefined")
      throw new Error(`Response is missing required field 'pc': ${e}`);
    if (!Array.isArray(e.stack))
      throw new Error(`Response is missing required array field 'stack': ${e}`);
    return new Wn({ line: e.line, pc: e.pc, stack: e.stack.map(yn.from_obj_for_encoding), error: e.error, scratch: typeof e.scratch != "undefined" ? e.scratch.map(yn.from_obj_for_encoding) : void 0 });
  }
}, Wi = class extends se {
  constructor({ disassembly: e, appCallMessages: t, appCallTrace: n, budgetAdded: i, budgetConsumed: s, globalDelta: o, localDeltas: c, logicSigDisassembly: l2, logicSigMessages: f2, logicSigTrace: h2, logs: _ }) {
    super(), this.disassembly = e, this.appCallMessages = t, this.appCallTrace = n, this.budgetAdded = i, this.budgetConsumed = s, this.globalDelta = o, this.localDeltas = c, this.logicSigDisassembly = l2, this.logicSigMessages = f2, this.logicSigTrace = h2, this.logs = _, this.attribute_map = { disassembly: "disassembly", appCallMessages: "app-call-messages", appCallTrace: "app-call-trace", budgetAdded: "budget-added", budgetConsumed: "budget-consumed", globalDelta: "global-delta", localDeltas: "local-deltas", logicSigDisassembly: "logic-sig-disassembly", logicSigMessages: "logic-sig-messages", logicSigTrace: "logic-sig-trace", logs: "logs" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.disassembly))
      throw new Error(`Response is missing required array field 'disassembly': ${e}`);
    return new Wi({ disassembly: e.disassembly, appCallMessages: e["app-call-messages"], appCallTrace: typeof e["app-call-trace"] != "undefined" ? e["app-call-trace"].map(Wn.from_obj_for_encoding) : void 0, budgetAdded: e["budget-added"], budgetConsumed: e["budget-consumed"], globalDelta: typeof e["global-delta"] != "undefined" ? e["global-delta"].map(mn.from_obj_for_encoding) : void 0, localDeltas: typeof e["local-deltas"] != "undefined" ? e["local-deltas"].map(Un.from_obj_for_encoding) : void 0, logicSigDisassembly: e["logic-sig-disassembly"], logicSigMessages: e["logic-sig-messages"], logicSigTrace: typeof e["logic-sig-trace"] != "undefined" ? e["logic-sig-trace"].map(Wn.from_obj_for_encoding) : void 0, logs: e.logs });
  }
}, mo = class extends se {
  constructor({ message: e, data: t }) {
    super(), this.message = e, this.data = t, this.attribute_map = { message: "message", data: "data" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.message == "undefined")
      throw new Error(`Response is missing required field 'message': ${e}`);
    return new mo({ message: e.message, data: e.data });
  }
}, Ki = class extends se {
  constructor({ action: e, bytes: t, uint: n }) {
    super(), this.action = e, this.bytes = t, this.uint = n, this.attribute_map = { action: "action", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.action == "undefined")
      throw new Error(`Response is missing required field 'action': ${e}`);
    return new Ki({ action: e.action, bytes: e.bytes, uint: e.uint });
  }
}, mn = class extends se {
  constructor({ key: e, value: t }) {
    super(), this.key = e, this.value = t, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key == "undefined")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value == "undefined")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new mn({ key: e.key, value: Ki.from_obj_for_encoding(e.value) });
  }
}, Kn = class extends se {
  constructor({ offset: e }) {
    super(), this.offset = e, this.attribute_map = { offset: "offset" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.offset == "undefined")
      throw new Error(`Response is missing required field 'offset': ${e}`);
    return new Kn({ offset: e.offset });
  }
}, Hn = class extends se {
  constructor({ round: e }) {
    super(), this.round = e, this.attribute_map = { round: "round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new Hn({ round: e.round });
  }
}, yo = class extends se {
  constructor({ key: e, value: t }) {
    super(), this.key = typeof e == "string" ? new Uint8Array(Rt.Buffer.from(e, "base64")) : e, this.value = typeof t == "string" ? new Uint8Array(Rt.Buffer.from(t, "base64")) : t, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    return new yo({ key: e.key, value: e.value });
  }
}, Hi = class extends se {
  constructor({ delta: e, ids: t }) {
    super(), this.delta = e, this.ids = t, this.attribute_map = { delta: "delta", ids: "ids" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.delta == "undefined")
      throw new Error(`Response is missing required field 'delta': ${e}`);
    if (!Array.isArray(e.ids))
      throw new Error(`Response is missing required array field 'ids': ${e}`);
    return new Hi({ delta: e.delta, ids: e.ids });
  }
}, xo = class extends se {
  constructor({ index: e, proof: t, treedepth: n }) {
    super(), this.index = e, this.proof = typeof t == "string" ? new Uint8Array(Rt.Buffer.from(t, "base64")) : t, this.treedepth = n, this.attribute_map = { index: "index", proof: "proof", treedepth: "treedepth" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index == "undefined")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.proof == "undefined")
      throw new Error(`Response is missing required field 'proof': ${e}`);
    if (typeof e.treedepth == "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${e}`);
    return new xo({ index: e.index, proof: e.proof, treedepth: e.treedepth });
  }
}, wo = class extends se {
  constructor({ catchupTime: e, lastRound: t, lastVersion: n, nextVersion: i, nextVersionRound: s, nextVersionSupported: o, stoppedAtUnsupportedRound: c, timeSinceLastRound: l2, catchpoint: f2, catchpointAcquiredBlocks: h2, catchpointProcessedAccounts: _, catchpointProcessedKvs: j2, catchpointTotalAccounts: ie, catchpointTotalBlocks: G, catchpointTotalKvs: Q, catchpointVerifiedAccounts: N2, catchpointVerifiedKvs: U, lastCatchpoint: ee, upgradeDelay: re2, upgradeNextProtocolVoteBefore: le, upgradeNoVotes: H2, upgradeNodeVote: I, upgradeVoteRounds: K2, upgradeVotes: P2, upgradeVotesRequired: k2, upgradeYesVotes: te2 }) {
    super(), this.catchupTime = e, this.lastRound = t, this.lastVersion = n, this.nextVersion = i, this.nextVersionRound = s, this.nextVersionSupported = o, this.stoppedAtUnsupportedRound = c, this.timeSinceLastRound = l2, this.catchpoint = f2, this.catchpointAcquiredBlocks = h2, this.catchpointProcessedAccounts = _, this.catchpointProcessedKvs = j2, this.catchpointTotalAccounts = ie, this.catchpointTotalBlocks = G, this.catchpointTotalKvs = Q, this.catchpointVerifiedAccounts = N2, this.catchpointVerifiedKvs = U, this.lastCatchpoint = ee, this.upgradeDelay = re2, this.upgradeNextProtocolVoteBefore = le, this.upgradeNoVotes = H2, this.upgradeNodeVote = I, this.upgradeVoteRounds = K2, this.upgradeVotes = P2, this.upgradeVotesRequired = k2, this.upgradeYesVotes = te2, this.attribute_map = { catchupTime: "catchup-time", lastRound: "last-round", lastVersion: "last-version", nextVersion: "next-version", nextVersionRound: "next-version-round", nextVersionSupported: "next-version-supported", stoppedAtUnsupportedRound: "stopped-at-unsupported-round", timeSinceLastRound: "time-since-last-round", catchpoint: "catchpoint", catchpointAcquiredBlocks: "catchpoint-acquired-blocks", catchpointProcessedAccounts: "catchpoint-processed-accounts", catchpointProcessedKvs: "catchpoint-processed-kvs", catchpointTotalAccounts: "catchpoint-total-accounts", catchpointTotalBlocks: "catchpoint-total-blocks", catchpointTotalKvs: "catchpoint-total-kvs", catchpointVerifiedAccounts: "catchpoint-verified-accounts", catchpointVerifiedKvs: "catchpoint-verified-kvs", lastCatchpoint: "last-catchpoint", upgradeDelay: "upgrade-delay", upgradeNextProtocolVoteBefore: "upgrade-next-protocol-vote-before", upgradeNoVotes: "upgrade-no-votes", upgradeNodeVote: "upgrade-node-vote", upgradeVoteRounds: "upgrade-vote-rounds", upgradeVotes: "upgrade-votes", upgradeVotesRequired: "upgrade-votes-required", upgradeYesVotes: "upgrade-yes-votes" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["catchup-time"] == "undefined")
      throw new Error(`Response is missing required field 'catchup-time': ${e}`);
    if (typeof e["last-round"] == "undefined")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (typeof e["last-version"] == "undefined")
      throw new Error(`Response is missing required field 'last-version': ${e}`);
    if (typeof e["next-version"] == "undefined")
      throw new Error(`Response is missing required field 'next-version': ${e}`);
    if (typeof e["next-version-round"] == "undefined")
      throw new Error(`Response is missing required field 'next-version-round': ${e}`);
    if (typeof e["next-version-supported"] == "undefined")
      throw new Error(`Response is missing required field 'next-version-supported': ${e}`);
    if (typeof e["stopped-at-unsupported-round"] == "undefined")
      throw new Error(`Response is missing required field 'stopped-at-unsupported-round': ${e}`);
    if (typeof e["time-since-last-round"] == "undefined")
      throw new Error(`Response is missing required field 'time-since-last-round': ${e}`);
    return new wo({ catchupTime: e["catchup-time"], lastRound: e["last-round"], lastVersion: e["last-version"], nextVersion: e["next-version"], nextVersionRound: e["next-version-round"], nextVersionSupported: e["next-version-supported"], stoppedAtUnsupportedRound: e["stopped-at-unsupported-round"], timeSinceLastRound: e["time-since-last-round"], catchpoint: e.catchpoint, catchpointAcquiredBlocks: e["catchpoint-acquired-blocks"], catchpointProcessedAccounts: e["catchpoint-processed-accounts"], catchpointProcessedKvs: e["catchpoint-processed-kvs"], catchpointTotalAccounts: e["catchpoint-total-accounts"], catchpointTotalBlocks: e["catchpoint-total-blocks"], catchpointTotalKvs: e["catchpoint-total-kvs"], catchpointVerifiedAccounts: e["catchpoint-verified-accounts"], catchpointVerifiedKvs: e["catchpoint-verified-kvs"], lastCatchpoint: e["last-catchpoint"], upgradeDelay: e["upgrade-delay"], upgradeNextProtocolVoteBefore: e["upgrade-next-protocol-vote-before"], upgradeNoVotes: e["upgrade-no-votes"], upgradeNodeVote: e["upgrade-node-vote"], upgradeVoteRounds: e["upgrade-vote-rounds"], upgradeVotes: e["upgrade-votes"], upgradeVotesRequired: e["upgrade-votes-required"], upgradeYesVotes: e["upgrade-yes-votes"] });
  }
}, Yn = class extends se {
  constructor({ poolError: e, txn: t, applicationIndex: n, assetClosingAmount: i, assetIndex: s, closeRewards: o, closingAmount: c, confirmedRound: l2, globalStateDelta: f2, innerTxns: h2, localStateDelta: _, logs: j2, receiverRewards: ie, senderRewards: G }) {
    super(), this.poolError = e, this.txn = t, this.applicationIndex = n, this.assetClosingAmount = i, this.assetIndex = s, this.closeRewards = o, this.closingAmount = c, this.confirmedRound = l2, this.globalStateDelta = f2, this.innerTxns = h2, this.localStateDelta = _, this.logs = j2, this.receiverRewards = ie, this.senderRewards = G, this.attribute_map = { poolError: "pool-error", txn: "txn", applicationIndex: "application-index", assetClosingAmount: "asset-closing-amount", assetIndex: "asset-index", closeRewards: "close-rewards", closingAmount: "closing-amount", confirmedRound: "confirmed-round", globalStateDelta: "global-state-delta", innerTxns: "inner-txns", localStateDelta: "local-state-delta", logs: "logs", receiverRewards: "receiver-rewards", senderRewards: "sender-rewards" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["pool-error"] == "undefined")
      throw new Error(`Response is missing required field 'pool-error': ${e}`);
    if (typeof e.txn == "undefined")
      throw new Error(`Response is missing required field 'txn': ${e}`);
    return new Yn({ poolError: e["pool-error"], txn: e.txn, applicationIndex: e["application-index"], assetClosingAmount: e["asset-closing-amount"], assetIndex: e["asset-index"], closeRewards: e["close-rewards"], closingAmount: e["closing-amount"], confirmedRound: e["confirmed-round"], globalStateDelta: typeof e["global-state-delta"] != "undefined" ? e["global-state-delta"].map(mn.from_obj_for_encoding) : void 0, innerTxns: typeof e["inner-txns"] != "undefined" ? e["inner-txns"].map(Yn.from_obj_for_encoding) : void 0, localStateDelta: typeof e["local-state-delta"] != "undefined" ? e["local-state-delta"].map(Un.from_obj_for_encoding) : void 0, logs: e.logs, receiverRewards: e["receiver-rewards"], senderRewards: e["sender-rewards"] });
  }
}, bo = class extends se {
  constructor({ topTransactions: e, totalTransactions: t }) {
    super(), this.topTransactions = e, this.totalTransactions = t, this.attribute_map = { topTransactions: "top-transactions", totalTransactions: "total-transactions" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["top-transactions"]))
      throw new Error(`Response is missing required array field 'top-transactions': ${e}`);
    if (typeof e["total-transactions"] == "undefined")
      throw new Error(`Response is missing required field 'total-transactions': ${e}`);
    return new bo({ topTransactions: e["top-transactions"], totalTransactions: e["total-transactions"] });
  }
}, vo = class extends se {
  constructor({ txid: e }) {
    super(), this.txid = e, this.attribute_map = { txid: "txId" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.txId == "undefined")
      throw new Error(`Response is missing required field 'txId': ${e}`);
    return new vo({ txid: e.txId });
  }
}, Qr = class extends se {
  constructor({ txnGroups: e, allowEmptySignatures: t, allowMoreLogging: n, extraOpcodeBudget: i }) {
    super(), this.txnGroups = e, this.allowEmptySignatures = t, this.allowMoreLogging = n, this.extraOpcodeBudget = i, this.attribute_map = { txnGroups: "txn-groups", allowEmptySignatures: "allow-empty-signatures", allowMoreLogging: "allow-more-logging", extraOpcodeBudget: "extra-opcode-budget" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["txn-groups"]))
      throw new Error(`Response is missing required array field 'txn-groups': ${e}`);
    return new Qr({ txnGroups: e["txn-groups"].map(kr.from_obj_for_encoding), allowEmptySignatures: e["allow-empty-signatures"], allowMoreLogging: e["allow-more-logging"], extraOpcodeBudget: e["extra-opcode-budget"] });
  }
}, kr = class extends se {
  constructor({ txns: e }) {
    super(), this.txns = e, this.attribute_map = { txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new kr({ txns: e.txns });
  }
}, Jn = class extends se {
  constructor({ lastRound: e, txnGroups: t, version: n, evalOverrides: i }) {
    super(), this.lastRound = e, this.txnGroups = t, this.version = n, this.evalOverrides = i, this.attribute_map = { lastRound: "last-round", txnGroups: "txn-groups", version: "version", evalOverrides: "eval-overrides" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["last-round"] == "undefined")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (!Array.isArray(e["txn-groups"]))
      throw new Error(`Response is missing required array field 'txn-groups': ${e}`);
    if (typeof e.version == "undefined")
      throw new Error(`Response is missing required field 'version': ${e}`);
    return new Jn({ lastRound: e["last-round"], txnGroups: e["txn-groups"].map(Yi.from_obj_for_encoding), version: e.version, evalOverrides: typeof e["eval-overrides"] != "undefined" ? Zi.from_obj_for_encoding(e["eval-overrides"]) : void 0 });
  }
}, Yi = class extends se {
  constructor({ txnResults: e, appBudgetAdded: t, appBudgetConsumed: n, failedAt: i, failureMessage: s }) {
    super(), this.txnResults = e, this.appBudgetAdded = t, this.appBudgetConsumed = n, this.failedAt = i, this.failureMessage = s, this.attribute_map = { txnResults: "txn-results", appBudgetAdded: "app-budget-added", appBudgetConsumed: "app-budget-consumed", failedAt: "failed-at", failureMessage: "failure-message" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["txn-results"]))
      throw new Error(`Response is missing required array field 'txn-results': ${e}`);
    return new Yi({ txnResults: e["txn-results"].map(Ji.from_obj_for_encoding), appBudgetAdded: e["app-budget-added"], appBudgetConsumed: e["app-budget-consumed"], failedAt: e["failed-at"], failureMessage: e["failure-message"] });
  }
}, Ji = class extends se {
  constructor({ txnResult: e, appBudgetConsumed: t, logicSigBudgetConsumed: n }) {
    super(), this.txnResult = e, this.appBudgetConsumed = t, this.logicSigBudgetConsumed = n, this.attribute_map = { txnResult: "txn-result", appBudgetConsumed: "app-budget-consumed", logicSigBudgetConsumed: "logic-sig-budget-consumed" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["txn-result"] == "undefined")
      throw new Error(`Response is missing required field 'txn-result': ${e}`);
    return new Ji({ txnResult: Yn.from_obj_for_encoding(e["txn-result"]), appBudgetConsumed: e["app-budget-consumed"], logicSigBudgetConsumed: e["logic-sig-budget-consumed"] });
  }
}, Zi = class extends se {
  constructor({ allowEmptySignatures: e, extraOpcodeBudget: t, maxLogCalls: n, maxLogSize: i }) {
    super(), this.allowEmptySignatures = e, this.extraOpcodeBudget = t, this.maxLogCalls = n, this.maxLogSize = i, this.attribute_map = { allowEmptySignatures: "allow-empty-signatures", extraOpcodeBudget: "extra-opcode-budget", maxLogCalls: "max-log-calls", maxLogSize: "max-log-size" };
  }
  static from_obj_for_encoding(e) {
    return new Zi({ allowEmptySignatures: e["allow-empty-signatures"], extraOpcodeBudget: e["extra-opcode-budget"], maxLogCalls: e["max-log-calls"], maxLogSize: e["max-log-size"] });
  }
}, _o = class extends se {
  constructor({ message: e, stateproof: t }) {
    super(), this.message = e, this.stateproof = typeof t == "string" ? new Uint8Array(Rt.Buffer.from(t, "base64")) : t, this.attribute_map = { message: "Message", stateproof: "StateProof" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.Message == "undefined")
      throw new Error(`Response is missing required field 'Message': ${e}`);
    if (typeof e.StateProof == "undefined")
      throw new Error(`Response is missing required field 'StateProof': ${e}`);
    return new _o({ message: Xi.from_obj_for_encoding(e.Message), stateproof: e.StateProof });
  }
}, Xi = class extends se {
  constructor({ blockheaderscommitment: e, firstattestedround: t, lastattestedround: n, lnprovenweight: i, voterscommitment: s }) {
    super(), this.blockheaderscommitment = typeof e == "string" ? new Uint8Array(Rt.Buffer.from(e, "base64")) : e, this.firstattestedround = t, this.lastattestedround = n, this.lnprovenweight = i, this.voterscommitment = typeof s == "string" ? new Uint8Array(Rt.Buffer.from(s, "base64")) : s, this.attribute_map = { blockheaderscommitment: "BlockHeadersCommitment", firstattestedround: "FirstAttestedRound", lastattestedround: "LastAttestedRound", lnprovenweight: "LnProvenWeight", voterscommitment: "VotersCommitment" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.BlockHeadersCommitment == "undefined")
      throw new Error(`Response is missing required field 'BlockHeadersCommitment': ${e}`);
    if (typeof e.FirstAttestedRound == "undefined")
      throw new Error(`Response is missing required field 'FirstAttestedRound': ${e}`);
    if (typeof e.LastAttestedRound == "undefined")
      throw new Error(`Response is missing required field 'LastAttestedRound': ${e}`);
    if (typeof e.LnProvenWeight == "undefined")
      throw new Error(`Response is missing required field 'LnProvenWeight': ${e}`);
    if (typeof e.VotersCommitment == "undefined")
      throw new Error(`Response is missing required field 'VotersCommitment': ${e}`);
    return new Xi({ blockheaderscommitment: e.BlockHeadersCommitment, firstattestedround: e.FirstAttestedRound, lastattestedround: e.LastAttestedRound, lnprovenweight: e.LnProvenWeight, voterscommitment: e.VotersCommitment });
  }
}, Ao = class extends se {
  constructor({ currentRound: e, onlineMoney: t, totalMoney: n }) {
    super(), this.currentRound = e, this.onlineMoney = t, this.totalMoney = n, this.attribute_map = { currentRound: "current_round", onlineMoney: "online-money", totalMoney: "total-money" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.current_round == "undefined")
      throw new Error(`Response is missing required field 'current_round': ${e}`);
    if (typeof e["online-money"] == "undefined")
      throw new Error(`Response is missing required field 'online-money': ${e}`);
    if (typeof e["total-money"] == "undefined")
      throw new Error(`Response is missing required field 'total-money': ${e}`);
    return new Ao({ currentRound: e.current_round, onlineMoney: e["online-money"], totalMoney: e["total-money"] });
  }
}, Zn = class extends se {
  constructor({ key: e, value: t }) {
    super(), this.key = e, this.value = t, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key == "undefined")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value == "undefined")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new Zn({ key: e.key, value: yn.from_obj_for_encoding(e.value) });
  }
}, yn = class extends se {
  constructor({ type: e, bytes: t, uint: n }) {
    super(), this.type = e, this.bytes = t, this.uint = n, this.attribute_map = { type: "type", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.type == "undefined")
      throw new Error(`Response is missing required field 'type': ${e}`);
    if (typeof e.bytes == "undefined")
      throw new Error(`Response is missing required field 'bytes': ${e}`);
    if (typeof e.uint == "undefined")
      throw new Error(`Response is missing required field 'uint': ${e}`);
    return new yn({ type: e.type, bytes: e.bytes, uint: e.uint });
  }
}, Xn = class extends se {
  constructor({ deltas: e }) {
    super(), this.deltas = e, this.attribute_map = { deltas: "deltas" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.Deltas))
      throw new Error(`Response is missing required array field 'Deltas': ${e}`);
    return new Xn({ deltas: e.Deltas.map(Hi.from_obj_for_encoding) });
  }
}, Eo = class extends se {
  constructor({ consensusVersion: e, fee: t, genesisHash: n, genesisId: i, lastRound: s, minFee: o }) {
    super(), this.consensusVersion = e, this.fee = t, this.genesisHash = typeof n == "string" ? new Uint8Array(Rt.Buffer.from(n, "base64")) : n, this.genesisId = i, this.lastRound = s, this.minFee = o, this.attribute_map = { consensusVersion: "consensus-version", fee: "fee", genesisHash: "genesis-hash", genesisId: "genesis-id", lastRound: "last-round", minFee: "min-fee" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["consensus-version"] == "undefined")
      throw new Error(`Response is missing required field 'consensus-version': ${e}`);
    if (typeof e.fee == "undefined")
      throw new Error(`Response is missing required field 'fee': ${e}`);
    if (typeof e["genesis-hash"] == "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${e}`);
    if (typeof e["genesis-id"] == "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${e}`);
    if (typeof e["last-round"] == "undefined")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (typeof e["min-fee"] == "undefined")
      throw new Error(`Response is missing required field 'min-fee': ${e}`);
    return new Eo({ consensusVersion: e["consensus-version"], fee: e.fee, genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], lastRound: e["last-round"], minFee: e["min-fee"] });
  }
}, Io = class extends se {
  constructor({ idx: e, proof: t, stibhash: n, treedepth: i, hashtype: s }) {
    super(), this.idx = e, this.proof = typeof t == "string" ? new Uint8Array(Rt.Buffer.from(t, "base64")) : t, this.stibhash = typeof n == "string" ? new Uint8Array(Rt.Buffer.from(n, "base64")) : n, this.treedepth = i, this.hashtype = s, this.attribute_map = { idx: "idx", proof: "proof", stibhash: "stibhash", treedepth: "treedepth", hashtype: "hashtype" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.idx == "undefined")
      throw new Error(`Response is missing required field 'idx': ${e}`);
    if (typeof e.proof == "undefined")
      throw new Error(`Response is missing required field 'proof': ${e}`);
    if (typeof e.stibhash == "undefined")
      throw new Error(`Response is missing required field 'stibhash': ${e}`);
    if (typeof e.treedepth == "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${e}`);
    return new Io({ idx: e.idx, proof: e.proof, stibhash: e.stibhash, treedepth: e.treedepth, hashtype: e.hashtype });
  }
}, To = class extends se {
  constructor({ build: e, genesisHashB64: t, genesisId: n, versions: i }) {
    super(), this.build = e, this.genesisHashB64 = typeof t == "string" ? new Uint8Array(Rt.Buffer.from(t, "base64")) : t, this.genesisId = n, this.versions = i, this.attribute_map = { build: "build", genesisHashB64: "genesis_hash_b64", genesisId: "genesis_id", versions: "versions" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.build == "undefined")
      throw new Error(`Response is missing required field 'build': ${e}`);
    if (typeof e.genesis_hash_b64 == "undefined")
      throw new Error(`Response is missing required field 'genesis_hash_b64': ${e}`);
    if (typeof e.genesis_id == "undefined")
      throw new Error(`Response is missing required field 'genesis_id': ${e}`);
    if (!Array.isArray(e.versions))
      throw new Error(`Response is missing required array field 'versions': ${e}`);
    return new To({ build: Vi.from_obj_for_encoding(e.build), genesisHashB64: e.genesis_hash_b64, genesisId: e.genesis_id, versions: e.versions });
  }
};
var oe = class {
  constructor(e, t) {
    this.c = e, this.query = {}, this.intDecoding = t || ln.DEFAULT;
  }
  prepare(e) {
    return e;
  }
  async do(e = {}) {
    let t = {};
    this.intDecoding !== "default" && (t.intDecoding = this.intDecoding);
    let n = await this.c.get(this.path(), this.query, e, t);
    return this.prepare(n.body);
  }
  async doRaw(e = {}) {
    return (await this.c.get(this.path(), this.query, e, {}, false)).body;
  }
  setIntDecoding(e) {
    if (e !== "default" && e !== "safe" && e !== "mixed" && e !== "bigint")
      throw new Error(`Invalid method for int decoding: ${e}`);
    return this.intDecoding = e, this;
  }
};
var So = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.account = n, this.account = n;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
var Fo = class extends oe {
  constructor(e, t, n, i) {
    super(e, t), this.account = n, this.assetID = i, this.account = n, this.assetID = i;
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
};
var No = class extends oe {
  constructor(e, t, n, i) {
    super(e, t), this.account = n, this.applicationID = i, this.account = n, this.applicationID = i;
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
};
var Oo = class extends oe {
  constructor(e, t) {
    if (super(e), !Number.isInteger(t))
      throw Error("roundNumber should be an integer");
    this.round = t, this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return St(e);
  }
};
var yd = lt(Tt());
function df(r = {}) {
  let e = r;
  return Object.keys(e).every((t) => t.toLowerCase() !== "content-type") && (e = at({}, r), e["Content-Type"] = "text/plain"), e;
}
var Do = class extends oe {
  constructor(e, t) {
    super(e), this.source = t, this.source = t;
  }
  path() {
    return "/v2/teal/compile";
  }
  sourcemap(e = true) {
    return this.query.sourcemap = e, this;
  }
  async do(e = {}) {
    let t = df(e);
    return (await this.c.post(this.path(), yd.Buffer.from(this.source), t, this.query)).body;
  }
};
var xd = lt(Tt());
var Mo = class extends oe {
  constructor(e, t) {
    super(e), this.blob = Mt(t.get_obj_for_encoding(true));
  }
  path() {
    return "/v2/teal/dryrun";
  }
  async do(e = {}) {
    let t = df(e);
    return (await this.c.post(this.path(), xd.Buffer.from(this.blob), t)).body;
  }
};
var Ro = class extends oe {
  path() {
    return "/genesis";
  }
};
var Co = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
};
var ko = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
};
var jo = class extends oe {
  constructor(e, t, n) {
    if (super(e, t), !Number.isInteger(n))
      throw Error("roundNumber should be an integer");
    this.round = n;
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
};
var wd = lt(Tt());
var Bo = class extends oe {
  constructor(e, t, n, i) {
    super(e, t), this.index = n, this.index = n;
    let s = wd.Buffer.from(i).toString("base64");
    this.query.name = encodeURI(`b64:${s}`);
  }
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  prepare(e) {
    return $n.from_obj_for_encoding(e);
  }
};
var Lo = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n, this.query.max = 0;
  }
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  max(e) {
    return this.query.max = e, this;
  }
  prepare(e) {
    return Vn.from_obj_for_encoding(e);
  }
};
var Uo = class extends oe {
  path() {
    return "/health";
  }
  async do(e = {}) {
    let t = await this.c.get(this.path(), {}, e);
    if (!t.ok)
      throw new Error(`Health response: ${t.status}`);
    return {};
  }
};
var Po = class extends oe {
  constructor(e, t) {
    super(e), this.txid = t, this.txid = t, this.query.format = "msgpack";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return St(e);
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  max(e) {
    return this.query.max = e, this;
  }
};
var zo = class extends oe {
  constructor(e) {
    super(e), this.query.format = "msgpack";
  }
  path() {
    return "/v2/transactions/pending";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return St(e);
  }
  max(e) {
    return this.query.max = e, this;
  }
};
var qo = class extends oe {
  constructor(e, t) {
    super(e), this.address = t, this.address = t, this.query.format = "msgpack";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return St(e);
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  max(e) {
    return this.query.max = e, this;
  }
};
var $o = class extends oe {
  constructor(e, t, n, i) {
    super(e, t), this.round = n, this.txID = i, this.round = n, this.txID = i;
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  hashType(e) {
    return this.query.hashtype = e, this;
  }
};
var vd = lt(Tt());
function nm(r = {}) {
  let e = r;
  return Object.keys(e).every((t) => t.toLowerCase() !== "content-type") && (e = at({}, r), e["Content-Type"] = "application/x-binary"), e;
}
function bd(r) {
  return r && r.byteLength !== void 0;
}
var Vo = class extends oe {
  constructor(e, t) {
    super(e);
    let n = t;
    if (Array.isArray(t)) {
      if (!t.every(bd))
        throw new TypeError("Array elements must be byte arrays");
      n = Nt(...t);
    } else if (!bd(n))
      throw new TypeError("Argument must be byte array");
    this.txnBytesToPost = n;
  }
  path() {
    return "/v2/transactions";
  }
  async do(e = {}) {
    let t = nm(e);
    return (await this.c.post(this.path(), vd.Buffer.from(this.txnBytesToPost), t)).body;
  }
};
var Go = class extends oe {
  path() {
    return "/v2/status";
  }
};
var Wo = class extends oe {
  constructor(e, t, n) {
    if (super(e, t), this.round = n, !Number.isInteger(n))
      throw Error("round should be an integer");
    this.round = n;
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
};
var Ko = class extends oe {
  path() {
    return "/v2/transactions/params";
  }
  prepare(e) {
    return { flatFee: false, fee: e.fee, firstRound: e["last-round"], lastRound: e["last-round"] + 1e3, genesisID: e["genesis-id"], genesisHash: e["genesis-hash"], minFee: e["min-fee"] };
  }
};
var Ho = class extends oe {
  path() {
    return "/v2/ledger/supply";
  }
};
var Yo = class extends oe {
  path() {
    return "/versions";
  }
};
var Jo = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.round = n, this.round = n;
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
};
var Zo = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.round = n, this.round = n;
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
};
var Xo = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.round = n, this.round = n;
  }
  path() {
    return `/v2/ledger/sync/${this.round}`;
  }
  async do(e = {}) {
    return (await this.c.post(this.path(), e)).body;
  }
};
var Qo = class extends oe {
  path() {
    return "/v2/ledger/sync";
  }
  prepare(e) {
    return Hn.from_obj_for_encoding(e);
  }
};
var ea = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.offset = n, this.offset = n;
  }
  path() {
    return `/v2/devmode/blocks/offset/${this.offset}`;
  }
  async do(e = {}) {
    return (await this.c.post(this.path(), e)).body;
  }
};
var ta = class extends oe {
  path() {
    return "/v2/devmode/blocks/offset";
  }
  prepare(e) {
    return Kn.from_obj_for_encoding(e);
  }
};
var _d2 = lt(Tt());
function im(r = {}) {
  let e = r;
  return Object.keys(e).every((t) => t.toLowerCase() !== "content-type") && (e = at({}, r), e["Content-Type"] = "text/plain"), e;
}
var ra = class extends oe {
  constructor(e, t) {
    super(e), this.source = t, this.source = t;
  }
  path() {
    return "/v2/teal/disassemble";
  }
  async do(e = {}) {
    let t = im(e);
    return (await this.c.post(this.path(), _d2.Buffer.from(this.source), t, this.query)).body;
  }
};
var Ad = lt(Tt());
function sm(r = {}) {
  let e = r;
  return Object.keys(e).every((t) => t.toLowerCase() !== "content-type") && (e = at({}, r), e["Content-Type"] = "application/msgpack"), e;
}
var na = class extends oe {
  constructor(e, t) {
    super(e), this.query.format = "msgpack", this.requestBytes = of(t.get_obj_for_encoding(true));
  }
  path() {
    return "/v2/transactions/simulate";
  }
  async do(e = {}) {
    let t = sm(e), n = await this.c.post(this.path(), Ad.Buffer.from(this.requestBytes), t, this.query, false);
    return this.prepare(n.body);
  }
  prepare(e) {
    let t = St(e);
    return Jn.from_obj_for_encoding(t);
  }
};
var ia = class extends oe {
  path() {
    return "/ready";
  }
};
var sa = class extends oe {
  path() {
    return "/v2/ledger/sync";
  }
  async do(e = {}) {
    return (await this.c.delete(this.path(), e)).body;
  }
};
var oa = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.id = n, this.id = n;
  }
  path() {
    return `/v2/deltas/txn/group/${this.id}`;
  }
};
var aa = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.round = n, this.round = n;
  }
  path() {
    return `/v2/deltas/${this.round}`;
  }
};
var ca = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.round = n, this.round = n;
  }
  path() {
    return `/v2/deltas/${this.round}/txn/group`;
  }
  prepare(e) {
    return Xn.from_obj_for_encoding(e);
  }
};
var Qn = class extends Jr {
  constructor(e, t, n, i = {}) {
    super("X-Algo-API-Token", e, t, n, i);
  }
  healthCheck() {
    return new Uo(this.c);
  }
  versionsCheck() {
    return new Yo(this.c);
  }
  sendRawTransaction(e) {
    return new Vo(this.c, e);
  }
  accountInformation(e) {
    return new So(this.c, this.intDecoding, e);
  }
  accountAssetInformation(e, t) {
    return new Fo(this.c, this.intDecoding, e, t);
  }
  accountApplicationInformation(e, t) {
    return new No(this.c, this.intDecoding, e, t);
  }
  block(e) {
    return new Oo(this.c, e);
  }
  getBlockHash(e) {
    return new jo(this.c, this.intDecoding, e);
  }
  pendingTransactionInformation(e) {
    return new Po(this.c, e);
  }
  pendingTransactionsInformation() {
    return new zo(this.c);
  }
  pendingTransactionByAddress(e) {
    return new qo(this.c, e);
  }
  status() {
    return new Go(this.c, this.intDecoding);
  }
  statusAfterBlock(e) {
    return new Wo(this.c, this.intDecoding, e);
  }
  getTransactionParams() {
    return new Ko(this.c);
  }
  supply() {
    return new Ho(this.c, this.intDecoding);
  }
  compile(e) {
    return new Do(this.c, e);
  }
  disassemble(e) {
    return new ra(this.c, e);
  }
  dryrun(e) {
    return new Mo(this.c, e);
  }
  getAssetByID(e) {
    return new Co(this.c, this.intDecoding, e);
  }
  getApplicationByID(e) {
    return new ko(this.c, this.intDecoding, e);
  }
  getApplicationBoxByName(e, t) {
    return new Bo(this.c, this.intDecoding, e, t);
  }
  getApplicationBoxes(e) {
    return new Lo(this.c, this.intDecoding, e);
  }
  genesis() {
    return new Ro(this.c, this.intDecoding);
  }
  getTransactionProof(e, t) {
    return new $o(this.c, this.intDecoding, e, t);
  }
  getLightBlockHeaderProof(e) {
    return new Jo(this.c, this.intDecoding, e);
  }
  getStateProof(e) {
    return new Zo(this.c, this.intDecoding, e);
  }
  simulateRawTransactions(e) {
    let t = [];
    if (Array.isArray(e))
      for (let i of e)
        t.push(St(i));
    else
      t.push(St(e));
    let n = new Qr({ txnGroups: [new kr({ txns: t })] });
    return this.simulateTransactions(n);
  }
  simulateTransactions(e) {
    return new na(this.c, e);
  }
  setBlockOffsetTimestamp(e) {
    return new ea(this.c, this.intDecoding, e);
  }
  getBlockOffsetTimestamp() {
    return new ta(this.c, this.intDecoding);
  }
  setSyncRound(e) {
    return new Xo(this.c, this.intDecoding, e);
  }
  unsetSyncRound() {
    return new sa(this.c, this.intDecoding);
  }
  getSyncRound() {
    return new Qo(this.c, this.intDecoding);
  }
  ready() {
    return new ia(this.c, this.intDecoding);
  }
  getLedgerStateDeltaForTransactionGroup(e) {
    return new oa(this.c, this.intDecoding, e);
  }
  getLedgerStateDelta(e) {
    return new aa(this.c, this.intDecoding, e);
  }
  getTransactionGroupLedgerStateDeltasForRound(e) {
    return new ca(this.c, this.intDecoding, e);
  }
};
var wr = lt(Tt());
var ua = class extends Jr {
  constructor(e, t = "http://127.0.0.1", n = 7833, i = {}) {
    super("X-KMD-API-Token", e, t, n, i);
  }
  async versions() {
    return (await this.c.get("/versions")).body;
  }
  async listWallets() {
    return (await this.c.get("/v1/wallets")).body;
  }
  async createWallet(e, t, n = new Uint8Array(), i = "sqlite") {
    let s = { wallet_name: e, wallet_driver_name: i, wallet_password: t, master_derivation_key: wr.Buffer.from(n).toString("base64") };
    return (await this.c.post("/v1/wallet", s)).body;
  }
  async initWalletHandle(e, t) {
    let n = { wallet_id: e, wallet_password: t };
    return (await this.c.post("/v1/wallet/init", n)).body;
  }
  async releaseWalletHandle(e) {
    let t = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/release", t)).body;
  }
  async renewWalletHandle(e) {
    let t = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/renew", t)).body;
  }
  async renameWallet(e, t, n) {
    let i = { wallet_id: e, wallet_password: t, wallet_name: n };
    return (await this.c.post("/v1/wallet/rename", i)).body;
  }
  async getWallet(e) {
    let t = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/info", t)).body;
  }
  async exportMasterDerivationKey(e, t) {
    let n = { wallet_handle_token: e, wallet_password: t }, i = await this.c.post("/v1/master-key/export", n);
    return { master_derivation_key: wr.Buffer.from(i.body.master_derivation_key, "base64") };
  }
  async importKey(e, t) {
    let n = { wallet_handle_token: e, private_key: wr.Buffer.from(t).toString("base64") };
    return (await this.c.post("/v1/key/import", n)).body;
  }
  async exportKey(e, t, n) {
    let i = { wallet_handle_token: e, address: n, wallet_password: t }, s = await this.c.post("/v1/key/export", i);
    return { private_key: wr.Buffer.from(s.body.private_key, "base64") };
  }
  async generateKey(e) {
    let t = { wallet_handle_token: e, display_mnemonic: false };
    return (await this.c.post("/v1/key", t)).body;
  }
  async deleteKey(e, t, n) {
    let i = { wallet_handle_token: e, address: n, wallet_password: t };
    return (await this.c.delete("/v1/key", i)).body;
  }
  async listKeys(e) {
    let t = { wallet_handle_token: e };
    return (await this.c.post("/v1/key/list", t)).body;
  }
  async signTransaction(e, t, n) {
    let i = yr(n), s = { wallet_handle_token: e, wallet_password: t, transaction: wr.Buffer.from(i.toByte()).toString("base64") }, o = await this.c.post("/v1/transaction/sign", s);
    return o.status === 200 ? wr.Buffer.from(o.body.signed_transaction, "base64") : o.body;
  }
  async signTransactionWithSpecificPublicKey(e, t, n, i) {
    let s = yr(n), o = { wallet_handle_token: e, wallet_password: t, transaction: wr.Buffer.from(s.toByte()).toString("base64"), public_key: wr.Buffer.from(i).toString("base64") }, c = await this.c.post("/v1/transaction/sign", o);
    return c.status === 200 ? wr.Buffer.from(c.body.signed_transaction, "base64") : c.body;
  }
  async listMultisig(e) {
    let t = { wallet_handle_token: e };
    return (await this.c.post("/v1/multisig/list", t)).body;
  }
  async importMultisig(e, t, n, i) {
    let s = { wallet_handle_token: e, multisig_version: t, threshold: n, pks: i };
    return (await this.c.post("/v1/multisig/import", s)).body;
  }
  async exportMultisig(e, t) {
    let n = { wallet_handle_token: e, address: t };
    return (await this.c.post("/v1/multisig/export", n)).body;
  }
  async signMultisigTransaction(e, t, n, i, s) {
    let o = yr(n), c = { wallet_handle_token: e, transaction: wr.Buffer.from(o.toByte()).toString("base64"), public_key: wr.Buffer.from(i).toString("base64"), partial_multisig: s, wallet_password: t };
    return (await this.c.post("/v1/multisig/sign", c)).body;
  }
  async deleteMultisig(e, t, n) {
    let i = { wallet_handle_token: e, address: n, wallet_password: t };
    return (await this.c.delete("/v1/multisig", i)).body;
  }
};
var fa = class extends oe {
  path() {
    return "/health";
  }
};
var la = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n;
  }
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
var Ed = lt(Tt());
function ha(r) {
  return typeof r == "string" ? r : Ed.Buffer.from(r).toString("base64");
}
var da = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.account = n, this.account = n;
  }
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  notePrefix(e) {
    return this.query["note-prefix"] = ha(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
};
var pa = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n;
  }
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  notePrefix(e) {
    return this.query["note-prefix"] = ha(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  addressRole(e) {
    return this.query["address-role"] = e, this;
  }
  address(e) {
    return this.query.address = e, this;
  }
  excludeCloseTo(e) {
    return this.query["exclude-close-to"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
};
var ga = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.round = n, this.round = n;
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  headerOnly(e) {
    return this.query["header-only"] = e, this;
  }
};
var ma = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.txID = n, this.txID = n;
  }
  path() {
    return `/v2/transactions/${this.txID}`;
  }
};
var ya = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.account = n, this.account = n;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  round(e) {
    return this.query.round = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
var xa = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.account = n, this.account = n;
  }
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  assetId(e) {
    return this.query["asset-id"] = e, this;
  }
};
var wa = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.account = n, this.account = n;
  }
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
};
var ba = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.account = n, this.account = n;
  }
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
var va = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.account = n, this.account = n;
  }
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
var _a = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
var Aa = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
var Ea = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.appID = n, this.appID = n;
  }
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  sender(e) {
    return this.query["sender-address"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
};
var Id = lt(Tt());
var hf = {};
Pu(hf, { Account: () => ei, AccountParticipation: () => Qi, AccountResponse: () => Ia, AccountStateDelta: () => es, AccountsResponse: () => Ta, Application: () => xn, ApplicationLocalState: () => ti, ApplicationLocalStatesResponse: () => Sa, ApplicationLogData: () => ts, ApplicationLogsResponse: () => Fa, ApplicationParams: () => rs, ApplicationResponse: () => Na, ApplicationStateSchema: () => en, ApplicationsResponse: () => Oa, Asset: () => wn, AssetBalancesResponse: () => Da, AssetHolding: () => ri, AssetHoldingsResponse: () => Ma, AssetParams: () => ni, AssetResponse: () => Ra, AssetsResponse: () => Ca, Block: () => ka, BlockRewards: () => ns, BlockUpgradeState: () => is, BlockUpgradeVote: () => ss, Box: () => ii, BoxDescriptor: () => os, BoxesResponse: () => si, ErrorResponse: () => ja, EvalDelta: () => as, EvalDeltaKeyValue: () => oi, HashFactory: () => cs, HealthCheck: () => Ba, IndexerStateProofMessage: () => us, MerkleArrayProof: () => bn, MiniAssetHolding: () => fs, ParticipationUpdates: () => ls, StateProofFields: () => ds, StateProofParticipant: () => hs, StateProofReveal: () => ps, StateProofSigSlot: () => gs, StateProofSignature: () => ms, StateProofTracking: () => ys, StateProofVerifier: () => xs, StateSchema: () => ai, TealKeyValue: () => ci, TealValue: () => ws, Transaction: () => tn, TransactionApplication: () => bs, TransactionAssetConfig: () => vs, TransactionAssetFreeze: () => _s, TransactionAssetTransfer: () => As, TransactionKeyreg: () => Es, TransactionPayment: () => Is, TransactionResponse: () => La, TransactionSignature: () => Ts, TransactionSignatureLogicsig: () => Ss, TransactionSignatureMultisig: () => ui, TransactionSignatureMultisigSubsignature: () => Fs, TransactionStateProof: () => Ns, TransactionsResponse: () => Ua });
var ot = lt(Tt());
var ei = class extends se {
  constructor({ address: e, amount: t, amountWithoutPendingRewards: n, pendingRewards: i, rewards: s, round: o, status: c, totalAppsOptedIn: l2, totalAssetsOptedIn: f2, totalBoxBytes: h2, totalBoxes: _, totalCreatedApps: j2, totalCreatedAssets: ie, appsLocalState: G, appsTotalExtraPages: Q, appsTotalSchema: N2, assets: U, authAddr: ee, closedAtRound: re2, createdApps: le, createdAssets: H2, createdAtRound: I, deleted: K2, participation: P2, rewardBase: k2, sigType: te2 }) {
    super(), this.address = e, this.amount = t, this.amountWithoutPendingRewards = n, this.pendingRewards = i, this.rewards = s, this.round = o, this.status = c, this.totalAppsOptedIn = l2, this.totalAssetsOptedIn = f2, this.totalBoxBytes = h2, this.totalBoxes = _, this.totalCreatedApps = j2, this.totalCreatedAssets = ie, this.appsLocalState = G, this.appsTotalExtraPages = Q, this.appsTotalSchema = N2, this.assets = U, this.authAddr = ee, this.closedAtRound = re2, this.createdApps = le, this.createdAssets = H2, this.createdAtRound = I, this.deleted = K2, this.participation = P2, this.rewardBase = k2, this.sigType = te2, this.attribute_map = { address: "address", amount: "amount", amountWithoutPendingRewards: "amount-without-pending-rewards", pendingRewards: "pending-rewards", rewards: "rewards", round: "round", status: "status", totalAppsOptedIn: "total-apps-opted-in", totalAssetsOptedIn: "total-assets-opted-in", totalBoxBytes: "total-box-bytes", totalBoxes: "total-boxes", totalCreatedApps: "total-created-apps", totalCreatedAssets: "total-created-assets", appsLocalState: "apps-local-state", appsTotalExtraPages: "apps-total-extra-pages", appsTotalSchema: "apps-total-schema", assets: "assets", authAddr: "auth-addr", closedAtRound: "closed-at-round", createdApps: "created-apps", createdAssets: "created-assets", createdAtRound: "created-at-round", deleted: "deleted", participation: "participation", rewardBase: "reward-base", sigType: "sig-type" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address == "undefined")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount == "undefined")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["amount-without-pending-rewards"] == "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${e}`);
    if (typeof e["pending-rewards"] == "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${e}`);
    if (typeof e.rewards == "undefined")
      throw new Error(`Response is missing required field 'rewards': ${e}`);
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.status == "undefined")
      throw new Error(`Response is missing required field 'status': ${e}`);
    if (typeof e["total-apps-opted-in"] == "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${e}`);
    if (typeof e["total-assets-opted-in"] == "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${e}`);
    if (typeof e["total-box-bytes"] == "undefined")
      throw new Error(`Response is missing required field 'total-box-bytes': ${e}`);
    if (typeof e["total-boxes"] == "undefined")
      throw new Error(`Response is missing required field 'total-boxes': ${e}`);
    if (typeof e["total-created-apps"] == "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${e}`);
    if (typeof e["total-created-assets"] == "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${e}`);
    return new ei({ address: e.address, amount: e.amount, amountWithoutPendingRewards: e["amount-without-pending-rewards"], pendingRewards: e["pending-rewards"], rewards: e.rewards, round: e.round, status: e.status, totalAppsOptedIn: e["total-apps-opted-in"], totalAssetsOptedIn: e["total-assets-opted-in"], totalBoxBytes: e["total-box-bytes"], totalBoxes: e["total-boxes"], totalCreatedApps: e["total-created-apps"], totalCreatedAssets: e["total-created-assets"], appsLocalState: typeof e["apps-local-state"] != "undefined" ? e["apps-local-state"].map(ti.from_obj_for_encoding) : void 0, appsTotalExtraPages: e["apps-total-extra-pages"], appsTotalSchema: typeof e["apps-total-schema"] != "undefined" ? en.from_obj_for_encoding(e["apps-total-schema"]) : void 0, assets: typeof e.assets != "undefined" ? e.assets.map(ri.from_obj_for_encoding) : void 0, authAddr: e["auth-addr"], closedAtRound: e["closed-at-round"], createdApps: typeof e["created-apps"] != "undefined" ? e["created-apps"].map(xn.from_obj_for_encoding) : void 0, createdAssets: typeof e["created-assets"] != "undefined" ? e["created-assets"].map(wn.from_obj_for_encoding) : void 0, createdAtRound: e["created-at-round"], deleted: e.deleted, participation: typeof e.participation != "undefined" ? Qi.from_obj_for_encoding(e.participation) : void 0, rewardBase: e["reward-base"], sigType: e["sig-type"] });
  }
}, Qi = class extends se {
  constructor({ selectionParticipationKey: e, voteFirstValid: t, voteKeyDilution: n, voteLastValid: i, voteParticipationKey: s, stateProofKey: o }) {
    super(), this.selectionParticipationKey = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.voteFirstValid = t, this.voteKeyDilution = n, this.voteLastValid = i, this.voteParticipationKey = typeof s == "string" ? new Uint8Array(ot.Buffer.from(s, "base64")) : s, this.stateProofKey = typeof o == "string" ? new Uint8Array(ot.Buffer.from(o, "base64")) : o, this.attribute_map = { selectionParticipationKey: "selection-participation-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key", stateProofKey: "state-proof-key" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["selection-participation-key"] == "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${e}`);
    if (typeof e["vote-first-valid"] == "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${e}`);
    if (typeof e["vote-key-dilution"] == "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${e}`);
    if (typeof e["vote-last-valid"] == "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${e}`);
    if (typeof e["vote-participation-key"] == "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${e}`);
    return new Qi({ selectionParticipationKey: e["selection-participation-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"], stateProofKey: e["state-proof-key"] });
  }
}, Ia = class extends se {
  constructor({ account: e, currentRound: t }) {
    super(), this.account = e, this.currentRound = t, this.attribute_map = { account: "account", currentRound: "current-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.account == "undefined")
      throw new Error(`Response is missing required field 'account': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Ia({ account: ei.from_obj_for_encoding(e.account), currentRound: e["current-round"] });
  }
}, es = class extends se {
  constructor({ address: e, delta: t }) {
    super(), this.address = e, this.delta = t, this.attribute_map = { address: "address", delta: "delta" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address == "undefined")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (!Array.isArray(e.delta))
      throw new Error(`Response is missing required array field 'delta': ${e}`);
    return new es({ address: e.address, delta: e.delta.map(oi.from_obj_for_encoding) });
  }
}, Ta = class extends se {
  constructor({ accounts: e, currentRound: t, nextToken: n }) {
    super(), this.accounts = e, this.currentRound = t, this.nextToken = n, this.attribute_map = { accounts: "accounts", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.accounts))
      throw new Error(`Response is missing required array field 'accounts': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Ta({ accounts: e.accounts.map(ei.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, xn = class extends se {
  constructor({ id: e, params: t, createdAtRound: n, deleted: i, deletedAtRound: s }) {
    super(), this.id = e, this.params = t, this.createdAtRound = n, this.deleted = i, this.deletedAtRound = s, this.attribute_map = { id: "id", params: "params", createdAtRound: "created-at-round", deleted: "deleted", deletedAtRound: "deleted-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id == "undefined")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.params == "undefined")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new xn({ id: e.id, params: rs.from_obj_for_encoding(e.params), createdAtRound: e["created-at-round"], deleted: e.deleted, deletedAtRound: e["deleted-at-round"] });
  }
}, ti = class extends se {
  constructor({ id: e, schema: t, closedOutAtRound: n, deleted: i, keyValue: s, optedInAtRound: o }) {
    super(), this.id = e, this.schema = t, this.closedOutAtRound = n, this.deleted = i, this.keyValue = s, this.optedInAtRound = o, this.attribute_map = { id: "id", schema: "schema", closedOutAtRound: "closed-out-at-round", deleted: "deleted", keyValue: "key-value", optedInAtRound: "opted-in-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id == "undefined")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.schema == "undefined")
      throw new Error(`Response is missing required field 'schema': ${e}`);
    return new ti({ id: e.id, schema: en.from_obj_for_encoding(e.schema), closedOutAtRound: e["closed-out-at-round"], deleted: e.deleted, keyValue: typeof e["key-value"] != "undefined" ? e["key-value"].map(ci.from_obj_for_encoding) : void 0, optedInAtRound: e["opted-in-at-round"] });
  }
}, Sa = class extends se {
  constructor({ appsLocalStates: e, currentRound: t, nextToken: n }) {
    super(), this.appsLocalStates = e, this.currentRound = t, this.nextToken = n, this.attribute_map = { appsLocalStates: "apps-local-states", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["apps-local-states"]))
      throw new Error(`Response is missing required array field 'apps-local-states': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Sa({ appsLocalStates: e["apps-local-states"].map(ti.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, ts = class extends se {
  constructor({ logs: e, txid: t }) {
    super(), this.logs = e, this.txid = t, this.attribute_map = { logs: "logs", txid: "txid" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.logs))
      throw new Error(`Response is missing required array field 'logs': ${e}`);
    if (typeof e.txid == "undefined")
      throw new Error(`Response is missing required field 'txid': ${e}`);
    return new ts({ logs: e.logs, txid: e.txid });
  }
}, Fa = class extends se {
  constructor({ applicationId: e, currentRound: t, logData: n, nextToken: i }) {
    super(), this.applicationId = e, this.currentRound = t, this.logData = n, this.nextToken = i, this.attribute_map = { applicationId: "application-id", currentRound: "current-round", logData: "log-data", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] == "undefined")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Fa({ applicationId: e["application-id"], currentRound: e["current-round"], logData: typeof e["log-data"] != "undefined" ? e["log-data"].map(ts.from_obj_for_encoding) : void 0, nextToken: e["next-token"] });
  }
}, rs = class extends se {
  constructor({ approvalProgram: e, clearStateProgram: t, creator: n, extraProgramPages: i, globalState: s, globalStateSchema: o, localStateSchema: c }) {
    super(), this.approvalProgram = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.clearStateProgram = typeof t == "string" ? new Uint8Array(ot.Buffer.from(t, "base64")) : t, this.creator = n, this.extraProgramPages = i, this.globalState = s, this.globalStateSchema = o, this.localStateSchema = c, this.attribute_map = { approvalProgram: "approval-program", clearStateProgram: "clear-state-program", creator: "creator", extraProgramPages: "extra-program-pages", globalState: "global-state", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["approval-program"] == "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${e}`);
    if (typeof e["clear-state-program"] == "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${e}`);
    return new rs({ approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], creator: e.creator, extraProgramPages: e["extra-program-pages"], globalState: typeof e["global-state"] != "undefined" ? e["global-state"].map(ci.from_obj_for_encoding) : void 0, globalStateSchema: typeof e["global-state-schema"] != "undefined" ? en.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] != "undefined" ? en.from_obj_for_encoding(e["local-state-schema"]) : void 0 });
  }
}, Na = class extends se {
  constructor({ currentRound: e, application: t }) {
    super(), this.currentRound = e, this.application = t, this.attribute_map = { currentRound: "current-round", application: "application" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Na({ currentRound: e["current-round"], application: typeof e.application != "undefined" ? xn.from_obj_for_encoding(e.application) : void 0 });
  }
}, en = class extends se {
  constructor({ numByteSlice: e, numUint: t }) {
    super(), this.numByteSlice = e, this.numUint = t, this.attribute_map = { numByteSlice: "num-byte-slice", numUint: "num-uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-byte-slice"] == "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    if (typeof e["num-uint"] == "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    return new en({ numByteSlice: e["num-byte-slice"], numUint: e["num-uint"] });
  }
}, Oa = class extends se {
  constructor({ applications: e, currentRound: t, nextToken: n }) {
    super(), this.applications = e, this.currentRound = t, this.nextToken = n, this.attribute_map = { applications: "applications", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.applications))
      throw new Error(`Response is missing required array field 'applications': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Oa({ applications: e.applications.map(xn.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, wn = class extends se {
  constructor({ index: e, params: t, createdAtRound: n, deleted: i, destroyedAtRound: s }) {
    super(), this.index = e, this.params = t, this.createdAtRound = n, this.deleted = i, this.destroyedAtRound = s, this.attribute_map = { index: "index", params: "params", createdAtRound: "created-at-round", deleted: "deleted", destroyedAtRound: "destroyed-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index == "undefined")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.params == "undefined")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new wn({ index: e.index, params: ni.from_obj_for_encoding(e.params), createdAtRound: e["created-at-round"], deleted: e.deleted, destroyedAtRound: e["destroyed-at-round"] });
  }
}, Da = class extends se {
  constructor({ balances: e, currentRound: t, nextToken: n }) {
    super(), this.balances = e, this.currentRound = t, this.nextToken = n, this.attribute_map = { balances: "balances", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.balances))
      throw new Error(`Response is missing required array field 'balances': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Da({ balances: e.balances.map(fs.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, ri = class extends se {
  constructor({ amount: e, assetId: t, isFrozen: n, deleted: i, optedInAtRound: s, optedOutAtRound: o }) {
    super(), this.amount = e, this.assetId = t, this.isFrozen = n, this.deleted = i, this.optedInAtRound = s, this.optedOutAtRound = o, this.attribute_map = { amount: "amount", assetId: "asset-id", isFrozen: "is-frozen", deleted: "deleted", optedInAtRound: "opted-in-at-round", optedOutAtRound: "opted-out-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount == "undefined")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] == "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["is-frozen"] == "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new ri({ amount: e.amount, assetId: e["asset-id"], isFrozen: e["is-frozen"], deleted: e.deleted, optedInAtRound: e["opted-in-at-round"], optedOutAtRound: e["opted-out-at-round"] });
  }
}, Ma = class extends se {
  constructor({ assets: e, currentRound: t, nextToken: n }) {
    super(), this.assets = e, this.currentRound = t, this.nextToken = n, this.attribute_map = { assets: "assets", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.assets))
      throw new Error(`Response is missing required array field 'assets': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Ma({ assets: e.assets.map(ri.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, ni = class extends se {
  constructor({ creator: e, decimals: t, total: n, clawback: i, defaultFrozen: s, freeze: o, manager: c, metadataHash: l2, name: f2, nameB64: h2, reserve: _, unitName: j2, unitNameB64: ie, url: G, urlB64: Q }) {
    super(), this.creator = e, this.decimals = t, this.total = n, this.clawback = i, this.defaultFrozen = s, this.freeze = o, this.manager = c, this.metadataHash = typeof l2 == "string" ? new Uint8Array(ot.Buffer.from(l2, "base64")) : l2, this.name = f2, this.nameB64 = typeof h2 == "string" ? new Uint8Array(ot.Buffer.from(h2, "base64")) : h2, this.reserve = _, this.unitName = j2, this.unitNameB64 = typeof ie == "string" ? new Uint8Array(ot.Buffer.from(ie, "base64")) : ie, this.url = G, this.urlB64 = typeof Q == "string" ? new Uint8Array(ot.Buffer.from(Q, "base64")) : Q, this.attribute_map = { creator: "creator", decimals: "decimals", total: "total", clawback: "clawback", defaultFrozen: "default-frozen", freeze: "freeze", manager: "manager", metadataHash: "metadata-hash", name: "name", nameB64: "name-b64", reserve: "reserve", unitName: "unit-name", unitNameB64: "unit-name-b64", url: "url", urlB64: "url-b64" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.creator == "undefined")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    if (typeof e.decimals == "undefined")
      throw new Error(`Response is missing required field 'decimals': ${e}`);
    if (typeof e.total == "undefined")
      throw new Error(`Response is missing required field 'total': ${e}`);
    return new ni({ creator: e.creator, decimals: e.decimals, total: e.total, clawback: e.clawback, defaultFrozen: e["default-frozen"], freeze: e.freeze, manager: e.manager, metadataHash: e["metadata-hash"], name: e.name, nameB64: e["name-b64"], reserve: e.reserve, unitName: e["unit-name"], unitNameB64: e["unit-name-b64"], url: e.url, urlB64: e["url-b64"] });
  }
}, Ra = class extends se {
  constructor({ asset: e, currentRound: t }) {
    super(), this.asset = e, this.currentRound = t, this.attribute_map = { asset: "asset", currentRound: "current-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.asset == "undefined")
      throw new Error(`Response is missing required field 'asset': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Ra({ asset: wn.from_obj_for_encoding(e.asset), currentRound: e["current-round"] });
  }
}, Ca = class extends se {
  constructor({ assets: e, currentRound: t, nextToken: n }) {
    super(), this.assets = e, this.currentRound = t, this.nextToken = n, this.attribute_map = { assets: "assets", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.assets))
      throw new Error(`Response is missing required array field 'assets': ${e}`);
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Ca({ assets: e.assets.map(wn.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, ka = class extends se {
  constructor({ genesisHash: e, genesisId: t, previousBlockHash: n, round: i, seed: s, timestamp: o, transactionsRoot: c, transactionsRootSha256: l2, participationUpdates: f2, rewards: h2, stateProofTracking: _, transactions: j2, txnCounter: ie, upgradeState: G, upgradeVote: Q }) {
    super(), this.genesisHash = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.genesisId = t, this.previousBlockHash = typeof n == "string" ? new Uint8Array(ot.Buffer.from(n, "base64")) : n, this.round = i, this.seed = typeof s == "string" ? new Uint8Array(ot.Buffer.from(s, "base64")) : s, this.timestamp = o, this.transactionsRoot = typeof c == "string" ? new Uint8Array(ot.Buffer.from(c, "base64")) : c, this.transactionsRootSha256 = typeof l2 == "string" ? new Uint8Array(ot.Buffer.from(l2, "base64")) : l2, this.participationUpdates = f2, this.rewards = h2, this.stateProofTracking = _, this.transactions = j2, this.txnCounter = ie, this.upgradeState = G, this.upgradeVote = Q, this.attribute_map = { genesisHash: "genesis-hash", genesisId: "genesis-id", previousBlockHash: "previous-block-hash", round: "round", seed: "seed", timestamp: "timestamp", transactionsRoot: "transactions-root", transactionsRootSha256: "transactions-root-sha256", participationUpdates: "participation-updates", rewards: "rewards", stateProofTracking: "state-proof-tracking", transactions: "transactions", txnCounter: "txn-counter", upgradeState: "upgrade-state", upgradeVote: "upgrade-vote" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["genesis-hash"] == "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${e}`);
    if (typeof e["genesis-id"] == "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${e}`);
    if (typeof e["previous-block-hash"] == "undefined")
      throw new Error(`Response is missing required field 'previous-block-hash': ${e}`);
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.seed == "undefined")
      throw new Error(`Response is missing required field 'seed': ${e}`);
    if (typeof e.timestamp == "undefined")
      throw new Error(`Response is missing required field 'timestamp': ${e}`);
    if (typeof e["transactions-root"] == "undefined")
      throw new Error(`Response is missing required field 'transactions-root': ${e}`);
    if (typeof e["transactions-root-sha256"] == "undefined")
      throw new Error(`Response is missing required field 'transactions-root-sha256': ${e}`);
    return new ka({ genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], previousBlockHash: e["previous-block-hash"], round: e.round, seed: e.seed, timestamp: e.timestamp, transactionsRoot: e["transactions-root"], transactionsRootSha256: e["transactions-root-sha256"], participationUpdates: typeof e["participation-updates"] != "undefined" ? ls.from_obj_for_encoding(e["participation-updates"]) : void 0, rewards: typeof e.rewards != "undefined" ? ns.from_obj_for_encoding(e.rewards) : void 0, stateProofTracking: typeof e["state-proof-tracking"] != "undefined" ? e["state-proof-tracking"].map(ys.from_obj_for_encoding) : void 0, transactions: typeof e.transactions != "undefined" ? e.transactions.map(tn.from_obj_for_encoding) : void 0, txnCounter: e["txn-counter"], upgradeState: typeof e["upgrade-state"] != "undefined" ? is.from_obj_for_encoding(e["upgrade-state"]) : void 0, upgradeVote: typeof e["upgrade-vote"] != "undefined" ? ss.from_obj_for_encoding(e["upgrade-vote"]) : void 0 });
  }
}, ns = class extends se {
  constructor({ feeSink: e, rewardsCalculationRound: t, rewardsLevel: n, rewardsPool: i, rewardsRate: s, rewardsResidue: o }) {
    super(), this.feeSink = e, this.rewardsCalculationRound = t, this.rewardsLevel = n, this.rewardsPool = i, this.rewardsRate = s, this.rewardsResidue = o, this.attribute_map = { feeSink: "fee-sink", rewardsCalculationRound: "rewards-calculation-round", rewardsLevel: "rewards-level", rewardsPool: "rewards-pool", rewardsRate: "rewards-rate", rewardsResidue: "rewards-residue" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["fee-sink"] == "undefined")
      throw new Error(`Response is missing required field 'fee-sink': ${e}`);
    if (typeof e["rewards-calculation-round"] == "undefined")
      throw new Error(`Response is missing required field 'rewards-calculation-round': ${e}`);
    if (typeof e["rewards-level"] == "undefined")
      throw new Error(`Response is missing required field 'rewards-level': ${e}`);
    if (typeof e["rewards-pool"] == "undefined")
      throw new Error(`Response is missing required field 'rewards-pool': ${e}`);
    if (typeof e["rewards-rate"] == "undefined")
      throw new Error(`Response is missing required field 'rewards-rate': ${e}`);
    if (typeof e["rewards-residue"] == "undefined")
      throw new Error(`Response is missing required field 'rewards-residue': ${e}`);
    return new ns({ feeSink: e["fee-sink"], rewardsCalculationRound: e["rewards-calculation-round"], rewardsLevel: e["rewards-level"], rewardsPool: e["rewards-pool"], rewardsRate: e["rewards-rate"], rewardsResidue: e["rewards-residue"] });
  }
}, is = class extends se {
  constructor({ currentProtocol: e, nextProtocol: t, nextProtocolApprovals: n, nextProtocolSwitchOn: i, nextProtocolVoteBefore: s }) {
    super(), this.currentProtocol = e, this.nextProtocol = t, this.nextProtocolApprovals = n, this.nextProtocolSwitchOn = i, this.nextProtocolVoteBefore = s, this.attribute_map = { currentProtocol: "current-protocol", nextProtocol: "next-protocol", nextProtocolApprovals: "next-protocol-approvals", nextProtocolSwitchOn: "next-protocol-switch-on", nextProtocolVoteBefore: "next-protocol-vote-before" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-protocol"] == "undefined")
      throw new Error(`Response is missing required field 'current-protocol': ${e}`);
    return new is({ currentProtocol: e["current-protocol"], nextProtocol: e["next-protocol"], nextProtocolApprovals: e["next-protocol-approvals"], nextProtocolSwitchOn: e["next-protocol-switch-on"], nextProtocolVoteBefore: e["next-protocol-vote-before"] });
  }
}, ss = class extends se {
  constructor({ upgradeApprove: e, upgradeDelay: t, upgradePropose: n }) {
    super(), this.upgradeApprove = e, this.upgradeDelay = t, this.upgradePropose = n, this.attribute_map = { upgradeApprove: "upgrade-approve", upgradeDelay: "upgrade-delay", upgradePropose: "upgrade-propose" };
  }
  static from_obj_for_encoding(e) {
    return new ss({ upgradeApprove: e["upgrade-approve"], upgradeDelay: e["upgrade-delay"], upgradePropose: e["upgrade-propose"] });
  }
}, ii = class extends se {
  constructor({ name: e, value: t }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.value = typeof t == "string" ? new Uint8Array(ot.Buffer.from(t, "base64")) : t, this.attribute_map = { name: "name", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name == "undefined")
      throw new Error(`Response is missing required field 'name': ${e}`);
    if (typeof e.value == "undefined")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new ii({ name: e.name, value: e.value });
  }
}, os = class extends se {
  constructor({ name: e }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.attribute_map = { name: "name" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name == "undefined")
      throw new Error(`Response is missing required field 'name': ${e}`);
    return new os({ name: e.name });
  }
}, si = class extends se {
  constructor({ applicationId: e, boxes: t, nextToken: n }) {
    super(), this.applicationId = e, this.boxes = t, this.nextToken = n, this.attribute_map = { applicationId: "application-id", boxes: "boxes", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] == "undefined")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    if (!Array.isArray(e.boxes))
      throw new Error(`Response is missing required array field 'boxes': ${e}`);
    return new si({ applicationId: e["application-id"], boxes: e.boxes.map(os.from_obj_for_encoding), nextToken: e["next-token"] });
  }
}, ja = class extends se {
  constructor({ message: e, data: t }) {
    super(), this.message = e, this.data = t, this.attribute_map = { message: "message", data: "data" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.message == "undefined")
      throw new Error(`Response is missing required field 'message': ${e}`);
    return new ja({ message: e.message, data: e.data });
  }
}, as = class extends se {
  constructor({ action: e, bytes: t, uint: n }) {
    super(), this.action = e, this.bytes = t, this.uint = n, this.attribute_map = { action: "action", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.action == "undefined")
      throw new Error(`Response is missing required field 'action': ${e}`);
    return new as({ action: e.action, bytes: e.bytes, uint: e.uint });
  }
}, oi = class extends se {
  constructor({ key: e, value: t }) {
    super(), this.key = e, this.value = t, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key == "undefined")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value == "undefined")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new oi({ key: e.key, value: as.from_obj_for_encoding(e.value) });
  }
}, cs = class extends se {
  constructor({ hashType: e }) {
    super(), this.hashType = e, this.attribute_map = { hashType: "hash-type" };
  }
  static from_obj_for_encoding(e) {
    return new cs({ hashType: e["hash-type"] });
  }
}, Ba = class extends se {
  constructor({ dbAvailable: e, isMigrating: t, message: n, round: i, version: s, data: o, errors: c }) {
    super(), this.dbAvailable = e, this.isMigrating = t, this.message = n, this.round = i, this.version = s, this.data = o, this.errors = c, this.attribute_map = { dbAvailable: "db-available", isMigrating: "is-migrating", message: "message", round: "round", version: "version", data: "data", errors: "errors" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["db-available"] == "undefined")
      throw new Error(`Response is missing required field 'db-available': ${e}`);
    if (typeof e["is-migrating"] == "undefined")
      throw new Error(`Response is missing required field 'is-migrating': ${e}`);
    if (typeof e.message == "undefined")
      throw new Error(`Response is missing required field 'message': ${e}`);
    if (typeof e.round == "undefined")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.version == "undefined")
      throw new Error(`Response is missing required field 'version': ${e}`);
    return new Ba({ dbAvailable: e["db-available"], isMigrating: e["is-migrating"], message: e.message, round: e.round, version: e.version, data: e.data, errors: e.errors });
  }
}, us = class extends se {
  constructor({ blockHeadersCommitment: e, firstAttestedRound: t, latestAttestedRound: n, lnProvenWeight: i, votersCommitment: s }) {
    super(), this.blockHeadersCommitment = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.firstAttestedRound = t, this.latestAttestedRound = n, this.lnProvenWeight = i, this.votersCommitment = typeof s == "string" ? new Uint8Array(ot.Buffer.from(s, "base64")) : s, this.attribute_map = { blockHeadersCommitment: "block-headers-commitment", firstAttestedRound: "first-attested-round", latestAttestedRound: "latest-attested-round", lnProvenWeight: "ln-proven-weight", votersCommitment: "voters-commitment" };
  }
  static from_obj_for_encoding(e) {
    return new us({ blockHeadersCommitment: e["block-headers-commitment"], firstAttestedRound: e["first-attested-round"], latestAttestedRound: e["latest-attested-round"], lnProvenWeight: e["ln-proven-weight"], votersCommitment: e["voters-commitment"] });
  }
}, bn = class extends se {
  constructor({ hashFactory: e, path: t, treeDepth: n }) {
    super(), this.hashFactory = e, this.path = t, this.treeDepth = n, this.attribute_map = { hashFactory: "hash-factory", path: "path", treeDepth: "tree-depth" };
  }
  static from_obj_for_encoding(e) {
    return new bn({ hashFactory: typeof e["hash-factory"] != "undefined" ? cs.from_obj_for_encoding(e["hash-factory"]) : void 0, path: e.path, treeDepth: e["tree-depth"] });
  }
}, fs = class extends se {
  constructor({ address: e, amount: t, isFrozen: n, deleted: i, optedInAtRound: s, optedOutAtRound: o }) {
    super(), this.address = e, this.amount = t, this.isFrozen = n, this.deleted = i, this.optedInAtRound = s, this.optedOutAtRound = o, this.attribute_map = { address: "address", amount: "amount", isFrozen: "is-frozen", deleted: "deleted", optedInAtRound: "opted-in-at-round", optedOutAtRound: "opted-out-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address == "undefined")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount == "undefined")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["is-frozen"] == "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new fs({ address: e.address, amount: e.amount, isFrozen: e["is-frozen"], deleted: e.deleted, optedInAtRound: e["opted-in-at-round"], optedOutAtRound: e["opted-out-at-round"] });
  }
}, ls = class extends se {
  constructor({ expiredParticipationAccounts: e }) {
    super(), this.expiredParticipationAccounts = e, this.attribute_map = { expiredParticipationAccounts: "expired-participation-accounts" };
  }
  static from_obj_for_encoding(e) {
    return new ls({ expiredParticipationAccounts: e["expired-participation-accounts"] });
  }
}, ds = class extends se {
  constructor({ partProofs: e, positionsToReveal: t, reveals: n, saltVersion: i, sigCommit: s, sigProofs: o, signedWeight: c }) {
    super(), this.partProofs = e, this.positionsToReveal = t, this.reveals = n, this.saltVersion = i, this.sigCommit = typeof s == "string" ? new Uint8Array(ot.Buffer.from(s, "base64")) : s, this.sigProofs = o, this.signedWeight = c, this.attribute_map = { partProofs: "part-proofs", positionsToReveal: "positions-to-reveal", reveals: "reveals", saltVersion: "salt-version", sigCommit: "sig-commit", sigProofs: "sig-proofs", signedWeight: "signed-weight" };
  }
  static from_obj_for_encoding(e) {
    return new ds({ partProofs: typeof e["part-proofs"] != "undefined" ? bn.from_obj_for_encoding(e["part-proofs"]) : void 0, positionsToReveal: e["positions-to-reveal"], reveals: typeof e.reveals != "undefined" ? e.reveals.map(ps.from_obj_for_encoding) : void 0, saltVersion: e["salt-version"], sigCommit: e["sig-commit"], sigProofs: typeof e["sig-proofs"] != "undefined" ? bn.from_obj_for_encoding(e["sig-proofs"]) : void 0, signedWeight: e["signed-weight"] });
  }
}, hs = class extends se {
  constructor({ verifier: e, weight: t }) {
    super(), this.verifier = e, this.weight = t, this.attribute_map = { verifier: "verifier", weight: "weight" };
  }
  static from_obj_for_encoding(e) {
    return new hs({ verifier: typeof e.verifier != "undefined" ? xs.from_obj_for_encoding(e.verifier) : void 0, weight: e.weight });
  }
}, ps = class extends se {
  constructor({ participant: e, position: t, sigSlot: n }) {
    super(), this.participant = e, this.position = t, this.sigSlot = n, this.attribute_map = { participant: "participant", position: "position", sigSlot: "sig-slot" };
  }
  static from_obj_for_encoding(e) {
    return new ps({ participant: typeof e.participant != "undefined" ? hs.from_obj_for_encoding(e.participant) : void 0, position: e.position, sigSlot: typeof e["sig-slot"] != "undefined" ? gs.from_obj_for_encoding(e["sig-slot"]) : void 0 });
  }
}, gs = class extends se {
  constructor({ lowerSigWeight: e, signature: t }) {
    super(), this.lowerSigWeight = e, this.signature = t, this.attribute_map = { lowerSigWeight: "lower-sig-weight", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    return new gs({ lowerSigWeight: e["lower-sig-weight"], signature: typeof e.signature != "undefined" ? ms.from_obj_for_encoding(e.signature) : void 0 });
  }
}, ms = class extends se {
  constructor({ falconSignature: e, merkleArrayIndex: t, proof: n, verifyingKey: i }) {
    super(), this.falconSignature = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.merkleArrayIndex = t, this.proof = n, this.verifyingKey = typeof i == "string" ? new Uint8Array(ot.Buffer.from(i, "base64")) : i, this.attribute_map = { falconSignature: "falcon-signature", merkleArrayIndex: "merkle-array-index", proof: "proof", verifyingKey: "verifying-key" };
  }
  static from_obj_for_encoding(e) {
    return new ms({ falconSignature: e["falcon-signature"], merkleArrayIndex: e["merkle-array-index"], proof: typeof e.proof != "undefined" ? bn.from_obj_for_encoding(e.proof) : void 0, verifyingKey: e["verifying-key"] });
  }
}, ys = class extends se {
  constructor({ nextRound: e, onlineTotalWeight: t, type: n, votersCommitment: i }) {
    super(), this.nextRound = e, this.onlineTotalWeight = t, this.type = n, this.votersCommitment = typeof i == "string" ? new Uint8Array(ot.Buffer.from(i, "base64")) : i, this.attribute_map = { nextRound: "next-round", onlineTotalWeight: "online-total-weight", type: "type", votersCommitment: "voters-commitment" };
  }
  static from_obj_for_encoding(e) {
    return new ys({ nextRound: e["next-round"], onlineTotalWeight: e["online-total-weight"], type: e.type, votersCommitment: e["voters-commitment"] });
  }
}, xs = class extends se {
  constructor({ commitment: e, keyLifetime: t }) {
    super(), this.commitment = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.keyLifetime = t, this.attribute_map = { commitment: "commitment", keyLifetime: "key-lifetime" };
  }
  static from_obj_for_encoding(e) {
    return new xs({ commitment: e.commitment, keyLifetime: e["key-lifetime"] });
  }
}, ai = class extends se {
  constructor({ numByteSlice: e, numUint: t }) {
    super(), this.numByteSlice = e, this.numUint = t, this.attribute_map = { numByteSlice: "num-byte-slice", numUint: "num-uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-byte-slice"] == "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    if (typeof e["num-uint"] == "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    return new ai({ numByteSlice: e["num-byte-slice"], numUint: e["num-uint"] });
  }
}, ci = class extends se {
  constructor({ key: e, value: t }) {
    super(), this.key = e, this.value = t, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key == "undefined")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value == "undefined")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new ci({ key: e.key, value: ws.from_obj_for_encoding(e.value) });
  }
}, ws = class extends se {
  constructor({ bytes: e, type: t, uint: n }) {
    super(), this.bytes = e, this.type = t, this.uint = n, this.attribute_map = { bytes: "bytes", type: "type", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.bytes == "undefined")
      throw new Error(`Response is missing required field 'bytes': ${e}`);
    if (typeof e.type == "undefined")
      throw new Error(`Response is missing required field 'type': ${e}`);
    if (typeof e.uint == "undefined")
      throw new Error(`Response is missing required field 'uint': ${e}`);
    return new ws({ bytes: e.bytes, type: e.type, uint: e.uint });
  }
}, tn = class extends se {
  constructor({ fee: e, firstValid: t, lastValid: n, sender: i, applicationTransaction: s, assetConfigTransaction: o, assetFreezeTransaction: c, assetTransferTransaction: l2, authAddr: f2, closeRewards: h2, closingAmount: _, confirmedRound: j2, createdApplicationIndex: ie, createdAssetIndex: G, genesisHash: Q, genesisId: N2, globalStateDelta: U, group: ee, id: re2, innerTxns: le, intraRoundOffset: H2, keyregTransaction: I, lease: K2, localStateDelta: P2, logs: k2, note: te2, paymentTransaction: T, receiverRewards: D2, rekeyTo: V2, roundTime: pe, senderRewards: we, signature: ve, stateProofTransaction: qe, txType: Ve }) {
    super(), this.fee = e, this.firstValid = t, this.lastValid = n, this.sender = i, this.applicationTransaction = s, this.assetConfigTransaction = o, this.assetFreezeTransaction = c, this.assetTransferTransaction = l2, this.authAddr = f2, this.closeRewards = h2, this.closingAmount = _, this.confirmedRound = j2, this.createdApplicationIndex = ie, this.createdAssetIndex = G, this.genesisHash = typeof Q == "string" ? new Uint8Array(ot.Buffer.from(Q, "base64")) : Q, this.genesisId = N2, this.globalStateDelta = U, this.group = typeof ee == "string" ? new Uint8Array(ot.Buffer.from(ee, "base64")) : ee, this.id = re2, this.innerTxns = le, this.intraRoundOffset = H2, this.keyregTransaction = I, this.lease = typeof K2 == "string" ? new Uint8Array(ot.Buffer.from(K2, "base64")) : K2, this.localStateDelta = P2, this.logs = k2, this.note = typeof te2 == "string" ? new Uint8Array(ot.Buffer.from(te2, "base64")) : te2, this.paymentTransaction = T, this.receiverRewards = D2, this.rekeyTo = V2, this.roundTime = pe, this.senderRewards = we, this.signature = ve, this.stateProofTransaction = qe, this.txType = Ve, this.attribute_map = { fee: "fee", firstValid: "first-valid", lastValid: "last-valid", sender: "sender", applicationTransaction: "application-transaction", assetConfigTransaction: "asset-config-transaction", assetFreezeTransaction: "asset-freeze-transaction", assetTransferTransaction: "asset-transfer-transaction", authAddr: "auth-addr", closeRewards: "close-rewards", closingAmount: "closing-amount", confirmedRound: "confirmed-round", createdApplicationIndex: "created-application-index", createdAssetIndex: "created-asset-index", genesisHash: "genesis-hash", genesisId: "genesis-id", globalStateDelta: "global-state-delta", group: "group", id: "id", innerTxns: "inner-txns", intraRoundOffset: "intra-round-offset", keyregTransaction: "keyreg-transaction", lease: "lease", localStateDelta: "local-state-delta", logs: "logs", note: "note", paymentTransaction: "payment-transaction", receiverRewards: "receiver-rewards", rekeyTo: "rekey-to", roundTime: "round-time", senderRewards: "sender-rewards", signature: "signature", stateProofTransaction: "state-proof-transaction", txType: "tx-type" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.fee == "undefined")
      throw new Error(`Response is missing required field 'fee': ${e}`);
    if (typeof e["first-valid"] == "undefined")
      throw new Error(`Response is missing required field 'first-valid': ${e}`);
    if (typeof e["last-valid"] == "undefined")
      throw new Error(`Response is missing required field 'last-valid': ${e}`);
    if (typeof e.sender == "undefined")
      throw new Error(`Response is missing required field 'sender': ${e}`);
    return new tn({ fee: e.fee, firstValid: e["first-valid"], lastValid: e["last-valid"], sender: e.sender, applicationTransaction: typeof e["application-transaction"] != "undefined" ? bs.from_obj_for_encoding(e["application-transaction"]) : void 0, assetConfigTransaction: typeof e["asset-config-transaction"] != "undefined" ? vs.from_obj_for_encoding(e["asset-config-transaction"]) : void 0, assetFreezeTransaction: typeof e["asset-freeze-transaction"] != "undefined" ? _s.from_obj_for_encoding(e["asset-freeze-transaction"]) : void 0, assetTransferTransaction: typeof e["asset-transfer-transaction"] != "undefined" ? As.from_obj_for_encoding(e["asset-transfer-transaction"]) : void 0, authAddr: e["auth-addr"], closeRewards: e["close-rewards"], closingAmount: e["closing-amount"], confirmedRound: e["confirmed-round"], createdApplicationIndex: e["created-application-index"], createdAssetIndex: e["created-asset-index"], genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], globalStateDelta: typeof e["global-state-delta"] != "undefined" ? e["global-state-delta"].map(oi.from_obj_for_encoding) : void 0, group: e.group, id: e.id, innerTxns: typeof e["inner-txns"] != "undefined" ? e["inner-txns"].map(tn.from_obj_for_encoding) : void 0, intraRoundOffset: e["intra-round-offset"], keyregTransaction: typeof e["keyreg-transaction"] != "undefined" ? Es.from_obj_for_encoding(e["keyreg-transaction"]) : void 0, lease: e.lease, localStateDelta: typeof e["local-state-delta"] != "undefined" ? e["local-state-delta"].map(es.from_obj_for_encoding) : void 0, logs: e.logs, note: e.note, paymentTransaction: typeof e["payment-transaction"] != "undefined" ? Is.from_obj_for_encoding(e["payment-transaction"]) : void 0, receiverRewards: e["receiver-rewards"], rekeyTo: e["rekey-to"], roundTime: e["round-time"], senderRewards: e["sender-rewards"], signature: typeof e.signature != "undefined" ? Ts.from_obj_for_encoding(e.signature) : void 0, stateProofTransaction: typeof e["state-proof-transaction"] != "undefined" ? Ns.from_obj_for_encoding(e["state-proof-transaction"]) : void 0, txType: e["tx-type"] });
  }
}, bs = class extends se {
  constructor({ applicationId: e, accounts: t, applicationArgs: n, approvalProgram: i, clearStateProgram: s, extraProgramPages: o, foreignApps: c, foreignAssets: l2, globalStateSchema: f2, localStateSchema: h2, onCompletion: _ }) {
    super(), this.applicationId = e, this.accounts = t, this.applicationArgs = n, this.approvalProgram = typeof i == "string" ? new Uint8Array(ot.Buffer.from(i, "base64")) : i, this.clearStateProgram = typeof s == "string" ? new Uint8Array(ot.Buffer.from(s, "base64")) : s, this.extraProgramPages = o, this.foreignApps = c, this.foreignAssets = l2, this.globalStateSchema = f2, this.localStateSchema = h2, this.onCompletion = _, this.attribute_map = { applicationId: "application-id", accounts: "accounts", applicationArgs: "application-args", approvalProgram: "approval-program", clearStateProgram: "clear-state-program", extraProgramPages: "extra-program-pages", foreignApps: "foreign-apps", foreignAssets: "foreign-assets", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema", onCompletion: "on-completion" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] == "undefined")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    return new bs({ applicationId: e["application-id"], accounts: e.accounts, applicationArgs: e["application-args"], approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], extraProgramPages: e["extra-program-pages"], foreignApps: e["foreign-apps"], foreignAssets: e["foreign-assets"], globalStateSchema: typeof e["global-state-schema"] != "undefined" ? ai.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] != "undefined" ? ai.from_obj_for_encoding(e["local-state-schema"]) : void 0, onCompletion: e["on-completion"] });
  }
}, vs = class extends se {
  constructor({ assetId: e, params: t }) {
    super(), this.assetId = e, this.params = t, this.attribute_map = { assetId: "asset-id", params: "params" };
  }
  static from_obj_for_encoding(e) {
    return new vs({ assetId: e["asset-id"], params: typeof e.params != "undefined" ? ni.from_obj_for_encoding(e.params) : void 0 });
  }
}, _s = class extends se {
  constructor({ address: e, assetId: t, newFreezeStatus: n }) {
    super(), this.address = e, this.assetId = t, this.newFreezeStatus = n, this.attribute_map = { address: "address", assetId: "asset-id", newFreezeStatus: "new-freeze-status" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address == "undefined")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e["asset-id"] == "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["new-freeze-status"] == "undefined")
      throw new Error(`Response is missing required field 'new-freeze-status': ${e}`);
    return new _s({ address: e.address, assetId: e["asset-id"], newFreezeStatus: e["new-freeze-status"] });
  }
}, As = class extends se {
  constructor({ amount: e, assetId: t, receiver: n, closeAmount: i, closeTo: s, sender: o }) {
    super(), this.amount = e, this.assetId = t, this.receiver = n, this.closeAmount = i, this.closeTo = s, this.sender = o, this.attribute_map = { amount: "amount", assetId: "asset-id", receiver: "receiver", closeAmount: "close-amount", closeTo: "close-to", sender: "sender" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount == "undefined")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] == "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e.receiver == "undefined")
      throw new Error(`Response is missing required field 'receiver': ${e}`);
    return new As({ amount: e.amount, assetId: e["asset-id"], receiver: e.receiver, closeAmount: e["close-amount"], closeTo: e["close-to"], sender: e.sender });
  }
}, Es = class extends se {
  constructor({ nonParticipation: e, selectionParticipationKey: t, stateProofKey: n, voteFirstValid: i, voteKeyDilution: s, voteLastValid: o, voteParticipationKey: c }) {
    super(), this.nonParticipation = e, this.selectionParticipationKey = typeof t == "string" ? new Uint8Array(ot.Buffer.from(t, "base64")) : t, this.stateProofKey = typeof n == "string" ? new Uint8Array(ot.Buffer.from(n, "base64")) : n, this.voteFirstValid = i, this.voteKeyDilution = s, this.voteLastValid = o, this.voteParticipationKey = typeof c == "string" ? new Uint8Array(ot.Buffer.from(c, "base64")) : c, this.attribute_map = { nonParticipation: "non-participation", selectionParticipationKey: "selection-participation-key", stateProofKey: "state-proof-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key" };
  }
  static from_obj_for_encoding(e) {
    return new Es({ nonParticipation: e["non-participation"], selectionParticipationKey: e["selection-participation-key"], stateProofKey: e["state-proof-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"] });
  }
}, Is = class extends se {
  constructor({ amount: e, receiver: t, closeAmount: n, closeRemainderTo: i }) {
    super(), this.amount = e, this.receiver = t, this.closeAmount = n, this.closeRemainderTo = i, this.attribute_map = { amount: "amount", receiver: "receiver", closeAmount: "close-amount", closeRemainderTo: "close-remainder-to" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount == "undefined")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e.receiver == "undefined")
      throw new Error(`Response is missing required field 'receiver': ${e}`);
    return new Is({ amount: e.amount, receiver: e.receiver, closeAmount: e["close-amount"], closeRemainderTo: e["close-remainder-to"] });
  }
}, La = class extends se {
  constructor({ currentRound: e, transaction: t }) {
    super(), this.currentRound = e, this.transaction = t, this.attribute_map = { currentRound: "current-round", transaction: "transaction" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    if (typeof e.transaction == "undefined")
      throw new Error(`Response is missing required field 'transaction': ${e}`);
    return new La({ currentRound: e["current-round"], transaction: tn.from_obj_for_encoding(e.transaction) });
  }
}, Ts = class extends se {
  constructor({ logicsig: e, multisig: t, sig: n }) {
    super(), this.logicsig = e, this.multisig = t, this.sig = typeof n == "string" ? new Uint8Array(ot.Buffer.from(n, "base64")) : n, this.attribute_map = { logicsig: "logicsig", multisig: "multisig", sig: "sig" };
  }
  static from_obj_for_encoding(e) {
    return new Ts({ logicsig: typeof e.logicsig != "undefined" ? Ss.from_obj_for_encoding(e.logicsig) : void 0, multisig: typeof e.multisig != "undefined" ? ui.from_obj_for_encoding(e.multisig) : void 0, sig: e.sig });
  }
}, Ss = class extends se {
  constructor({ logic: e, args: t, multisigSignature: n, signature: i }) {
    super(), this.logic = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.args = t, this.multisigSignature = n, this.signature = typeof i == "string" ? new Uint8Array(ot.Buffer.from(i, "base64")) : i, this.attribute_map = { logic: "logic", args: "args", multisigSignature: "multisig-signature", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.logic == "undefined")
      throw new Error(`Response is missing required field 'logic': ${e}`);
    return new Ss({ logic: e.logic, args: e.args, multisigSignature: typeof e["multisig-signature"] != "undefined" ? ui.from_obj_for_encoding(e["multisig-signature"]) : void 0, signature: e.signature });
  }
}, ui = class extends se {
  constructor({ subsignature: e, threshold: t, version: n }) {
    super(), this.subsignature = e, this.threshold = t, this.version = n, this.attribute_map = { subsignature: "subsignature", threshold: "threshold", version: "version" };
  }
  static from_obj_for_encoding(e) {
    return new ui({ subsignature: typeof e.subsignature != "undefined" ? e.subsignature.map(Fs.from_obj_for_encoding) : void 0, threshold: e.threshold, version: e.version });
  }
}, Fs = class extends se {
  constructor({ publicKey: e, signature: t }) {
    super(), this.publicKey = typeof e == "string" ? new Uint8Array(ot.Buffer.from(e, "base64")) : e, this.signature = typeof t == "string" ? new Uint8Array(ot.Buffer.from(t, "base64")) : t, this.attribute_map = { publicKey: "public-key", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    return new Fs({ publicKey: e["public-key"], signature: e.signature });
  }
}, Ns = class extends se {
  constructor({ message: e, stateProof: t, stateProofType: n }) {
    super(), this.message = e, this.stateProof = t, this.stateProofType = n, this.attribute_map = { message: "message", stateProof: "state-proof", stateProofType: "state-proof-type" };
  }
  static from_obj_for_encoding(e) {
    return new Ns({ message: typeof e.message != "undefined" ? us.from_obj_for_encoding(e.message) : void 0, stateProof: typeof e["state-proof"] != "undefined" ? ds.from_obj_for_encoding(e["state-proof"]) : void 0, stateProofType: e["state-proof-type"] });
  }
}, Ua = class extends se {
  constructor({ currentRound: e, transactions: t, nextToken: n }) {
    super(), this.currentRound = e, this.transactions = t, this.nextToken = n, this.attribute_map = { currentRound: "current-round", transactions: "transactions", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] == "undefined")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    if (!Array.isArray(e.transactions))
      throw new Error(`Response is missing required array field 'transactions': ${e}`);
    return new Ua({ currentRound: e["current-round"], transactions: e.transactions.map(tn.from_obj_for_encoding), nextToken: e["next-token"] });
  }
};
var Pa = class extends oe {
  constructor(e, t, n, i) {
    super(e, t), this.index = n, this.index = n;
    let s = Id.Buffer.from(i).toString("base64");
    this.query.name = encodeURI(`b64:${s}`);
  }
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  prepare(e) {
    return ii.from_obj_for_encoding(e);
  }
};
var za = class extends oe {
  path() {
    return "/v2/accounts";
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  authAddr(e) {
    return this.query["auth-addr"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
var qa = class extends oe {
  path() {
    return "/v2/transactions";
  }
  notePrefix(e) {
    return this.query["note-prefix"] = ha(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  addressRole(e) {
    return this.query["address-role"] = e, this;
  }
  address(e) {
    return this.query.address = e, this;
  }
  excludeCloseTo(e) {
    return this.query["exclude-close-to"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
var $a = class extends oe {
  path() {
    return "/v2/assets";
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  creator(e) {
    return this.query.creator = e, this;
  }
  name(e) {
    return this.query.name = e, this;
  }
  unit(e) {
    return this.query.unit = e, this;
  }
  index(e) {
    return this.query["asset-id"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
var Va = class extends oe {
  path() {
    return "/v2/applications";
  }
  index(e) {
    return this.query["application-id"] = e, this;
  }
  creator(e) {
    return this.query.creator = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
var Ga = class extends oe {
  constructor(e, t, n) {
    super(e, t), this.index = n, this.index = n;
  }
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  prepare(e) {
    return si.from_obj_for_encoding(e);
  }
};
var fi = class extends Jr {
  constructor(e, t = "http://127.0.0.1", n = 8080, i = {}) {
    super("X-Indexer-API-Token", e, t, n, i);
  }
  makeHealthCheck() {
    return new fa(this.c, this.intDecoding);
  }
  lookupAssetBalances(e) {
    return new la(this.c, this.intDecoding, e);
  }
  lookupAssetTransactions(e) {
    return new pa(this.c, this.intDecoding, e);
  }
  lookupAccountTransactions(e) {
    return new da(this.c, this.intDecoding, e);
  }
  lookupBlock(e) {
    return new ga(this.c, this.intDecoding, e);
  }
  lookupTransactionByID(e) {
    return new ma(this.c, this.intDecoding, e);
  }
  lookupAccountByID(e) {
    return new ya(this.c, this.intDecoding, e);
  }
  lookupAccountAssets(e) {
    return new xa(this.c, this.intDecoding, e);
  }
  lookupAccountCreatedAssets(e) {
    return new wa(this.c, this.intDecoding, e);
  }
  lookupAccountAppLocalStates(e) {
    return new ba(this.c, this.intDecoding, e);
  }
  lookupAccountCreatedApplications(e) {
    return new va(this.c, this.intDecoding, e);
  }
  lookupAssetByID(e) {
    return new _a(this.c, this.intDecoding, e);
  }
  lookupApplications(e) {
    return new Aa(this.c, this.intDecoding, e);
  }
  lookupApplicationLogs(e) {
    return new Ea(this.c, this.intDecoding, e);
  }
  searchAccounts() {
    return new za(this.c, this.intDecoding);
  }
  searchForTransactions() {
    return new qa(this.c, this.intDecoding);
  }
  searchForAssets() {
    return new $a(this.c, this.intDecoding);
  }
  searchForApplications() {
    return new Va(this.c, this.intDecoding);
  }
  searchForApplicationBoxes(e) {
    return new Ga(this.c, this.intDecoding, e);
  }
  lookupApplicationBoxByIDandName(e, t) {
    return new Pa(this.c, this.intDecoding, e, t);
  }
};
async function Jc(r, e, t) {
  let n = await r.status().do();
  if (typeof n == "undefined")
    throw new Error("Unable to get node status");
  let i = n["last-round"] + 1, s = i;
  for (; s < i + t; ) {
    let o = false;
    try {
      let c = await r.pendingTransactionInformation(e).do();
      if (c["confirmed-round"])
        return c;
      if (c["pool-error"])
        throw o = true, new Error(`Transaction Rejected: ${c["pool-error"]}`);
    } catch (c) {
      if (o)
        throw c;
    }
    await r.statusAfterBlock(s).do(), s += 1;
  }
  throw new Error(`Transaction not confirmed after ${t} rounds`);
}
var Td = lt(Tt());
function rn(r, e) {
  let t = r.toString(16);
  t.length !== e * 2 && (t = t.padStart(e * 2, "0"));
  let n = new Uint8Array(t.length / 2);
  for (let i = 0, s = 0; i < t.length / 2; i++, s += 2)
    n[i] = parseInt(t.slice(s, s + 2), 16);
  return n;
}
function Wa(r) {
  let e = BigInt(0), t = Td.Buffer.from(r);
  for (let n = 0; n < r.length; n++)
    e = BigInt(Number(t.readUIntBE(n, 1))) + e * BigInt(256);
  return e;
}
function Ka() {
  let r = Pl();
  return { addr: xe(r.publicKey), sk: r.secretKey };
}
var om = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"], Zc = om;
var pf = "failed to decode mnemonic", am = "the mnemonic contains a word that is not in the wordlist";
function Sd(r) {
  let e = [], t = 0, n = 0;
  function i(o) {
    t |= o << n, n += 8, n >= 11 && (e.push(t & 2047), t >>= 11, n -= 11);
  }
  function s() {
    n && e.push(t);
  }
  return r.forEach(i), s(), e;
}
function Fd(r) {
  return r.map((e) => Zc[e]);
}
function Nd(r) {
  let e = tr(r), t = Sd(e);
  return Fd(t)[0];
}
function Xc(r) {
  if (r.length !== jc)
    throw new RangeError(`Seed length must be ${jc}`);
  let e = Sd(r), t = Fd(e), n = Nd(r);
  return `${t.join(" ")} ${n}`;
}
function cm(r) {
  let e = [], t = 0, n = 0;
  function i(o) {
    for (t |= o << n, n += 11; n >= 8; )
      e.push(t & 255), t >>= 8, n -= 8;
  }
  function s() {
    n && e.push(t);
  }
  return r.forEach(i), s(), new Uint8Array(e);
}
function Qc(r) {
  let e = r.split(" "), t = e.slice(0, 24);
  for (let c of t)
    if (Zc.indexOf(c) === -1)
      throw new Error(am);
  let n = e[e.length - 1], i = t.map((c) => Zc.indexOf(c)), s = cm(i);
  if (s.length !== 33)
    throw new Error(pf);
  if (s[s.length - 1] !== 0)
    throw new Error(pf);
  if (s = s.slice(0, s.length - 1), Nd(s) === n)
    return s;
  throw new Error(pf);
}
function li(r) {
  let e = Qc(r), t = Zu(e);
  return { addr: xe(t.publicKey), sk: t.secretKey };
}
function eu(r) {
  let e = r.slice(0, jc);
  return Xc(e);
}
function Od(r) {
  return Qc(r);
}
function Dd(r) {
  return Xc(r);
}
var Os = lt(Tt());
var Md = 16, gf = class {
  constructor(e) {
    if (this.name = "Transaction group", this.tag = Os.Buffer.from("TG"), e.length > Md) {
      let t = `${e.length.toString()} transactions grouped together but max group size is ${Md.toString()}`;
      throw Error(t);
    }
    this.txGroupHashes = e;
  }
  get_obj_for_encoding() {
    return { txlist: this.txGroupHashes };
  }
  static from_obj_for_encoding(e) {
    let t = Object.create(this.prototype);
    t.name = "Transaction group", t.tag = Os.Buffer.from("TG"), t.txGroupHashes = [];
    for (let n of e.txlist)
      t.txGroupHashes.push(Os.Buffer.from(n));
    return t;
  }
  toByte() {
    return Mt(this.get_obj_for_encoding());
  }
};
function mf(r) {
  let e = [];
  for (let o of r) {
    let c = yr(o);
    e.push(c.rawTxID());
  }
  let t = new gf(e), n = t.toByte(), i = Os.Buffer.from(Nt(t.tag, n)), s = tr(i);
  return Os.Buffer.from(s);
}
function tu(r, e) {
  let t = mf(r), n = [];
  for (let i of r) {
    let s = yr(i);
    (!e || xe(s.from.publicKey) === e) && (s.group = t, n.push(s));
  }
  return n;
}
var nn = lt(Tt());
var vn = lt(Tt());
var um = "Not enough multisig transactions to merge. Need at least two", fm = "Cannot merge txs. txIDs differ", lm = "Cannot merge txs. Auth addrs differ", Rd = "Cannot merge txs. Multisig preimages differ", dm = "Cannot merge txs. subsigs are mismatched.", hm = "Key does not exist", Cd = "Cannot mutate a multisig field as it would invalidate all existing signatures.", pm = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.", gm = "Cannot add multisig signature. Signature is not of the correct length.";
function yf(r, { version: e, threshold: t, addrs: n }) {
  let i = n.map((h2) => Ue(h2).publicKey), s = i.map((h2) => ({ pk: vn.Buffer.from(h2) })), o = { v: e, thr: t, subsig: s }, c = r.get_obj_for_encoding(), l2 = { msig: o, txn: c }, f2 = Rr({ version: e, threshold: t, pks: i });
  return xe(c.snd) !== xe(f2) && (l2.sgnr = vn.Buffer.from(f2)), new Uint8Array(Mt(l2));
}
function kd(r, { rawSig: e, myPk: t }, { version: n, threshold: i, pks: s }) {
  let o = yf(r, { version: n, threshold: i, addrs: s.map((h2) => xe(h2)) }), c = St(o), l2 = false;
  if (c.msig.subsig.forEach((h2, _) => {
    kc(h2.pk, t) && (l2 = true, c.msig.subsig[_].s = e);
  }), l2 === false)
    throw new Error(hm);
  let f2 = Rr({ version: n, threshold: i, pks: s });
  return xe(c.txn.snd) !== xe(f2) && (c.sgnr = vn.Buffer.from(f2)), new Uint8Array(Mt(c));
}
var _n = class extends At {
  addLease() {
    throw new Error(Cd);
  }
  addRekey() {
    throw new Error(Cd);
  }
  signTxn(e) {
    throw new Error(pm);
  }
  partialSignTxn({ version: e, threshold: t, pks: n }, i) {
    let s = Wr(i).publicKey;
    return kd(this, { rawSig: this.rawSignTxn(i), myPk: s }, { version: e, threshold: t, pks: n });
  }
  partialSignWithMultisigSignature(e, t, n) {
    if (!Cc(n.length))
      throw new Error(gm);
    return kd(this, { rawSig: n, myPk: Ue(t).publicKey }, e);
  }
  static from_obj_for_encoding(e) {
    return super.from_obj_for_encoding(e);
  }
};
function Ds(r) {
  if (r.length < 2)
    throw new Error(um);
  let e = St(r[0]), t = _n.from_obj_for_encoding(e.txn).txID(), n = e.sgnr ? xe(e.sgnr) : void 0, i = { version: e.msig.v, threshold: e.msig.thr, pks: e.msig.subsig.map((f2) => f2.pk) }, s = xe(Rr(i)), o = e.msig.subsig.map((f2) => at({}, f2));
  for (let f2 = 1; f2 < r.length; f2++) {
    let h2 = St(r[f2]);
    if (_n.from_obj_for_encoding(h2.txn).txID() !== t)
      throw new Error(fm);
    let j2 = h2.sgnr ? xe(h2.sgnr) : void 0;
    if (n !== j2)
      throw new Error(lm);
    if (h2.msig.subsig.length !== e.msig.subsig.length)
      throw new Error(Rd);
    let ie = { version: h2.msig.v, threshold: h2.msig.thr, pks: h2.msig.subsig.map((Q) => Q.pk) }, G = xe(Rr(ie));
    if (s !== G)
      throw new Error(Rd);
    h2.msig.subsig.forEach((Q, N2) => {
      if (!Q.s)
        return;
      let U = o[N2];
      if (U.s && vn.Buffer.compare(vn.Buffer.from(Q.s), vn.Buffer.from(U.s)) !== 0)
        throw new Error(dm);
      U.s = Q.s;
    });
  }
  let l2 = { msig: { v: e.msig.v, thr: e.msig.thr, subsig: o }, txn: e.txn };
  return typeof n != "undefined" && (l2.sgnr = vn.Buffer.from(Ue(n).publicKey)), new Uint8Array(Mt(l2));
}
function ru(r, e, t) {
  let n = e.v, i = e.thr, s = e.subsig, o = s.map((h2) => h2.pk);
  if (e.subsig.length < i)
    return false;
  let c;
  try {
    c = Rr({ version: n, threshold: i, pks: o });
  } catch (h2) {
    return false;
  }
  if (!kn(c, t))
    return false;
  let l2 = 0;
  for (let h2 of s)
    h2.s !== void 0 && (l2 += 1);
  if (l2 < i)
    return false;
  let f2 = 0;
  for (let h2 of s)
    h2.s !== void 0 && Cn(r, h2.s, h2.pk) && (f2 += 1);
  return !(f2 < i);
}
function nu(r, { version: e, threshold: t, addrs: n }, i) {
  let s = nf({ version: e, threshold: t, addrs: n });
  Object.prototype.hasOwnProperty.call(r, "from") || (r.from = s);
  let o = n.map((h2) => Ue(h2).publicKey), c = r instanceof At, l2, f2;
  return c ? (l2 = r, f2 = _n.prototype.partialSignTxn.call(l2, { version: e, threshold: t, pks: o }, i)) : (l2 = new _n(r), f2 = l2.partialSignTxn({ version: e, threshold: t, pks: o }, i)), { txID: l2.txID().toString(), blob: f2 };
}
function jd(r, { version: e, threshold: t, addrs: n }, i) {
  let s = n.map((f2) => Ue(f2).publicKey), o = St(r), c = _n.from_obj_for_encoding(o.txn), l2 = c.partialSignTxn({ version: e, threshold: t, pks: s }, i);
  return { txID: c.txID().toString(), blob: Ds([r, l2]) };
}
function Bd(r, { version: e, threshold: t, addrs: n }, i, s) {
  let o = n.map((h2) => Ue(h2).publicKey), c = St(r), l2 = _n.from_obj_for_encoding(c.txn), f2 = l2.partialSignWithMultisigSignature({ version: e, threshold: t, pks: o }, i, s);
  return { txID: l2.txID().toString(), blob: Ds([r, f2]) };
}
function Ld({ version: r, threshold: e, addrs: t }) {
  return nf({ version: r, threshold: e, addrs: t });
}
function Ud(r) {
  if (!r || r.length === 0)
    throw new Error("empty program");
  let e = `
`.charCodeAt(0), t = " ".charCodeAt(0), n = "~".charCodeAt(0), i = (o) => t <= o && o <= n;
  if (r.every((o) => o === e || i(o))) {
    let o = nn.Buffer.from(r).toString();
    throw hn(o) ? new Error("requesting program bytes, get Algorand address") : nn.Buffer.from(o, "base64").toString("base64") === o ? new Error("program should not be b64 encoded") : new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
var Tr = class {
  constructor(e, t) {
    if (this.tag = nn.Buffer.from("Program"), t && (!Array.isArray(t) || !t.every((i) => i.constructor === Uint8Array || nn.Buffer.isBuffer(i))))
      throw new TypeError("Invalid arguments");
    let n;
    t != null && (n = t.map((i) => new Uint8Array(i))), Ud(e), this.logic = e, this.args = n, this.sig = void 0, this.msig = void 0;
  }
  get_obj_for_encoding() {
    let e = { l: this.logic };
    return this.args && (e.arg = this.args), this.sig ? e.sig = this.sig : this.msig && (e.msig = this.msig), e;
  }
  static from_obj_for_encoding(e) {
    let t = new Tr(e.l, e.arg);
    return t.sig = e.sig, t.msig = e.msig, t;
  }
  verify(e) {
    if (this.sig && this.msig)
      return false;
    try {
      Ud(this.logic);
    } catch (n) {
      return false;
    }
    let t = Nt(this.tag, this.logic);
    if (!this.sig && !this.msig) {
      let n = tr(t);
      return kn(n, e);
    }
    return this.sig ? Cn(t, this.sig, e) : ru(t, this.msig, e);
  }
  address() {
    let e = Nt(this.tag, this.logic), t = tr(e);
    return xe(new Uint8Array(t));
  }
  sign(e, t) {
    if (t == null)
      this.sig = this.signProgram(e);
    else {
      let n = t.addrs.map((o) => ({ pk: Ue(o).publicKey }));
      this.msig = { v: t.version, thr: t.threshold, subsig: n };
      let [i, s] = this.singleSignMultisig(e, this.msig);
      this.msig.subsig[s].s = i;
    }
  }
  appendToMultisig(e) {
    if (this.msig === void 0)
      throw new Error("no multisig present");
    let [t, n] = this.singleSignMultisig(e, this.msig);
    this.msig.subsig[n].s = t;
  }
  signProgram(e) {
    let t = Nt(this.tag, this.logic);
    return Kr(t, e);
  }
  singleSignMultisig(e, t) {
    let n = -1, i = Wr(e).publicKey;
    for (let o = 0; o < t.subsig.length; o++) {
      let { pk: c } = t.subsig[o];
      if (kn(c, i)) {
        n = o;
        break;
      }
    }
    if (n === -1)
      throw new Error("invalid secret key");
    return [this.signProgram(e), n];
  }
  toByte() {
    return Mt(this.get_obj_for_encoding());
  }
  static fromByte(e) {
    let t = St(e);
    return Tr.from_obj_for_encoding(t);
  }
}, jr = class {
  constructor(e, t) {
    this.lsig = new Tr(e, t), this.sigkey = void 0;
  }
  get_obj_for_encoding() {
    let e = { lsig: this.lsig.get_obj_for_encoding() };
    return this.sigkey && (e.sigkey = this.sigkey), e;
  }
  static from_obj_for_encoding(e) {
    let t = new jr(e.lsig.l, e.lsig.arg);
    return t.lsig = Tr.from_obj_for_encoding(e.lsig), t.sigkey = e.sigkey, t;
  }
  toByte() {
    return Mt(this.get_obj_for_encoding());
  }
  static fromByte(e) {
    let t = St(e);
    return jr.from_obj_for_encoding(t);
  }
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig);
  }
  verify() {
    let e = this.address();
    return this.lsig.verify(Ue(e).publicKey);
  }
  address() {
    if (this.lsig.sig && this.lsig.msig)
      throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
    if (this.lsig.sig) {
      if (!this.sigkey)
        throw new Error("Signing key for delegated account is missing");
      return xe(this.sigkey);
    }
    if (this.lsig.msig) {
      let e = { version: this.lsig.msig.v, threshold: this.lsig.msig.thr, pks: this.lsig.msig.subsig.map((t) => t.pk) };
      return xe(Rr(e));
    }
    return this.lsig.address();
  }
  signMultisig(e, t) {
    this.lsig.sign(t, e);
  }
  appendToMultisig(e) {
    this.lsig.appendToMultisig(e);
  }
  sign(e) {
    this.lsig.sign(e), this.sigkey = Wr(e).publicKey;
  }
};
function mm(r, e, t) {
  if (!e.verify(t))
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  let n = { lsig: e.get_obj_for_encoding(), txn: r.get_obj_for_encoding() };
  return kc(t, r.from.publicKey) || (n.sgnr = nn.Buffer.from(t)), { txID: r.txID().toString(), blob: Mt(n) };
}
function di(r, e) {
  let t, n;
  if (e instanceof jr)
    t = e.lsig, n = Ue(e.address()).publicKey;
  else if (t = e, t.sig)
    n = r.from.publicKey;
  else if (t.msig) {
    let i = { version: t.msig.v, threshold: t.msig.thr, pks: t.msig.subsig.map((s) => s.pk) };
    n = Rr(i);
  } else
    n = Ue(t.address()).publicKey;
  return mm(r, t, n);
}
function Pd(r, e) {
  let t = yr(r);
  return di(t, e);
}
function zd(r) {
  return Tr.fromByte(r);
}
var qd = nn.Buffer.from("ProgData");
function xf(r, e, t) {
  let n = Nt(Ue(t).publicKey, e), i = nn.Buffer.from(Nt(qd, n));
  return Kr(i, r);
}
function $d(r, e, t, n) {
  let i = Nt(Ue(e).publicKey, r), s = nn.Buffer.from(Nt(qd, i));
  return Cn(s, t, n);
}
function Vd(r, e, t) {
  let i = new Tr(t).address();
  return xf(r, e, i);
}
var Gd = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(r, e) {
  Gd[r] = e;
});
function Wd(r) {
  let e = [], t = 0, n = 0;
  for (let i = 0; i < r.length; i += 1) {
    let s = Gd[r[i]];
    if (s === void 0)
      throw new Error("Invalid character (" + r[i] + ")");
    let o = s & 32;
    if (s &= 31, n += s << t, o)
      t += 5;
    else {
      let c = n & 1;
      n >>>= 1, c ? e.push(n === 0 ? -2147483648 : -n) : e.push(n), n = t = 0;
    }
  }
  return e;
}
var iu = class {
  constructor({ version: e, sources: t, names: n, mappings: i }) {
    if (this.version = e, this.sources = t, this.names = n, this.mappings = i, this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    let s = this.mappings.split(";").map((c) => {
      let l2 = Wd(c);
      if (l2.length > 2)
        return l2[2];
    });
    this.pcToLine = {}, this.lineToPc = {};
    let o = 0;
    for (let [c, l2] of s.entries())
      l2 !== void 0 && (o += l2), o in this.lineToPc || (this.lineToPc[o] = []), this.lineToPc[o].push(c), this.pcToLine[c] = o;
  }
  getLineForPc(e) {
    return this.pcToLine[e];
  }
  getPcsForLine(e) {
    return this.lineToPc[e];
  }
};
var Ms = lt(Tt());
var wm = 1380011588, wf = 30;
function Kd(r) {
  return r.params["approval-program"] = Ms.Buffer.from(r.params["approval-program"].toString(), "base64"), r.params["clear-state-program"] = Ms.Buffer.from(r.params["clear-state-program"].toString(), "base64"), r;
}
async function bm({ client: r, txns: e, protocolVersion: t, latestTimestamp: n, round: i, sources: s }) {
  let o = [], c = [], l2 = [], f2 = [], h2 = [];
  for (let G of e)
    G.txn.type === wt.appl && (h2.push(xe(G.txn.from.publicKey)), G.txn.appAccounts && h2.push(...G.txn.appAccounts.map((Q) => xe(Q.publicKey))), G.txn.appForeignApps && (l2.push(...G.txn.appForeignApps), h2.push(...G.txn.appForeignApps.map((Q) => Bn(Q)))), G.txn.appForeignAssets && f2.push(...G.txn.appForeignAssets), G.txn.appIndex === void 0 || G.txn.appIndex === 0 ? o.push(new Zr({ id: wm, params: new Xr({ creator: xe(G.txn.from.publicKey), approvalProgram: G.txn.appApprovalProgram, clearStateProgram: G.txn.appClearProgram, localStateSchema: new xr({ numUint: G.txn.appLocalInts, numByteSlice: G.txn.appLocalByteSlices }), globalStateSchema: new xr({ numUint: G.txn.appGlobalInts, numByteSlice: G.txn.appGlobalByteSlices }) }) })) : (l2.push(G.txn.appIndex), h2.push(Bn(G.txn.appIndex))));
  let _ = [];
  for (let G of [...new Set(f2)])
    _.push(r.getAssetByID(G).do().then((Q) => {
      h2.push(Q.params.creator);
    }));
  await Promise.all(_);
  let j2 = [];
  for (let G of [...new Set(l2)])
    j2.push(r.getApplicationByID(G).do().then((Q) => {
      let N2 = Kd(Q);
      o.push(N2), h2.push(N2.params.creator);
    }));
  await Promise.all(j2);
  let ie = [];
  for (let G of [...new Set(h2)])
    ie.push(r.accountInformation(G).do().then((Q) => {
      "created-apps" in Q && (Q["created-apps"] = Q["created-apps"].map((N2) => Kd(N2))), c.push(Q);
    }));
  return await Promise.all(ie), new Gn({ txns: e.map((G) => Er(at({}, G), { txn: G.txn.get_obj_for_encoding() })), accounts: c, apps: o, latestTimestamp: n, round: i, protocolVersion: t, sources: s });
}
var vf = class {
  constructor(e) {
    this.type = 0, this.bytes = "", this.uint = 0, this.type = e.type, this.bytes = e.bytes, this.uint = e.uint;
  }
  toString() {
    return this.type === 1 ? `0x${Ms.Buffer.from(this.bytes, "base64").toString("hex")}` : this.uint.toString();
  }
}, _f2 = class {
  constructor(e) {
    this.error = "", this.line = 0, this.pc = 0, this.scratch = [], this.stack = [], this.error = e.error === void 0 ? "" : e.error, this.line = e.line, this.pc = e.pc, this.scratch = e.scratch, this.stack = e.stack.map((t) => new vf(t));
  }
}, su = class {
  constructor(e) {
    this.trace = [], e != null && (this.trace = e.map((t) => new _f2(t)));
  }
};
function bf(r, e) {
  return r.length > e && e > 0 ? `${r.slice(0, e)}...` : r;
}
function vm(r, e) {
  if (e.length === 0)
    return "";
  let t = null;
  for (let i = 0; i < e.length; i++) {
    if (i > r.length) {
      t = i;
      continue;
    }
    JSON.stringify(r[i]) !== JSON.stringify(e[i]) && (t = i);
  }
  if (t == null)
    return "";
  let n = e[t];
  return n.bytes.length > 0 ? `${t} = 0x${Ms.Buffer.from(n.bytes, "base64").toString("hex")}` : `${t} = ${n.uint.toString()}`;
}
function _m(r, e) {
  return `[${(e ? r.reverse() : r).map((n) => {
    switch (n.type) {
      case 1:
        return `0x${Ms.Buffer.from(n.bytes, "base64").toString("hex")}`;
      case 2:
        return `${n.uint.toString()}`;
      default:
        return "";
    }
  }).join(", ")}]`;
}
var Rs = class {
  constructor(e) {
    this.disassembly = [], this.appCallMessages = [], this.localDeltas = [], this.globalDelta = [], this.cost = 0, this.logicSigMessages = [], this.logicSigDisassembly = [], this.logs = [], this.appCallTrace = void 0, this.logicSigTrace = void 0, this.required = ["disassembly"], this.optionals = ["app-call-messages", "local-deltas", "global-delta", "cost", "logic-sig-messages", "logic-sig-disassembly", "logs"], this.traces = ["app-call-trace", "logic-sig-trace"], this.disassembly = e.disassembly, this.appCallMessages = e["app-call-messages"], this.localDeltas = e["local-deltas"], this.globalDelta = e["global-delta"], this.cost = e.cost, this.logicSigMessages = e["logic-sig-messages"], this.logicSigDisassembly = e["logic-sig-disassembly"], this.logs = e.logs, this.appCallTrace = new su(e["app-call-trace"]), this.logicSigTrace = new su(e["logic-sig-trace"]);
  }
  appCallRejected() {
    return this.appCallMessages !== void 0 && this.appCallMessages.includes("REJECT");
  }
  logicSigRejected() {
    return this.logicSigMessages !== void 0 && this.logicSigMessages.includes("REJECT");
  }
  static trace(e, t, n) {
    let i = n.maxValueWidth || wf, s = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let c = 0; c < e.trace.length; c++) {
      let { line: l2, error: f2, pc: h2, scratch: _, stack: j2 } = e.trace[c], ie = _ !== void 0 ? _ : [], G = c > 0 && e.trace[c - 1].scratch !== void 0 ? e.trace[c - 1].scratch : [], Q = f2 === "" ? t[l2] : `!! ${f2} !!`;
      s.push([h2.toString().padEnd(3, " "), l2.toString().padEnd(3, " "), bf(Q, i), bf(vm(G, ie), i), bf(_m(j2, n.topOfStackFirst), i)]);
    }
    let o = s.reduce((c, l2) => {
      let f2 = new Array(s[0].length).fill(0);
      for (let h2 = 0; h2 < c.length; h2++)
        f2[h2] = l2[h2].length > c[h2] ? l2[h2].length : c[h2];
      return f2;
    }, new Array(s[0].length).fill(0));
    return `${s.map((c) => c.map((l2, f2) => l2.padEnd(o[f2] + 1, " ")).join("|").trim()).join(`
`)}
`;
  }
  appTrace(e) {
    if (this.appCallTrace === void 0 || !this.disassembly)
      return "";
    let t = e;
    return e === void 0 && (t = { maxValueWidth: wf, topOfStackFirst: false }), Rs.trace(this.appCallTrace, this.disassembly, t);
  }
  lsigTrace(e) {
    if (this.logicSigTrace === void 0 || this.logicSigDisassembly === void 0)
      return "";
    let t = e;
    return e === void 0 && (t = { maxValueWidth: wf, topOfStackFirst: true }), Rs.trace(this.logicSigTrace, this.logicSigDisassembly, t);
  }
}, Af = class {
  constructor(e) {
    this.error = "", this.protocolVersion = "", this.txns = [], this.error = e.error, this.protocolVersion = e["protocol-version"], this.txns = e.txns.map((t) => new Rs(t));
  }
};
function Hd(r, e, t, n, i, s, o) {
  let c = { from: r, to: e, amount: t, closeRemainderTo: n, note: i, suggestedParams: s, type: wt.pay, reKeyTo: o };
  return new At(c);
}
function ou(r) {
  return Hd(r.from, r.to, r.amount, r.closeRemainderTo, r.note, r.suggestedParams, r.rekeyTo);
}
function Yd(r, e, t, n, i, s, o, c, l2, f2 = false, h2 = void 0) {
  let _ = { from: r, note: e, voteKey: t, selectionKey: n, voteFirst: i, voteLast: s, voteKeyDilution: o, suggestedParams: c, type: wt.keyreg, reKeyTo: l2, nonParticipation: f2, stateProofKey: h2 };
  return new At(_);
}
function Am(r) {
  return Yd(r.from, r.note, r.voteKey, r.selectionKey, r.voteFirst, r.voteLast, r.voteKeyDilution, r.suggestedParams, r.rekeyTo, r.nonParticipation, r.stateProofKey);
}
function au(r, e, t, n, i, s, o, c, l2, f2, h2, _, j2, ie, G) {
  let Q = { from: r, note: e, suggestedParams: ie, assetTotal: t, assetDecimals: n, assetDefaultFrozen: i, assetUnitName: f2, assetName: h2, assetURL: _, assetMetadataHash: j2, assetManager: s, assetReserve: o, assetFreeze: c, assetClawback: l2, type: wt.acfg, reKeyTo: G };
  return new At(Q);
}
function Em(r) {
  return au(r.from, r.note, r.total, r.decimals, r.defaultFrozen, r.manager, r.reserve, r.freeze, r.clawback, r.unitName, r.assetName, r.assetURL, r.assetMetadataHash, r.suggestedParams, r.rekeyTo);
}
function Jd(r, e, t, n, i, s, o, c, l2 = true, f2) {
  if (l2 && (n === void 0 || i === void 0 || s === void 0 || o === void 0))
    throw Error("strict empty address checking was turned on, but at least one empty address was provided");
  let h2 = { from: r, suggestedParams: c, assetIndex: t, assetManager: n, assetReserve: i, assetFreeze: s, assetClawback: o, type: wt.acfg, note: e, reKeyTo: f2 };
  return new At(h2);
}
function Im(r) {
  return Jd(r.from, r.note, r.assetIndex, r.manager, r.reserve, r.freeze, r.clawback, r.suggestedParams, r.strictEmptyAddressChecking, r.rekeyTo);
}
function cu(r, e, t, n, i) {
  let s = { from: r, suggestedParams: n, assetIndex: t, type: wt.acfg, note: e, reKeyTo: i };
  return new At(s);
}
function Tm(r) {
  return cu(r.from, r.note, r.assetIndex, r.suggestedParams, r.rekeyTo);
}
function Zd(r, e, t, n, i, s, o) {
  let c = { from: r, type: wt.afrz, freezeAccount: n, assetIndex: t, freezeState: i, note: e, suggestedParams: s, reKeyTo: o };
  return new At(c);
}
function Sm(r) {
  return Zd(r.from, r.note, r.assetIndex, r.freezeTarget, r.freezeState, r.suggestedParams, r.rekeyTo);
}
function Xd(r, e, t, n, i, s, o, c, l2) {
  let f2 = { type: wt.axfer, from: r, to: e, amount: i, suggestedParams: c, assetIndex: o, note: s, assetRevocationTarget: n, closeRemainderTo: t, reKeyTo: l2 };
  return new At(f2);
}
function Ha(r) {
  return Xd(r.from, r.to, r.closeRemainderTo, r.revocationTarget, r.amount, r.note, r.assetIndex, r.suggestedParams, r.rekeyTo);
}
function Ya(r, e, t, n, i, s, o, c, l2, f2, h2, _, j2, ie, G, Q, N2, U) {
  let ee = { type: wt.appl, from: r, suggestedParams: e, appIndex: 0, appOnComplete: t, appLocalInts: s, appLocalByteSlices: o, appGlobalInts: c, appGlobalByteSlices: l2, appApprovalProgram: n, appClearProgram: i, appArgs: f2, appAccounts: h2, appForeignApps: _, appForeignAssets: j2, boxes: U, note: ie, lease: G, reKeyTo: Q, extraPages: N2 };
  return new At(ee);
}
function Ef(r) {
  return Ya(r.from, r.suggestedParams, r.onComplete, r.approvalProgram, r.clearProgram, r.numLocalInts, r.numLocalByteSlices, r.numGlobalInts, r.numGlobalByteSlices, r.appArgs, r.accounts, r.foreignApps, r.foreignAssets, r.note, r.lease, r.rekeyTo, r.extraPages, r.boxes);
}
function uu(r, e, t, n, i, s, o, c, l2, f2, h2, _, j2) {
  let ie = { type: wt.appl, from: r, suggestedParams: e, appIndex: t, appApprovalProgram: n, appOnComplete: Ht.UpdateApplicationOC, appClearProgram: i, appArgs: s, appAccounts: o, appForeignApps: c, appForeignAssets: l2, boxes: j2, note: f2, lease: h2, reKeyTo: _ };
  return new At(ie);
}
function Fm(r) {
  return uu(r.from, r.suggestedParams, r.appIndex, r.approvalProgram, r.clearProgram, r.appArgs, r.accounts, r.foreignApps, r.foreignAssets, r.note, r.lease, r.rekeyTo, r.boxes);
}
function fu(r, e, t, n, i, s, o, c, l2, f2, h2) {
  let _ = { type: wt.appl, from: r, suggestedParams: e, appIndex: t, appOnComplete: Ht.DeleteApplicationOC, appArgs: n, appAccounts: i, appForeignApps: s, appForeignAssets: o, boxes: h2, note: c, lease: l2, reKeyTo: f2 };
  return new At(_);
}
function Nm(r) {
  return fu(r.from, r.suggestedParams, r.appIndex, r.appArgs, r.accounts, r.foreignApps, r.foreignAssets, r.note, r.lease, r.rekeyTo, r.boxes);
}
function Qd(r, e, t, n, i, s, o, c, l2, f2, h2) {
  let _ = { type: wt.appl, from: r, suggestedParams: e, appIndex: t, appOnComplete: Ht.OptInOC, appArgs: n, appAccounts: i, appForeignApps: s, appForeignAssets: o, boxes: h2, note: c, lease: l2, reKeyTo: f2 };
  return new At(_);
}
function If(r) {
  return Qd(r.from, r.suggestedParams, r.appIndex, r.appArgs, r.accounts, r.foreignApps, r.foreignAssets, r.note, r.lease, r.rekeyTo, r.boxes);
}
function eh(r, e, t, n, i, s, o, c, l2, f2, h2) {
  let _ = { type: wt.appl, from: r, suggestedParams: e, appIndex: t, appOnComplete: Ht.CloseOutOC, appArgs: n, appAccounts: i, appForeignApps: s, appForeignAssets: o, boxes: h2, note: c, lease: l2, reKeyTo: f2 };
  return new At(_);
}
function Tf(r) {
  return eh(r.from, r.suggestedParams, r.appIndex, r.appArgs, r.accounts, r.foreignApps, r.foreignAssets, r.note, r.lease, r.rekeyTo, r.boxes);
}
function th(r, e, t, n, i, s, o, c, l2, f2, h2) {
  let _ = { type: wt.appl, from: r, suggestedParams: e, appIndex: t, appOnComplete: Ht.ClearStateOC, appArgs: n, appAccounts: i, appForeignApps: s, appForeignAssets: o, boxes: h2, note: c, lease: l2, reKeyTo: f2 };
  return new At(_);
}
function Om(r) {
  return th(r.from, r.suggestedParams, r.appIndex, r.appArgs, r.accounts, r.foreignApps, r.foreignAssets, r.note, r.lease, r.rekeyTo, r.boxes);
}
function rh(r, e, t, n, i, s, o, c, l2, f2, h2) {
  let _ = { type: wt.appl, from: r, suggestedParams: e, appIndex: t, appOnComplete: Ht.NoOpOC, appArgs: n, appAccounts: i, appForeignApps: s, appForeignAssets: o, boxes: h2, note: c, lease: l2, reKeyTo: f2 };
  return new At(_);
}
function lu(r) {
  return rh(r.from, r.suggestedParams, r.appIndex, r.appArgs, r.accounts, r.foreignApps, r.foreignAssets, r.note, r.lease, r.rekeyTo, r.boxes);
}
function Sf(r) {
  let e = { type: wt.appl, from: r.from, suggestedParams: r.suggestedParams, appIndex: r.appIndex, appOnComplete: r.onComplete, appLocalInts: r.numLocalInts, appLocalByteSlices: r.numLocalByteSlices, appGlobalInts: r.numGlobalInts, appGlobalByteSlices: r.numGlobalByteSlices, appApprovalProgram: r.approvalProgram, appClearProgram: r.clearProgram, appArgs: r.appArgs, appAccounts: r.accounts, appForeignApps: r.foreignApps, appForeignAssets: r.foreignAssets, boxes: r.boxes, note: r.note, lease: r.lease, reKeyTo: r.rekeyTo, extraPages: r.extraPages };
  return new At(e);
}
function Dm(r) {
  return (e, t) => {
    let n = [];
    for (let i of t)
      n.push(e[i].signTxn(r.sk));
    return Promise.resolve(n);
  };
}
function Mm(r) {
  return (e, t) => {
    let n = [];
    for (let i of t) {
      let { blob: s } = di(e[i], r);
      n.push(s);
    }
    return Promise.resolve(n);
  };
}
function Rm(r, e) {
  return (t, n) => {
    let i = [];
    for (let s of n) {
      let o = t[s], c = [];
      for (let l2 of e) {
        let { blob: f2 } = nu(o, r, l2);
        c.push(f2);
      }
      i.push(Ds(c));
    }
    return Promise.resolve(i);
  };
}
function Cm() {
  return (r, e) => {
    let t = [];
    for (let n of e)
      t.push(uf(r[n]));
    return Promise.resolve(t);
  };
}
function du(r) {
  return typeof r == "object" && Object.keys(r).length === 2 && typeof r.txn == "object" && typeof r.signer == "function";
}
var Mf = lt(Tt());
var Cs = lt(Tt());
var hi = 2 ** 16 - 1, nh = 32, ih = 1, sh = 1, ir = 2, km = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/, jm = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/, Vt = class {
  static from(e) {
    if (e.endsWith("[]")) {
      let t = Vt.from(e.slice(0, e.length - 2));
      return new Us(t);
    }
    if (e.endsWith("]")) {
      let t = e.match(km);
      if (t.length !== 3)
        throw new Error(`malformed static array string: ${e}`);
      let n = t[2], i = parseInt(n, 10);
      if (i > hi)
        throw new Error(`array length exceeds limit ${hi}`);
      let s = Vt.from(t[1]);
      return new Ls(s, i);
    }
    if (e.startsWith("uint")) {
      let t = (s) => [...s].every((o) => "0123456789".includes(o)), n = e.slice(4, e.length);
      if (!t(n))
        throw new Error(`malformed uint string: ${n}`);
      let i = parseInt(n, 10);
      if (i > hi)
        throw new Error(`malformed uint string: ${i}`);
      return new Br(i);
    }
    if (e === "byte")
      return new js();
    if (e.startsWith("ufixed")) {
      let t = e.match(jm);
      if (t.length !== 3)
        throw new Error(`malformed ufixed type: ${e}`);
      let n = parseInt(t[1], 10), i = parseInt(t[2], 10);
      return new ks(n, i);
    }
    if (e === "bool")
      return new Sr();
    if (e === "address")
      return new An();
    if (e === "string")
      return new Bs();
    if (e.length >= 2 && e[0] === "(" && e[e.length - 1] === ")") {
      let t = hr.parseTupleContent(e.slice(1, e.length - 1)), n = [];
      for (let i = 0; i < t.length; i++) {
        let s = Vt.from(t[i]);
        n.push(s);
      }
      return new hr(n);
    }
    throw new Error(`cannot convert a string ${e} to an ABI type`);
  }
}, Br = class extends Vt {
  constructor(e) {
    if (super(), e % 8 !== 0 || e < 8 || e > 512)
      throw new Error(`unsupported uint type bitSize: ${e}`);
    this.bitSize = e;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(e) {
    return e instanceof Br && this.bitSize === e.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(e) {
    if (typeof e != "bigint" && typeof e != "number")
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${e}`);
    if (e >= BigInt(2 ** this.bitSize) || e < BigInt(0))
      throw new Error(`${e} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    if (typeof e == "number" && !Number.isSafeInteger(e))
      throw new Error(`${e} should be converted into a BigInt before it is encoded`);
    return rn(e, this.bitSize / 8);
  }
  decode(e) {
    if (e.length !== this.bitSize / 8)
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    return Wa(e);
  }
}, ks = class extends Vt {
  constructor(e, t) {
    if (super(), e % 8 !== 0 || e < 8 || e > 512)
      throw new Error(`unsupported ufixed type bitSize: ${e}`);
    if (t > 160 || t < 1)
      throw new Error(`unsupported ufixed type precision: ${t}`);
    this.bitSize = e, this.precision = t;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(e) {
    return e instanceof ks && this.bitSize === e.bitSize && this.precision === e.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(e) {
    if (typeof e != "bigint" && typeof e != "number")
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (e >= BigInt(2 ** this.bitSize) || e < BigInt(0))
      throw new Error(`${e} is not a non-negative int or too big to fit in size ${this.toString()}`);
    if (typeof e == "number" && !Number.isSafeInteger(e))
      throw new Error(`${e} should be converted into a BigInt before it is encoded`);
    return rn(e, this.bitSize / 8);
  }
  decode(e) {
    if (e.length !== this.bitSize / 8)
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    return Wa(e);
  }
}, An = class extends Vt {
  toString() {
    return "address";
  }
  equals(e) {
    return e instanceof An;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return nh;
  }
  encode(e) {
    if (typeof e != "string" && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (typeof e == "string")
      return Ue(e).publicKey;
    if (e.byteLength !== 32)
      throw new Error("byte string must be 32 bytes long for an address");
    return e;
  }
  decode(e) {
    if (e.byteLength !== 32)
      throw new Error("byte string must be 32 bytes long for an address");
    return xe(e);
  }
}, Sr = class extends Vt {
  toString() {
    return "bool";
  }
  equals(e) {
    return e instanceof Sr;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return sh;
  }
  encode(e) {
    if (typeof e != "boolean")
      throw new Error(`Cannot encode value as bool: ${e}`);
    return e ? new Uint8Array([128]) : new Uint8Array([0]);
  }
  decode(e) {
    if (e.byteLength !== 1)
      throw new Error("bool string must be 1 byte long");
    let t = e[0];
    if (t === 128)
      return true;
    if (t === 0)
      return false;
    throw new Error("boolean could not be decoded from the byte string");
  }
}, js = class extends Vt {
  toString() {
    return "byte";
  }
  equals(e) {
    return e instanceof js;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return ih;
  }
  encode(e) {
    if (typeof e != "number" && typeof e != "bigint")
      throw new Error(`Cannot encode value as byte: ${e}`);
    if (typeof e == "bigint" && (e = Number(e)), e < 0 || e > 255)
      throw new Error(`${e} cannot be encoded into a byte`);
    return new Uint8Array([e]);
  }
  decode(e) {
    if (e.byteLength !== 1)
      throw new Error("byte string must be 1 byte long");
    return e[0];
  }
}, Bs = class extends Vt {
  toString() {
    return "string";
  }
  equals(e) {
    return e instanceof Bs;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(e) {
    if (typeof e != "string" && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as string: ${e}`);
    let t = Cs.Buffer.from(e), n = rn(t.length, ir), i = new Uint8Array(t.length + ir);
    return i.set(n), i.set(t, ir), i;
  }
  decode(e) {
    if (e.length < ir)
      throw new Error(`byte string is too short to be decoded. Actual length is ${e.length}, but expected at least ${ir}`);
    let n = Cs.Buffer.from(e).readUIntBE(0, ir), i = e.slice(ir, e.length);
    if (n !== i.length)
      throw new Error(`string length bytes do not match the actual length of string. Expected ${n}, got ${i.length}`);
    return Cs.Buffer.from(i).toString("utf-8");
  }
}, Ls = class extends Vt {
  constructor(e, t) {
    if (super(), t < 0)
      throw new Error(`static array must have a non negative length: ${t}`);
    this.childType = e, this.staticLength = t;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(e) {
    return e instanceof Ls && this.staticLength === e.staticLength && this.childType.equals(e.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    return this.childType.constructor === Sr ? Math.ceil(this.staticLength / 8) : this.staticLength * this.childType.byteLen();
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (e.length !== this.staticLength)
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${e.length}`);
    return this.toABITupleType().encode(e);
  }
  decode(e) {
    return this.toABITupleType().decode(e);
  }
  toABITupleType() {
    return new hr(Array(this.staticLength).fill(this.childType));
  }
}, Us = class extends Vt {
  constructor(e) {
    super(), this.childType = e;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(e) {
    return e instanceof Us && this.childType.equals(e.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    let t = this.toABITupleType(e.length), n = t.encode(e), i = rn(t.childTypes.length, ir);
    return Nt(i, n);
  }
  decode(e) {
    let n = Cs.Buffer.from(e).readUIntBE(0, ir);
    return this.toABITupleType(n).decode(e.slice(ir, e.length));
  }
  toABITupleType(e) {
    return new hr(Array(e).fill(this.childType));
  }
}, hr = class extends Vt {
  constructor(e) {
    if (super(), e.length >= hi)
      throw new Error("tuple type child type number larger than maximum uint16 error");
    this.childTypes = e;
  }
  toString() {
    let e = [];
    for (let t = 0; t < this.childTypes.length; t++)
      e[t] = this.childTypes[t].toString();
    return `(${e.join(",")})`;
  }
  equals(e) {
    return e instanceof hr && this.childTypes.length === e.childTypes.length && this.childTypes.every((t, n) => t.equals(e.childTypes[n]));
  }
  isDynamic() {
    let e = (t) => t.isDynamic();
    return this.childTypes.some(e);
  }
  byteLen() {
    let e = 0;
    for (let t = 0; t < this.childTypes.length; t++)
      if (this.childTypes[t].constructor === Sr) {
        let n = Ja(this.childTypes, t, 1), i = n + 1;
        t += n, e += Math.trunc((i + 7) / 8);
      } else {
        let n = this.childTypes[t].byteLen();
        e += n;
      }
    return e;
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    let t = Array.from(e);
    if (e.length > hi)
      throw new Error("length of tuple array should not exceed a uint16");
    let n = this.childTypes, i = [], s = [], o = /* @__PURE__ */ new Map(), c = 0;
    for (; c < n.length; ) {
      let h2 = n[c];
      if (h2.isDynamic())
        o.set(i.length, true), i.push(new Uint8Array([0, 0])), s.push(h2.encode(t[c]));
      else {
        if (h2.constructor === Sr) {
          let _ = Ja(n, c, -1), j2 = Ja(n, c, 1);
          if (_ % 8 !== 0)
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          j2 = Math.min(7, j2);
          let ie = Bm(t.slice(c, c + j2 + 1));
          i.push(rn(ie, 1)), c += j2;
        } else {
          let _ = h2.encode(t[c]);
          i.push(_);
        }
        o.set(c, false), s.push(new Uint8Array());
      }
      c += 1;
    }
    let l2 = 0;
    for (let h2 of i)
      l2 += h2.length;
    let f2 = 0;
    for (let h2 = 0; h2 < i.length; h2++) {
      if (o.get(h2)) {
        let _ = l2 + f2;
        if (_ > hi)
          throw new Error(`byte length of ${_} should not exceed a uint16`);
        i[h2] = rn(_, ir);
      }
      f2 += s[h2].length;
    }
    return Nt(...i, ...s);
  }
  decode(e) {
    let t = this.childTypes, n = [], i = [], s = 0, o = 0, c = Cs.Buffer.from(e);
    for (; s < t.length; ) {
      let h2 = t[s];
      if (h2.isDynamic()) {
        if (e.slice(o, e.length).length < ir)
          throw new Error("dynamic type in tuple is too short to be decoded");
        let _ = c.readUIntBE(o, ir);
        if (n.length > 0 && (n[n.length - 1].right = _, _ < n[n.length - 1].left))
          throw new Error("dynamic index segment miscalculation: left is greater than right index");
        let j2 = { left: _, right: -1 };
        n.push(j2), i.push(null), o += ir;
      } else if (h2.constructor === Sr) {
        let _ = Ja(this.childTypes, s, -1), j2 = Ja(this.childTypes, s, 1);
        if (_ % 8 !== 0)
          throw new Error("expected before bool number mod 8 === 0");
        j2 = Math.min(7, j2);
        for (let ie = 0; ie <= j2; ie++) {
          let G = 128 >> ie;
          (e[o] & G) > 0 ? i.push(new Uint8Array([128])) : i.push(new Uint8Array([0]));
        }
        s += j2, o += 1;
      } else {
        let _ = h2.byteLen();
        i.push(e.slice(o, o + _)), o += _;
      }
      if (s !== t.length - 1 && o >= e.length)
        throw new Error("input byte not enough to decode");
      s += 1;
    }
    if (n.length > 0 && (n[n.length - 1].right = e.length, o = e.length), o < e.length)
      throw new Error("input byte not fully consumed");
    for (let h2 = 0; h2 < n.length; h2++) {
      let _ = n[h2];
      if (_.left > _.right)
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      if (h2 !== n.length - 1 && _.right !== n[h2 + 1].left)
        throw new Error("dynamic segment should be consecutive");
    }
    let l2 = 0;
    for (let h2 = 0; h2 < t.length; h2++)
      t[h2].isDynamic() && (i[h2] = e.slice(n[l2].left, n[l2].right), l2 += 1);
    let f2 = [];
    for (let h2 = 0; h2 < t.length; h2++) {
      let _ = t[h2].decode(i[h2]);
      f2.push(_);
    }
    return f2;
  }
  static parseTupleContent(e) {
    if (e.length === 0)
      return [];
    if (e.endsWith(",") || e.startsWith(","))
      throw new Error("tuple string should not start with comma");
    if (e.includes(",,"))
      throw new Error("tuple string should not have consecutive commas");
    let t = [], n = 0, i = "";
    for (let s of e)
      i += s, s === "(" ? n += 1 : s === ")" ? n -= 1 : s === "," && n === 0 && (t.push(i.slice(0, i.length - 1)), i = "");
    if (i.length !== 0 && t.push(i), n !== 0)
      throw new Error("tuple string has mismatched parentheses");
    return t;
  }
};
function Bm(r) {
  let e = 0;
  if (r.length > 8)
    throw new Error("value list passed in should be no greater than length 8");
  for (let t = 0; t < r.length; t++) {
    let n = r[t];
    if (typeof n != "boolean")
      throw new Error("non-boolean values cannot be compressed into a byte");
    n && (e |= 1 << 7 - t);
  }
  return e;
}
function Ja(r, e, t) {
  let n = 0;
  for (; ; ) {
    let i = e + t * n;
    if (r[i].constructor === Sr)
      if (i !== r.length - 1 && t === 1)
        n += 1;
      else if (i > 0 && t === -1)
        n += 1;
      else
        break;
    else {
      n -= 1;
      break;
    }
  }
  return n;
}
var Fr;
(function(r) {
  r.any = "txn", r.pay = "pay", r.keyreg = "keyreg", r.acfg = "acfg", r.axfer = "axfer", r.afrz = "afrz", r.appl = "appl";
})(Fr || (Fr = {}));
function Ps(r) {
  return r === Fr.any || r === Fr.pay || r === Fr.keyreg || r === Fr.acfg || r === Fr.axfer || r === Fr.afrz || r === Fr.appl;
}
function Ff(r, e) {
  return r === Fr.any ? true : e.type && e.type.toString() === r.toString();
}
var Lr;
(function(r) {
  r.account = "account", r.application = "application", r.asset = "asset";
})(Lr || (Lr = {}));
function Za(r) {
  return r === Lr.account || r === Lr.application || r === Lr.asset;
}
function Lm(r) {
  let e = r.indexOf("(");
  if (e === -1)
    throw new Error(`Invalid method signature: ${r}`);
  let t = -1, n = 0;
  for (let i = e; i < r.length; i++) {
    let s = r[i];
    if (s === "(")
      n += 1;
    else if (s === ")") {
      if (n === 0)
        break;
      if (n -= 1, n === 0) {
        t = i;
        break;
      }
    }
  }
  if (t === -1)
    throw new Error(`Invalid method signature: ${r}`);
  return { name: r.slice(0, e), args: hr.parseTupleContent(r.slice(e + 1, t)), returns: r.slice(t + 1) };
}
var Ur = class {
  constructor(e) {
    if (typeof e.name != "string" || typeof e.returns != "object" || !Array.isArray(e.args))
      throw new Error("Invalid ABIMethod parameters");
    this.name = e.name, this.description = e.desc, this.args = e.args.map(({ type: t, name: n, desc: i }) => Ps(t) || Za(t) ? { type: t, name: n, description: i } : { type: Vt.from(t), name: n, description: i }), this.returns = { type: e.returns.type === "void" ? e.returns.type : Vt.from(e.returns.type), description: e.returns.desc };
  }
  getSignature() {
    let e = this.args.map((n) => n.type.toString()).join(","), t = this.returns.type.toString();
    return `${this.name}(${e})${t}`;
  }
  getSelector() {
    let e = tr(this.getSignature());
    return new Uint8Array(e.slice(0, 4));
  }
  txnCount() {
    let e = 1;
    for (let t of this.args)
      typeof t.type == "string" && Ps(t.type) && (e += 1);
    return e;
  }
  toJSON() {
    return { name: this.name, desc: this.description, args: this.args.map(({ type: e, name: t, description: n }) => ({ type: e.toString(), name: t, desc: n })), returns: { type: this.returns.type.toString(), desc: this.returns.description } };
  }
  static fromSignature(e) {
    let { name: t, args: n, returns: i } = Lm(e);
    return new Ur({ name: t, args: n.map((s) => ({ type: s })), returns: { type: i } });
  }
};
function Xa(r, e) {
  if (r === null || !Array.isArray(r) || !r.every((n) => n instanceof Ur))
    throw new Error("Methods list provided is null or not the correct type");
  let t = r.filter((n) => n.name === e);
  if (t.length > 1)
    throw new Error(`found ${t.length} methods with the same name ${t.map((n) => n.getSignature()).join(",")}`);
  if (t.length === 0)
    throw new Error(`found 0 methods with the name ${e}`);
  return t[0];
}
var Nf = class {
  constructor(e) {
    if (typeof e.name != "string" || !Array.isArray(e.methods) || e.networks && typeof e.networks != "object")
      throw new Error("Invalid ABIContract parameters");
    this.name = e.name, this.description = e.desc, this.networks = e.networks ? at({}, e.networks) : {}, this.methods = e.methods.map((t) => new Ur(t));
  }
  toJSON() {
    return { name: this.name, desc: this.description, networks: this.networks, methods: this.methods.map((e) => e.toJSON()) };
  }
  getMethodByName(e) {
    return Xa(this.methods, e);
  }
};
var Of = class {
  constructor(e) {
    if (typeof e.name != "string" || !Array.isArray(e.methods))
      throw new Error("Invalid ABIInterface parameters");
    this.name = e.name, this.description = e.desc, this.methods = e.methods.map((t) => new Ur(t));
  }
  toJSON() {
    return { name: this.name, desc: this.description, methods: this.methods.map((e) => e.toJSON()) };
  }
  getMethodByName(e) {
    return Xa(this.methods, e);
  }
};
var Um = Mf.Buffer.from([21, 31, 124, 117]), Qa = 16, nr;
(function(r) {
  r[r.BUILDING = 0] = "BUILDING", r[r.BUILT = 1] = "BUILT", r[r.SIGNED = 2] = "SIGNED", r[r.SUBMITTED = 3] = "SUBMITTED", r[r.COMMITTED = 4] = "COMMITTED";
})(nr || (nr = {}));
function Df(r, e, t) {
  if (t != null && r === t)
    return 0;
  let n = t == null ? 0 : 1;
  for (let i = 0; i < e.length; i++)
    if (r === e[i])
      return i + n;
  return e.push(r), e.length - 1 + n;
}
var br = class {
  constructor() {
    this.status = nr.BUILDING, this.transactions = [], this.methodCalls = /* @__PURE__ */ new Map(), this.signedTxns = [], this.txIDs = [];
  }
  getStatus() {
    return this.status;
  }
  count() {
    return this.transactions.length;
  }
  clone() {
    let e = new br();
    return e.transactions = this.transactions.map(({ txn: t, signer: n }) => ({ txn: At.from_obj_for_encoding(Er(at({}, t.get_obj_for_encoding()), { grp: void 0 })), signer: n })), e.methodCalls = new Map(this.methodCalls), e;
  }
  addTransaction(e) {
    if (this.status !== nr.BUILDING)
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    if (this.transactions.length === br.MAX_GROUP_SIZE)
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${br.MAX_GROUP_SIZE}`);
    if (e.txn.group && e.txn.group.some((t) => t !== 0))
      throw new Error("Cannot add a transaction with nonzero group ID");
    this.transactions.push(e);
  }
  addMethodCall({ appID: e, method: t, methodArgs: n, sender: i, suggestedParams: s, onComplete: o, approvalProgram: c, clearProgram: l2, numGlobalInts: f2, numGlobalByteSlices: h2, numLocalInts: _, numLocalByteSlices: j2, extraPages: ie, appAccounts: G, appForeignApps: Q, appForeignAssets: N2, boxes: U, note: ee, lease: re2, rekeyTo: le, signer: H2 }) {
    if (this.status !== nr.BUILDING)
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    if (this.transactions.length + t.txnCount() > br.MAX_GROUP_SIZE)
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${br.MAX_GROUP_SIZE}`);
    if (e === 0) {
      if (c == null || l2 == null || f2 == null || h2 == null || _ == null || j2 == null)
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
    } else if (o === Ht.UpdateApplicationOC) {
      if (c == null || l2 == null)
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      if (f2 != null || h2 != null || _ != null || j2 != null || ie != null)
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    } else if (c != null || l2 != null || f2 != null || h2 != null || _ != null || j2 != null || ie != null)
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    if (n == null && (n = []), n.length !== t.args.length)
      throw new Error(`Incorrect number of method arguments. Expected ${t.args.length}, got ${n.length}`);
    let I = [], K2 = [], P2 = [], k2 = [], te2 = [], T = /* @__PURE__ */ new Map(), D2 = U || [];
    for (let Te = 0; Te < n.length; Te++) {
      let ze = t.args[Te].type, Je = n[Te];
      if (Ps(ze)) {
        if (!du(Je) || !Ff(ze, Je.txn))
          throw new Error(`Expected ${ze} TransactionWithSigner for argument at index ${Te}`);
        if (Je.txn.group && Je.txn.group.some((Be) => Be !== 0))
          throw new Error("Cannot add a transaction with nonzero group ID");
        P2.push(Je);
        continue;
      }
      if (du(Je))
        throw new Error(`Expected non-transaction value for argument at index ${Te}`);
      if (Za(ze) && (T.set(k2.length, I.length), k2.push(ze), te2.push(Je), ze = new Br(8)), typeof ze == "string")
        throw new Error(`Unknown ABI type: ${ze}`);
      I.push(ze), K2.push(Je);
    }
    let V2 = [], pe = G == null ? [] : G.slice(), we = Q == null ? [] : Q.slice(), ve = N2 == null ? [] : N2.slice();
    for (let Te = 0; Te < k2.length; Te++) {
      let ze = k2[Te], Je = te2[Te], Be = 0;
      switch (ze) {
        case Lr.account: {
          let W2 = new An(), Se = W2.decode(W2.encode(Je));
          Be = Df(Se, pe, i);
          break;
        }
        case Lr.application: {
          let W2 = new Br(64), Se = W2.decode(W2.encode(Je));
          if (Se > Number.MAX_SAFE_INTEGER)
            throw new Error(`Expected safe integer for application value, got ${Se}`);
          Be = Df(Number(Se), we, e);
          break;
        }
        case Lr.asset: {
          let W2 = new Br(64), Se = W2.decode(W2.encode(Je));
          if (Se > Number.MAX_SAFE_INTEGER)
            throw new Error(`Expected safe integer for asset value, got ${Se}`);
          Be = Df(Number(Se), ve);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${ze}`);
      }
      V2.push(Be);
    }
    for (let Te = 0; Te < V2.length; Te++) {
      let ze = T.get(Te);
      K2[ze] = V2[Te];
    }
    if (I.length > Qa - 1) {
      let Te = I.slice(Qa - 2), ze = K2.slice(Qa - 2);
      I = I.slice(0, Qa - 2), K2 = K2.slice(0, Qa - 2), I.push(new hr(Te)), K2.push(ze);
    }
    let qe = [t.getSelector()];
    for (let Te = 0; Te < I.length; Te++)
      qe.push(I[Te].encode(K2[Te]));
    let Ve = { txn: Sf({ from: i, appIndex: e, appArgs: qe, accounts: pe, foreignApps: we, foreignAssets: ve, boxes: D2, onComplete: o == null ? Ht.NoOpOC : o, approvalProgram: c, clearProgram: l2, numGlobalInts: f2, numGlobalByteSlices: h2, numLocalInts: _, numLocalByteSlices: j2, extraPages: ie, lease: re2, note: ee, rekeyTo: le, suggestedParams: s }), signer: H2 };
    this.transactions.push(...P2, Ve), this.methodCalls.set(this.transactions.length - 1, t);
  }
  buildGroup() {
    if (this.status === nr.BUILDING) {
      if (this.transactions.length === 0)
        throw new Error("Cannot build a group with 0 transactions");
      this.transactions.length > 1 && tu(this.transactions.map((e) => e.txn)), this.status = nr.BUILT;
    }
    return this.transactions;
  }
  async gatherSignatures() {
    if (this.status >= nr.SIGNED)
      return this.signedTxns;
    let e = this.buildGroup(), t = e.map((l2) => l2.txn), n = /* @__PURE__ */ new Map();
    for (let l2 = 0; l2 < e.length; l2++) {
      let { signer: f2 } = e[l2];
      n.has(f2) || n.set(f2, []), n.get(f2).push(l2);
    }
    let i = Array.from(n), s = await Promise.all(i.map(([l2, f2]) => l2(t, f2))), o = e.map(() => null);
    for (let l2 = 0; l2 < i.length; l2++) {
      let f2 = i[l2][1], h2 = s[l2];
      for (let _ = 0; _ < f2.length; _++)
        o[f2[_]] = h2[_];
    }
    if (!o.every((l2) => l2 != null))
      throw new Error(`Missing signatures. Got ${o}`);
    let c = o.map((l2, f2) => {
      try {
        return Yr(l2).txn.txID();
      } catch (h2) {
        throw new Error(`Cannot decode signed transaction at index ${f2}. ${h2}`);
      }
    });
    return this.signedTxns = o, this.txIDs = c, this.status = nr.SIGNED, o;
  }
  async submit(e) {
    if (this.status > nr.SUBMITTED)
      throw new Error("Transaction group cannot be resubmitted");
    let t = await this.gatherSignatures();
    return await e.sendRawTransaction(t).do(), this.status = nr.SUBMITTED, this.txIDs;
  }
  async simulate(e, t) {
    if (this.status > nr.SUBMITTED)
      throw new Error("Simulated Transaction group has already been submitted to the network");
    let i = (await this.gatherSignatures()).map((l2) => St(l2)), s = t == null ? new Qr({ txnGroups: [] }) : t;
    s.txnGroups = [new kr({ txns: i })];
    let o = await e.simulateTransactions(s).do(), c = [];
    for (let [l2, f2] of this.methodCalls) {
      let h2 = this.txIDs[l2], _ = o.txnGroups[0].txnResults[l2].txnResult, j2 = { txID: h2, rawReturnValue: new Uint8Array(), method: f2 };
      c.push(br.parseMethodResponse(f2, j2, _.get_obj_for_encoding()));
    }
    return { methodResults: c, simulateResponse: o };
  }
  async execute(e, t) {
    if (this.status === nr.COMMITTED)
      throw new Error("Transaction group has already been executed successfully");
    let n = await this.submit(e);
    this.status = nr.SUBMITTED;
    let i = this.transactions.findIndex((f2, h2) => this.methodCalls.has(h2)), o = await Jc(e, n[i === -1 ? 0 : i], t);
    this.status = nr.COMMITTED;
    let c = o["confirmed-round"], l2 = [];
    for (let [f2, h2] of this.methodCalls) {
      let _ = n[f2], j2 = { txID: _, rawReturnValue: new Uint8Array(), method: h2 };
      try {
        let ie = f2 === i ? o : await e.pendingTransactionInformation(_).do();
        j2 = br.parseMethodResponse(h2, j2, ie);
      } catch (ie) {
        j2.decodeError = ie;
      }
      l2.push(j2);
    }
    return { confirmedRound: c, txIDs: n, methodResults: l2 };
  }
  static parseMethodResponse(e, t, n) {
    let i = t;
    try {
      if (i.txInfo = n, e.returns.type !== "void") {
        let s = n.logs || [];
        if (s.length === 0)
          throw new Error("App call transaction did not log a return value");
        let o = Mf.Buffer.from(s[s.length - 1], "base64");
        if (o.byteLength < 4 || !o.slice(0, 4).equals(Um))
          throw new Error("App call transaction did not log a return value");
        i.rawReturnValue = new Uint8Array(o.slice(4)), i.returnValue = e.returns.type.decode(t.rawReturnValue);
      }
    } catch (s) {
      i.decodeError = s;
    }
    return i;
  }
};
br.MAX_GROUP_SIZE = 16;
var oh = hu.Buffer.from([77, 88]), ah = "The transaction sender address and multisig preimage do not match.";
function Pm(r, e) {
  if (typeof r.from == "undefined") {
    let n = Wr(e);
    r.from = xe(n.publicKey);
  }
  let t = yr(r);
  return { txID: t.txID().toString(), blob: t.signTxn(e) };
}
function zm(r, e) {
  return new oo(r).signBid(e);
}
function qm(r, e) {
  let t = hu.Buffer.from(Nt(oh, r));
  return Kr(t, e);
}
function $m(r, e, t) {
  let n = hu.Buffer.from(Nt(oh, r)), i = Ue(t).publicKey;
  return Cn(n, e, i);
}
function Vm(r) {
  return new Uint8Array(Mt(r));
}
function sr(r) {
  return St(r);
}
var Gm = new Error(ah), Wm = new Error(ao);
var Cf = Rf;
var Lp = lt(Tt(), 1);
function vt(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  throw new Error(typeof r == "number" ? "[MobX] minified error nr: " + r + (t.length ? " " + t.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + r);
}
var Km = {};
function Ah() {
  return typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : Km;
}
var Eh = Object.assign, xu = Object.getOwnPropertyDescriptor, zr = Object.defineProperty, sc = Object.prototype, Pf = [];
Object.freeze(Pf);
var Wf = {};
Object.freeze(Wf);
var Hm = typeof Proxy != "undefined", Ym = Object.toString();
function Ih() {
  Hm || vt("Proxy not available");
}
function Th(r) {
  var e = false;
  return function() {
    if (!e)
      return e = true, r.apply(this, arguments);
  };
}
var $s = function() {
};
function Ar(r) {
  return typeof r == "function";
}
function mi(r) {
  var e = typeof r;
  switch (e) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function Tu(r) {
  return r !== null && typeof r == "object";
}
function an(r) {
  if (!Tu(r))
    return false;
  var e = Object.getPrototypeOf(r);
  if (e == null)
    return true;
  var t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t.toString() === Ym;
}
function Sh(r) {
  var e = r == null ? void 0 : r.constructor;
  return e ? e.name === "GeneratorFunction" || e.displayName === "GeneratorFunction" : false;
}
function oc(r, e, t) {
  zr(r, e, { enumerable: false, writable: true, configurable: true, value: t });
}
function Fh(r, e, t) {
  zr(r, e, { enumerable: false, writable: false, configurable: true, value: t });
}
function Fn(r, e) {
  var t = "isMobX" + r;
  return e.prototype[t] = true, function(n) {
    return Tu(n) && n[t] === true;
  };
}
function Zs(r) {
  return r instanceof Map;
}
function ac(r) {
  return r instanceof Set;
}
var Nh = typeof Object.getOwnPropertySymbols != "undefined";
function Jm(r) {
  var e = Object.keys(r);
  if (!Nh)
    return e;
  var t = Object.getOwnPropertySymbols(r);
  return t.length ? [].concat(e, t.filter(function(n) {
    return sc.propertyIsEnumerable.call(r, n);
  })) : e;
}
var Gs = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Nh ? function(r) {
  return Object.getOwnPropertyNames(r).concat(Object.getOwnPropertySymbols(r));
} : Object.getOwnPropertyNames;
function Oh(r) {
  return r === null ? null : typeof r == "object" ? "" + r : r;
}
function on(r, e) {
  return sc.hasOwnProperty.call(r, e);
}
var Zm = Object.getOwnPropertyDescriptors || function(e) {
  var t = {};
  return Gs(e).forEach(function(n) {
    t[n] = xu(e, n);
  }), t;
};
function ch(r, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(r, e0(n.key), n);
  }
}
function Kf(r, e, t) {
  return e && ch(r.prototype, e), t && ch(r, t), Object.defineProperty(r, "prototype", { writable: false }), r;
}
function Ws() {
  return Ws = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }, Ws.apply(this, arguments);
}
function Dh(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, zf(r, e);
}
function zf(r, e) {
  return zf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, zf(r, e);
}
function kf(r) {
  if (r === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function Xm(r, e) {
  if (r) {
    if (typeof r == "string")
      return uh(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set")
      return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return uh(r, e);
  }
}
function uh(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = r[t];
  return n;
}
function Vs(r, e) {
  var t = typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
  if (t)
    return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = Xm(r)) || e && r && typeof r.length == "number") {
    t && (r = t);
    var n = 0;
    return function() {
      return n >= r.length ? { done: true } : { done: false, value: r[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Qm(r, e) {
  if (typeof r != "object" || r === null)
    return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e || "default");
    if (typeof n != "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function e0(r) {
  var e = Qm(r, "string");
  return typeof e == "symbol" ? e : String(e);
}
var Pr = Symbol("mobx-stored-annotations");
function qr(r) {
  function e(t, n) {
    cc(t, n, r);
  }
  return Object.assign(e, r);
}
function cc(r, e, t) {
  if (on(r, Pr) || oc(r, Pr, Ws({}, r[Pr])), false)
    ;
  f0(t) || (r[Pr][e] = t);
}
function r0(r) {
  return on(r, Pr) || oc(r, Pr, Ws({}, r[Pr])), r[Pr];
}
var He = Symbol("mobx administration"), uc = function() {
  function r(t) {
    t === void 0 && (t = "Atom"), this.name_ = void 0, this.isPendingUnobservation_ = false, this.isBeingObserved_ = false, this.observers_ = /* @__PURE__ */ new Set(), this.diffValue_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = bt.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = t;
  }
  var e = r.prototype;
  return e.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, e.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, e.reportObserved = function() {
    return Xh(this);
  }, e.reportChanged = function() {
    cr(), Qh(this), be.stateVersion = be.stateVersion < Number.MAX_SAFE_INTEGER ? be.stateVersion + 1 : Number.MIN_SAFE_INTEGER, ur();
  }, e.toString = function() {
    return this.name_;
  }, r;
}(), Hf = Fn("Atom", uc);
function Mh(r, e, t) {
  e === void 0 && (e = $s), t === void 0 && (t = $s);
  var n = new uc(r);
  return e !== $s && cy(n, e), t !== $s && cp(n, t), n;
}
function n0(r, e) {
  return r === e;
}
function i0(r, e) {
  return el(r, e);
}
function s0(r, e) {
  return el(r, e, 1);
}
function o0(r, e) {
  return Object.is ? Object.is(r, e) : r === e ? r !== 0 || 1 / r === 1 / e : r !== r && e !== e;
}
var Ks = { identity: n0, structural: i0, default: o0, shallow: s0 };
function Hs(r, e, t) {
  return Zf(r) ? r : Array.isArray(r) ? Ft.array(r, { name: t }) : an(r) ? Ft.object(r, void 0, { name: t }) : Zs(r) ? Ft.map(r, { name: t }) : ac(r) ? Ft.set(r, { name: t }) : typeof r == "function" && !hc(r) && !Au(r) ? Sh(r) ? nc(r) : rc(t, r) : r;
}
function a0(r, e, t) {
  if (r == null || xi(r) || mc(r) || On(r) || wi(r))
    return r;
  if (Array.isArray(r))
    return Ft.array(r, { name: t, deep: false });
  if (an(r))
    return Ft.object(r, void 0, { name: t, deep: false });
  if (Zs(r))
    return Ft.map(r, { name: t, deep: false });
  if (ac(r))
    return Ft.set(r, { name: t, deep: false });
}
function Su(r) {
  return r;
}
function c0(r, e) {
  return el(r, e) ? e : r;
}
var u0 = "override";
function f0(r) {
  return r.annotationType_ === u0;
}
function fc(r, e) {
  return { annotationType_: r, options_: e, make_: l0, extend_: d0 };
}
function l0(r, e, t, n) {
  var i;
  if ((i = this.options_) != null && i.bound)
    return this.extend_(r, e, t, false) === null ? 0 : 1;
  if (n === r.target_)
    return this.extend_(r, e, t, false) === null ? 0 : 2;
  if (hc(t.value))
    return 1;
  var s = Rh(r, this, e, t, false);
  return zr(n, e, s), 2;
}
function d0(r, e, t, n) {
  var i = Rh(r, this, e, t);
  return r.defineProperty_(e, i, n);
}
function h0(r, e, t, n) {
  e.annotationType_;
  n.value;
}
function Rh(r, e, t, n, i) {
  var s, o, c, l2, f2, h2, _;
  i === void 0 && (i = be.safeDescriptors), h0(r, e, t, n);
  var j2 = n.value;
  if ((s = e.options_) != null && s.bound) {
    var ie;
    j2 = j2.bind((ie = r.proxy_) != null ? ie : r.target_);
  }
  return { value: Ys((o = (c = e.options_) == null ? void 0 : c.name) != null ? o : t.toString(), j2, (l2 = (f2 = e.options_) == null ? void 0 : f2.autoAction) != null ? l2 : false, (h2 = e.options_) != null && h2.bound ? (_ = r.proxy_) != null ? _ : r.target_ : void 0), configurable: i ? r.isPlainObject_ : true, enumerable: false, writable: !i };
}
function Ch(r, e) {
  return { annotationType_: r, options_: e, make_: p0, extend_: g0 };
}
function p0(r, e, t, n) {
  var i;
  if (n === r.target_)
    return this.extend_(r, e, t, false) === null ? 0 : 2;
  if ((i = this.options_) != null && i.bound && (!on(r.target_, e) || !Au(r.target_[e])) && this.extend_(r, e, t, false) === null)
    return 0;
  if (Au(t.value))
    return 1;
  var s = kh(r, this, e, t, false, false);
  return zr(n, e, s), 2;
}
function g0(r, e, t, n) {
  var i, s = kh(r, this, e, t, (i = this.options_) == null ? void 0 : i.bound);
  return r.defineProperty_(e, s, n);
}
function m0(r, e, t, n) {
  e.annotationType_;
  n.value;
}
function kh(r, e, t, n, i, s) {
  s === void 0 && (s = be.safeDescriptors), m0(r, e, t, n);
  var o = n.value;
  if (Au(o) || (o = nc(o)), i) {
    var c;
    o = o.bind((c = r.proxy_) != null ? c : r.target_), o.isMobXFlow = true;
  }
  return { value: o, configurable: s ? r.isPlainObject_ : true, enumerable: false, writable: !s };
}
function Yf(r, e) {
  return { annotationType_: r, options_: e, make_: y0, extend_: x0 };
}
function y0(r, e, t) {
  return this.extend_(r, e, t, false) === null ? 0 : 1;
}
function x0(r, e, t, n) {
  return w0(r, this, e, t), r.defineComputedProperty_(e, Ws({}, this.options_, { get: t.get, set: t.set }), n);
}
function w0(r, e, t, n) {
  e.annotationType_;
  n.get;
}
function Fu(r, e) {
  return { annotationType_: r, options_: e, make_: b0, extend_: v0 };
}
function b0(r, e, t) {
  return this.extend_(r, e, t, false) === null ? 0 : 1;
}
function v0(r, e, t, n) {
  var i, s;
  return _0(r, this), r.defineObservableProperty_(e, t.value, (i = (s = this.options_) == null ? void 0 : s.enhancer) != null ? i : Hs, n);
}
function _0(r, e, t, n) {
  e.annotationType_;
}
var A0 = "true", E0 = jh();
function jh(r) {
  return { annotationType_: A0, options_: r, make_: I0, extend_: T0 };
}
function I0(r, e, t, n) {
  var i, s;
  if (t.get)
    return Nu.make_(r, e, t, n);
  if (t.set) {
    var o = Ys(e.toString(), t.set);
    return n === r.target_ ? r.defineProperty_(e, { configurable: be.safeDescriptors ? r.isPlainObject_ : true, set: o }) === null ? 0 : 2 : (zr(n, e, { configurable: true, set: o }), 2);
  }
  if (n !== r.target_ && typeof t.value == "function") {
    var c;
    if (Sh(t.value)) {
      var l2, f2 = (l2 = this.options_) != null && l2.autoBind ? nc.bound : nc;
      return f2.make_(r, e, t, n);
    }
    var h2 = (c = this.options_) != null && c.autoBind ? rc.bound : rc;
    return h2.make_(r, e, t, n);
  }
  var _ = ((i = this.options_) == null ? void 0 : i.deep) === false ? Ft.ref : Ft;
  if (typeof t.value == "function" && (s = this.options_) != null && s.autoBind) {
    var j2;
    t.value = t.value.bind((j2 = r.proxy_) != null ? j2 : r.target_);
  }
  return _.make_(r, e, t, n);
}
function T0(r, e, t, n) {
  var i, s;
  if (t.get)
    return Nu.extend_(r, e, t, n);
  if (t.set)
    return r.defineProperty_(e, { configurable: be.safeDescriptors ? r.isPlainObject_ : true, set: Ys(e.toString(), t.set) }, n);
  if (typeof t.value == "function" && (i = this.options_) != null && i.autoBind) {
    var o;
    t.value = t.value.bind((o = r.proxy_) != null ? o : r.target_);
  }
  var c = ((s = this.options_) == null ? void 0 : s.deep) === false ? Ft.ref : Ft;
  return c.extend_(r, e, t, n);
}
var S0 = "observable", F0 = "observable.ref", N0 = "observable.shallow", O0 = "observable.struct", Bh = { deep: true, name: void 0, defaultDecorator: void 0, proxy: true };
Object.freeze(Bh);
function pu(r) {
  return r || Bh;
}
var Lh = Fu(S0), D0 = Fu(F0, { enhancer: Su }), M0 = Fu(N0, { enhancer: a0 }), R0 = Fu(O0, { enhancer: c0 }), Uh = qr(Lh);
function gu(r) {
  return r.deep === true ? Hs : r.deep === false ? Su : k0(r.defaultDecorator);
}
function C0(r) {
  var e;
  return r ? (e = r.defaultDecorator) != null ? e : jh(r) : void 0;
}
function k0(r) {
  var e, t;
  return r && (e = (t = r.options_) == null ? void 0 : t.enhancer) != null ? e : Hs;
}
function Ph(r, e, t) {
  if (mi(e)) {
    cc(r, e, Lh);
    return;
  }
  return Zf(r) ? r : an(r) ? Ft.object(r, e, t) : Array.isArray(r) ? Ft.array(r, e) : Zs(r) ? Ft.map(r, e) : ac(r) ? Ft.set(r, e) : typeof r == "object" && r !== null ? r : Ft.box(r, e);
}
Eh(Ph, Uh);
var j0 = { box: function(e, t) {
  var n = pu(t);
  return new pi(e, gu(n), n.name, true, n.equals);
}, array: function(e, t) {
  var n = pu(t);
  return (be.useProxies === false || n.proxy === false ? Dy : _y)(e, gu(n), n.name);
}, map: function(e, t) {
  var n = pu(t);
  return new yc(e, gu(n), n.name);
}, set: function(e, t) {
  var n = pu(t);
  return new wp(e, gu(n), n.name);
}, object: function(e, t, n) {
  return fp(be.useProxies === false || (n == null ? void 0 : n.proxy) === false ? xc({}, n) : wy({}, n), e, t);
}, ref: qr(D0), shallow: qr(M0), deep: Uh, struct: qr(R0) }, Ft = Eh(Ph, j0), zh = "computed", B0 = "computed.struct", qh = Yf(zh), L0 = Yf(B0, { equals: Ks.structural }), Nu = function(e, t) {
  if (mi(t))
    return cc(e, t, qh);
  if (an(e))
    return qr(Yf(zh, e));
  var n = an(t) ? t : {};
  return n.get = e, n.name || (n.name = e.name || ""), new tc(n);
};
Object.assign(Nu, qh);
Nu.struct = qr(L0);
var fh, lh, wu = 0, U0 = 1, P0 = (fh = (lh = xu(function() {
}, "name")) == null ? void 0 : lh.configurable) != null ? fh : false, dh = { value: "action", configurable: true, writable: false, enumerable: false };
function Ys(r, e, t, n) {
  t === void 0 && (t = false);
  function i() {
    return $h(r, t, e, n || this, arguments);
  }
  return i.isMobxAction = true, P0 && (dh.value = r, zr(i, "name", dh)), i;
}
function $h(r, e, t, n, i) {
  var s = z0(r, e);
  try {
    return t.apply(n, i);
  } catch (o) {
    throw s.error_ = o, o;
  } finally {
    q0(s);
  }
}
function z0(r, e, t, n) {
  var i = false, s = 0;
  var c = be.trackingDerivation, l2 = !e || !c;
  cr();
  var f2 = be.allowStateChanges;
  l2 && (Xs(), f2 = lc(true));
  var h2 = Jf(true), _ = { runAsAction_: l2, prevDerivation_: c, prevAllowStateChanges_: f2, prevAllowStateReads_: h2, notifySpy_: i, startTime_: s, actionId_: U0++, parentActionId_: wu };
  return wu = _.actionId_, _;
}
function q0(r) {
  wu !== r.actionId_ && vt(30), wu = r.parentActionId_, r.error_ !== void 0 && (be.suppressReactionErrors = true), dc(r.prevAllowStateChanges_), ec(r.prevAllowStateReads_), ur(), r.runAsAction_ && Tn(r.prevDerivation_), be.suppressReactionErrors = false;
}
function Vh(r, e) {
  var t = lc(r);
  try {
    return e();
  } finally {
    dc(t);
  }
}
function lc(r) {
  var e = be.allowStateChanges;
  return be.allowStateChanges = r, e;
}
function dc(r) {
  be.allowStateChanges = r;
}
var Gh;
Gh = Symbol.toPrimitive;
var pi = function(r) {
  Dh(e, r);
  function e(n, i, s, o, c) {
    var l2;
    return s === void 0 && (s = "ObservableValue"), c === void 0 && (c = Ks.default), l2 = r.call(this, s) || this, l2.enhancer = void 0, l2.name_ = void 0, l2.equals = void 0, l2.hasUnreportedChange_ = false, l2.interceptors_ = void 0, l2.changeListeners_ = void 0, l2.value_ = void 0, l2.dehancer = void 0, l2.enhancer = i, l2.name_ = s, l2.equals = c, l2.value_ = i(n, void 0, s), l2;
  }
  var t = e.prototype;
  return t.dehanceValue = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, t.set = function(i) {
    this.value_;
    if (i = this.prepareNewValue_(i), i !== be.UNCHANGED) {
      this.setNewValue_(i);
    }
  }, t.prepareNewValue_ = function(i) {
    if (vr(this)) {
      var s = _r(this, { object: this, type: $r, newValue: i });
      if (!s)
        return be.UNCHANGED;
      i = s.newValue;
    }
    return i = this.enhancer(i, this.value_, this.name_), this.equals(this.value_, i) ? be.UNCHANGED : i;
  }, t.setNewValue_ = function(i) {
    var s = this.value_;
    this.value_ = i, this.reportChanged(), Nr(this) && Or(this, { type: $r, object: this, newValue: i, oldValue: s });
  }, t.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, t.intercept_ = function(i) {
    return pc(this, i);
  }, t.observe_ = function(i, s) {
    return s && i({ observableKind: "value", debugObjectName: this.name_, object: this, type: $r, newValue: this.value_, oldValue: void 0 }), gc(this, i);
  }, t.raw = function() {
    return this.value_;
  }, t.toJSON = function() {
    return this.get();
  }, t.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, t.valueOf = function() {
    return Oh(this.get());
  }, t[Gh] = function() {
    return this.valueOf();
  }, e;
}(uc), $0 = Fn("ObservableValue", pi), Wh;
Wh = Symbol.toPrimitive;
var tc = function() {
  function r(t) {
    this.dependenciesState_ = bt.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.isBeingObserved_ = false, this.isPendingUnobservation_ = false, this.observers_ = /* @__PURE__ */ new Set(), this.diffValue_ = 0, this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = bt.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new bu(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.isComputing_ = false, this.isRunningSetter_ = false, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = In.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, t.get || vt(31), this.derivation = t.get, this.name_ = t.name || "ComputedValue", t.set && (this.setter_ = Ys("ComputedValue-setter", t.set)), this.equals_ = t.equals || (t.compareStructural || t.struct ? Ks.structural : Ks.default), this.scope_ = t.context, this.requiresReaction_ = t.requiresReaction, this.keepAlive_ = !!t.keepAlive;
  }
  var e = r.prototype;
  return e.onBecomeStale_ = function() {
    H0(this);
  }, e.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, e.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, e.get = function() {
    if (this.isComputing_ && vt(32, this.name_, this.derivation), be.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_)
      qf(this) && (this.warnAboutUntrackedRead_(), cr(), this.value_ = this.computeValue_(false), ur());
    else if (Xh(this), qf(this)) {
      var n = be.trackingContext;
      this.keepAlive_ && !n && (be.trackingContext = this), this.trackAndCompute() && K0(this), be.trackingContext = n;
    }
    var i = this.value_;
    if (yu(i))
      throw i.cause;
    return i;
  }, e.set = function(n) {
    if (this.setter_) {
      this.isRunningSetter_ && vt(33, this.name_), this.isRunningSetter_ = true;
      try {
        this.setter_.call(this.scope_, n);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else
      vt(34, this.name_);
  }, e.trackAndCompute = function() {
    var n = this.value_, i = this.dependenciesState_ === bt.NOT_TRACKING_, s = this.computeValue_(true), o = i || yu(n) || yu(s) || !this.equals_(n, s);
    return o && (this.value_ = s), o;
  }, e.computeValue_ = function(n) {
    this.isComputing_ = true;
    var i = lc(false), s;
    if (n)
      s = Kh(this, this.derivation, this.scope_);
    else if (be.disableErrorBoundaries === true)
      s = this.derivation.call(this.scope_);
    else
      try {
        s = this.derivation.call(this.scope_);
      } catch (o) {
        s = new bu(o);
      }
    return dc(i), this.isComputing_ = false, s;
  }, e.suspend_ = function() {
    this.keepAlive_ || ($f(this), this.value_ = void 0);
  }, e.observe_ = function(n, i) {
    var s = this, o = true, c = void 0;
    return ny(function() {
      var l2 = s.get();
      if (!o || i) {
        var f2 = Xs();
        n({ observableKind: "computed", debugObjectName: s.name_, type: $r, object: s, newValue: l2, oldValue: c }), Tn(f2);
      }
      o = false, c = l2;
    });
  }, e.warnAboutUntrackedRead_ = function() {
  }, e.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, e.valueOf = function() {
    return Oh(this.get());
  }, e[Wh] = function() {
    return this.valueOf();
  }, r;
}(), yi = Fn("ComputedValue", tc), bt;
(function(r) {
  r[r.NOT_TRACKING_ = -1] = "NOT_TRACKING_", r[r.UP_TO_DATE_ = 0] = "UP_TO_DATE_", r[r.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", r[r.STALE_ = 2] = "STALE_";
})(bt || (bt = {}));
var In;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.LOG = 1] = "LOG", r[r.BREAK = 2] = "BREAK";
})(In || (In = {}));
var bu = function(e) {
  this.cause = void 0, this.cause = e;
};
function yu(r) {
  return r instanceof bu;
}
function qf(r) {
  switch (r.dependenciesState_) {
    case bt.UP_TO_DATE_:
      return false;
    case bt.NOT_TRACKING_:
    case bt.STALE_:
      return true;
    case bt.POSSIBLY_STALE_: {
      for (var e = Jf(true), t = Xs(), n = r.observing_, i = n.length, s = 0; s < i; s++) {
        var o = n[s];
        if (yi(o)) {
          if (be.disableErrorBoundaries)
            o.get();
          else
            try {
              o.get();
            } catch (c) {
              return Tn(t), ec(e), true;
            }
          if (r.dependenciesState_ === bt.STALE_)
            return Tn(t), ec(e), true;
        }
      }
      return Yh(r), Tn(t), ec(e), false;
    }
  }
}
function Js(r) {
  return;
}
function Kh(r, e, t) {
  var n = Jf(true);
  Yh(r), r.newObserving_ = new Array(r.observing_.length + 100), r.unboundDepsCount_ = 0, r.runId_ = ++be.runId;
  var i = be.trackingDerivation;
  be.trackingDerivation = r, be.inBatch++;
  var s;
  if (be.disableErrorBoundaries === true)
    s = e.call(t);
  else
    try {
      s = e.call(t);
    } catch (o) {
      s = new bu(o);
    }
  return be.inBatch--, be.trackingDerivation = i, V0(r), ec(n), s;
}
function V0(r) {
  for (var e = r.observing_, t = r.observing_ = r.newObserving_, n = bt.UP_TO_DATE_, i = 0, s = r.unboundDepsCount_, o = 0; o < s; o++) {
    var c = t[o];
    c.diffValue_ === 0 && (c.diffValue_ = 1, i !== o && (t[i] = c), i++), c.dependenciesState_ > n && (n = c.dependenciesState_);
  }
  for (t.length = i, r.newObserving_ = null, s = e.length; s--; ) {
    var l2 = e[s];
    l2.diffValue_ === 0 && Jh(l2, r), l2.diffValue_ = 0;
  }
  for (; i--; ) {
    var f2 = t[i];
    f2.diffValue_ === 1 && (f2.diffValue_ = 0, W0(f2, r));
  }
  n !== bt.UP_TO_DATE_ && (r.dependenciesState_ = n, r.onBecomeStale_());
}
function $f(r) {
  var e = r.observing_;
  r.observing_ = [];
  for (var t = e.length; t--; )
    Jh(e[t], r);
  r.dependenciesState_ = bt.NOT_TRACKING_;
}
function Hh(r) {
  var e = Xs();
  try {
    return r();
  } finally {
    Tn(e);
  }
}
function Xs() {
  var r = be.trackingDerivation;
  return be.trackingDerivation = null, r;
}
function Tn(r) {
  be.trackingDerivation = r;
}
function Jf(r) {
  var e = be.allowStateReads;
  return be.allowStateReads = r, e;
}
function ec(r) {
  be.allowStateReads = r;
}
function Yh(r) {
  if (r.dependenciesState_ !== bt.UP_TO_DATE_) {
    r.dependenciesState_ = bt.UP_TO_DATE_;
    for (var e = r.observing_, t = e.length; t--; )
      e[t].lowestObserverState_ = bt.UP_TO_DATE_;
  }
}
var jf = function() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = false, this.allowStateChanges = false, this.allowStateReads = true, this.enforceActions = true, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = false, this.reactionRequiresObservable = false, this.observableRequiresReaction = false, this.disableErrorBoundaries = false, this.suppressReactionErrors = false, this.useProxies = true, this.verifyProxies = false, this.safeDescriptors = true, this.stateVersion = Number.MIN_SAFE_INTEGER;
}, Bf = true, be = function() {
  var r = Ah();
  return r.__mobxInstanceCount > 0 && !r.__mobxGlobals && (Bf = false), r.__mobxGlobals && r.__mobxGlobals.version !== new jf().version && (Bf = false), Bf ? r.__mobxGlobals ? (r.__mobxInstanceCount += 1, r.__mobxGlobals.UNCHANGED || (r.__mobxGlobals.UNCHANGED = {}), r.__mobxGlobals) : (r.__mobxInstanceCount = 1, r.__mobxGlobals = new jf()) : (setTimeout(function() {
    vt(35);
  }, 1), new jf());
}();
function W0(r, e) {
  r.observers_.add(e), r.lowestObserverState_ > e.dependenciesState_ && (r.lowestObserverState_ = e.dependenciesState_);
}
function Jh(r, e) {
  r.observers_.delete(e), r.observers_.size === 0 && Zh(r);
}
function Zh(r) {
  r.isPendingUnobservation_ === false && (r.isPendingUnobservation_ = true, be.pendingUnobservations.push(r));
}
function cr() {
  be.inBatch++;
}
function ur() {
  if (--be.inBatch === 0) {
    ep();
    for (var r = be.pendingUnobservations, e = 0; e < r.length; e++) {
      var t = r[e];
      t.isPendingUnobservation_ = false, t.observers_.size === 0 && (t.isBeingObserved_ && (t.isBeingObserved_ = false, t.onBUO()), t instanceof tc && t.suspend_());
    }
    be.pendingUnobservations = [];
  }
}
function Xh(r) {
  var e = be.trackingDerivation;
  return e !== null ? (e.runId_ !== r.lastAccessedBy_ && (r.lastAccessedBy_ = e.runId_, e.newObserving_[e.unboundDepsCount_++] = r, !r.isBeingObserved_ && be.trackingContext && (r.isBeingObserved_ = true, r.onBO())), r.isBeingObserved_) : (r.observers_.size === 0 && be.inBatch > 0 && Zh(r), false);
}
function Qh(r) {
  r.lowestObserverState_ !== bt.STALE_ && (r.lowestObserverState_ = bt.STALE_, r.observers_.forEach(function(e) {
    e.dependenciesState_ === bt.UP_TO_DATE_ && e.onBecomeStale_(), e.dependenciesState_ = bt.STALE_;
  }));
}
function K0(r) {
  r.lowestObserverState_ !== bt.STALE_ && (r.lowestObserverState_ = bt.STALE_, r.observers_.forEach(function(e) {
    e.dependenciesState_ === bt.POSSIBLY_STALE_ ? e.dependenciesState_ = bt.STALE_ : e.dependenciesState_ === bt.UP_TO_DATE_ && (r.lowestObserverState_ = bt.UP_TO_DATE_);
  }));
}
function H0(r) {
  r.lowestObserverState_ === bt.UP_TO_DATE_ && (r.lowestObserverState_ = bt.POSSIBLY_STALE_, r.observers_.forEach(function(e) {
    e.dependenciesState_ === bt.UP_TO_DATE_ && (e.dependenciesState_ = bt.POSSIBLY_STALE_, e.onBecomeStale_());
  }));
}
var vu = function() {
  function r(t, n, i, s) {
    t === void 0 && (t = "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = bt.NOT_TRACKING_, this.diffValue_ = 0, this.runId_ = 0, this.unboundDepsCount_ = 0, this.isDisposed_ = false, this.isScheduled_ = false, this.isTrackPending_ = false, this.isRunning_ = false, this.isTracing_ = In.NONE, this.name_ = t, this.onInvalidate_ = n, this.errorHandler_ = i, this.requiresObservable_ = s;
  }
  var e = r.prototype;
  return e.onBecomeStale_ = function() {
    this.schedule_();
  }, e.schedule_ = function() {
    this.isScheduled_ || (this.isScheduled_ = true, be.pendingReactions.push(this), ep());
  }, e.isScheduled = function() {
    return this.isScheduled_;
  }, e.runReaction_ = function() {
    if (!this.isDisposed_) {
      cr(), this.isScheduled_ = false;
      var n = be.trackingContext;
      if (be.trackingContext = this, qf(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
        } catch (i) {
          this.reportExceptionInDerivation_(i);
        }
      }
      be.trackingContext = n, ur();
    }
  }, e.track = function(n) {
    if (!this.isDisposed_) {
      cr();
      this.isRunning_ = true;
      var o = be.trackingContext;
      be.trackingContext = this;
      var c = Kh(this, n, void 0);
      be.trackingContext = o, this.isRunning_ = false, this.isTrackPending_ = false, this.isDisposed_ && $f(this), yu(c) && this.reportExceptionInDerivation_(c.cause), ur();
    }
  }, e.reportExceptionInDerivation_ = function(n) {
    var i = this;
    if (this.errorHandler_) {
      this.errorHandler_(n, this);
      return;
    }
    if (be.disableErrorBoundaries)
      throw n;
    var s = "[mobx] uncaught error in '" + this + "'";
    be.suppressReactionErrors || console.error(s, n), be.globalReactionErrorHandlers.forEach(function(o) {
      return o(n, i);
    });
  }, e.dispose = function() {
    this.isDisposed_ || (this.isDisposed_ = true, this.isRunning_ || (cr(), $f(this), ur()));
  }, e.getDisposer_ = function(n) {
    var i = this, s = function o() {
      i.dispose(), n == null || n.removeEventListener == null || n.removeEventListener("abort", o);
    };
    return n == null || n.addEventListener == null || n.addEventListener("abort", s), s[He] = this, s;
  }, e.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, e.trace = function(n) {
  }, r;
}();
var Y0 = 100, J0 = function(e) {
  return e();
};
function ep() {
  be.inBatch > 0 || be.isRunningReactions || J0(Z0);
}
function Z0() {
  be.isRunningReactions = true;
  for (var r = be.pendingReactions, e = 0; r.length > 0; ) {
    ++e === Y0 && (console.error("[mobx] cycle in reaction: " + r[0]), r.splice(0));
    for (var t = r.splice(0), n = 0, i = t.length; n < i; n++)
      t[n].runReaction_();
  }
  be.isRunningReactions = false;
}
var _u = Fn("Reaction", vu);
function gi() {
  return false;
}
function X0(r) {
  return console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  };
}
var tp = "action", Q0 = "action.bound", rp = "autoAction", ey = "autoAction.bound", np = "<unnamed action>", ip = fc(tp), ty = fc(Q0, { bound: true }), sp = fc(rp, { autoAction: true }), ry = fc(ey, { autoAction: true, bound: true });
function op(r) {
  var e = function(n, i) {
    if (Ar(n))
      return Ys(n.name || np, n, r);
    if (Ar(i))
      return Ys(n, i, r);
    if (mi(i))
      return cc(n, i, r ? sp : ip);
    if (mi(n))
      return qr(fc(r ? rp : tp, { name: n, autoAction: r }));
  };
  return e;
}
var pr = op(false);
Object.assign(pr, ip);
var rc = op(true);
Object.assign(rc, sp);
pr.bound = qr(ty);
rc.bound = qr(ry);
function Ou(r) {
  return $h(r.name || np, false, r, this, void 0);
}
function hc(r) {
  return Ar(r) && r.isMobxAction === true;
}
function ny(r, e) {
  var t, n, i, s, o;
  e === void 0 && (e = Wf);
  var c = (t = (n = e) == null ? void 0 : n.name) != null ? t : "Autorun", l2 = !e.scheduler && !e.delay, f2;
  if (l2)
    f2 = new vu(c, function() {
      this.track(j2);
    }, e.onError, e.requiresObservable);
  else {
    var h2 = ap(e), _ = false;
    f2 = new vu(c, function() {
      _ || (_ = true, h2(function() {
        _ = false, f2.isDisposed_ || f2.track(j2);
      }));
    }, e.onError, e.requiresObservable);
  }
  function j2() {
    r(f2);
  }
  return (i = e) != null && (s = i.signal) != null && s.aborted || f2.schedule_(), f2.getDisposer_((o = e) == null ? void 0 : o.signal);
}
var iy = function(e) {
  return e();
};
function ap(r) {
  return r.scheduler ? r.scheduler : r.delay ? function(e) {
    return setTimeout(e, r.delay);
  } : iy;
}
function Qs(r, e, t) {
  var n, i, s, o;
  t === void 0 && (t = Wf);
  var c = (n = t.name) != null ? n : "Reaction", l2 = pr(c, t.onError ? sy(t.onError, e) : e), f2 = !t.scheduler && !t.delay, h2 = ap(t), _ = true, j2 = false, ie, G, Q = t.compareStructural ? Ks.structural : t.equals || Ks.default, N2 = new vu(c, function() {
    _ || f2 ? U() : j2 || (j2 = true, h2(U));
  }, t.onError, t.requiresObservable);
  function U() {
    if (j2 = false, !N2.isDisposed_) {
      var ee = false;
      N2.track(function() {
        var re2 = Vh(false, function() {
          return r(N2);
        });
        ee = _ || !Q(ie, re2), G = ie, ie = re2;
      }), (_ && t.fireImmediately || !_ && ee) && l2(ie, G, N2), _ = false;
    }
  }
  return (i = t) != null && (s = i.signal) != null && s.aborted || N2.schedule_(), N2.getDisposer_((o = t) == null ? void 0 : o.signal);
}
function sy(r, e) {
  return function() {
    try {
      return e.apply(this, arguments);
    } catch (t) {
      r.call(this, t);
    }
  };
}
var oy = "onBO", ay = "onBUO";
function cy(r, e, t) {
  return up(oy, r, e, t);
}
function cp(r, e, t) {
  return up(ay, r, e, t);
}
function up(r, e, t, n) {
  var i = typeof n == "function" ? Sn(e, t) : Sn(e), s = Ar(n) ? n : t, o = r + "L";
  return i[o] ? i[o].add(s) : i[o] = /* @__PURE__ */ new Set([s]), function() {
    var c = i[o];
    c && (c.delete(s), c.size === 0 && delete i[o]);
  };
}
function fp(r, e, t, n) {
  var i = Zm(e), s = xc(r, n)[He];
  cr();
  try {
    Gs(i).forEach(function(o) {
      s.extend_(o, i[o], t && o in t ? t[o] : true);
    });
  } finally {
    ur();
  }
  return r;
}
var uy = 0;
function lp() {
  this.message = "FLOW_CANCELLED";
}
lp.prototype = Object.create(Error.prototype);
var hh = Ch("flow"), fy = Ch("flow.bound", { bound: true }), nc = Object.assign(function(e, t) {
  if (mi(t))
    return cc(e, t, hh);
  var n = e, i = n.name || "<unnamed flow>", s = function() {
    var c = this, l2 = arguments, f2 = ++uy, h2 = pr(i + " - runid: " + f2 + " - init", n).apply(c, l2), _, j2 = void 0, ie = new Promise(function(G, Q) {
      var N2 = 0;
      _ = Q;
      function U(le) {
        j2 = void 0;
        var H2;
        try {
          H2 = pr(i + " - runid: " + f2 + " - yield " + N2++, h2.next).call(h2, le);
        } catch (I) {
          return Q(I);
        }
        re2(H2);
      }
      function ee(le) {
        j2 = void 0;
        var H2;
        try {
          H2 = pr(i + " - runid: " + f2 + " - yield " + N2++, h2.throw).call(h2, le);
        } catch (I) {
          return Q(I);
        }
        re2(H2);
      }
      function re2(le) {
        if (Ar(le == null ? void 0 : le.then)) {
          le.then(re2, Q);
          return;
        }
        return le.done ? G(le.value) : (j2 = Promise.resolve(le.value), j2.then(U, ee));
      }
      U(void 0);
    });
    return ie.cancel = pr(i + " - runid: " + f2 + " - cancel", function() {
      try {
        j2 && ph(j2);
        var G = h2.return(void 0), Q = Promise.resolve(G.value);
        Q.then($s, $s), ph(Q), _(new lp());
      } catch (N2) {
        _(N2);
      }
    }), ie;
  };
  return s.isMobXFlow = true, s;
}, hh);
nc.bound = qr(fy);
function ph(r) {
  Ar(r.cancel) && r.cancel();
}
function Au(r) {
  return (r == null ? void 0 : r.isMobXFlow) === true;
}
function ly(r, e) {
  if (e === void 0)
    return yi(r);
  if (xi(r) === false || !r[He].values_.has(e))
    return false;
  var t = Sn(r, e);
  return yi(t);
}
function dp(r, e) {
  return ly(r, e);
}
function dy(r, e) {
  return r ? e !== void 0 ? xi(r) ? r[He].values_.has(e) : false : xi(r) || !!r[He] || Hf(r) || _u(r) || yi(r) : false;
}
function Zf(r) {
  return dy(r);
}
function hy(r) {
  if (xi(r))
    return r[He].ownKeys_();
  vt(38);
}
function Du(r, e, t, n) {
  return Ar(t) ? gy(r, e, t, n) : py(r, e, t);
}
function py(r, e, t) {
  return Ru(r).observe_(e, t);
}
function gy(r, e, t, n) {
  return Ru(r, e).observe_(t, n);
}
function mu(r, e, t) {
  return r.set(e, t), t;
}
function qs(r, e) {
  if (r == null || typeof r != "object" || r instanceof Date || !Zf(r))
    return r;
  if ($0(r) || yi(r))
    return qs(r.get(), e);
  if (e.has(r))
    return e.get(r);
  if (mc(r)) {
    var t = mu(e, r, new Array(r.length));
    return r.forEach(function(o, c) {
      t[c] = qs(o, e);
    }), t;
  }
  if (wi(r)) {
    var n = mu(e, r, /* @__PURE__ */ new Set());
    return r.forEach(function(o) {
      n.add(qs(o, e));
    }), n;
  }
  if (On(r)) {
    var i = mu(e, r, /* @__PURE__ */ new Map());
    return r.forEach(function(o, c) {
      i.set(c, qs(o, e));
    }), i;
  } else {
    var s = mu(e, r, {});
    return hy(r).forEach(function(o) {
      sc.propertyIsEnumerable.call(r, o) && (s[o] = qs(r[o], e));
    }), s;
  }
}
function Vr(r, e) {
  return qs(r, /* @__PURE__ */ new Map());
}
function sn(r, e) {
  e === void 0 && (e = void 0), cr();
  try {
    return r.apply(e);
  } finally {
    ur();
  }
}
function zs(r) {
  return r[He];
}
var xy = { has: function(e, t) {
  return zs(e).has_(t);
}, get: function(e, t) {
  return zs(e).get_(t);
}, set: function(e, t, n) {
  var i;
  return mi(t) ? (i = zs(e).set_(t, n, true)) != null ? i : true : false;
}, deleteProperty: function(e, t) {
  var n;
  return mi(t) ? (n = zs(e).delete_(t, true)) != null ? n : true : false;
}, defineProperty: function(e, t, n) {
  var i;
  return (i = zs(e).defineProperty_(t, n)) != null ? i : true;
}, ownKeys: function(e) {
  return zs(e).ownKeys_();
}, preventExtensions: function(e) {
  vt(13);
} };
function wy(r, e) {
  var t, n;
  return Ih(), r = xc(r, e), (n = (t = r[He]).proxy_) != null ? n : t.proxy_ = new Proxy(r, xy);
}
function vr(r) {
  return r.interceptors_ !== void 0 && r.interceptors_.length > 0;
}
function pc(r, e) {
  var t = r.interceptors_ || (r.interceptors_ = []);
  return t.push(e), Th(function() {
    var n = t.indexOf(e);
    n !== -1 && t.splice(n, 1);
  });
}
function _r(r, e) {
  var t = Xs();
  try {
    for (var n = [].concat(r.interceptors_ || []), i = 0, s = n.length; i < s && (e = n[i](e), e && !e.type && vt(14), !!e); i++)
      ;
    return e;
  } finally {
    Tn(t);
  }
}
function Nr(r) {
  return r.changeListeners_ !== void 0 && r.changeListeners_.length > 0;
}
function gc(r, e) {
  var t = r.changeListeners_ || (r.changeListeners_ = []);
  return t.push(e), Th(function() {
    var n = t.indexOf(e);
    n !== -1 && t.splice(n, 1);
  });
}
function Or(r, e) {
  var t = Xs(), n = r.changeListeners_;
  if (n) {
    n = n.slice();
    for (var i = 0, s = n.length; i < s; i++)
      n[i](e);
    Tn(t);
  }
}
function hp(r, e, t) {
  var n = xc(r, t)[He];
  cr();
  try {
    var i;
    (i = e) != null || (e = r0(r)), Gs(e).forEach(function(s) {
      return n.make_(s, e[s]);
    });
  } finally {
    ur();
  }
  return r;
}
var Lf = Symbol("mobx-keys");
function Mu(r, e, t) {
  if (an(r))
    return fp(r, r, e, t);
  var n = xc(r, t)[He];
  if (!r[Lf]) {
    var i = Object.getPrototypeOf(r), s = new Set([].concat(Gs(r), Gs(i)));
    s.delete("constructor"), s.delete(He), oc(i, Lf, s);
  }
  cr();
  try {
    r[Lf].forEach(function(o) {
      return n.make_(o, e && o in e ? e[o] : true);
    });
  } finally {
    ur();
  }
  return r;
}
var gh = "splice", $r = "update", by = 1e4, vy = { get: function(e, t) {
  var n = e[He];
  return t === He ? n : t === "length" ? n.getArrayLength_() : typeof t == "string" && !isNaN(t) ? n.get_(parseInt(t)) : on(Eu, t) ? Eu[t] : e[t];
}, set: function(e, t, n) {
  var i = e[He];
  return t === "length" && i.setArrayLength_(n), typeof t == "symbol" || isNaN(t) ? e[t] = n : i.set_(parseInt(t), n), true;
}, preventExtensions: function() {
  vt(15);
} }, Xf = function() {
  function r(t, n, i, s) {
    t === void 0 && (t = "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = i, this.legacyMode_ = s, this.atom_ = new uc(t), this.enhancer_ = function(o, c) {
      return n(o, c, "ObservableArray[..]");
    };
  }
  var e = r.prototype;
  return e.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, e.dehanceValues_ = function(n) {
    return this.dehancer !== void 0 && n.length > 0 ? n.map(this.dehancer) : n;
  }, e.intercept_ = function(n) {
    return pc(this, n);
  }, e.observe_ = function(n, i) {
    return i === void 0 && (i = false), i && n({ observableKind: "array", object: this.proxy_, debugObjectName: this.atom_.name_, type: "splice", index: 0, added: this.values_.slice(), addedCount: this.values_.length, removed: [], removedCount: 0 }), gc(this, n);
  }, e.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, e.setArrayLength_ = function(n) {
    (typeof n != "number" || isNaN(n) || n < 0) && vt("Out of range: " + n);
    var i = this.values_.length;
    if (n !== i)
      if (n > i) {
        for (var s = new Array(n - i), o = 0; o < n - i; o++)
          s[o] = void 0;
        this.spliceWithArray_(i, 0, s);
      } else
        this.spliceWithArray_(n, i - n);
  }, e.updateArrayLength_ = function(n, i) {
    n !== this.lastKnownLength_ && vt(16), this.lastKnownLength_ += i, this.legacyMode_ && i > 0 && Ap(n + i + 1);
  }, e.spliceWithArray_ = function(n, i, s) {
    var o = this;
    Js(this.atom_);
    var c = this.values_.length;
    if (n === void 0 ? n = 0 : n > c ? n = c : n < 0 && (n = Math.max(0, c + n)), arguments.length === 1 ? i = c - n : i == null ? i = 0 : i = Math.max(0, Math.min(i, c - n)), s === void 0 && (s = Pf), vr(this)) {
      var l2 = _r(this, { object: this.proxy_, type: gh, index: n, removedCount: i, added: s });
      if (!l2)
        return Pf;
      i = l2.removedCount, s = l2.added;
    }
    if (s = s.length === 0 ? s : s.map(function(_) {
      return o.enhancer_(_, void 0);
    }), this.legacyMode_) {
      var f2 = s.length - i;
      this.updateArrayLength_(c, f2);
    }
    var h2 = this.spliceItemsIntoValues_(n, i, s);
    return (i !== 0 || s.length !== 0) && this.notifyArraySplice_(n, s, h2), this.dehanceValues_(h2);
  }, e.spliceItemsIntoValues_ = function(n, i, s) {
    if (s.length < by) {
      var o;
      return (o = this.values_).splice.apply(o, [n, i].concat(s));
    } else {
      var c = this.values_.slice(n, n + i), l2 = this.values_.slice(n + i);
      this.values_.length += s.length - i;
      for (var f2 = 0; f2 < s.length; f2++)
        this.values_[n + f2] = s[f2];
      for (var h2 = 0; h2 < l2.length; h2++)
        this.values_[n + s.length + h2] = l2[h2];
      return c;
    }
  }, e.notifyArrayChildUpdate_ = function(n, i, s) {
    var o = !this.owned_ && gi(), c = Nr(this), l2 = c || o ? { observableKind: "array", object: this.proxy_, type: $r, debugObjectName: this.atom_.name_, index: n, newValue: i, oldValue: s } : null;
    this.atom_.reportChanged(), c && Or(this, l2);
  }, e.notifyArraySplice_ = function(n, i, s) {
    var o = !this.owned_ && gi(), c = Nr(this), l2 = c || o ? { observableKind: "array", object: this.proxy_, debugObjectName: this.atom_.name_, type: gh, index: n, removed: s, added: i, removedCount: s.length, addedCount: i.length } : null;
    this.atom_.reportChanged(), c && Or(this, l2);
  }, e.get_ = function(n) {
    if (this.legacyMode_ && n >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + n);
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[n]);
  }, e.set_ = function(n, i) {
    var s = this.values_;
    if (this.legacyMode_ && n > s.length && vt(17, n, s.length), n < s.length) {
      Js(this.atom_);
      var o = s[n];
      if (vr(this)) {
        var c = _r(this, { type: $r, object: this.proxy_, index: n, newValue: i });
        if (!c)
          return;
        i = c.newValue;
      }
      i = this.enhancer_(i, o);
      var l2 = i !== o;
      l2 && (s[n] = i, this.notifyArrayChildUpdate_(n, i, o));
    } else {
      for (var f2 = new Array(n + 1 - s.length), h2 = 0; h2 < f2.length - 1; h2++)
        f2[h2] = void 0;
      f2[f2.length - 1] = i, this.spliceWithArray_(s.length, 0, f2);
    }
  }, r;
}();
function _y(r, e, t, n) {
  t === void 0 && (t = "ObservableArray"), n === void 0 && (n = false), Ih();
  var i = new Xf(t, e, n, false);
  Fh(i.values_, He, i);
  var s = new Proxy(i.values_, vy);
  if (i.proxy_ = s, r && r.length) {
    var o = lc(true);
    i.spliceWithArray_(0, 0, r), dc(o);
  }
  return s;
}
var Eu = { clear: function() {
  return this.splice(0);
}, replace: function(e) {
  var t = this[He];
  return t.spliceWithArray_(0, t.values_.length, e);
}, toJSON: function() {
  return this.slice();
}, splice: function(e, t) {
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
    i[s - 2] = arguments[s];
  var o = this[He];
  switch (arguments.length) {
    case 0:
      return [];
    case 1:
      return o.spliceWithArray_(e);
    case 2:
      return o.spliceWithArray_(e, t);
  }
  return o.spliceWithArray_(e, t, i);
}, spliceWithArray: function(e, t, n) {
  return this[He].spliceWithArray_(e, t, n);
}, push: function() {
  for (var e = this[He], t = arguments.length, n = new Array(t), i = 0; i < t; i++)
    n[i] = arguments[i];
  return e.spliceWithArray_(e.values_.length, 0, n), e.values_.length;
}, pop: function() {
  return this.splice(Math.max(this[He].values_.length - 1, 0), 1)[0];
}, shift: function() {
  return this.splice(0, 1)[0];
}, unshift: function() {
  for (var e = this[He], t = arguments.length, n = new Array(t), i = 0; i < t; i++)
    n[i] = arguments[i];
  return e.spliceWithArray_(0, 0, n), e.values_.length;
}, reverse: function() {
  return be.trackingDerivation && vt(37, "reverse"), this.replace(this.slice().reverse()), this;
}, sort: function() {
  be.trackingDerivation && vt(37, "sort");
  var e = this.slice();
  return e.sort.apply(e, arguments), this.replace(e), this;
}, remove: function(e) {
  var t = this[He], n = t.dehanceValues_(t.values_).indexOf(e);
  return n > -1 ? (this.splice(n, 1), true) : false;
} };
Gt("concat", cn);
Gt("flat", cn);
Gt("includes", cn);
Gt("indexOf", cn);
Gt("join", cn);
Gt("lastIndexOf", cn);
Gt("slice", cn);
Gt("toString", cn);
Gt("toLocaleString", cn);
Gt("every", Nn);
Gt("filter", Nn);
Gt("find", Nn);
Gt("findIndex", Nn);
Gt("flatMap", Nn);
Gt("forEach", Nn);
Gt("map", Nn);
Gt("some", Nn);
Gt("reduce", pp);
Gt("reduceRight", pp);
function Gt(r, e) {
  typeof Array.prototype[r] == "function" && (Eu[r] = e(r));
}
function cn(r) {
  return function() {
    var e = this[He];
    e.atom_.reportObserved();
    var t = e.dehanceValues_(e.values_);
    return t[r].apply(t, arguments);
  };
}
function Nn(r) {
  return function(e, t) {
    var n = this, i = this[He];
    i.atom_.reportObserved();
    var s = i.dehanceValues_(i.values_);
    return s[r](function(o, c) {
      return e.call(t, o, c, n);
    });
  };
}
function pp(r) {
  return function() {
    var e = this, t = this[He];
    t.atom_.reportObserved();
    var n = t.dehanceValues_(t.values_), i = arguments[0];
    return arguments[0] = function(s, o, c) {
      return i(s, o, c, e);
    }, n[r].apply(n, arguments);
  };
}
var Ay = Fn("ObservableArrayAdministration", Xf);
function mc(r) {
  return Tu(r) && Ay(r[He]);
}
var gp, mp, Ey = {}, En = "add", Iu = "delete";
gp = Symbol.iterator;
mp = Symbol.toStringTag;
var yc = function() {
  function r(t, n, i) {
    var s = this;
    n === void 0 && (n = Hs), i === void 0 && (i = "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[He] = Ey, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = n, this.name_ = i, Ar(Map) || vt(18), this.keysAtom_ = Mh("ObservableMap.keys()"), this.data_ = /* @__PURE__ */ new Map(), this.hasMap_ = /* @__PURE__ */ new Map(), Vh(true, function() {
      s.merge(t);
    });
  }
  var e = r.prototype;
  return e.has_ = function(n) {
    return this.data_.has(n);
  }, e.has = function(n) {
    var i = this;
    if (!be.trackingDerivation)
      return this.has_(n);
    var s = this.hasMap_.get(n);
    if (!s) {
      var o = s = new pi(this.has_(n), Su, "ObservableMap.key?", false);
      this.hasMap_.set(n, o), cp(o, function() {
        return i.hasMap_.delete(n);
      });
    }
    return s.get();
  }, e.set = function(n, i) {
    var s = this.has_(n);
    if (vr(this)) {
      var o = _r(this, { type: s ? $r : En, object: this, newValue: i, name: n });
      if (!o)
        return this;
      i = o.newValue;
    }
    return s ? this.updateValue_(n, i) : this.addValue_(n, i), this;
  }, e.delete = function(n) {
    var i = this;
    if (Js(this.keysAtom_), vr(this)) {
      var s = _r(this, { type: Iu, object: this, name: n });
      if (!s)
        return false;
    }
    if (this.has_(n)) {
      var o = gi(), c = Nr(this), l2 = c || o ? { observableKind: "map", debugObjectName: this.name_, type: Iu, object: this, oldValue: this.data_.get(n).value_, name: n } : null;
      return sn(function() {
        var f2;
        i.keysAtom_.reportChanged(), (f2 = i.hasMap_.get(n)) == null || f2.setNewValue_(false);
        var h2 = i.data_.get(n);
        h2.setNewValue_(void 0), i.data_.delete(n);
      }), c && Or(this, l2), true;
    }
    return false;
  }, e.updateValue_ = function(n, i) {
    var s = this.data_.get(n);
    if (i = s.prepareNewValue_(i), i !== be.UNCHANGED) {
      var o = gi(), c = Nr(this), l2 = c || o ? { observableKind: "map", debugObjectName: this.name_, type: $r, object: this, oldValue: s.value_, name: n, newValue: i } : null;
      s.setNewValue_(i), c && Or(this, l2);
    }
  }, e.addValue_ = function(n, i) {
    var s = this;
    Js(this.keysAtom_), sn(function() {
      var f2, h2 = new pi(i, s.enhancer_, "ObservableMap.key", false);
      s.data_.set(n, h2), i = h2.value_, (f2 = s.hasMap_.get(n)) == null || f2.setNewValue_(true), s.keysAtom_.reportChanged();
    });
    var o = gi(), c = Nr(this), l2 = c || o ? { observableKind: "map", debugObjectName: this.name_, type: En, object: this, name: n, newValue: i } : null;
    c && Or(this, l2);
  }, e.get = function(n) {
    return this.has(n) ? this.dehanceValue_(this.data_.get(n).get()) : this.dehanceValue_(void 0);
  }, e.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, e.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, e.values = function() {
    var n = this, i = this.keys();
    return ic({ next: function() {
      var o = i.next(), c = o.done, l2 = o.value;
      return { done: c, value: c ? void 0 : n.get(l2) };
    } });
  }, e.entries = function() {
    var n = this, i = this.keys();
    return ic({ next: function() {
      var o = i.next(), c = o.done, l2 = o.value;
      return { done: c, value: c ? void 0 : [l2, n.get(l2)] };
    } });
  }, e[gp] = function() {
    return this.entries();
  }, e.forEach = function(n, i) {
    for (var s = Vs(this), o; !(o = s()).done; ) {
      var c = o.value, l2 = c[0], f2 = c[1];
      n.call(i, f2, l2, this);
    }
  }, e.merge = function(n) {
    var i = this;
    return On(n) && (n = new Map(n)), sn(function() {
      an(n) ? Jm(n).forEach(function(s) {
        return i.set(s, n[s]);
      }) : Array.isArray(n) ? n.forEach(function(s) {
        var o = s[0], c = s[1];
        return i.set(o, c);
      }) : Zs(n) ? (n.constructor !== Map && vt(19, n), n.forEach(function(s, o) {
        return i.set(o, s);
      })) : n != null && vt(20, n);
    }), this;
  }, e.clear = function() {
    var n = this;
    sn(function() {
      Hh(function() {
        for (var i = Vs(n.keys()), s; !(s = i()).done; ) {
          var o = s.value;
          n.delete(o);
        }
      });
    });
  }, e.replace = function(n) {
    var i = this;
    return sn(function() {
      for (var s = Iy(n), o = /* @__PURE__ */ new Map(), c = false, l2 = Vs(i.data_.keys()), f2; !(f2 = l2()).done; ) {
        var h2 = f2.value;
        if (!s.has(h2)) {
          var _ = i.delete(h2);
          if (_)
            c = true;
          else {
            var j2 = i.data_.get(h2);
            o.set(h2, j2);
          }
        }
      }
      for (var ie = Vs(s.entries()), G; !(G = ie()).done; ) {
        var Q = G.value, N2 = Q[0], U = Q[1], ee = i.data_.has(N2);
        if (i.set(N2, U), i.data_.has(N2)) {
          var re2 = i.data_.get(N2);
          o.set(N2, re2), ee || (c = true);
        }
      }
      if (!c)
        if (i.data_.size !== o.size)
          i.keysAtom_.reportChanged();
        else
          for (var le = i.data_.keys(), H2 = o.keys(), I = le.next(), K2 = H2.next(); !I.done; ) {
            if (I.value !== K2.value) {
              i.keysAtom_.reportChanged();
              break;
            }
            I = le.next(), K2 = H2.next();
          }
      i.data_ = o;
    }), this;
  }, e.toString = function() {
    return "[object ObservableMap]";
  }, e.toJSON = function() {
    return Array.from(this);
  }, e.observe_ = function(n, i) {
    return gc(this, n);
  }, e.intercept_ = function(n) {
    return pc(this, n);
  }, Kf(r, [{ key: "size", get: function() {
    return this.keysAtom_.reportObserved(), this.data_.size;
  } }, { key: mp, get: function() {
    return "Map";
  } }]), r;
}(), On = Fn("ObservableMap", yc);
function Iy(r) {
  if (Zs(r) || On(r))
    return r;
  if (Array.isArray(r))
    return new Map(r);
  if (an(r)) {
    var e = /* @__PURE__ */ new Map();
    for (var t in r)
      e.set(t, r[t]);
    return e;
  } else
    return vt(21, r);
}
var yp, xp, Ty = {};
yp = Symbol.iterator;
xp = Symbol.toStringTag;
var wp = function() {
  function r(t, n, i) {
    n === void 0 && (n = Hs), i === void 0 && (i = "ObservableSet"), this.name_ = void 0, this[He] = Ty, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = i, Ar(Set) || vt(22), this.atom_ = Mh(this.name_), this.enhancer_ = function(s, o) {
      return n(s, o, i);
    }, t && this.replace(t);
  }
  var e = r.prototype;
  return e.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, e.clear = function() {
    var n = this;
    sn(function() {
      Hh(function() {
        for (var i = Vs(n.data_.values()), s; !(s = i()).done; ) {
          var o = s.value;
          n.delete(o);
        }
      });
    });
  }, e.forEach = function(n, i) {
    for (var s = Vs(this), o; !(o = s()).done; ) {
      var c = o.value;
      n.call(i, c, c, this);
    }
  }, e.add = function(n) {
    var i = this;
    if (Js(this.atom_), vr(this)) {
      var s = _r(this, { type: En, object: this, newValue: n });
      if (!s)
        return this;
    }
    if (!this.has(n)) {
      sn(function() {
        i.data_.add(i.enhancer_(n, void 0)), i.atom_.reportChanged();
      });
      var o = false, c = Nr(this), l2 = c || o ? { observableKind: "set", debugObjectName: this.name_, type: En, object: this, newValue: n } : null;
      c && Or(this, l2);
    }
    return this;
  }, e.delete = function(n) {
    var i = this;
    if (vr(this)) {
      var s = _r(this, { type: Iu, object: this, oldValue: n });
      if (!s)
        return false;
    }
    if (this.has(n)) {
      var o = false, c = Nr(this), l2 = c || o ? { observableKind: "set", debugObjectName: this.name_, type: Iu, object: this, oldValue: n } : null;
      return sn(function() {
        i.atom_.reportChanged(), i.data_.delete(n);
      }), c && Or(this, l2), true;
    }
    return false;
  }, e.has = function(n) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(n));
  }, e.entries = function() {
    var n = 0, i = Array.from(this.keys()), s = Array.from(this.values());
    return ic({ next: function() {
      var c = n;
      return n += 1, c < s.length ? { value: [i[c], s[c]], done: false } : { done: true };
    } });
  }, e.keys = function() {
    return this.values();
  }, e.values = function() {
    this.atom_.reportObserved();
    var n = this, i = 0, s = Array.from(this.data_.values());
    return ic({ next: function() {
      return i < s.length ? { value: n.dehanceValue_(s[i++]), done: false } : { done: true };
    } });
  }, e.replace = function(n) {
    var i = this;
    return wi(n) && (n = new Set(n)), sn(function() {
      Array.isArray(n) ? (i.clear(), n.forEach(function(s) {
        return i.add(s);
      })) : ac(n) ? (i.clear(), n.forEach(function(s) {
        return i.add(s);
      })) : n != null && vt("Cannot initialize set from " + n);
    }), this;
  }, e.observe_ = function(n, i) {
    return gc(this, n);
  }, e.intercept_ = function(n) {
    return pc(this, n);
  }, e.toJSON = function() {
    return Array.from(this);
  }, e.toString = function() {
    return "[object ObservableSet]";
  }, e[yp] = function() {
    return this.values();
  }, Kf(r, [{ key: "size", get: function() {
    return this.atom_.reportObserved(), this.data_.size;
  } }, { key: xp, get: function() {
    return "Set";
  } }]), r;
}(), wi = Fn("ObservableSet", wp), mh = /* @__PURE__ */ Object.create(null), yh = "remove", bp = function() {
  function r(t, n, i, s) {
    n === void 0 && (n = /* @__PURE__ */ new Map()), s === void 0 && (s = E0), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = t, this.values_ = n, this.name_ = i, this.defaultAnnotation_ = s, this.keysAtom_ = new uc("ObservableObject.keys"), this.isPlainObject_ = an(this.target_);
  }
  var e = r.prototype;
  return e.getObservablePropValue_ = function(n) {
    return this.values_.get(n).get();
  }, e.setObservablePropValue_ = function(n, i) {
    var s = this.values_.get(n);
    if (s instanceof tc)
      return s.set(i), true;
    if (vr(this)) {
      var o = _r(this, { type: $r, object: this.proxy_ || this.target_, name: n, newValue: i });
      if (!o)
        return null;
      i = o.newValue;
    }
    if (i = s.prepareNewValue_(i), i !== be.UNCHANGED) {
      var c = Nr(this), l2 = false, f2 = c || l2 ? { type: $r, observableKind: "object", debugObjectName: this.name_, object: this.proxy_ || this.target_, oldValue: s.value_, name: n, newValue: i } : null;
      s.setNewValue_(i), c && Or(this, f2);
    }
    return true;
  }, e.get_ = function(n) {
    return be.trackingDerivation && !on(this.target_, n) && this.has_(n), this.target_[n];
  }, e.set_ = function(n, i, s) {
    return s === void 0 && (s = false), on(this.target_, n) ? this.values_.has(n) ? this.setObservablePropValue_(n, i) : s ? Reflect.set(this.target_, n, i) : (this.target_[n] = i, true) : this.extend_(n, { value: i, enumerable: true, writable: true, configurable: true }, this.defaultAnnotation_, s);
  }, e.has_ = function(n) {
    if (!be.trackingDerivation)
      return n in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var i = this.pendingKeys_.get(n);
    return i || (i = new pi(n in this.target_, Su, "ObservableObject.key?", false), this.pendingKeys_.set(n, i)), i.get();
  }, e.make_ = function(n, i) {
    if (i === true && (i = this.defaultAnnotation_), i !== false) {
      if (!(n in this.target_)) {
        var s;
        if ((s = this.target_[Pr]) != null && s[n])
          return;
        vt(1, i.annotationType_, this.name_ + "." + n.toString());
      }
      for (var o = this.target_; o && o !== sc; ) {
        var c = xu(o, n);
        if (c) {
          var l2 = i.make_(this, n, c, o);
          if (l2 === 0)
            return;
          if (l2 === 1)
            break;
        }
        o = Object.getPrototypeOf(o);
      }
      wh(this, i, n);
    }
  }, e.extend_ = function(n, i, s, o) {
    if (o === void 0 && (o = false), s === true && (s = this.defaultAnnotation_), s === false)
      return this.defineProperty_(n, i, o);
    var c = s.extend_(this, n, i, o);
    return c && wh(this, s, n), c;
  }, e.defineProperty_ = function(n, i, s) {
    s === void 0 && (s = false);
    try {
      cr();
      var o = this.delete_(n);
      if (!o)
        return o;
      if (vr(this)) {
        var c = _r(this, { object: this.proxy_ || this.target_, name: n, type: En, newValue: i.value });
        if (!c)
          return null;
        var l2 = c.newValue;
        i.value !== l2 && (i = Ws({}, i, { value: l2 }));
      }
      if (s) {
        if (!Reflect.defineProperty(this.target_, n, i))
          return false;
      } else
        zr(this.target_, n, i);
      this.notifyPropertyAddition_(n, i.value);
    } finally {
      ur();
    }
    return true;
  }, e.defineObservableProperty_ = function(n, i, s, o) {
    o === void 0 && (o = false);
    try {
      cr();
      var c = this.delete_(n);
      if (!c)
        return c;
      if (vr(this)) {
        var l2 = _r(this, { object: this.proxy_ || this.target_, name: n, type: En, newValue: i });
        if (!l2)
          return null;
        i = l2.newValue;
      }
      var f2 = xh(n), h2 = { configurable: be.safeDescriptors ? this.isPlainObject_ : true, enumerable: true, get: f2.get, set: f2.set };
      if (o) {
        if (!Reflect.defineProperty(this.target_, n, h2))
          return false;
      } else
        zr(this.target_, n, h2);
      var _ = new pi(i, s, "ObservableObject.key", false);
      this.values_.set(n, _), this.notifyPropertyAddition_(n, _.value_);
    } finally {
      ur();
    }
    return true;
  }, e.defineComputedProperty_ = function(n, i, s) {
    s === void 0 && (s = false);
    try {
      cr();
      var o = this.delete_(n);
      if (!o)
        return o;
      if (vr(this)) {
        var c = _r(this, { object: this.proxy_ || this.target_, name: n, type: En, newValue: void 0 });
        if (!c)
          return null;
      }
      i.name || (i.name = "ObservableObject.key"), i.context = this.proxy_ || this.target_;
      var l2 = xh(n), f2 = { configurable: be.safeDescriptors ? this.isPlainObject_ : true, enumerable: false, get: l2.get, set: l2.set };
      if (s) {
        if (!Reflect.defineProperty(this.target_, n, f2))
          return false;
      } else
        zr(this.target_, n, f2);
      this.values_.set(n, new tc(i)), this.notifyPropertyAddition_(n, void 0);
    } finally {
      ur();
    }
    return true;
  }, e.delete_ = function(n, i) {
    if (i === void 0 && (i = false), !on(this.target_, n))
      return true;
    if (vr(this)) {
      var s = _r(this, { object: this.proxy_ || this.target_, name: n, type: yh });
      if (!s)
        return null;
    }
    try {
      var o, c;
      cr();
      var l2 = Nr(this), f2 = false, h2 = this.values_.get(n), _ = void 0;
      if (!h2 && (l2 || f2)) {
        var j2;
        _ = (j2 = xu(this.target_, n)) == null ? void 0 : j2.value;
      }
      if (i) {
        if (!Reflect.deleteProperty(this.target_, n))
          return false;
      } else
        delete this.target_[n];
      if (h2 && (this.values_.delete(n), h2 instanceof pi && (_ = h2.value_), Qh(h2)), this.keysAtom_.reportChanged(), (o = this.pendingKeys_) == null || (c = o.get(n)) == null || c.set(n in this.target_), l2 || f2) {
        var ie = { type: yh, observableKind: "object", object: this.proxy_ || this.target_, debugObjectName: this.name_, oldValue: _, name: n };
        l2 && Or(this, ie);
      }
    } finally {
      ur();
    }
    return true;
  }, e.observe_ = function(n, i) {
    return gc(this, n);
  }, e.intercept_ = function(n) {
    return pc(this, n);
  }, e.notifyPropertyAddition_ = function(n, i) {
    var s, o, c = Nr(this), l2 = false;
    if (c || l2) {
      var f2 = c || l2 ? { type: En, observableKind: "object", debugObjectName: this.name_, object: this.proxy_ || this.target_, name: n, newValue: i } : null;
      c && Or(this, f2);
    }
    (s = this.pendingKeys_) == null || (o = s.get(n)) == null || o.set(true), this.keysAtom_.reportChanged();
  }, e.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), Gs(this.target_);
  }, e.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, r;
}();
function xc(r, e) {
  var t;
  if (on(r, He))
    return r;
  var n = (t = e == null ? void 0 : e.name) != null ? t : "ObservableObject", i = new bp(r, /* @__PURE__ */ new Map(), String(n), C0(e));
  return oc(r, He, i), r;
}
var Sy = Fn("ObservableObjectAdministration", bp);
function xh(r) {
  return mh[r] || (mh[r] = { get: function() {
    return this[He].getObservablePropValue_(r);
  }, set: function(t) {
    return this[He].setObservablePropValue_(r, t);
  } });
}
function xi(r) {
  return Tu(r) ? Sy(r[He]) : false;
}
function wh(r, e, t) {
  var n;
  (n = r.target_[Pr]) == null || delete n[t];
}
var Fy = _p(0), Uf = 0, vp = function() {
};
function Ny(r, e) {
  Object.setPrototypeOf ? Object.setPrototypeOf(r.prototype, e) : r.prototype.__proto__ !== void 0 ? r.prototype.__proto__ = e : r.prototype = e;
}
Ny(vp, Array.prototype);
var Qf = function(r, e, t) {
  Dh(n, r);
  function n(s, o, c, l2) {
    var f2;
    c === void 0 && (c = "ObservableArray"), l2 === void 0 && (l2 = false), f2 = r.call(this) || this;
    var h2 = new Xf(c, o, l2, true);
    if (h2.proxy_ = kf(f2), Fh(kf(f2), He, h2), s && s.length) {
      var _ = lc(true);
      f2.spliceWithArray(0, 0, s), dc(_);
    }
    return Object.defineProperty(kf(f2), "0", Fy), f2;
  }
  var i = n.prototype;
  return i.concat = function() {
    this[He].atom_.reportObserved();
    for (var o = arguments.length, c = new Array(o), l2 = 0; l2 < o; l2++)
      c[l2] = arguments[l2];
    return Array.prototype.concat.apply(this.slice(), c.map(function(f2) {
      return mc(f2) ? f2.slice() : f2;
    }));
  }, i[t] = function() {
    var s = this, o = 0;
    return ic({ next: function() {
      return o < s.length ? { value: s[o++], done: false } : { done: true, value: void 0 };
    } });
  }, Kf(n, [{ key: "length", get: function() {
    return this[He].getArrayLength_();
  }, set: function(o) {
    this[He].setArrayLength_(o);
  } }, { key: e, get: function() {
    return "Array";
  } }]), n;
}(vp, Symbol.toStringTag, Symbol.iterator);
Object.entries(Eu).forEach(function(r) {
  var e = r[0], t = r[1];
  e !== "concat" && oc(Qf.prototype, e, t);
});
function _p(r) {
  return { enumerable: false, configurable: true, get: function() {
    return this[He].get_(r);
  }, set: function(t) {
    this[He].set_(r, t);
  } };
}
function Oy(r) {
  zr(Qf.prototype, "" + r, _p(r));
}
function Ap(r) {
  if (r > Uf) {
    for (var e = Uf; e < r + 100; e++)
      Oy(e);
    Uf = r;
  }
}
Ap(1e3);
function Dy(r, e, t) {
  return new Qf(r, e, t);
}
function Sn(r, e) {
  if (typeof r == "object" && r !== null) {
    if (mc(r))
      return e !== void 0 && vt(23), r[He].atom_;
    if (wi(r))
      return r.atom_;
    if (On(r)) {
      if (e === void 0)
        return r.keysAtom_;
      var t = r.data_.get(e) || r.hasMap_.get(e);
      return t || vt(25, e, Vf(r)), t;
    }
    if (xi(r)) {
      if (!e)
        return vt(26);
      var n = r[He].values_.get(e);
      return n || vt(27, e, Vf(r)), n;
    }
    if (Hf(r) || yi(r) || _u(r))
      return r;
  } else if (Ar(r) && _u(r[He]))
    return r[He];
  vt(28);
}
function Ru(r, e) {
  if (r || vt(29), e !== void 0)
    return Ru(Sn(r, e));
  if (Hf(r) || yi(r) || _u(r) || On(r) || wi(r))
    return r;
  if (r[He])
    return r[He];
  vt(24, r);
}
function Vf(r, e) {
  var t;
  if (e !== void 0)
    t = Sn(r, e);
  else {
    if (hc(r))
      return r.name;
    xi(r) || On(r) || wi(r) ? t = Ru(r) : t = Sn(r);
  }
  return t.name_;
}
var vh = sc.toString;
function el(r, e, t) {
  return t === void 0 && (t = -1), Gf(r, e, t);
}
function Gf(r, e, t, n, i) {
  if (r === e)
    return r !== 0 || 1 / r === 1 / e;
  if (r == null || e == null)
    return false;
  if (r !== r)
    return e !== e;
  var s = typeof r;
  if (s !== "function" && s !== "object" && typeof e != "object")
    return false;
  var o = vh.call(r);
  if (o !== vh.call(e))
    return false;
  switch (o) {
    case "[object RegExp]":
    case "[object String]":
      return "" + r == "" + e;
    case "[object Number]":
      return +r != +r ? +e != +e : +r == 0 ? 1 / +r === 1 / e : +r == +e;
    case "[object Date]":
    case "[object Boolean]":
      return +r == +e;
    case "[object Symbol]":
      return typeof Symbol != "undefined" && Symbol.valueOf.call(r) === Symbol.valueOf.call(e);
    case "[object Map]":
    case "[object Set]":
      t >= 0 && t++;
      break;
  }
  r = _h2(r), e = _h2(e);
  var c = o === "[object Array]";
  if (!c) {
    if (typeof r != "object" || typeof e != "object")
      return false;
    var l2 = r.constructor, f2 = e.constructor;
    if (l2 !== f2 && !(Ar(l2) && l2 instanceof l2 && Ar(f2) && f2 instanceof f2) && "constructor" in r && "constructor" in e)
      return false;
  }
  if (t === 0)
    return false;
  t < 0 && (t = -1), n = n || [], i = i || [];
  for (var h2 = n.length; h2--; )
    if (n[h2] === r)
      return i[h2] === e;
  if (n.push(r), i.push(e), c) {
    if (h2 = r.length, h2 !== e.length)
      return false;
    for (; h2--; )
      if (!Gf(r[h2], e[h2], t - 1, n, i))
        return false;
  } else {
    var _ = Object.keys(r), j2;
    if (h2 = _.length, Object.keys(e).length !== h2)
      return false;
    for (; h2--; )
      if (j2 = _[h2], !(on(e, j2) && Gf(r[j2], e[j2], t - 1, n, i)))
        return false;
  }
  return n.pop(), i.pop(), true;
}
function _h2(r) {
  return mc(r) ? r.slice() : Zs(r) || On(r) || ac(r) || wi(r) ? Array.from(r.entries()) : r;
}
function ic(r) {
  return r[Symbol.iterator] = My, r;
}
function My() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(r) {
  var e = Ah();
  typeof e[r] == "undefined" && vt("MobX requires global '" + r + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy: X0, extras: { getDebugName: Vf }, $mobx: He });
var gr = /* @__PURE__ */ new Map();
var un = {}, Ep = {};
var Ip = function(r) {
  return (/* @__PURE__ */ new Date()).getTime() + r;
}, Tp = function(r) {
  var e = (/* @__PURE__ */ new Date()).getTime(), t = new Date(r).getTime();
  return t <= e;
};
var Sp = function(r) {
  return !!r && Array.isArray(r) === false && typeof r == "object";
};
var tl = function(r) {
  return r && r instanceof Function;
}, Ry = function(r) {
  return typeof Storage != "undefined" && r instanceof Storage ? true : [r == null ? void 0 : r.hasOwnProperty("getItem"), r == null ? void 0 : r.hasOwnProperty("removeItem"), r == null ? void 0 : r.hasOwnProperty("setItem"), tl(r == null ? void 0 : r.getItem), tl(r == null ? void 0 : r.removeItem), tl(r == null ? void 0 : r.setItem)].every(Boolean);
}, wc = typeof window != "undefined", bc = false, Fp = function(r, e) {
  wc && bc && !Ry(r) && console.warn("mobx-persist-store: ".concat(e, ` does not have a valid storage adaptor.

* Make sure the storage controller has 'getItem', 'setItem' and 'removeItem' methods."`));
}, Np = function(r, e) {
  wc && bc && r && console.warn(`mobx-persist-store: 'makePersistable' was called was called with the same storage name "`.concat(e, `".

 * Make sure you call "stopPersisting" before recreating "`).concat(e, `" to avoid memory leaks. 
 * Or double check you did not have two stores with the same name.`));
}, Op = function(r, e) {
  wc && bc && r && console.warn("mobx-persist-store: The property '".concat(e, "' is computed and will not persist."));
}, Dp = function(r, e) {
  wc && bc && r && console.warn("mobx-persist-store: The property '".concat(e, "' is an action and will not persist."));
}, Zt = function(r, e, t) {
  t === void 0 && (t = ""), r && wc && bc && console.info("%c mobx-persist-store: (Debug Mode) ".concat(e, " "), "background: #4B8CC5; color: black; display: block;", t);
}, Mp = function(r) {
  return Array.isArray(r) ? r.every(function(e) {
    return Array.isArray(e);
  }) : false;
};
var rl = function(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function c(h2) {
      try {
        f2(n.next(h2));
      } catch (_) {
        o(_);
      }
    }
    function l2(h2) {
      try {
        f2(n.throw(h2));
      } catch (_) {
        o(_);
      }
    }
    function f2(h2) {
      h2.done ? s(h2.value) : i(h2.value).then(c, l2);
    }
    f2((n = n.apply(r, e || [])).next());
  });
}, nl = function(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(f2) {
    return function(h2) {
      return l2([f2, h2]);
    };
  }
  function l2(f2) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (n = 1, i && (s = f2[0] & 2 ? i.return : f2[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f2[1])).done)
          return s;
        switch (i = 0, s && (f2 = [f2[0] & 2, s.value]), f2[0]) {
          case 0:
          case 1:
            s = f2;
            break;
          case 4:
            return t.label++, { value: f2[1], done: false };
          case 5:
            t.label++, i = f2[1], f2 = [0];
            continue;
          case 7:
            f2 = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (f2[0] === 6 || f2[0] === 2)) {
              t = 0;
              continue;
            }
            if (f2[0] === 3 && (!s || f2[1] > s[0] && f2[1] < s[3])) {
              t.label = f2[1];
              break;
            }
            if (f2[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = f2;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(f2);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        f2 = e.call(r, t);
      } catch (h2) {
        f2 = [6, h2], i = 0;
      } finally {
        n = s = 0;
      }
    if (f2[0] & 5)
      throw f2[1];
    return { value: f2[0] ? f2[1] : void 0, done: true };
  }
}, Rp = function() {
  function r(e) {
    this.options = e;
  }
  return r.prototype.setItem = function(e, t) {
    var n;
    return rl(this, void 0, void 0, function() {
      var i, s, o, c, l2, f2, h2;
      return nl(this, function(_) {
        switch (_.label) {
          case 0:
            return i = this.options, s = i.stringify, o = s === void 0 ? true : s, c = i.debugMode, l2 = c === void 0 ? false : c, f2 = this.options.expireIn ? Object.assign({}, t, { __mps__: { expireInTimestamp: Ip(this.options.expireIn) } }) : t, h2 = o ? JSON.stringify(f2) : f2, Zt(l2, "".concat(e, " - setItem:"), h2), [4, (n = this.options.storage) === null || n === void 0 ? void 0 : n.setItem(e, h2)];
          case 1:
            return _.sent(), [2];
        }
      });
    });
  }, r.prototype.getItem = function(e) {
    var t, n;
    return rl(this, void 0, void 0, function() {
      var i, s, o, c, l2, f2, h2, _;
      return nl(this, function(j2) {
        switch (j2.label) {
          case 0:
            return i = this.options, s = i.removeOnExpiration, o = s === void 0 ? true : s, c = i.debugMode, l2 = c === void 0 ? false : c, [4, (t = this.options.storage) === null || t === void 0 ? void 0 : t.getItem(e)];
          case 1:
            f2 = j2.sent();
            try {
              h2 = JSON.parse(f2) || {};
            } catch (ie) {
              h2 = f2 || {};
            }
            return _ = Tp((n = h2.__mps__) === null || n === void 0 ? void 0 : n.expireInTimestamp), Zt(l2, "".concat(e, " - hasExpired"), _), _ && o ? [4, this.removeItem(e)] : [3, 3];
          case 2:
            j2.sent(), j2.label = 3;
          case 3:
            return h2 = _ ? {} : h2, Zt(l2, "".concat(e, " - (getItem):"), h2), [2, h2];
        }
      });
    });
  }, r.prototype.removeItem = function(e) {
    var t;
    return rl(this, void 0, void 0, function() {
      var n, i;
      return nl(this, function(s) {
        switch (s.label) {
          case 0:
            return n = this.options.debugMode, i = n === void 0 ? false : n, Zt(i, "".concat(e, " - (removeItem): storage was removed")), [4, (t = this.options.storage) === null || t === void 0 ? void 0 : t.removeItem(e)];
          case 1:
            return s.sent(), [2];
        }
      });
    });
  }, r;
}();
var Cy = function(r) {
  var e = ["key", "serialize", "deserialize"];
  return Sp(r) ? e.every(function(t) {
    return r.hasOwnProperty(t) && typeof t != "undefined" ? true : (Zt(!!un.debugMode, "".concat(String(t), " not found in SerializableProperty"), { key: t, obj: r }), false);
  }) : (Zt(!!un.debugMode, "passed value is not an object", { obj: r }), false);
}, Cp = function(r) {
  return r.reduce(function(e, t) {
    return typeof t == "string" ? (e.push({ key: t, serialize: function(n) {
      return n;
    }, deserialize: function(n) {
      return n;
    } }), e) : (Cy(t) && e.push(t), e);
  }, []);
};
var vc = function(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function c(h2) {
      try {
        f2(n.next(h2));
      } catch (_) {
        o(_);
      }
    }
    function l2(h2) {
      try {
        f2(n.throw(h2));
      } catch (_) {
        o(_);
      }
    }
    function f2(h2) {
      h2.done ? s(h2.value) : i(h2.value).then(c, l2);
    }
    f2((n = n.apply(r, e || [])).next());
  });
}, _c2 = function(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(f2) {
    return function(h2) {
      return l2([f2, h2]);
    };
  }
  function l2(f2) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (n = 1, i && (s = f2[0] & 2 ? i.return : f2[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f2[1])).done)
          return s;
        switch (i = 0, s && (f2 = [f2[0] & 2, s.value]), f2[0]) {
          case 0:
          case 1:
            s = f2;
            break;
          case 4:
            return t.label++, { value: f2[1], done: false };
          case 5:
            t.label++, i = f2[1], f2 = [0];
            continue;
          case 7:
            f2 = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (f2[0] === 6 || f2[0] === 2)) {
              t = 0;
              continue;
            }
            if (f2[0] === 3 && (!s || f2[1] > s[0] && f2[1] < s[3])) {
              t.label = f2[1];
              break;
            }
            if (f2[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = f2;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(f2);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        f2 = e.call(r, t);
      } catch (h2) {
        f2 = [6, h2], i = 0;
      } finally {
        n = s = 0;
      }
    if (f2[0] & 5)
      throw f2[1];
    return { value: f2[0] ? f2[1] : void 0, done: true };
  }
}, kp = function() {
  function r(e, t, n) {
    n === void 0 && (n = {});
    var i, s, o, c, l2, f2, h2;
    this.cancelWatch = null, this.properties = [], this.reactionOptions = {}, this.storageAdapter = null, this.target = null, this.debugMode = false, this.isHydrated = false, this.isPersisting = false, this.storageName = "", this.target = e, this.storageName = t.name, this.properties = Cp(t.properties), this.reactionOptions = Object.assign({ fireImmediately: true }, Ep, n), this.debugMode = (s = (i = t.debugMode) !== null && i !== void 0 ? i : un.debugMode) !== null && s !== void 0 ? s : false, this.storageAdapter = new Rp({ expireIn: (o = t.expireIn) !== null && o !== void 0 ? o : un.expireIn, removeOnExpiration: (l2 = (c = t.removeOnExpiration) !== null && c !== void 0 ? c : un.removeOnExpiration) !== null && l2 !== void 0 ? l2 : true, stringify: (h2 = (f2 = t.stringify) !== null && f2 !== void 0 ? f2 : un.stringify) !== null && h2 !== void 0 ? h2 : true, storage: t.storage ? t.storage : un.storage, debugMode: this.debugMode }), hp(this, { clearPersistedStore: pr, hydrateStore: pr, isHydrated: Ft, isPersisting: Ft, pausePersisting: pr, startPersisting: pr, stopPersisting: pr }, { autoBind: true, deep: false }), Fp(this.storageAdapter.options.storage, this.storageName), Zt(this.debugMode, "".concat(this.storageName, " - (makePersistable)"), { properties: this.properties, storageAdapter: this.storageAdapter, reactionOptions: this.reactionOptions });
  }
  return r.prototype.init = function() {
    return vc(this, void 0, void 0, function() {
      return _c2(this, function(e) {
        switch (e.label) {
          case 0:
            return [4, this.hydrateStore()];
          case 1:
            return e.sent(), this.startPersisting(), [2, this];
        }
      });
    });
  }, r.prototype.hydrateStore = function() {
    return vc(this, void 0, void 0, function() {
      var e, t, n, i = this;
      return _c2(this, function(s) {
        switch (s.label) {
          case 0:
            return e = !!this.cancelWatch, this.isPersisting && this.pausePersisting(), Ou(function() {
              i.isHydrated = false, Zt(i.debugMode, "".concat(i.storageName, " - (hydrateStore) isHydrated:"), i.isHydrated);
            }), this.storageAdapter && this.target ? [4, this.storageAdapter.getItem(this.storageName)] : [3, 2];
          case 1:
            t = s.sent(), n = this.target, t && Ou(function() {
              i.properties.forEach(function(o) {
                var c = [n.hasOwnProperty(o.key), typeof t[o.key] != "undefined"].every(Boolean);
                if (c) {
                  var l2 = t[o.key];
                  n[o.key] instanceof yc && Mp(l2) ? n[o.key] = o.deserialize(new Map(l2)) : n[o.key] = o.deserialize(l2);
                }
              });
            }), s.label = 2;
          case 2:
            return Ou(function() {
              i.isHydrated = true, Zt(i.debugMode, "".concat(i.storageName, " - isHydrated:"), i.isHydrated);
            }), e && this.startPersisting(), [2];
        }
      });
    });
  }, r.prototype.startPersisting = function() {
    var e = this;
    if (!(!this.storageAdapter || !this.target || this.cancelWatch)) {
      var t = this.target;
      this.cancelWatch = Qs(function() {
        var n = {};
        return e.properties.forEach(function(i) {
          var s = dp(t, i.key), o = hc(t[i.key]);
          if (Op(s, String(i.key)), Dp(o, String(i.key)), !s && !o) {
            var c = i.serialize(t[i.key]);
            if (c instanceof yc) {
              var l2 = [];
              c.forEach(function(f2, h2) {
                l2.push([h2, Vr(f2)]);
              }), c = l2;
            }
            n[i.key] = Vr(c);
          }
        }), n;
      }, function(n) {
        return vc(e, void 0, void 0, function() {
          return _c2(this, function(i) {
            switch (i.label) {
              case 0:
                return this.storageAdapter ? [4, this.storageAdapter.setItem(this.storageName, n)] : [3, 2];
              case 1:
                i.sent(), i.label = 2;
              case 2:
                return [2];
            }
          });
        });
      }, this.reactionOptions), this.isPersisting = true, Zt(this.debugMode, "".concat(this.storageName, " - (startPersisting) isPersisting:"), this.isPersisting);
    }
  }, r.prototype.pausePersisting = function() {
    this.isPersisting = false, Zt(this.debugMode, "".concat(this.storageName, " - pausePersisting (isPersisting):"), this.isPersisting), this.cancelWatch && (this.cancelWatch(), this.cancelWatch = null);
  }, r.prototype.stopPersisting = function() {
    this.pausePersisting(), Zt(this.debugMode, "".concat(this.storageName, " - (stopPersisting)")), gr.delete(this.target), this.cancelWatch = null, this.properties = [], this.reactionOptions = {}, this.storageAdapter = null, this.target = null;
  }, r.prototype.clearPersistedStore = function() {
    return vc(this, void 0, void 0, function() {
      return _c2(this, function(e) {
        switch (e.label) {
          case 0:
            return this.storageAdapter ? (Zt(this.debugMode, "".concat(this.storageName, " - (clearPersistedStore)")), [4, this.storageAdapter.removeItem(this.storageName)]) : [3, 2];
          case 1:
            e.sent(), e.label = 2;
          case 2:
            return [2];
        }
      });
    });
  }, r.prototype.getPersistedStore = function() {
    return vc(this, void 0, void 0, function() {
      return _c2(this, function(e) {
        return this.storageAdapter ? (Zt(this.debugMode, "".concat(this.storageName, " - (getPersistedStore)")), [2, this.storageAdapter.getItem(this.storageName)]) : [2, null];
      });
    });
  }, r;
}();
var ky = function(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function c(h2) {
      try {
        f2(n.next(h2));
      } catch (_) {
        o(_);
      }
    }
    function l2(h2) {
      try {
        f2(n.throw(h2));
      } catch (_) {
        o(_);
      }
    }
    function f2(h2) {
      h2.done ? s(h2.value) : i(h2.value).then(c, l2);
    }
    f2((n = n.apply(r, e || [])).next());
  });
}, jy = function(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(f2) {
    return function(h2) {
      return l2([f2, h2]);
    };
  }
  function l2(f2) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (n = 1, i && (s = f2[0] & 2 ? i.return : f2[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f2[1])).done)
          return s;
        switch (i = 0, s && (f2 = [f2[0] & 2, s.value]), f2[0]) {
          case 0:
          case 1:
            s = f2;
            break;
          case 4:
            return t.label++, { value: f2[1], done: false };
          case 5:
            t.label++, i = f2[1], f2 = [0];
            continue;
          case 7:
            f2 = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (f2[0] === 6 || f2[0] === 2)) {
              t = 0;
              continue;
            }
            if (f2[0] === 3 && (!s || f2[1] > s[0] && f2[1] < s[3])) {
              t.label = f2[1];
              break;
            }
            if (f2[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = f2;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(f2);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        f2 = e.call(r, t);
      } catch (h2) {
        f2 = [6, h2], i = 0;
      } finally {
        n = s = 0;
      }
    if (f2[0] & 5)
      throw f2[1];
    return { value: f2[0] ? f2[1] : void 0, done: true };
  }
}, jp = function(r, e, t) {
  return ky(void 0, void 0, void 0, function() {
    var n, i;
    return jy(this, function(s) {
      return n = new kp(r, e, t), i = Array.from(gr.values()).map(function(o) {
        return o.storageName;
      }).includes(n.storageName), Np(i, n.storageName), gr.set(r, n), [2, n.init()];
    });
  });
};
var By = Object.defineProperty, zt = (r, e) => By(r, "name", { value: e, configurable: true });
function ku() {
  let r = false;
  return typeof window !== void 0 && typeof window == "object" && "document" in window && typeof window.document == "object" && (r = true), r;
}
zt(ku, "isBrowser");
var Ly = zt((r) => {
  if (typeof window == null)
    throw new Error("Cannot access window for simple btoa conversion.");
  for (var e = "", t = new Uint8Array(r), n = t.byteLength, i = 0; i < n; i++)
    e += String.fromCharCode(t[i]);
  return window.btoa(e);
}, "arrayBufferToBase64"), xt = { enabled: false, log(...r) {
  this.enabled && console.log(...r);
}, warn(...r) {
  this.enabled && console.warn(...r);
}, debug(...r) {
  this.enabled && console.debug(...r);
} }, Et = { PERA: "pera", INKEY: "inkey", MYALGO: "myalgo", ALGOSIGNER: "algosigner", EXODUS: "exodus", DEFLY: "defly", MNEMONIC: "mnemonic" }, Ai, Di = (Ai = class {
  constructor(e) {
  }
}, (() => {
  zt(Ai, "BaseClient");
})(), je(Ai, "metadata"), je(Ai, "init"), Ai), Uy = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzcgMTg3Ij48cmVjdCB4PSItMTEuMzgiIHk9Ii0yNS45NyIgd2lkdGg9IjIwMC4wMiIgaGVpZ2h0PSIyMzEuNTMiIHN0eWxlPSJmaWxsOiNmZTU7Ii8+PHBhdGggZD0iTTk0LjA1LDU5LjYxYzIuMDUsOC40OCwxLjM2LDE1Ljk0LTEuNTUsMTYuNjYtMi45LC43Mi02LjkxLTUuNTctOC45Ni0xNC4wNS0yLjA1LTguNDgtMS4zNi0xNS45NCwxLjU1LTE2LjY2LDIuOS0uNzIsNi45MSw1LjU3LDguOTYsMTQuMDVaIiBzdHlsZT0iZmlsbDojMWMxYzFjOyIvPjxwYXRoIGQ9Ik0xMjcuODUsNjYuOWMtNC41My00LjgxLTEzLjU1LTMuNS0yMC4xNSwyLjkxLTYuNTksNi40MS04LjI2LDE1LjUtMy43MywyMC4zMSw0LjUzLDQuOCwxMy41NSwzLjUsMjAuMTUtMi45MXM4LjI2LTE1LjUsMy43My0yMC4zMVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTkxLjc5LDE0MC40N2MyLjktLjcyLDMuNDktOC42LDEuMzItMTcuNjEtMi4xNy05LTYuMjktMTUuNzEtOS4xOS0xNC45OS0yLjksLjcyLTMuNDksOC42LTEuMzIsMTcuNjEsMi4xNyw5LDYuMjksMTUuNzEsOS4xOSwxNC45OVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTYyLjIyLDcxLjNjOC4zNywyLjQ3LDE0LjQ4LDYuOCwxMy42Niw5LjY3LS44MywyLjg3LTguMjgsMy4yLTE2LjY1LC43My04LjM3LTIuNDctMTQuNDgtNi44LTEzLjY2LTkuNjcsLjgzLTIuODcsOC4yOC0zLjIsMTYuNjUtLjczWiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48cGF0aCBkPSJNMTE2LjU0LDEwMy43NGM4Ljg4LDIuNjIsMTUuNDEsNy4wNywxNC41OSw5Ljk0LS44MywyLjg3LTguNywzLjA4LTE3LjU4LC40Ni04Ljg4LTIuNjItMTUuNDEtNy4wNy0xNC41OS05Ljk0LC44My0yLjg3LDguNy0zLjA4LDE3LjU4LS40NloiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTcxLjY0LDk3LjcxYy0yLjA4LTIuMTUtOC44OCwuOTgtMTUuMiw2Ljk5LTYuMzIsNi4wMS05Ljc2LDEyLjYzLTcuNjksMTQuNzgsMi4wOCwyLjE1LDguODgtLjk4LDE1LjItNi45OSw2LjMyLTYuMDEsOS43Ni0xMi42Myw3LjY5LTE0Ljc4WiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48L3N2Zz4=", bi = { id: Et.PERA, chain: "algorand", name: "Pera Wallet", icon: Uy, pkg: "@perawallet/connect" }, Ei, Py = (Ei = class extends Di {
  constructor({ sdk: t }) {
    super();
    je(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let n;
      if (t && t.sdk)
        n = t.sdk;
      else {
        let i, s = { shouldShowSignTxnToast: false };
        i = (t == null ? void 0 : t.config) || s;
        let o = await __vitePreload(() => import("./index-55265d93.js").then((n2) => n2.i), true ? ["./index-55265d93.js","./qr-code-styling-87721598.js","./algosdk.min-94b10098.js","./index-9c89cd5b.js"] : void 0, import.meta.url), c = o.PeraWalletConnect || o.default.PeraWalletConnect;
        n = new c(i);
      }
      return n = n, new Ei({ sdk: n });
    } catch (n) {
      return console.error(`[${bi.id}] Error initializing...`, n), null;
    }
  }
  async connect(t) {
    var i;
    let n = await this.sdk.connect();
    if ((i = this.sdk.connector) == null || i.on("disconnect", t), n.length === 0)
      throw new Error(`No accounts found for ${bi.id}`);
    return n.map((s, o) => ({ name: `Pera Account ${o + 1}`, address: s, walletId: bi.id, chain: bi.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(t) {
    var i;
    let n = await this.sdk.reconnectSession().catch(console.info);
    return (i = this.sdk.connector) == null || i.on("disconnect", t), n ? n.map((s, o) => ({ name: `Pera Account ${o + 1}`, address: s, walletId: bi.id, chain: bi.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() })) : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, n) {
    let i = n.map((c) => sr(c)), s = i.reduce((c, l2, f2) => {
      let h2 = t.map((_) => _.address);
      return !("txn" in l2) && h2.includes(xe(l2.snd)) ? c.push({ txn: Ln(n[f2]) }) : c.push({ txn: Yr(n[f2]).txn, signers: [] }), c;
    }, []), o = await this.sdk.signTransaction([s]);
    return i.reduce((c, l2, f2) => {
      if ("txn" in l2)
        c.push(n[f2]);
      else {
        let h2 = o.shift();
        h2 && c.push(h2);
      }
      return c;
    }, []);
  }
}, (() => {
  zt(Ei, "PeraClient");
})(), je(Ei, "metadata", bi), Ei), zy = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTIiIGhlaWdodD0iNTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cmVjdCB3aWR0aD0iNTIiIGhlaWdodD0iNTIiIHJ4PSIxMiIgZmlsbD0iI2ZmZiIvPjxjaXJjbGUgY3g9IjI2LjI1MSIgY3k9IjE3Ljg5MSIgcj0iMTMuODkxIiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTkuNzc2IiBjeT0iMTcuODkxIiBmaWxsPSIjZmZmIiByPSIyLjY0MyIvPjxjaXJjbGUgY3g9IjMxLjYzOCIgY3k9IjE3Ljg5MSIgZmlsbD0iI2ZmZiIgcj0iMi42NDMiLz48cGF0aCBkPSJNMjEgMjQuMmMxLjAyIDQuNjU5LTIuNzUgMTQuNTg4LTkuNTE0IDE1LjI5OU0zMC43NCAyNi44MDFjMS43NjQgMS44MzcgMy44ODUgMTQuMzIxLTEuNTgyIDIwLjE5OU0yNS4zMjMgMjkuMDA0YzEuMDExIDQuNjYxIDEuNDA2IDEzLjYyMi04LjQ1IDE3LjgxNiIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjUuMzk5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48Y2lyY2xlIGN4PSIxOS43NzYiIGN5PSIxNy44ODciIHI9IjEuNDE2IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMzEuNjM4IiBjeT0iMTcuODg3IiByPSIxLjQxNiIgZmlsbD0iIzAwMCIvPjwvZz48ZGVmcz48Y2xpcFBhdGggaWQ9ImEiPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0wIDBoNTJ2NTJIMHoiLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4=", Ac = { id: Et.INKEY, chain: "algorand", name: "Inkey Microwallet", icon: zy, pkg: "@thencc/inkey-client-js" }, Ii, qy = (Ii = class extends Di {
  constructor({ sdk: t }) {
    super();
    je(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let n;
      if (t && t.sdk)
        n = t.sdk;
      else {
        let i, s = { src: "https://inkey.app", align: "center" };
        i = (t == null ? void 0 : t.config) || s;
        let o = await __vitePreload(() => import("./index.esm-144aec08.js"), true ? [] : void 0, import.meta.url);
        n = await (o.createClient || o.default.createClient)(i);
      }
      return await new Promise((i) => setTimeout(i, 600)), new Ii({ sdk: n });
    } catch (n) {
      return console.warn(`[${Ac.id}] Error initializing...`, n), null;
    }
  }
  async connect(t) {
    let n = await this.sdk.connect(t);
    if (!n)
      throw new Error("no inkeyAccounts");
    if (n.length === 0)
      throw new Error(`No accounts found for ${Ac.id}`);
    return t != null && t.onDisconnect && this.sdk.frameBus.setOnDisconnect(t.onDisconnect), n.map((i) => ({ name: i.name, address: i.address, walletId: Ac.id, chain: Ac.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, n) {
    let i = n.map((l2) => sr(l2)), s = i.reduce((l2, f2, h2) => {
      let _ = t.map((j2) => j2.address);
      return !("txn" in f2) && _.includes(xe(f2.snd)) && l2.push(n[h2]), l2;
    }, []).map((l2) => Ly(l2)), o = await this.sdk.signTxns(s, t);
    if (!o.success)
      throw new Error("Error signing transactions");
    let c = o.signedTxns;
    return i.reduce((l2, f2, h2) => {
      if ("txn" in f2)
        l2.push(n[h2]);
      else {
        let _ = c.shift();
        _ && l2.push(_);
      }
      return l2;
    }, []);
  }
}, (() => {
  zt(Ii, "InkeyClient");
})(), je(Ii, "metadata", Ac), Ii), $y = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHBhdGggZmlsbD0iIzI0NUVDNiIgZD0iTTE2LDMyYy0zLjIsMC02LjItMC45LTguOS0yLjdjLTIuNi0xLjgtNC43LTQuMy01LjktNy4yQzAsMTkuMi0wLjMsMTYsMC4zLDEyLjlDMC45LDkuOCwyLjQsNyw0LjcsNC43IEM2LjIsMy4yLDcuOSwyLDkuOSwxLjJDMTEuOCwwLjQsMTMuOSwwLDE2LDBzNC4yLDAuNCw2LjEsMS4yYzEuOSwwLjgsMy43LDIsNS4yLDMuNXMyLjcsMy4zLDMuNSw1LjJjMC44LDEuOSwxLjIsNCwxLjIsNi4xIHMtMC40LDQuMi0xLjIsNi4xYy0wLjgsMS45LTIsMy43LTMuNSw1LjJjLTEuNSwxLjUtMy4yLDIuNy01LjIsMy41QzIwLjIsMzEuNiwxOC4xLDMyLDE2LDMyTDE2LDMyeiBNMjAuMiwxMS4ybDAuMSwwLjVsMi42LDkuNWgyLjEgTDIxLjUsOC45bC0wLjEtMC4zaC0xLjlsMCwwLjFsLTEuNywzLjFMMTYsMTQuOWwwLDAuMWwwLTAuMWwtMC4yLTAuOGwtMC42LTIuNGwtMC4xLTAuMmwtMC43LTIuNmwtMC4xLTAuM2gtMS45bDAsMC4xbC0xLjcsMy4xIGwtMS44LDMuMkw3LjEsMThsLTEuOCwzLjJoMi4xTDkuMiwxOGwxLjgtMy4ybDEuOC0zLjJsMC4zLTAuNWwwLjEsMC41bDAuNSwyLjFsMC43LDIuNmwwLjIsMC45TDE0LjIsMThsLTEuOCwzLjJoMi4xbDAuOC0xLjMgbDEuMy0yLjNsMS41LTIuN2wxLjgtMy4yTDIwLjIsMTEuMkwyMC4yLDExLjJ6Ii8+Cjwvc3ZnPgo=", Ec = { id: Et.MYALGO, chain: "algorand", name: "MyAlgo", icon: $y, pkg: "@randlabs/myalgo-connect" }, Ti, Vy = (Ti = class extends Di {
  constructor({ sdk: t }) {
    super();
    je(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let n;
      if (t && t.sdk)
        n = t.sdk;
      else {
        let i, s = { disableLedgerNano: false };
        i = (t == null ? void 0 : t.config) || s;
        let o = await Promise.resolve().then(() => lt(Tt(), 1));
        window.Buffer || (window.Buffer = o.Buffer || o.default.Buffer);
        let c = (await __vitePreload(() => import("./index-35f2ef62.js").then((n2) => n2.i), true ? [] : void 0, import.meta.url)).default;
        n = new c(i);
      }
      return n = n, new Ti({ sdk: n });
    } catch (n) {
      return console.error(`[${Ec.id}] Error initializing...`, n), null;
    }
  }
  async connect() {
    let t = await this.sdk.connect();
    if (t.length === 0)
      throw new Error(`No accounts found for ${Ec.id}`);
    return t.map((n) => Er(at({}, n), { walletId: Ec.id, chain: Ec.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
  }
  async signTransactions(t, n) {
    let i = n.map((c) => sr(c)), s = i.reduce((c, l2, f2) => {
      let h2 = t.map((_) => _.address);
      return !("txn" in l2) && h2.includes(xe(l2.snd)) && c.push(n[f2]), c;
    }, []), o = await this.sdk.signTransaction(s);
    return i.reduce((c, l2, f2) => {
      var h2;
      if ("txn" in l2)
        c.push(n[f2]);
      else {
        let _ = (h2 = o.shift()) == null ? void 0 : h2.blob;
        _ && c.push(_);
      }
      return c;
    }, []);
  }
}, (() => {
  zt(Ti, "MyAlgoClient");
})(), je(Ti, "metadata", Ec), Ti), Gy = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjM4IiBoZWlnaHQ9IjIzOCIgdmlld0JveD0iMCAwIDIzOCAyMzgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01MS43MDUgMTQ1LjA0MkgxMTYuNzA1TDEwNy43MDUgMTU1LjA0Mkg1MS43MDVWMTQ1LjA0MloiIGZpbGw9IiNENjQ1MDAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNDcuNTE5IDE5MS41NTdMMTI5LjU3NyAxNDQuMzk0TDE0Mi40MDQgMTI3LjExMkwxNjcuODc1IDE5MS41NTdIMTQ3LjUxOVpNMTEwLjkzNiA5NS4zOTMyTDEyMC42MTMgMTIwLjgzMUwxMzMuMzU5IDEwNC4yMjhMMTE3LjQ3NSA2NC4wNDIyQzExNS45MjggNjAuMTI4IDExMi4xNDYgNTcuNTU2NSAxMDcuOTM4IDU3LjU1NjVDMTAzLjcyOSA1Ny41NTY1IDk5Ljk0NzQgNjAuMTI4IDk4LjQwMDMgNjQuMDQyMkw2Ny45NjU5IDE0MS4wNDJIODcuNzgwN0M5NS40MTUzIDEyMS4wMTEgMTAyLjg5MyAxMDEuMzk5IDEwNS4xOTggOTUuMzU0MUMxMDUuNjQxIDk0LjE5MTIgMTA2Ljc0MyA5My40NTk5IDEwNy45ODcgOTMuNDU5OUgxMDguMTMyQzEwOS4zNzggOTMuNDU5OSAxMTAuNDkzIDk0LjIyOTMgMTEwLjkzNiA5NS4zOTMyWk04MC45MjEgMTU5LjA0MkM3NC45Mjg5IDE3NC43NjggNjkuODY2MSAxODguMDYzIDY4LjU0NDcgMTkxLjU1N0g0OEw2MC44NTE0IDE1OS4wNDJIODAuOTIxWiIgZmlsbD0iIzIyMkI2MCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3Ni4wMjYgNTQuNzUwOUMxNzcuOTk3IDUyLjA4NzIgMTgxLjc1NCA1MS41MjU3IDE4NC40MTggNTMuNDk2N0MxODcuMDgyIDU1LjQ2NzggMTg3LjY0MyA1OS4yMjUxIDE4NS42NzIgNjEuODg4OEwxMzAuMDEzIDEzNy4xMDdDMTI5LjcxNCAxMzcuNTEyIDEyOS4zNDEgMTM3Ljg1NyAxMjguOTEzIDEzOC4xMjNMMTE3Ljg1NiAxNDUuMDEzQzExNy4wODcgMTQ1LjQ5MyAxMTYuMTI4IDE0NC43ODMgMTE2LjM2MSAxNDMuOTA3TDExOS43MTggMTMxLjMxOEMxMTkuODQ3IDEzMC44MzIgMTIwLjA2OCAxMzAuMzc0IDEyMC4zNjcgMTI5Ljk3TDE3MC42NyA2MS45ODlMMTY5LjkyOSA2MS40NDA1QzE2OS40ODUgNjEuMTEyIDE2OC44NTkgNjEuMjA1NiAxNjguNTMgNjEuNjQ5NkwxNTIuMzExIDgzLjU2ODhDMTUyLjU4NiA4NC4yMDIzIDE1Mi41MjQgODQuOTYxMiAxNTIuMDg0IDg1LjU1NjJMMTQ5LjExIDg5LjU3NTVDMTQ4LjQ1MyA5MC40NjM0IDE0Ny4yMDEgOTAuNjUwNiAxNDYuMzEzIDg5Ljk5MzZDMTQ1LjQyNSA4OS4zMzY2IDE0NS4yMzggODguMDg0MSAxNDUuODk1IDg3LjE5NjJMMTQ3LjY3OSA4NC43ODQ3TDE0OC44NjkgODMuMTc2OUwxNjcuMzA4IDU4LjI1NzRDMTY4LjYyMiA1Ni40ODE1IDE3MS4xMjcgNTYuMTA3MiAxNzIuOTAzIDU3LjQyMTJMMTczLjY0NCA1Ny45Njk3TDE3Ni4wMjYgNTQuNzUwOVoiIGZpbGw9IiNENjQ1MDAiLz4KPC9zdmc+Cg==", Ic = { id: Et.ALGOSIGNER, chain: "algorand", name: "AlgoSigner", icon: Gy, pkg: "" }, Wy = zt((r) => r === "betanet" ? "BetaNet" : r === "testnet" ? "TestNet" : r === "mainnet" ? "MainNet" : r, "getNetwork"), Si, Ky = (Si = class extends Di {
  constructor({ sdk: t, network: n }) {
    super();
    je(this, "sdk");
    je(this, "network");
    this.sdk = t, this.network = n;
  }
  static async init(t) {
    var n;
    try {
      if (typeof window > "u" || window.AlgoSigner === void 0)
        throw new Error("AlgoSigner is not available.");
      let i = window.AlgoSigner, s = "mainnet";
      return (n = t == null ? void 0 : t.config) != null && n.network && (t.config.network == "mainnet" || t.config.network == "testnet" || t.config.network == "betanet" ? s = t.config.network : console.warn(`invalid network in ${Ic.id} config`)), new Si({ sdk: i, network: s });
    } catch (i) {
      return console.error("Error initializing...", i), null;
    }
  }
  async connect() {
    await this.sdk.connect();
    let t = await this.sdk.accounts({ ledger: Wy(this.network) });
    if (t.length === 0)
      throw new Error(`No accounts found for ${Ic.id}`);
    return t.map(({ address: n }, i) => ({ name: `AlgoSigner Account ${i + 1}`, address: n, walletId: Ic.id, chain: Ic.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(t) {
    return (window === void 0 || window.AlgoSigner === void 0) && t(), null;
  }
  async disconnect() {
  }
  async signTransactions(t, n) {
    let i = n.map((s) => sr(s)).reduce((s, o, c) => {
      let l2 = { txn: this.sdk.encoding.msgpackToBase64(n[c]) }, f2 = t.map((h2) => h2.address);
      return ("txn" in o || !f2.includes(xe(o.snd))) && (l2.txn = this.sdk.encoding.msgpackToBase64(Yr(n[c]).txn.toByte()), l2.signers = []), s.push(l2), s;
    }, []);
    return (await this.sdk.signTxn(i)).reduce((s, o, c) => (o ? s.push(new Uint8Array(Lp.Buffer.from(o.blob, "base64"))) : s.push(n[c]), s), []);
  }
}, (() => {
  zt(Si, "AlgoSignerClient");
})(), je(Si, "metadata", Ic), Si), Hy = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMDAgMzAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMDAgMzAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6dXJsKCNTVkdJRF8xXyk7fQoJLnN0MXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNDM0MjYxNjcxNDAxMDY1ODIyNzAwMDAwMDIxMzA3Njg5MDYwNzMxMTM0ODRfKTt9Cgkuc3Qye2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEwMjUxOTMxNjAxNTI3NjU4MTY0MDAwMDAxNjI3NDExMjM4MzE3NTY0MTc1OV8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTt9Cgkuc3Qze2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEzODU2MzM4MjQ2MjA4NjAyMDM1MDAwMDAxNDg3ODQ5MDI3MDc4MjA3MTIwN18pO30KCS5zdDR7bWFzazp1cmwoI21hc2swXzE2NjFfMjk1XzAwMDAwMDg4MTMyMjUxNTk3NDQxNTczNDkwMDAwMDExNjkzNjEyMDE4NTA2NjgxNDgxXyk7fQoJLnN0NXtmaWxsOnVybCgjU1ZHSURfMDAwMDAxMDYxMjA2MzI0NjE3OTI4NzExNjAwMDAwMDc0MzM5MTMwMzgzMzc3NjY1NzZfKTt9Cjwvc3R5bGU+CjxnPgoJCgkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDYuNjAzIiB5MT0iOS4yMjEyIiB4Mj0iMTc0LjE1OCIgeTI9IjMwOC41NDI2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xCgkJTDI3NC43LDkzLjl6Ii8+CgkKCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMjkuMzUxNiIgeTE9Ii0xOS4xNTczIiB4Mj0iNTYuOTA2NiIgeTI9IjI4MC4xNjQxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1Xyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCWw2OS4yLTQ1LjFWMjNMMjUuMyw5My45TDQzLDE1MC4xbC0xNy43LDU2LjJMMTMzLjcsMjc3di0zOS42bC02OS40LTQ1LjFMNzIuNSwxNjYuNHoiLz4KCTxkZWZzPgoJCTxmaWx0ZXIgaWQ9IkFkb2JlX09wYWNpdHlNYXNrRmlsdGVyIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ij4KCQkJPGZlQ29sb3JNYXRyaXggIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIxIDAgMCAwIDAgIDAgMSAwIDAgMCAgMCAwIDEgMCAwICAwIDAgMCAxIDAiLz4KCQk8L2ZpbHRlcj4KCTwvZGVmcz4KCQoJCTxtYXNrIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0IiBpZD0ibWFzazBfMTY2MV8yOTVfMDAwMDAwODgxMzIyNTE1OTc0NDE1NzM0OTAwMDAwMTE2OTM2MTIwMTg1MDY2ODE0ODFfIj4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjQ2LjYwMzgiIHkxPSI5LjIyMTQiIHgyPSIxNzQuMTU4OCIgeTI9IjMwOC41NDI4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwQjQ2RjkiLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JCRkJFMCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJPHBhdGggc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTsiIGQ9IgoJCQlNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xTDI3NC43LDkzLjl6Ii8+CgkJCgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMTk4MTE3MDc2MjE0NzI4MTQyNzAwMDAwMTA4Mjk2NTkzODM4NTEyMDI0OTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyOS4zNTIxIiB5MT0iLTE5LjE1NzEiIHgyPSI1Ni45MDcxIiB5Mj0iMjgwLjE2NDIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAzMDIpIj4KCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQkJGQkUwIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCQk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTE5ODExNzA3NjIxNDcyODE0MjcwMDAwMDEwODI5NjU5MzgzODUxMjAyNDkxXyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCQlsNjkuMi00NS4xVjIzTDI1LjMsOTMuOUw0MywxNTAuMWwtMTcuNyw1Ni4yTDEzMy43LDI3N3YtMzkuNmwtNjkuNC00NS4xTDcyLjUsMTY2LjR6Ii8+Cgk8L21hc2s+Cgk8ZyBjbGFzcz0ic3Q0Ij4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDEwOTAxOTkxODU1Nzc3MzA1MzQyMDAwMDAxNzYwMjQwNTkwODA2NzEyMDMwMF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDYuNDY2MiIgeTE9IjIyOC43NTU0IiB4Mj0iMTcxLjg2MzgiIHkyPSIxMzUuMTAzOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDMwMikiPgoJCQk8c3RvcCAgb2Zmc2V0PSIwLjExOTgiIHN0eWxlPSJzdG9wLWNvbG9yOiM4OTUyRkY7c3RvcC1vcGFjaXR5OjAuODciLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0RBQkRGRjtzdG9wLW9wYWNpdHk6MCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJCgkJCTxyZWN0IHg9IjI1LjQiIHk9IjIzIiBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTA5MDE5OTE4NTU3NzczMDUzNDIwMDAwMDE3NjAyNDA1OTA4MDY3MTIwMzAwXyk7IiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ii8+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", Cu = { id: Et.EXODUS, chain: "algorand", name: "Exodus", icon: Hy, pkg: "" }, Fi, Yy = (Fi = class extends Di {
  constructor({ sdk: t, onlyIfTrusted: n }) {
    super();
    je(this, "sdk");
    je(this, "onlyIfTrusted");
    this.sdk = t, this.onlyIfTrusted = n;
  }
  static async init(t) {
    var n, i;
    try {
      if (typeof window > "u" || window.exodus === void 0)
        throw new Error("Exodus is not available. Do you have the browser extension installed?");
      let s = window.exodus.algorand, o = false;
      return (n = t == null ? void 0 : t.config) != null && n.onlyIfTrusted && (o = (i = t == null ? void 0 : t.config) == null ? void 0 : i.onlyIfTrusted), new Fi({ sdk: s, onlyIfTrusted: o });
    } catch (s) {
      return console.error("Error initializing...", s), null;
    }
  }
  async connect() {
    let t = "";
    try {
      let { address: n } = await window.exodus.algorand.connect({ onlyIfTrusted: this.onlyIfTrusted });
      t = n;
    } catch (n) {
      throw console.warn("err w exodus connect"), n;
    }
    if (!t)
      throw new Error(`No accounts found for ${Cu.id}`);
    return [{ name: `Exodus Account ${(/* @__PURE__ */ new Date()).getTime()}`, address: t, walletId: Cu.id, chain: Cu.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }];
  }
  async reconnect(t) {
    return (window === void 0 || window.exodus === void 0 || window.exodus.algorand.isConnected !== true) && t(), null;
  }
  async disconnect() {
    window.exodus.algorand.disconnect();
  }
  async signTransactions(t, n, i, s = true) {
    let o = n.map((h2) => sr(h2)), c = [], l2 = o.reduce((h2, _, j2) => {
      let ie = "txn" in _, G = t.map((Q) => Q.address);
      return (i && i.length && i.includes(j2) || !ie && G.includes(xe(_.snd))) && (c.push(j2), h2.push(n[j2])), h2;
    }, []), f2 = await window.exodus.algorand.signTransaction(l2);
    return n.reduce((h2, _, j2) => {
      if (c.includes(j2)) {
        let ie = f2.shift();
        ie && h2.push(ie);
      } else
        s && h2.push(n[j2]);
      return h2;
    }, []);
  }
}, (() => {
  zt(Fi, "ExodusClient");
})(), je(Fi, "metadata", Cu), Fi), Jy = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiLz4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNjgyMDksMCwwLDEuNjgyMDksMjI2LjM2OCwyMTIuODE4KSI+CiAgICAgICAgPHBhdGggZD0iTTMyNy4wNDksMjgwLjE5MkwxNjkuNTI0LDEzTDEyLDI4MC4xOTJMMTY5LjUyNCwxODkuMDg0TDMyNy4wNDksMjgwLjE5MloiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvOyIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS42ODIwOSwwLDAsMS42ODIwOSwyMjYuMzY4LDIxMi44MTgpIj4KICAgICAgICA8cGF0aCBkPSJNMjk5LjU0NiwzMDdMMTY5LjUyNSwyMzguNDczTDM5LjUwNCwzMDdMMTY5LjUyNSwyNjQuNjdMMjk5LjU0NiwzMDdaIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybzsiLz4KICAgIDwvZz4KPC9zdmc+Cg==", eo = { id: Et.DEFLY, chain: "algorand", name: "Defly", icon: Jy, pkg: "@blockshake/defly-connect" }, Ni, Zy = (Ni = class extends Di {
  constructor({ sdk: t }) {
    super();
    je(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let n;
      if (t && t.sdk)
        n = t.sdk;
      else {
        let i, s = { shouldShowSignTxnToast: false };
        i = (t == null ? void 0 : t.config) || s;
        let o = await __vitePreload(() => import("./index-f2d5bedc.js").then((n2) => n2.i), true ? ["./index-f2d5bedc.js","./qr-code-styling-87721598.js","./algosdk.min-94b10098.js","./lottie-b035792e.js"] : void 0, import.meta.url), c = o.DeflyWalletConnect || o.default.DeflyWalletConnect;
        n = new c(i);
      }
      return new Ni({ sdk: n });
    } catch (n) {
      return console.error("Error initializing...", n), null;
    }
  }
  async connect(t) {
    let n = await this.sdk.connect().catch(console.info);
    if (this.sdk.connector.on("disconnect", t), !n || n.length === 0)
      throw new Error(`No accounts found for ${eo.id}`);
    return n.map((i, s) => ({ name: `Defly Account ${s + 1}`, address: i, walletId: eo.id, chain: eo.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(t) {
    var i;
    let n = await this.sdk.reconnectSession().catch(console.info);
    return (i = this.sdk.connector) == null || i.on("disconnect", t), n ? n.map((s, o) => ({ name: `Defly Account ${o + 1}`, address: s, walletId: eo.id, chain: eo.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() })) : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, n) {
    let i = n.map((c) => sr(c)), s = i.reduce((c, l2, f2) => {
      let h2 = t.map((_) => _.address);
      return !("txn" in l2) && h2.includes(xe(l2.snd)) ? c.push({ txn: Ln(n[f2]) }) : c.push({ txn: Yr(n[f2]).txn, signers: [] }), c;
    }, []), o = await this.sdk.signTransaction([s]);
    return i.reduce((c, l2, f2) => {
      if ("txn" in l2)
        c.push(n[f2]);
      else {
        let h2 = o.shift();
        h2 && c.push(h2);
      }
      return c;
    }, []);
  }
}, (() => {
  zt(Ni, "DeflyClient");
})(), je(Ni, "metadata", eo), Ni), Xy = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e %3c!-- Generated by Pixelmator Pro 3.2.2 --%3e %3csvg width='409' height='210' viewBox='0 0 409 210' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctext id='MNEMONIC' xml:space='preserve' x='0' y='129' font-family='Helvetica' font-size='72' fill='black'%3eMNEMONIC%3c/text%3e%3c/svg%3e", il = { id: Et.MNEMONIC, name: "Mnemonic", icon: Xy, chain: "algorand", pkg: "" }, Oi, Qy = (Oi = class extends Di {
  constructor({ sdk: t }) {
    super();
    je(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let n;
      if (t)
        if (typeof t == "string")
          n = li(t);
        else if (typeof t == "object") {
          if (t.sdk)
            n = t.sdk;
          else if (t.config && t.config.mnemonic) {
            let i = t.config.mnemonic;
            n = li(i);
          }
        } else
          throw new Error("bad initParams for mnemonic client");
      else
        console.error("mnemonic wallet needs to be inited w a mnemonic - none provided.");
      return new Oi({ sdk: n });
    } catch (n) {
      return console.error("Error initializing...", n), null;
    }
  }
  async connect() {
    var t;
    return this.sdk == null && console.warn("mnemonic client wasnt initialized properly... no mnemonic passed in so cannot connect."), [{ name: `Mnemonic Account ${(/* @__PURE__ */ new Date()).getTime()}`, address: ((t = this.sdk) == null ? void 0 : t.addr) || "", walletId: il.id, chain: il.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }];
  }
  async disconnect() {
    this.sdk = void 0;
  }
  async reconnect() {
    return null;
  }
  async signTransactions(t, n, i, s = true) {
    if (this.sdk || await this.connect(), !this.sdk)
      throw new Error("Client could not init");
    let o = n.map((_) => sr(_)), c = [], l2 = [];
    for (let _ in o) {
      let j2 = o[_], ie = "txn" in j2, G = t.map((N2) => N2.address);
      if (c.push(n[_]), ie || i && i.length && !i.includes(Number(_)) || !G.includes(xe(j2.snd)))
        continue;
      c[_] = new Uint8Array();
      let Q = At.from_obj_for_encoding(j2).signTxn(this.sdk.sk);
      l2.push(Q);
    }
    let f2 = 0, h2 = c.reduce((_, j2, ie) => (j2.length === 0 ? (_.push(l2[f2]), f2 += 1) : s && _.push(j2), _), []);
    return Promise.resolve(h2);
  }
}, (() => {
  zt(Oi, "MnemonicClient");
})(), je(Oi, "metadata", il), Oi), _i = { [Et.PERA]: { client: Py }, [Et.INKEY]: { client: qy }, [Et.MYALGO]: { client: Vy }, [Et.ALGOSIGNER]: { client: Ky }, [Et.EXODUS]: { client: Yy }, [Et.DEFLY]: { client: Zy }, [Et.MNEMONIC]: { client: Qy } };
Object.values(_i).map((r) => r.client.metadata.id);
Object.values(_i).map((r) => r.client.metadata.pkg).filter((r) => r !== "");
zt((r) => {
  let e = [];
  for (let t of r)
    e.push(_i[t].client.metadata.pkg);
  return e;
}, "excludeClients");
var vi = zt((r, e, t = true) => {
  xt.debug("createWallet", r, e);
  let s = class {
    constructor() {
      je(this, "id", e);
      je(this, "metadata", _i[e].client.metadata);
      je(this, "client", null);
      je(this, "initParams", t);
      je(this, "inited", false);
      je(this, "initing", false);
      je(this, "signing", false);
      je(this, "connecting", false);
      je(this, "loadClient", async () => (xt.debug("loadClient:", e), i.inited ? (xt.debug("aw already inited client"), true) : (i.initing = true, typeof i.initParams == "string" ? i.client = await _i[e].client.init(i.initParams) : typeof i.initParams == "object" && (i.initParams.config || i.initParams.sdk) ? i.client = await _i[e].client.init(i.initParams) : t == true ? i.client = await _i[e].client.init() : console.warn("Bad/incomplete init params for wallet:", e), i.initing = false, i.inited = true, true)));
      je(this, "unloadClient", async () => {
        var c;
        await ((c = i.client) == null ? void 0 : c.disconnect()), i.inited = false;
      });
      je(this, "connect", async (c) => {
        i.connecting = true;
        try {
          if (await i.loadClient(), i.accounts) {
            c == null && (c = {});
            let f2 = Vr(i.accounts);
            c.connectedAccounts = [...f2];
          }
          let l2 = await i.client.connect(c);
          return r.addConnectedAccounts(l2), r.setAsActiveAccount(l2[0]), l2;
        } catch (l2) {
          throw l2;
        } finally {
          i.connecting = false;
        }
      });
      je(this, "disconnect", async () => {
        xt.debug("disconnect", i.id), i.removeAccounts(), await i.loadClient();
        try {
          await i.unloadClient();
        } catch (c) {
          console.warn(c);
        }
      });
      je(this, "reconnect", async () => {
        await i.loadClient(), await i.client.reconnect(() => {
        });
      });
      je(this, "setAsActiveWallet", () => {
        let c = r.getAccountsByWalletId(e);
        if (c)
          r.setAsActiveAccount(c[0]);
        else
          throw new Error("No accounts for this provider to set as active");
      });
      je(this, "removeAccounts", () => {
        r.removeAccountsByWalletId(e);
      });
      je(this, "signTransactions", async (c) => {
        await i.loadClient();
        let l2 = Vr(i.accounts);
        l2.length || (l2 = await i.connect(), await new Promise((f2) => setTimeout(f2, 1e3))), i.signing = true;
        try {
          return await i.client.signTransactions(l2, c);
        } catch (f2) {
          throw f2;
        } finally {
          i.signing = false;
        }
      });
      Mu(this);
    }
    get accounts() {
      return r.getAccountsByWalletId(e);
    }
    get isConnected() {
      return r.connectedAccounts.some((c) => c.walletId === e);
    }
    get isActive() {
      var c;
      return ((c = r.activeAccount) == null ? void 0 : c.walletId) === e;
    }
  }, n = s;
  (() => {
    zt(s, "AWallet");
  })();
  let i = new n();
  return i;
}, "createWallet"), ex = zt(async (r, e) => {
  if (xt.log("signTransactions", e), !r.activeAccount)
    throw new Error("No active account to sign txns with.");
  let t = r.activeWallet;
  if (!t)
    throw new Error("No active wallet... how'd you get here.");
  return await t.signTransactions(e);
}, "signTransactions"), Up = zt((r) => {
  xt.enabled = r;
}, "setLogsEnabled"), sl = false, Tc, Pp = (Tc = class {
  constructor(e) {
    je(this, "allWallets", { [Et.PERA]: vi(this, Et.PERA), [Et.INKEY]: vi(this, Et.INKEY), [Et.MYALGO]: vi(this, Et.MYALGO), [Et.ALGOSIGNER]: vi(this, Et.ALGOSIGNER), [Et.EXODUS]: vi(this, Et.EXODUS), [Et.DEFLY]: vi(this, Et.DEFLY), [Et.MNEMONIC]: vi(this, Et.MNEMONIC) });
    je(this, "activeAccount");
    je(this, "connectedAccounts");
    je(this, "changedAccountHandlers", /* @__PURE__ */ new Set());
    je(this, "arr", Ft.array([]));
    je(this, "selfId", `${Math.random()}_${(/* @__PURE__ */ new Date()).getTime()}`);
    je(this, "storageKey");
    je(this, "storageController");
    je(this, "emitSyncStates", () => {
      if (xt.log("emitSyncStates"), ku()) {
        if (!sl) {
          let e2 = new CustomEvent("aw-state-change", { detail: { from: this.selfId } });
          xt.log("dispatching c evt", e2), window.top.dispatchEvent(e2);
        }
      } else
        console.warn("Not in browser, no access to Window. Will not dispatch custom event");
    });
    je(this, "setAsActiveAccount", (e2) => {
      xt.debug("setAsActiveAccount", e2), e2.active = true, e2.dateLastActive = (/* @__PURE__ */ new Date()).getTime(), this.activeAccount = e2, this.connectedAccounts.forEach((t) => {
        t.walletId == e2.walletId && t.address == e2.address && t.name == e2.name ? t.active = true : t.active = false;
      });
    });
    je(this, "removeAccount", (e2) => {
      if (this.activeAccount) {
        let i = this.connectedAccounts.filter((s) => s.walletId == e2.walletId && s.name == e2.name && s.address == e2.address);
        for (let s of i)
          if (s.address == this.activeAccount.address && s.walletId == this.activeAccount.walletId) {
            this.activeAccount = null;
            break;
          }
      }
      let t = this.connectedAccounts, n = t.findIndex((i) => i.walletId == e2.walletId && i.address == e2.address && i.name == e2.name);
      t.splice(n, 1), this.connectedAccounts = t;
    });
    je(this, "removeAllAccounts", () => {
      this.activeAccount = null, this.connectedAccounts = [];
    });
    je(this, "removeAccountsByWalletId", (e2) => {
      if (xt.debug("removeAccountsByWalletId", e2), this.activeAccount) {
        let n = this.connectedAccounts.filter((i) => i.walletId == e2);
        for (let i of n)
          if (i.address == this.activeAccount.address && i.walletId == this.activeAccount.walletId) {
            this.activeAccount = null;
            break;
          }
      }
      let t = this.connectedAccounts.filter((n) => n.walletId !== e2);
      this.connectedAccounts = t;
    });
    je(this, "getAccountsByWalletId", (e2) => this.connectedAccounts.filter((t) => t.walletId === e2));
    je(this, "initWallet", (e2, t) => {
      let n = this.allWallets[e2];
      if (!n)
        throw new Error(`Unknown wallet: ${e2}`);
      return t !== void 0 ? n.initParams = t : xt.log("didnt update wallet's init params... kept whatever existed before"), n;
    });
    je(this, "initWallets", (e2) => {
      xt.log("initWallets started", e2);
      for (let [t, n] of Object.entries(e2)) {
        let i = t;
        this.initWallet(i, n);
      }
      return this.allWallets;
    });
    je(this, "connectWallet", async (e2, t) => {
      t !== void 0 && this.initWallet(e2, t);
      let n = this.allWallets[e2];
      if (!n)
        throw new Error(`Unknown wallet: ${e2}`);
      return await n.connect();
    });
    je(this, "disconnectWallet", async (e2) => {
      let t = this.allWallets[e2];
      if (!t)
        throw new Error(`Unknown wallet: ${e2}`);
      if (t.isConnected)
        return await t.disconnect();
      xt.debug("disconnectWallet > wallet not connected:", e2);
    });
    je(this, "disconnectAllWallets", async () => {
      xt.debug("disconnectAllWallets"), Object.values(this.allWallets).forEach(async (e2) => {
        await this.disconnectWallet(e2.id);
      });
    });
    je(this, "signTransactions", async (e2) => await ex(this, e2));
    je(this, "subscribeToAccountChanges", (e2, t = { callOnSet: true }) => (this.changedAccountHandlers.add(e2), t.callOnSet && e2(this.activeAccount), zt(() => {
      this.changedAccountHandlers.delete(e2);
    }, "unsubscribe")));
    this.initVars(), Mu(this, { arr: Ft.deep, connectedAccounts: Ft.deep, activeAccount: Ft, allWallets: false, changedAccountHandlers: false }, { deep: true }), e && (tx(this), e.storageKey && (this.storageKey = e.storageKey, e.storageController ? this.storageController = e.storageController : e.storageKey && (ku() ? this.storageController = window.localStorage : console.warn("Provide a storageController if you want to persist state outside browser.")), jp(this, { name: this.storageKey, properties: [{ key: "activeAccount", serialize: (t) => Vr(t), deserialize: (t) => Ft(t) }, { key: "connectedAccounts", serialize: (t) => Vr(t), deserialize: (t) => Ft.array(t) }, { key: "arr", serialize: (t) => Vr(t), deserialize: (t) => Ft.array(t) }], storage: this.storageController }).then((t) => {
      xt.log("pStore inited", t), rx(this, t);
    })));
  }
  initVars() {
    xt.log("initVars"), this.activeAccount = null, this.connectedAccounts = [], this.arr = Ft.array([]);
  }
  addConnectedAccounts(e) {
    xt.log("addConnectedAccounts", e);
    for (let t of e) {
      let n = false;
      for (let i of this.connectedAccounts)
        t.walletId == i.walletId && t.address == i.address && (n = true);
      n || this.connectedAccounts.push(t);
    }
  }
  get activeAddress() {
    let e = "";
    return this.activeAccount && (e = this.activeAccount.address), e;
  }
  get activeWalletId() {
    let e = null;
    return this.activeAccount && (e = this.activeAccount.walletId), e;
  }
  get activeWallet() {
    let e;
    return this.activeWalletId !== null && (e = this.allWallets[this.activeWalletId]), e;
  }
  get isSigning() {
    let e = false;
    for (let [t, n] of Object.entries(this.allWallets))
      if (n.signing) {
        e = true;
        break;
      }
    return e;
  }
  get isIniting() {
    let e = false;
    for (let [t, n] of Object.entries(this.allWallets))
      if (n.initing) {
        e = true;
        break;
      }
    return e;
  }
}, (() => {
  zt(Tc, "AnyWalletState");
})(), Tc), Bp = zt((r, e) => {
  xt.log("resetStore", r.selfId), e.pausePersisting(), r.initVars(), setTimeout(() => {
    e.startPersisting();
  }, 100);
}, "resetStore"), tx = zt((r) => {
  xt.log("initWatchers", r.selfId), Du(r, () => {
    xt.log("observed"), r.emitSyncStates();
  }), Qs(() => r.activeAccount, async (e) => {
    xt.log("activeAccount changed", e), r.changedAccountHandlers.forEach((t) => t(e)), r.emitSyncStates();
  }), Du(r.connectedAccounts, (e) => {
    xt.log("connectedAccounts observed", e), r.emitSyncStates();
  }), Qs(() => r.connectedAccounts.length, async (e) => {
    xt.log("connectedAccounts length change"), r.emitSyncStates();
  }), Du(r.arr, (e) => {
    xt.log("arr observed", e), r.emitSyncStates();
  }), Qs(() => r.arr.length, async (e) => {
    xt.log("arr length change"), r.emitSyncStates();
  });
}, "initWatchers"), rx = zt((r, e) => {
  xt.log("initListeners", r.selfId), ku() ? (window.top.addEventListener("aw-state-change", async (t) => {
    xt.log("caught aw-state-change evt", t), t.detail.from !== r.selfId && (sl = true, setTimeout(async () => {
      xt.log("timeout hyd store"), await e.hydrateStore(), setTimeout(() => {
        sl = false;
      }, 10);
    }, 10));
  }, false), window.addEventListener("storage", (t) => {
    if (xt.log("storage evt", t), t.key == null)
      Bp(r, e);
    else if (t.key == r.storageKey)
      if (t.newValue == null)
        Bp(r, e);
      else {
        let n = t.newValue, i = JSON.parse(n);
        xt.log("newVObj", i), xt.log("pausingPersist"), e.pausePersisting();
        for (let s in i) {
          let o = i[s];
          xt.log(`${s}: ${o}`), r[s] = o;
        }
        setTimeout(() => {
          xt.log("startPersist"), e.startPersisting();
        }, 10);
      }
  }, false)) : console.warn("No attaching Window event listeners (aw-state-change, dom storage)");
}, "initListeners");
var ol = { LEDGER: "testnet", BASE_SERVER: "https://testnet-api.algonode.cloud", INDEX_SERVER: "https://testnet-idx.algonode.cloud", API_TOKEN: "", PORT: "" }, zp = { LEDGER: "mainnet", BASE_SERVER: "https://mainnet-api.algonode.cloud", INDEX_SERVER: "https://mainnet-idx.algonode.cloud", API_TOKEN: "", PORT: "" }, al = ol;
var cl = { disableLogs: true };
var Ct = { enabled: false, log(...r) {
  this.enabled && console.log(...r);
}, debug(...r) {
  this.enabled && console.debug(...r);
} };
var ul = null, fl = class {
  constructor(e) {
    this.indexerClient = void 0;
    this.nodeConfig = al;
    this.libConfig = cl;
    this.sdk = Cf;
    this.inkeyClientSdk = null;
    this.inkeyLoading = false;
    this.inkeyLoaded = false;
    this.account = null;
    this.setNodeConfig(e == null ? void 0 : e.nodeConfig), this.setLibConfig(e), this.initAwState(e);
  }
  get connectedAccounts() {
    return this.walletState.connectedAccounts;
  }
  initAwState(e) {
    Ct.log("initAwState", e);
    let t = e ? { storageKey: e.storageKey, storageController: e.storageController } : void 0;
    this.walletState = new Pp(t), this.initWallets(e == null ? void 0 : e.initWallets), this.initAcctSync(), this.subscribeToAccountChanges = this.walletState.subscribeToAccountChanges, this.setActiveAccount = this.walletState.setAsActiveAccount, this.connect = this.walletState.connectWallet, this.disconnect = this.walletState.disconnectWallet, this.disconnectAll = this.walletState.disconnectAllWallets;
  }
  setLibConfig(e) {
    e == null ? cl : "disableLogs" in e && typeof e.disableLogs == "boolean" && (Ct.enabled = !e.disableLogs, Up(!e.disableLogs));
  }
  isValidNodeConfig(e) {
    let t = true;
    return (e == null || !e.BASE_SERVER) && (t = false), t;
  }
  setNodeConfig(e) {
    if (Ct.log("setNodeConfig", e), e == null && (e = al), typeof e == "string")
      if (e == "mainnet")
        e = zp;
      else if (e == "testnet")
        e = ol;
      else
        throw new Error("bad node config string.");
    if (!this.isValidNodeConfig(e))
      throw new Error("bad node config!");
    if (typeof e == "undefined")
      throw new Error("node config undefined");
    this.nodeConfig = e, this.algodClient = new Qn(e.API_TOKEN, e.BASE_SERVER, e.PORT), e.INDEX_SERVER ? this.indexerClient = new fi(e.API_TOKEN, e.INDEX_SERVER, e.PORT) : console.warn("No indexer configured because INDEX_SERVER was not provided.");
  }
  getNodeConfig() {
    return this.nodeConfig ? this.nodeConfig : false;
  }
  async checkStatus() {
    if (!this.getNodeConfig())
      throw new Error("No node configuration set.");
    let e = await this.algodClient.status().do();
    return Ct.log("Algorand network status: %o", e), e;
  }
  initAcctSync() {
    ul = this.walletState.subscribeToAccountChanges((e) => {
      Ct.log("acct changed", e), this.account = e;
    });
  }
  stopAcctSync() {
    ul && ul();
  }
  initWallets(e) {
    e == null && Ct.debug(".enableWallets called without any init params.");
    let n = e || {};
    this.walletState.initWallets(n);
  }
  async mnemonicConnect(e) {
    if (!e)
      throw new Error("algonaut.mnemonicConnect: No mnemonic provided.");
    return await this.connect("mnemonic", e);
  }
  async inkeyConnect() {
    return console.warn(".inkeyConnect is deprecated. please use .connect"), await this.connect("inkey");
  }
  async inkeyDisconnect() {
    return console.warn(".inkeyDisconnect is deprecated. please use .disconnect"), await this.disconnect(Et.INKEY);
  }
  async inkeyShow(e) {
    (await this.getInkeyClientSdk()).show(e);
  }
  async inkeyHide() {
    (await this.getInkeyClientSdk()).hide();
  }
  async getInkeyClientSdk() {
    if (Ct.log("getInkeyClientSdk"), this.inkeyClientSdk !== null)
      return this.inkeyLoaded = true, this.inkeyClientSdk;
    {
      let e = this.walletState.allWallets.inkey;
      if (!e)
        throw console.warn("Inkey wallet not enabled by dev"), new Error("Inkey wallet not enabled by dev");
      this.inkeyLoading = true, await e.loadClient(), this.inkeyLoading = false;
      let t = e.client.sdk;
      return t.frameBus.ready == false && (Ct.debug("inkeySdk FrameBus not yet ready..."), await t.frameBus.isReady(), Ct.debug("inkeySdk FrameBus IS ready.")), this.inkeyLoaded = true, this.inkeyClientSdk = t, this.inkeyClientSdk;
    }
  }
  async waitForConfirmation(e, t, n = false) {
    var c;
    if (!e)
      throw new Error("waitForConfirmation: No transaction ID provided.");
    let i = (await this.algodClient.status().do())["last-round"], s = i + (t || 50), o = { status: "fail", message: "" };
    for (; i < s; ) {
      let l2 = "";
      try {
        l2 = await this.algodClient.pendingTransactionInformation(e).do(), n && Ct.log("waiting for confirmation");
      } catch (f2) {
        console.error((c = f2.response) == null ? void 0 : c.text);
      }
      if (l2["confirmed-round"] !== null && l2["confirmed-round"] > 0) {
        n && Ct.log("Transaction confirmed in round " + l2["confirmed-round"]), o.txId = e, o.status = "success", o.message = "Transaction confirmed in round " + l2["confirmed-round"];
        break;
      }
      i = (await this.algodClient.status().do())["last-round"];
    }
    return o;
  }
  generateLogicSig(e) {
    if (!e)
      throw new Error("No program string provided.");
    let t = new Uint8Array(fr.Buffer.from(e, "base64"));
    return new jr(t);
  }
  async atomicOptInAsset(e, t) {
    if (!this.walletState.activeAddress)
      throw new Error("No account set in Algonaut.");
    if (!e)
      throw new Error("No asset index provided.");
    let n = (t == null ? void 0 : t.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Ha({ from: this.walletState.activeAddress, to: this.walletState.activeAddress, assetIndex: e, amount: 0, suggestedParams: n }), isLogigSig: false };
  }
  async optInAsset(e, t, n) {
    if (!this.walletState.activeAddress)
      throw new Error("There was no account!");
    if (!e)
      throw new Error("No asset index provided.");
    let { transaction: i } = await this.atomicOptInAsset(e, n);
    return await this.sendTransaction(i, t);
  }
  async isOptedIntoAsset(e) {
    if (!e.account)
      throw new Error("No account provided.");
    if (!e.assetId)
      throw new Error("No asset ID provided.");
    let t = false;
    return (await this.getAccountInfo(e.account)).assets.forEach((i) => {
      i["asset-id"] == e.assetId && (t = true);
    }), t;
  }
  encodeArguments(e) {
    let t = [];
    return e.forEach((n) => {
      typeof n == "number" ? t.push(jn(n)) : typeof n == "bigint" ? t.push(jn(n)) : typeof n == "string" && t.push(new Uint8Array(fr.Buffer.from(n)));
    }), t;
  }
  async atomicCreateAsset(e) {
    var ie;
    if (!e.assetName)
      throw new Error("args.assetName not provided.");
    if (!e.symbol)
      throw new Error("args.symbol not provided");
    if (typeof e.decimals == "undefined")
      throw new Error("args.decimals not provided.");
    if (!e.amount)
      throw new Error("args.amount not provided.");
    let t = e.from || this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    e.metaBlock || (e.metaBlock = " "), e.defaultFrozen || (e.defaultFrozen = false), e.assetURL || (e.assetURL = void 0);
    let n = e.metaBlock.length;
    if (n > 1023)
      throw console.error("meta block is " + n), new Error("drat! this meta block is too long!");
    let s = new TextEncoder().encode(e.metaBlock), o = e.amount, c = e.manager && e.manager.length > 0 ? e.manager : t, l2 = e.reserve && e.reserve.length > 0 ? e.reserve : t, f2 = e.freeze && e.freeze.length > 0 ? e.freeze : t, h2 = e.clawback && e.clawback.length > 0 ? e.clawback : t, _ = ((ie = e.optionalFields) == null ? void 0 : ie.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: au(t, s, o, e.decimals, e.defaultFrozen, c, l2, f2, h2, e.symbol, e.assetName, e.assetURL, e.assetMetadataHash, _), isLogigSig: false };
  }
  async createAsset(e, t) {
    let i = (await this.atomicCreateAsset(e)).transaction;
    try {
      let s = await this.sendTransaction(i, t), o = await this.algodClient.pendingTransactionInformation(i.txID().toString()).do();
      return s.createdIndex = o["asset-index"], s;
    } catch (s) {
      throw Ct.log("transaction error"), Ct.log(s), new Error(s);
    }
  }
  async atomicDeleteAsset(e, t) {
    if (!this.walletState.activeAddress)
      throw new Error("there was no account!");
    if (!e)
      throw new Error("No assetId provided!");
    let n = new TextEncoder(), i = (t == null ? void 0 : t.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: cu(this.walletState.activeAddress, n.encode("doh!"), e, i), isLogigSig: false };
  }
  async deleteAsset(e, t, n) {
    if (!e)
      throw new Error("No asset ID provided!");
    let { transaction: i } = await this.atomicDeleteAsset(e, n);
    return await this.sendTransaction(i, t);
  }
  async atomicSendAsset(e) {
    var s;
    if (!e.to)
      throw new Error("No to address provided");
    if (!hn(e.to))
      throw new Error("Invalid to address");
    if (!e.assetIndex)
      throw new Error("No asset index provided");
    if (!(typeof e.amount == "bigint" || typeof e.amount == "number"))
      throw new Error("Amount has to be a number.");
    let t = e.from || this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    let n = ((s = e.optionalFields) == null ? void 0 : s.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Ha({ from: t, to: e.to, amount: e.amount, assetIndex: e.assetIndex, suggestedParams: n }), isLogigSig: false };
  }
  async sendAsset(e, t) {
    if (!(e.from || this.walletState.activeAddress))
      throw new Error("there is no fromAddr");
    let { transaction: i } = await this.atomicSendAsset(e);
    return await this.sendTransaction(i, t);
  }
  async getAssetInfo(e) {
    if (!e)
      throw new Error("No asset ID provided");
    return await this.algodClient.getAssetByID(e).do();
  }
  async atomicOptInApp(e) {
    var s, o, c, l2, f2, h2, _;
    if (!e.appIndex)
      throw new Error("No app ID provided");
    let t = this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    let n = ((s = e.optionalFields) == null ? void 0 : s.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: If({ from: t, appIndex: e.appIndex, suggestedParams: n, appArgs: e.appArgs ? this.encodeArguments(e.appArgs) : void 0, accounts: (o = e.optionalFields) != null && o.accounts ? (c = e.optionalFields) == null ? void 0 : c.accounts : void 0, foreignApps: (l2 = e.optionalFields) != null && l2.applications ? (f2 = e.optionalFields) == null ? void 0 : f2.applications : void 0, foreignAssets: (h2 = e.optionalFields) != null && h2.assets ? (_ = e.optionalFields) == null ? void 0 : _.assets : void 0 }), isLogigSig: false };
  }
  async optInApp(e, t) {
    let { transaction: n } = await this.atomicOptInApp(e);
    return await this.sendTransaction(n, t);
  }
  async atomicDeleteApp(e, t) {
    if (!e)
      throw new Error("No app ID provided");
    let n = this.walletState.activeAddress;
    if (!n)
      throw new Error("there is no fromAddr");
    let i = (t == null ? void 0 : t.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: fu(n, i, e), isLogigSig: false };
  }
  async deleteApp(e, t, n) {
    var i;
    try {
      let { transaction: s } = await this.atomicDeleteApp(e, n), o = s.txID().toString();
      return { status: "success", message: "deleted app index " + (await this.algodClient.pendingTransactionInformation(o).do()).txn.txn.apid, txId: o };
    } catch (s) {
      throw Ct.log(s), new Error((i = s.response) == null ? void 0 : i.text);
    }
  }
  async atomicCallApp(e) {
    var o, c, l2, f2, h2;
    let t = (e == null ? void 0 : e.from) || this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    if (!e.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    let n = this.encodeArguments(e.appArgs), i = ((o = e.optionalFields) == null ? void 0 : o.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: lu({ from: t, suggestedParams: i, appIndex: e.appIndex, appArgs: n, accounts: ((c = e.optionalFields) == null ? void 0 : c.accounts) || void 0, foreignApps: ((l2 = e.optionalFields) == null ? void 0 : l2.applications) || void 0, foreignAssets: ((f2 = e.optionalFields) == null ? void 0 : f2.assets) || void 0, note: (h2 = e.optionalFields) != null && h2.note ? this.toUint8Array(e.optionalFields.note) : void 0 }), isLogigSig: false };
  }
  async callApp(e, t) {
    let { transaction: n } = await this.atomicCallApp(e);
    return await this.sendTransaction(n, t);
  }
  async atomicCallAppWithLSig(e) {
    var s, o, c, l2;
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    if (!e.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    let t = this.encodeArguments(e.appArgs), n = ((s = e.optionalFields) == null ? void 0 : s.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: lu({ from: e.lsig.address(), suggestedParams: n, appIndex: e.appIndex, appArgs: t, accounts: ((o = e.optionalFields) == null ? void 0 : o.accounts) || void 0, foreignApps: ((c = e.optionalFields) == null ? void 0 : c.applications) || void 0, foreignAssets: ((l2 = e.optionalFields) == null ? void 0 : l2.assets) || void 0 }), isLogigSig: true, lSig: e.lsig };
  }
  async atomicCloseOutApp(e) {
    var n, i, s, o;
    let t = (e == null ? void 0 : e.from) || this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    try {
      let c = ((n = e.optionalFields) == null ? void 0 : n.suggestedParams) || await this.algodClient.getTransactionParams().do(), l2 = this.encodeArguments(e.appArgs);
      return { transaction: Tf({ from: t, suggestedParams: c, appIndex: e.appIndex, appArgs: l2, accounts: ((i = e.optionalFields) == null ? void 0 : i.accounts) || void 0, foreignApps: ((s = e.optionalFields) == null ? void 0 : s.applications) || void 0, foreignAssets: ((o = e.optionalFields) == null ? void 0 : o.assets) || void 0 }), isLogigSig: false };
    } catch (c) {
      throw new Error(c);
    }
  }
  async closeOutApp(e, t) {
    let { transaction: n } = await this.atomicCloseOutApp(e);
    return await this.sendTransaction(n, t);
  }
  getAppEscrowAccount(e) {
    if (!e)
      throw new Error("No appId provided");
    return Bn(e);
  }
  async getAppInfo(e) {
    if (!e)
      throw new Error("No appId provided");
    let t = [this.algodClient.getApplicationByID(e).do()];
    this.walletState.activeAddress && t.push(this.getAppLocalState(e));
    let i = await Promise.all(t), s = i[0], o = i[1], c = { hasState: true, globals: [], locals: (o == null ? void 0 : o.locals) || [], creatorAddress: s.params.creator, index: e };
    return s.params["global-state"] && (c.globals = this.decodeStateArray(s.params["global-state"])), c;
  }
  async createApp(e, t) {
    var i, s, o, c, l2;
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw console.warn("drat! your note is too long!"), new Error("Your note is too long");
    let n = this.walletState.activeAddress;
    if (!n)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (!e.schema)
      throw new Error("No schema provided");
    try {
      let f2 = ((i = e.optionalFields) == null ? void 0 : i.suggestedParams) || await this.algodClient.getTransactionParams().do(), h2 = new Uint8Array(), _ = new Uint8Array();
      if (h2 = await this.compileProgram(e.tealApprovalCode), _ = await this.compileProgram(e.tealClearCode), h2 && _) {
        let j2 = Ef({ from: n, suggestedParams: f2, onComplete: Ht.NoOpOC, approvalProgram: h2, clearProgram: _, numLocalInts: e.schema.localInts, numLocalByteSlices: e.schema.localBytes, numGlobalInts: e.schema.globalInts, numGlobalByteSlices: e.schema.globalBytes, appArgs: this.encodeArguments(e.appArgs), accounts: (s = e.optionalFields) != null && s.accounts ? e.optionalFields.accounts : void 0, foreignApps: (o = e.optionalFields) != null && o.applications ? e.optionalFields.applications : void 0, foreignAssets: (c = e.optionalFields) != null && c.assets ? e.optionalFields.assets : void 0, note: (l2 = e.optionalFields) != null && l2.note ? this.toUint8Array(e.optionalFields.note) : void 0 }), ie = j2.txID().toString(), G = await this.sendTransaction(j2, t), Q = await this.algodClient.pendingTransactionInformation(ie).do();
        return G.message = "Created App ID: " + Q["application-index"], G.createdIndex = Q["application-index"], G.meta = Q, G.txId = ie, G;
      } else
        throw new Error("could not compile teal code");
    } catch (f2) {
      throw new Error(f2.message);
    }
  }
  async atomicCreateApp(e) {
    var n, i, s, o, c;
    let t = this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (!e.schema)
      throw new Error("No schema provided");
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    if (t)
      try {
        let l2 = Ht.NoOpOC, f2 = ((n = e.optionalFields) == null ? void 0 : n.suggestedParams) || await this.algodClient.getTransactionParams().do(), h2 = new Uint8Array(), _ = new Uint8Array();
        if (h2 = await this.compileProgram(e.tealApprovalCode), _ = await this.compileProgram(e.tealClearCode), !h2 || !_)
          throw new Error("Error: you must provide an approval program and a clear state program.");
        return { transaction: Ya(t, f2, l2, h2, _, e.schema.localInts, e.schema.localBytes, e.schema.globalInts, e.schema.globalBytes, this.encodeArguments(e.appArgs), (i = e.optionalFields) != null && i.accounts ? e.optionalFields.accounts : void 0, (s = e.optionalFields) != null && s.applications ? e.optionalFields.applications : void 0, (o = e.optionalFields) != null && o.assets ? e.optionalFields.assets : void 0, (c = e.optionalFields) != null && c.note ? this.toUint8Array(e.optionalFields.note) : void 0), isLogigSig: false };
      } catch (l2) {
        throw new Error("There was an error creating the transaction");
      }
    else
      throw new Error("Algonaut.js has no account loaded!");
  }
  async deployTealWithLSig(e) {
    var l2, f2;
    if (e.noteText && e.noteText.length > 511)
      throw new Error("Your note is too long");
    let t = [];
    e.appArgs && e.appArgs.length && (t = this.encodeArguments(e.appArgs));
    let n = e.lsig.address(), i = Ht.NoOpOC, s = ((l2 = e.optionalFields) == null ? void 0 : l2.suggestedParams) || await this.algodClient.getTransactionParams().do(), o = new Uint8Array(), c = new Uint8Array();
    try {
      if (o = await this.compileProgram(e.tealApprovalCode), c = await this.compileProgram(e.tealClearCode), o && c) {
        let h2 = Ya(n, s, i, o, c, e.schema.localInts, e.schema.localBytes, e.schema.globalInts, e.schema.globalBytes, t, ((f2 = e.optionalFields) == null ? void 0 : f2.accounts) || void 0), _ = h2.txID().toString(), j2 = di(h2, e.lsig);
        return await this.algodClient.sendRawTransaction(j2.blob).do(), { status: "success", message: "created new app with id: " + (await this.algodClient.pendingTransactionInformation(_).do())["application-index"], txId: _ };
      } else
        throw new Error("Error compiling programs.");
    } catch (h2) {
      throw console.error("Error deploying contract:"), new Error(h2);
    }
  }
  async atomicUpdateApp(e) {
    var n, i, s, o, c;
    let t = this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    try {
      let l2 = ((n = e.optionalFields) == null ? void 0 : n.suggestedParams) || await this.algodClient.getTransactionParams().do(), f2 = new Uint8Array(), h2 = new Uint8Array();
      if (f2 = await this.compileProgram(e.tealApprovalCode), h2 = await this.compileProgram(e.tealClearCode), !f2 || !h2)
        throw new Error("Error: you must provide an approval program and a clear state program.");
      return { transaction: uu(t, l2, e.appIndex, f2, h2, this.encodeArguments(e.appArgs), (i = e.optionalFields) != null && i.accounts ? e.optionalFields.accounts : void 0, (s = e.optionalFields) != null && s.applications ? e.optionalFields.applications : void 0, (o = e.optionalFields) != null && o.assets ? e.optionalFields.assets : void 0, (c = e.optionalFields) != null && c.note ? this.toUint8Array(e.optionalFields.note) : void 0), isLogigSig: false };
    } catch (l2) {
      throw new Error("There was an error creating the transaction");
    }
  }
  async updateApp(e, t) {
    let { transaction: n } = await this.atomicUpdateApp(e);
    return await this.sendTransaction(n, t);
  }
  async compileProgram(e) {
    let n = new TextEncoder().encode(e), i = await this.algodClient.compile(n).do();
    return new Uint8Array(fr.Buffer.from(i.result, "base64"));
  }
  async atomicSendAlgo(e) {
    var n, i;
    if (!(typeof e.amount == "bigint" || typeof e.amount == "number"))
      throw new Error("Amount has to be a number.");
    if (!e.to)
      throw new Error("You did not specify a to address");
    if (!hn(e.to))
      throw new Error("Invalid to address");
    let t = e.from || this.walletState.activeAddress;
    if (!t)
      throw new Error("there is no fromAddr");
    if (t) {
      let s = (n = e.optionalFields) != null && n.note ? this.toUint8Array(e.optionalFields.note) : new Uint8Array(), o = ((i = e.optionalFields) == null ? void 0 : i.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: ou({ from: t, to: e.to, amount: e.amount, note: s, suggestedParams: o }), isLogigSig: false };
    } else
      throw new Error("there is no fromAddr");
  }
  async sendAlgo(e, t) {
    let { transaction: n } = await this.atomicSendAlgo(e);
    return await this.sendTransaction(n, t);
  }
  async getAccountInfo(e) {
    if (!e)
      throw new Error("No address provided");
    return await this.algodClient.accountInformation(e).do();
  }
  async getAlgoBalance(e) {
    if (!e)
      throw new Error("No address provided");
    return (await this.algodClient.accountInformation(e).do()).amount;
  }
  async getTokenBalance(e, t) {
    if (!e)
      throw new Error("No address provided");
    if (!t)
      throw new Error("No asset index provided");
    let n = await this.algodClient.accountInformation(e).do(), i = 0;
    return n.assets.forEach((s) => {
      s["asset-id"] == t && (i = s.amount);
    }), i;
  }
  async accountHasTokens(e, t) {
    return await this.getTokenBalance(e, t) > 0;
  }
  async getAppGlobalState(e) {
    if (!e)
      throw new Error("No application ID provided");
    let t = await this.getAppInfo(e);
    return t.hasState ? this.stateArrayToObject(t.globals) : {};
  }
  async getAppLocalState(e, t) {
    if (!e)
      throw new Error("No application ID provided");
    let n = { hasState: false, globals: [], locals: [], creatorAddress: "", index: e };
    if (this.walletState.activeAddress && !t && (t = this.walletState.activeAddress), t) {
      let i = await this.algodClient.accountInformation(t).do();
      for (let s = 0; s < i["apps-local-state"].length; s++)
        if (i["apps-local-state"][s].id == e) {
          n.hasState = true;
          for (let o = 0; o < i["apps-local-state"][s]["key-value"].length; o++) {
            let c = i["apps-local-state"][s]["key-value"][o], l2 = fr.Buffer.from(c.key, "base64").toString(), f2 = c.value.type, h2, _ = "";
            f2 == 1 ? (h2 = fr.Buffer.from(c.value.bytes, "base64").toString(), _ = xe(fr.Buffer.from(c.value.bytes, "base64"))) : c.value.type == 2 && (h2 = c.value.uint), n.locals.push({ key: l2, value: h2 || "", address: _ });
          }
        }
      return n;
    } else
      console.warn("Algonaut used in non-authd state, not getting local vars");
  }
  async atomicAssetTransferWithLSig(e) {
    var t;
    if (e.lsig) {
      let n = ((t = e.optionalFields) == null ? void 0 : t.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: Ha({ from: e.lsig.address(), to: e.to, amount: e.amount, assetIndex: e.assetIndex, suggestedParams: n }), isLogigSig: true, lSig: e.lsig };
    } else
      throw new Error("there is no logic sig object!");
  }
  async atomicPaymentWithLSig(e) {
    var t;
    if (e.lsig) {
      let n = ((t = e.optionalFields) == null ? void 0 : t.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: ou({ from: e.lsig.address(), to: e.to, amount: e.amount, suggestedParams: n }), isLogigSig: true, lSig: e.lsig };
    } else
      throw new Error("there is no account!");
  }
  normalizeTxns(e) {
    Ct.log("normalizeTxns", e);
    let t = [];
    Array.isArray(e) ? t = e : t = [e];
    let n = [];
    if (n = t.map((s) => {
      let o = s.transaction;
      return o == null && (o = s), o;
    }), Ct.log("algoTxnArr", [...n]), n.length > 1 && (n = Cf.assignGroupID(n), Ct.log("added group id to txn array"), n[0].group)) {
      let s = this.txnBuffToB64(n[0].group);
      Ct.log("gId", s);
    }
    let i = n.map((s) => s.toByte());
    return Ct.log("txnBuffArr", i), i;
  }
  async signTransaction(e) {
    let t = this.normalizeTxns(e);
    Ct.log("awTxnsToSign", t);
    let n;
    try {
      n = await this.walletState.signTransactions(t), Ct.log("awTxnsSigned", n);
    } catch (i) {
      throw console.warn("err signing txns..."), Ct.log(i), new Error("Error signing transactions");
    }
    return n;
  }
  async sendTransaction(e, t) {
    let n = await this.signTransaction(e);
    t != null && t.onSign && t.onSign(n);
    let i = await this.algodClient.sendRawTransaction(n).do();
    t != null && t.onSend && t.onSend(i);
    let s = await this.waitForConfirmation(i.txId), o = await this.algodClient.pendingTransactionInformation(i.txId).do();
    return s.meta = o, t != null && t.onConfirm && t.onConfirm(s), s;
  }
  toUint8Array(e, t = "utf8") {
    return new Uint8Array(fr.Buffer.from(e, t));
  }
  to8Arr(e, t = "utf8") {
    return this.toUint8Array(e, t);
  }
  stateArrayToObject(e) {
    let t = {};
    return e.forEach((n) => {
      n.key && (t[n.key] = n.value || null);
    }), t;
  }
  b64StrToHumanStr(e) {
    return fr.Buffer.from(e, "base64").toString();
  }
  fromBase64(e) {
    return this.b64StrToHumanStr(e);
  }
  valueAsAddr(e) {
    return xe(fr.Buffer.from(e, "base64"));
  }
  decodeStateArray(e) {
    let t = [];
    for (let n = 0; n < e.length; n++) {
      let i = e[n], s = this.b64StrToHumanStr(i.key), o = i.value.type, c, l2 = "";
      o == 1 ? (c = this.b64StrToHumanStr(i.value.bytes), l2 = this.valueAsAddr(i.value.bytes)) : i.value.type == 2 && (c = i.value.uint), t.push({ key: s, value: c || "", address: l2 });
    }
    return t;
  }
  decodeBase64UnsignedTransaction(e) {
    return Ln(fr.Buffer.from(e, "base64"));
  }
  txnSummary(e) {
    if (e.type) {
      let t = e.to ? xe(e.to.publicKey) : "", n = e.from ? xe(e.from.publicKey) : "";
      if (e.type === "pay")
        return e.amount ? `Send ${Vc(e.amount)} ALGO to ${t}` : `Send 0 ALGO to ${t}`;
      if (e.type === "axfer")
        return !e.amount && t === n ? `Opt-in to asset ID ${e.assetIndex}` : `Transfer ${e.amount ? e.amount : 0} of asset ID ${e.assetIndex} to ${t}`;
      if (e.type === "acfg")
        return e.assetUnitName ? `Create asset ${e.assetName}, symbol ${e.assetUnitName}` : `Configure asset ${e.assetIndex}`;
      if (e.type === "afrz")
        return `Freeze asset ${e.assetIndex}`;
      if (e.type === "appl")
        switch (e.appOnComplete) {
          case 0:
            return `Call to application ID ${e.appIndex}`;
          case 1:
            return `Opt-in to application ID ${e.appIndex}`;
          case 2:
            return `Close out application ID ${e.appIndex}`;
          case 3:
            return `Execute clear state program of application ID ${e.appIndex}`;
          case 4:
            return `Update application ID ${e.appIndex}`;
          case 5:
            return `Delete application ID ${e.appIndex}`;
          default:
            return e.appIndex == null ? "Create an application" : `Call to application ID ${e.appIndex}`;
        }
      else
        return `Transaction of type ${e.type} to ${t}`;
    } else
      return e.toString();
  }
  createWallet() {
    let e = Ka();
    if (e) {
      let t = eu(e.sk);
      return { address: e.addr, mnemonic: t };
    } else
      throw new Error("There was no account: could not create algonaut wallet!");
  }
  recoverAccount(e) {
    if (!e)
      throw new Error("No mnemonic provided.");
    try {
      let t = li(e);
      if (hn(t == null ? void 0 : t.addr))
        return t;
      throw new Error("Not a valid mnemonic.");
    } catch (t) {
      throw console.error(t), new Error("Could not recover account from mnemonic.");
    }
  }
  txnB64ToTxnBuff(e) {
    return fr.Buffer.from(e, "base64");
  }
  txnBuffToB64(e) {
    return fr.Buffer.from(e).toString("base64");
  }
  txnToStr(e) {
    let t = e.toByte();
    return this.txnBuffToB64(t);
  }
};
fr.Buffer;
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

js-sha512/src/sha512.js:
  (*
   * [js-sha512]{@link https://github.com/emn178/js-sha512}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2018
   * @license MIT
   *)

hi-base32/src/base32.js:
  (*
   * [hi-base32]{@link https://github.com/emn178/hi-base32}
   *
   * @version 0.5.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/
const awState = markRaw(new H({
  storageKey: "state1"
}));
const algonaut = new fl();
const algodClient = new algosdk.Algodv2(
  "",
  "https://testnet-api.algonode.cloud",
  443
);
const unsubAcctChange1 = awState.subscribeToAccountChanges(
  (acct) => {
    console.log("outside acct changed", acct);
  }
);
const _sfc_main$1 = defineComponent({
  data() {
    return {
      awState,
      walletListOpen: false,
      selectedAddrFromDropdown: awState.activeAccount
    };
  },
  mounted() {
    awState.subscribeToAccountChanges(
      (acct) => {
        this.selectedAddrFromDropdown = acct;
        this.$forceUpdate();
      }
    );
  },
  methods: {
    getAddrFromAccount(a) {
      return a.address;
    },
    activeAddrChanged(x2) {
      awState.activeAccount = x2;
    },
    async connectInkey() {
      let accts = await awState.connectWallet("inkey");
      return accts;
    },
    async connectMnemonic() {
      return await awState.connectWallet("mnemonic", "123 456 789 ...");
    },
    async doTxnSimpleAlgJs() {
      console.log("doTxnSimpleAlgJs");
      let addr = awState.activeAddress;
      if (!addr) {
        alert("no .to address provided");
        return;
      }
      const txn = await algonaut.atomicSendAlgo({
        amount: 1e3,
        to: addr,
        from: addr
        // .from needed IF algonaut doesnt have this.account populated
      });
      console.log("txn", txn);
      const txnBytes = txn.transaction.toByte();
      const txnArray = [
        txnBytes
      ];
      try {
        let res = await awState.signTransactions(txnArray);
        console.log("res", res);
      } catch (e) {
        console.warn(e);
      }
    },
    async doTxnSimpleAlgosdk() {
      console.log("doTxnSimpleAlgosdk");
      let addr = awState.activeAddress;
      if (!addr) {
        alert("no .to address provided");
        return;
      }
      const suggestedParams = await algodClient.getTransactionParams().do();
      console.log("suggestedParams", suggestedParams);
      const transaction2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
        from: addr,
        to: addr,
        amount: 1e3,
        suggestedParams
      });
      console.log("transaction", transaction2);
      const txnBytes = transaction2.toByte();
      const txnArray = [
        txnBytes
      ];
      try {
        let res = await awState.signTransactions(txnArray);
        console.log("res", res);
      } catch (e) {
        console.warn(e);
      }
    },
    doUnsub() {
      console.log("doUnsub");
      unsubAcctChange1();
    }
  }
});
const Demo_vue_vue_type_style_index_0_scoped_c70210fb_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _withScopeId = (n) => (pushScopeId("data-v-c70210fb"), n = n(), popScopeId(), n);
const _hoisted_1 = { class: "auth-test-container" };
const _hoisted_2 = { style: { "color": "red" } };
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { key: 1 };
const _hoisted_5 = {
  key: 0,
  class: "wallet-list"
};
const _hoisted_6 = {
  key: 0,
  class: "active-account-details"
};
const _hoisted_7 = { style: { "font-weight": "bold" } };
const _hoisted_8 = { style: { "font-family": "monospace", "word-break": "break-all" } };
const _hoisted_9 = { class: "wallet-list-item" };
const _hoisted_10 = ["src"];
const _hoisted_11 = { style: { "padding": "0 1em" } };
const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { style: { "flex-grow": "1" } }, null, -1));
const _hoisted_13 = ["name"];
const _hoisted_14 = ["value"];
const _hoisted_15 = ["onClick", "disabled"];
const _hoisted_16 = ["onClick", "disabled"];
const _hoisted_17 = ["onClick"];
const _hoisted_18 = ["disabled"];
const _hoisted_19 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_20 = ["disabled"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createBaseVNode("header", null, [
      createBaseVNode("span", _hoisted_2, toDisplayString(_ctx.awState.isSigning ? "(signing)" : ""), 1),
      createBaseVNode("button", {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.walletListOpen = !_ctx.walletListOpen)
      }, [
        _ctx.awState.activeAddress ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(`${_ctx.awState.activeAddress.substring(0, 6)}...${_ctx.awState.activeAddress.substring(_ctx.awState.activeAddress.length - 3)}`) + " (" + toDisplayString(_ctx.awState.activeWalletId) + ") ", 1)) : (openBlock(), createElementBlock("span", _hoisted_4, " Connect Wallet "))
      ])
    ]),
    _ctx.walletListOpen ? (openBlock(), createElementBlock("div", _hoisted_5, [
      _ctx.awState.activeAccount ? (openBlock(), createElementBlock("div", _hoisted_6, [
        createBaseVNode("span", _hoisted_7, toDisplayString(_ctx.awState.activeAccount.name), 1),
        createBaseVNode("span", null, "(" + toDisplayString(_ctx.awState.activeAccount.walletId) + ")", 1),
        createBaseVNode("div", _hoisted_8, toDisplayString(_ctx.awState.activeAddress), 1)
      ])) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.awState.allWallets, (p2, key) => {
        return openBlock(), createElementBlock("div", _hoisted_9, [
          p2 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("img", {
              src: p2.metadata.icon,
              alt: "",
              style: { "width": "40px", "height": "40px" }
            }, null, 8, _hoisted_10),
            createBaseVNode("span", _hoisted_11, toDisplayString(p2.metadata.name), 1),
            _hoisted_12,
            createBaseVNode("span", null, toDisplayString(p2.initing ? "(loading)" : ""), 1),
            createBaseVNode("span", null, toDisplayString(p2.connecting ? "(connecting)" : ""), 1),
            createBaseVNode("span", null, toDisplayString(p2.signing ? "(signing)" : ""), 1),
            p2.isActive ? withDirectives((openBlock(), createElementBlock("select", {
              key: 0,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedAddrFromDropdown = $event),
              style: { "width": "100px" },
              name: `w_${key}_select`,
              id: "",
              onChange: _cache[2] || (_cache[2] = ($event) => _ctx.activeAddrChanged(_ctx.selectedAddrFromDropdown))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(p2.accounts, (a) => {
                return openBlock(), createElementBlock("option", { value: a }, toDisplayString(_ctx.getAddrFromAccount(a)) + " (" + toDisplayString(a.name) + ") ", 9, _hoisted_14);
              }), 256))
            ], 40, _hoisted_13)), [
              [vModelSelect, _ctx.selectedAddrFromDropdown]
            ]) : createCommentVNode("", true),
            p2.isConnected && !p2.isActive ? (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: ($event) => p2.setAsActiveWallet(),
              disabled: !(p2.isConnected && !p2.isActive)
            }, "set as active", 8, _hoisted_15)) : p2.isConnected ? (openBlock(), createElementBlock("button", {
              key: 2,
              onClick: ($event) => p2.disconnect(),
              disabled: !p2.isConnected
            }, "disconnect", 8, _hoisted_16)) : createCommentVNode("", true),
            createBaseVNode("button", {
              onClick: ($event) => p2.connect()
            }, "connect", 8, _hoisted_17)
          ], 64)) : createCommentVNode("", true)
        ]);
      }), 256))
    ])) : createCommentVNode("", true),
    _ctx.awState.activeWallet !== null ? (openBlock(), createElementBlock("button", {
      key: 1,
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.doTxnSimpleAlgJs && _ctx.doTxnSimpleAlgJs(...args)),
      disabled: !(_ctx.awState.activeWallet !== null)
    }, " sign transaction test ", 8, _hoisted_18)) : createCommentVNode("", true),
    _hoisted_19,
    _ctx.awState.activeWallet !== null ? (openBlock(), createElementBlock("button", {
      key: 2,
      onClick: _cache[4] || (_cache[4] = (...args) => _ctx.doTxnSimpleAlgosdk && _ctx.doTxnSimpleAlgosdk(...args)),
      disabled: !(_ctx.awState.activeWallet !== null)
    }, " sign transaction test (algosdk) ", 8, _hoisted_20)) : createCommentVNode("", true)
  ]);
}
const Demo = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-c70210fb"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Demo);
    };
  }
});
const App_vue_vue_type_style_index_0_scoped_872f38e6_lang = "";
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-872f38e6"]]);
const style = "";
const app = createApp(App);
app.mount("#app");
export {
  commonjsGlobal as a,
  buffer as b,
  commonjsRequire as c,
  getAugmentedNamespace as d,
  getDefaultExportFromCjs as g,
  require$$0 as r
};
