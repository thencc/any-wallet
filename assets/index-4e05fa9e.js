var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function _mergeNamespaces(n, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e = m2[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k2 in e) {
        if (k2 !== "default" && !(k2 in n)) {
          const d2 = Object.getOwnPropertyDescriptor(e, k2);
          if (d2) {
            Object.defineProperty(n, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b2) {
  if (a.length !== b2.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b2[i]);
  }
  return equal;
}
function looseEqual(a, b2) {
  if (a === b2)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b2);
  if (aValidType || bValidType) {
    return a === b2;
  }
  aValidType = isArray(a);
  bValidType = isArray(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b2) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ] && !(isReadonly2 && target[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ]);
  }
  return !!(value && value[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ]);
}
function isReadonly(value) {
  return !!(value && value[
    "__v_isReadonly"
    /* ReactiveFlags.IS_READONLY */
  ]);
}
function isShallow(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref) {
  if (shouldTrack && activeEffect) {
    ref = toRaw(ref);
    {
      trackEffects(ref.dep || (ref.dep = createDep()));
    }
  }
}
function triggerRefValue(ref, newVal) {
  ref = toRaw(ref);
  const dep = ref.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r3) {
  return !!(r3 && r3.__v_isRef === true);
}
function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var _a$1;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$1] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this[
      "__v_isReadonly"
      /* ReactiveFlags.IS_READONLY */
    ] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$1 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn$1(msg, ...args) {
  return;
}
function callWithErrorHandling$1(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError$1(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling$1(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling$1(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError$1(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling$1(fn[i], instance, type, args));
  }
  return values;
}
function handleError$1(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling$1(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b2) => getId(a) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b2) => {
  const diff = getId(a) - getId(b2);
  if (diff === 0) {
    if (a.pre && !b2.pre)
      return -1;
    if (b2.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling$1(
          job,
          null,
          14
          /* ErrorCodes.SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling$1(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling$1(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render2(
        props,
        null
        /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError$1(
      err,
      instance,
      1
      /* ErrorCodes.RENDER_FUNCTION */
    );
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
const INITIAL_WATCHER_VALUE$1 = {};
function watch$1(source, cb, options) {
  return doWatch$1(source, cb, options);
}
function doWatch$1(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse$1(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling$1(
          s,
          instance,
          2
          /* ErrorCodes.WATCH_GETTER */
        );
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling$1(
        source,
        instance,
        2
        /* ErrorCodes.WATCH_GETTER */
      );
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling$1(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse$1(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling$1(
        fn,
        instance,
        4
        /* ErrorCodes.WATCH_CLEANUP */
      );
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling$1(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE$1) : INITIAL_WATCHER_VALUE$1;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling$1(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE$1 ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE$1 ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch$1(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse$1(value, seen2) {
  if (!isObject(value) || value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse$1(value.value, seen2);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse$1(value[i], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse$1(v2, seen2);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse$1(value[key], seen2);
    }
  }
  return value;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling$1(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook(
  "bm"
  /* LifecycleHooks.BEFORE_MOUNT */
);
const onMounted = createHook(
  "m"
  /* LifecycleHooks.MOUNTED */
);
const onBeforeUpdate = createHook(
  "bu"
  /* LifecycleHooks.BEFORE_UPDATE */
);
const onUpdated = createHook(
  "u"
  /* LifecycleHooks.UPDATED */
);
const onBeforeUnmount = createHook(
  "bum"
  /* LifecycleHooks.BEFORE_UNMOUNT */
);
const onUnmounted = createHook(
  "um"
  /* LifecycleHooks.UNMOUNTED */
);
const onServerPrefetch = createHook(
  "sp"
  /* LifecycleHooks.SERVER_PREFETCH */
);
const onRenderTriggered = createHook(
  "rtg"
  /* LifecycleHooks.RENDER_TRIGGERED */
);
const onRenderTracked = createHook(
  "rtc"
  /* LifecycleHooks.RENDER_TRACKED */
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse$1(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling$1(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(
      options.beforeCreate,
      instance,
      "bc"
      /* LifecycleHooks.BEFORE_CREATE */
    );
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v2) => c.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(
      created,
      instance,
      "c"
      /* LifecycleHooks.CREATED */
    );
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling$1(isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch$1(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch$1(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r3) => createWatcher(r3, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch$1(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to2, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions(to2, m2, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from[key]) : from[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from) {
  if (!from) {
    return to2;
  }
  if (!to2) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction(to2) ? to2.call(this, this) : to2, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to2, from) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
  return to2 ? extend(extend(/* @__PURE__ */ Object.create(null), to2), from) : from;
}
function mergeWatchOptions(to2, from) {
  if (!to2)
    return from;
  if (!from)
    return to2;
  const merged = extend(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from) {
    merged[key] = mergeAsArray(to2[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* BooleanFlags.shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* BooleanFlags.shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* BooleanFlags.shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* BooleanFlags.shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b2) {
  return getType(a) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach((r3, i) => setRef(r3, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref)) {
    callWithErrorHandling$1(ref, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (hasOwn(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (hasOwn(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n12 === n2) {
      return;
    }
    if (n12 && !isSameVNodeType(n12, n2)) {
      anchor = getNextHostNode(n12);
      unmount(n12, parentComponent, parentSuspense, true);
      n12 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n12, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n12, n2, container, anchor);
        break;
      case Static:
        if (n12 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
    }
  };
  const processText = (n12, n2, container, anchor) => {
    if (n12 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n12.el;
      if (n2.children !== n12.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n12, n2, container, anchor) => {
    if (n12 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n12.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n12 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n12, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n12, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n12.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n12.patchFlag & 16;
    const oldProps = n12.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n12.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n12, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n12.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n12.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n12 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n12.dynamicChildren) {
        patchBlockChildren(n12.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n12,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(n12, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n12 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n12, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n12, n2, optimized) => {
    const instance = n2.component = n12.component;
    if (shouldUpdateComponent(n12, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n12.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu: bu2, u: u3, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu2) {
          invokeArrayFns(bu2);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u3) {
          queuePostRenderEffect(u3, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n12 && n12.children;
    const prevShapeFlag = n12 ? n12.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n12 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n12, n2)) {
        patch(n12, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n12 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n12, n2)) {
        patch(n12, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
            move(
              nextChild,
              container,
              anchor,
              2
              /* MoveType.REORDER */
            );
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n12, n2, shallow = false) {
  const ch1 = n12.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j2, u3, v2, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i] = j2;
        result.push(i);
        continue;
      }
      u3 = 0;
      v2 = result.length - 1;
      while (u3 < v2) {
        c = u3 + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u3 = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u3]]) {
        if (u3 > 0) {
          p2[i] = result[u3 - 1];
        }
        result[u3] = i;
      }
    }
  }
  u3 = result.length;
  v2 = result[u3 - 1];
  while (u3-- > 0) {
    result[u3] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    true
    /* isBlock */
  ));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    true
    /* isBlock: prevent a block from tracking itself */
  ));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n12, n2) {
  return n12.type === n2.type && n12.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }) => {
  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style2)) {
      if (isProxy(style2) && !isArray(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling$1(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling$1(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError$1(
            e,
            instance,
            0
            /* ErrorCodes.SETUP_FUNCTION */
          );
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version = "3.2.47";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is2, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && // custom elements may use _value internally
  !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
    // textContent if no value attribute is present. And setting .value for
    // OPTION has no side effect
    el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling$1(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map((o) => number ? looseToNumber(getValue(o)) : getValue(o));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link2 = links[i];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
function callWithErrorHandling(fn, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++)
    values.push(callWithAsyncErrorHandling(fn[i], type, args));
  return values;
}
function handleError(err, type) {
  console.error(new Error(`[@vue-reactivity/watch]: ${type}`));
  console.error(err);
}
function warn(message) {
  console.warn(createError(message));
}
function createError(message) {
  return new Error(`[reactivue]: ${message}`);
}
var INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush } = {}) {
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);
    getter = () => source.map((s) => {
      if (isRef(s))
        return s.value;
      else if (isReactive(s))
        return traverse(s);
      else if (isFunction(s))
        return callWithErrorHandling(s, "watch getter");
      else
        return warn("invalid source");
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, "watch getter");
    } else {
      getter = () => {
        if (cleanup)
          cleanup();
        return callWithAsyncErrorHandling(source, "watch callback", [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, "watch cleanup");
    };
  };
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active)
      return;
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup)
          cleanup();
        callWithAsyncErrorHandling(cb, "watch value", [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else {
    scheduler = () => {
      job();
    };
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate)
      job();
    else
      oldValue = effect.run();
  } else {
    effect.run();
  }
  return () => effect.stop();
}
function traverse(value, seen2 = /* @__PURE__ */ new Set()) {
  if (!isObject(value) || seen2.has(value))
    return value;
  seen2.add(value);
  if (isArray(value)) {
    for (let i = 0; i < value.length; i++)
      traverse(value[i], seen2);
  } else if (value instanceof Map) {
    value.forEach((_, key) => {
      traverse(value.get(key), seen2);
    });
  } else if (value instanceof Set) {
    value.forEach((v2) => {
      traverse(v2, seen2);
    });
  } else {
    for (const key of Object.keys(value))
      traverse(value[key], seen2);
  }
  return value;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f2, args);
        return new Ctor();
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a;
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d2;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2)
      return 0;
    let x2 = a.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x2 = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n, m2) {
    const i = b2[n];
    b2[n] = b2[m2];
    b2[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 6] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 5] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 4] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi2, lo2;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo2 = c % 256;
      byteArray.push(lo2);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const index = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: buffer
}, [buffer]);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFastExports = {};
var naclFast = {
  get exports() {
    return naclFastExports;
  },
  set exports(v2) {
    naclFastExports = v2;
  }
};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module) {
  (function(nacl2) {
    var gf2 = function(init) {
      var i, r3 = new Float64Array(16);
      if (init)
        for (i = 0; i < init.length; i++)
          r3[i] = init[i];
      return r3;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf2(), gf1 = gf2([1]), _121665 = gf2([56129, 1]), D2 = gf2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x2, i, h2, l) {
      x2[i] = h2 >> 24 & 255;
      x2[i + 1] = h2 >> 16 & 255;
      x2[i + 2] = h2 >> 8 & 255;
      x2[i + 3] = h2 & 255;
      x2[i + 4] = l >> 24 & 255;
      x2[i + 5] = l >> 16 & 255;
      x2[i + 6] = l >> 8 & 255;
      x2[i + 7] = l & 255;
    }
    function vn2(x2, xi2, y2, yi, n) {
      var i, d2 = 0;
      for (i = 0; i < n; i++)
        d2 |= x2[xi2 + i] ^ y2[yi + i];
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x2, xi2, y2, yi) {
      return vn2(x2, xi2, y2, yi, 16);
    }
    function crypto_verify_32(x2, xi2, y2, yi) {
      return vn2(x2, xi2, y2, yi, 32);
    }
    function core_salsa20(o, p2, k2, c) {
      var j02 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j32 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j42 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x02 = j02, x1 = j1, x2 = j2, x32 = j32, x42 = j42, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u3;
      for (var i = 0; i < 20; i += 2) {
        u3 = x02 + x12 | 0;
        x42 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x42 + x02 | 0;
        x8 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x8 + x42 | 0;
        x12 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x12 + x8 | 0;
        x02 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x5 + x1 | 0;
        x9 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x9 + x5 | 0;
        x13 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x13 + x9 | 0;
        x1 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x1 + x13 | 0;
        x5 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x10 + x6 | 0;
        x14 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x14 + x10 | 0;
        x2 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x2 + x14 | 0;
        x6 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x6 + x2 | 0;
        x10 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x15 + x11 | 0;
        x32 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x32 + x15 | 0;
        x7 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x7 + x32 | 0;
        x11 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x11 + x7 | 0;
        x15 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x02 + x32 | 0;
        x1 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x1 + x02 | 0;
        x2 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x2 + x1 | 0;
        x32 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x32 + x2 | 0;
        x02 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x5 + x42 | 0;
        x6 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x6 + x5 | 0;
        x7 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x7 + x6 | 0;
        x42 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x42 + x7 | 0;
        x5 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x10 + x9 | 0;
        x11 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x11 + x10 | 0;
        x8 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x8 + x11 | 0;
        x9 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x9 + x8 | 0;
        x10 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x15 + x14 | 0;
        x12 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x12 + x15 | 0;
        x13 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x13 + x12 | 0;
        x14 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x14 + x13 | 0;
        x15 ^= u3 << 18 | u3 >>> 32 - 18;
      }
      x02 = x02 + j02 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x32 = x32 + j32 | 0;
      x42 = x42 + j42 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x02 >>> 0 & 255;
      o[1] = x02 >>> 8 & 255;
      o[2] = x02 >>> 16 & 255;
      o[3] = x02 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x32 >>> 0 & 255;
      o[13] = x32 >>> 8 & 255;
      o[14] = x32 >>> 16 & 255;
      o[15] = x32 >>> 24 & 255;
      o[16] = x42 >>> 0 & 255;
      o[17] = x42 >>> 8 & 255;
      o[18] = x42 >>> 16 & 255;
      o[19] = x42 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p2, k2, c) {
      var j02 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j32 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j42 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x02 = j02, x1 = j1, x2 = j2, x32 = j32, x42 = j42, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u3;
      for (var i = 0; i < 20; i += 2) {
        u3 = x02 + x12 | 0;
        x42 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x42 + x02 | 0;
        x8 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x8 + x42 | 0;
        x12 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x12 + x8 | 0;
        x02 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x5 + x1 | 0;
        x9 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x9 + x5 | 0;
        x13 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x13 + x9 | 0;
        x1 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x1 + x13 | 0;
        x5 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x10 + x6 | 0;
        x14 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x14 + x10 | 0;
        x2 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x2 + x14 | 0;
        x6 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x6 + x2 | 0;
        x10 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x15 + x11 | 0;
        x32 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x32 + x15 | 0;
        x7 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x7 + x32 | 0;
        x11 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x11 + x7 | 0;
        x15 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x02 + x32 | 0;
        x1 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x1 + x02 | 0;
        x2 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x2 + x1 | 0;
        x32 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x32 + x2 | 0;
        x02 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x5 + x42 | 0;
        x6 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x6 + x5 | 0;
        x7 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x7 + x6 | 0;
        x42 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x42 + x7 | 0;
        x5 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x10 + x9 | 0;
        x11 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x11 + x10 | 0;
        x8 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x8 + x11 | 0;
        x9 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x9 + x8 | 0;
        x10 ^= u3 << 18 | u3 >>> 32 - 18;
        u3 = x15 + x14 | 0;
        x12 ^= u3 << 7 | u3 >>> 32 - 7;
        u3 = x12 + x15 | 0;
        x13 ^= u3 << 9 | u3 >>> 32 - 9;
        u3 = x13 + x12 | 0;
        x14 ^= u3 << 13 | u3 >>> 32 - 13;
        u3 = x14 + x13 | 0;
        x15 ^= u3 << 18 | u3 >>> 32 - 18;
      }
      o[0] = x02 >>> 0 & 255;
      o[1] = x02 >>> 8 & 255;
      o[2] = x02 >>> 16 & 255;
      o[3] = x02 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c) {
      core_salsa20(out, inp, k2, c);
    }
    function crypto_core_hsalsa20(out, inp, k2, c) {
      core_hsalsa20(out, inp, k2, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m2, mpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u3, i;
      for (i = 0; i < 16; i++)
        z2[i] = 0;
      for (i = 0; i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = m2[mpos + i] ^ x2[i];
        u3 = 1;
        for (i = 8; i < 16; i++) {
          u3 = u3 + (z2[i] & 255) | 0;
          z2[i] = u3 & 255;
          u3 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < b2; i++)
          c[cpos + i] = m2[mpos + i] ^ x2[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u3, i;
      for (i = 0; i < 16; i++)
        z2[i] = 0;
      for (i = 0; i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < 64; i++)
          c[cpos + i] = x2[i];
        u3 = 1;
        for (i = 8; i < 16; i++) {
          u3 = u3 + (z2[i] & 255) | 0;
          z2[i] = u3 & 255;
          u3 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0; i < b2; i++)
          c[cpos + i] = x2[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d2, n, k2) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k2, sigma);
      var sn2 = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn2[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d2, sn2, s);
    }
    function crypto_stream_xor(c, cpos, m2, mpos, d2, n, k2) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k2, sigma);
      var sn2 = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn2[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m2, mpos, d2, sn2, s);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t12, t2, t32, t42, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t12 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t12 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t12 >>> 10 | t2 << 6) & 7939;
      t32 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t32 << 9) & 8191;
      t42 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t32 >>> 4 | t42 << 12) & 255;
      this.r[5] = t42 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t42 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m2, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t12, t2, t32, t42, t5, t6, t7, c;
      var d0, d1, d2, d32, d42, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h32 = this.h[3], h42 = this.h[4], h5 = this.h[5], h62 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r3 = this.r[3], r42 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r82 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t12 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t12 << 3) & 8191;
        t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
        h2 += (t12 >>> 10 | t2 << 6) & 8191;
        t32 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
        h32 += (t2 >>> 7 | t32 << 9) & 8191;
        t42 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
        h42 += (t32 >>> 4 | t42 << 12) & 8191;
        h5 += t42 >>> 1 & 8191;
        t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
        h62 += (t42 >>> 14 | t5 << 2) & 8191;
        t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r82);
        d0 += h32 * (5 * r7);
        d0 += h42 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h62 * (5 * r42);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r22);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h32 * (5 * r82);
        d1 += h42 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h62 * (5 * r5);
        d1 += h7 * (5 * r42);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r22);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r22;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h32 * (5 * r9);
        d2 += h42 * (5 * r82);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h62 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r42);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d32 = c;
        d32 += h0 * r3;
        d32 += h1 * r22;
        d32 += h2 * r1;
        d32 += h32 * r0;
        d32 += h42 * (5 * r9);
        c = d32 >>> 13;
        d32 &= 8191;
        d32 += h5 * (5 * r82);
        d32 += h62 * (5 * r7);
        d32 += h7 * (5 * r6);
        d32 += h8 * (5 * r5);
        d32 += h9 * (5 * r42);
        c += d32 >>> 13;
        d32 &= 8191;
        d42 = c;
        d42 += h0 * r42;
        d42 += h1 * r3;
        d42 += h2 * r22;
        d42 += h32 * r1;
        d42 += h42 * r0;
        c = d42 >>> 13;
        d42 &= 8191;
        d42 += h5 * (5 * r9);
        d42 += h62 * (5 * r82);
        d42 += h7 * (5 * r7);
        d42 += h8 * (5 * r6);
        d42 += h9 * (5 * r5);
        c += d42 >>> 13;
        d42 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r42;
        d5 += h2 * r3;
        d5 += h32 * r22;
        d5 += h42 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h62 * (5 * r9);
        d5 += h7 * (5 * r82);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r42;
        d6 += h32 * r3;
        d6 += h42 * r22;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h62 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r82);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h32 * r42;
        d7 += h42 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r22;
        d7 += h62 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r82);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r82;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h32 * r5;
        d8 += h42 * r42;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h62 * r22;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r82;
        d9 += h2 * r7;
        d9 += h32 * r6;
        d9 += h42 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r42;
        d9 += h62 * r3;
        d9 += h7 * r22;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h32 = d32;
        h42 = d42;
        h5 = d5;
        h62 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h32;
      this.h[4] = h42;
      this.h[5] = h5;
      this.h[6] = h62;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g5 = new Uint16Array(10);
      var c, mask, f2, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g5[0] = this.h[0] + 5;
      c = g5[0] >>> 13;
      g5[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g5[i] = this.h[i] + c;
        c = g5[i] >>> 13;
        g5[i] &= 8191;
      }
      g5[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++)
        g5[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g5[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f2 = this.h[0] + this.pad[0];
      this.h[0] = f2 & 65535;
      for (i = 1; i < 8; i++) {
        f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
        this.h[i] = f2 & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m2, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m2, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m2, mpos, n, k2) {
      var s = new poly1305(k2);
      s.update(m2, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n, k2) {
      var x2 = new Uint8Array(16);
      crypto_onetimeauth(x2, 0, m2, mpos, n, k2);
      return crypto_verify_16(h2, hpos, x2, 0);
    }
    function crypto_secretbox(c, m2, d2, n, k2) {
      var i;
      if (d2 < 32)
        return -1;
      crypto_stream_xor(c, 0, m2, 0, d2, n, k2);
      crypto_onetimeauth(c, 16, c, 32, d2 - 32, c);
      for (i = 0; i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m2, c, d2, n, k2) {
      var i;
      var x2 = new Uint8Array(32);
      if (d2 < 32)
        return -1;
      crypto_stream(x2, 0, 32, n, k2);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d2 - 32, x2) !== 0)
        return -1;
      crypto_stream_xor(m2, 0, c, 0, d2, n, k2);
      for (i = 0; i < 32; i++)
        m2[i] = 0;
      return 0;
    }
    function set25519(r3, a) {
      var i;
      for (i = 0; i < 16; i++)
        r3[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v2, c = 1;
      for (i = 0; i < 16; i++) {
        v2 = o[i] + c + 65535;
        c = Math.floor(v2 / 65536);
        o[i] = v2 - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p2, q2, b2) {
      var t, c = ~(b2 - 1);
      for (var i = 0; i < 16; i++) {
        t = c & (p2[i] ^ q2[i]);
        p2[i] ^= t;
        q2[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j2, b2;
      var m2 = gf2(), t = gf2();
      for (i = 0; i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j2 = 0; j2 < 2; j2++) {
        m2[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m2[i] = t[i] - 65535 - (m2[i - 1] >> 16 & 1);
          m2[i - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b2);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b2) {
      var c = new Uint8Array(32), d2 = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d2, b2);
      return crypto_verify_32(c, 0, d2, 0);
    }
    function par25519(a) {
      var d2 = new Uint8Array(32);
      pack25519(d2, a);
      return d2[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A2(o, a, b2) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] + b2[i];
    }
    function Z(o, a, b2) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] - b2[i];
    }
    function M(o, a, b2) {
      var v2, c, t0 = 0, t12 = 0, t2 = 0, t32 = 0, t42 = 0, t5 = 0, t6 = 0, t7 = 0, t82 = 0, t9 = 0, t10 = 0, t11 = 0, t122 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b32 = b2[3], b42 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a[0];
      t0 += v2 * b0;
      t12 += v2 * b1;
      t2 += v2 * b22;
      t32 += v2 * b32;
      t42 += v2 * b42;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t82 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t122 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a[1];
      t12 += v2 * b0;
      t2 += v2 * b1;
      t32 += v2 * b22;
      t42 += v2 * b32;
      t5 += v2 * b42;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t82 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t122 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a[2];
      t2 += v2 * b0;
      t32 += v2 * b1;
      t42 += v2 * b22;
      t5 += v2 * b32;
      t6 += v2 * b42;
      t7 += v2 * b5;
      t82 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t122 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a[3];
      t32 += v2 * b0;
      t42 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b32;
      t7 += v2 * b42;
      t82 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t122 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a[4];
      t42 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b32;
      t82 += v2 * b42;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t122 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t82 += v2 * b32;
      t9 += v2 * b42;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t122 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t82 += v2 * b22;
      t9 += v2 * b32;
      t10 += v2 * b42;
      t11 += v2 * b5;
      t122 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a[7];
      t7 += v2 * b0;
      t82 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b32;
      t11 += v2 * b42;
      t122 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a[8];
      t82 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b32;
      t122 += v2 * b42;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t122 += v2 * b32;
      t13 += v2 * b42;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t122 += v2 * b22;
      t13 += v2 * b32;
      t14 += v2 * b42;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a[11];
      t11 += v2 * b0;
      t122 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b32;
      t15 += v2 * b42;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a[12];
      t122 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b32;
      t16 += v2 * b42;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b32;
      t17 += v2 * b42;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b32;
      t18 += v2 * b42;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b32;
      t19 += v2 * b42;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t12 += 38 * t17;
      t2 += 38 * t18;
      t32 += 38 * t19;
      t42 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t82 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t122 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t32 + c + 65535;
      c = Math.floor(v2 / 65536);
      t32 = v2 - c * 65536;
      v2 = t42 + c + 65535;
      c = Math.floor(v2 / 65536);
      t42 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t82 + c + 65535;
      c = Math.floor(v2 / 65536);
      t82 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t122 + c + 65535;
      c = Math.floor(v2 / 65536);
      t122 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t32 + c + 65535;
      c = Math.floor(v2 / 65536);
      t32 = v2 - c * 65536;
      v2 = t42 + c + 65535;
      c = Math.floor(v2 / 65536);
      t42 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t82 + c + 65535;
      c = Math.floor(v2 / 65536);
      t82 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t122 + c + 65535;
      c = Math.floor(v2 / 65536);
      t122 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t12;
      o[2] = t2;
      o[3] = t32;
      o[4] = t42;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t82;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t122;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S2(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf2();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S2(c, c);
        if (a !== 2 && a !== 4)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf2();
      var a;
      for (a = 0; a < 16; a++)
        c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S2(c, c);
        if (a !== 1)
          M(c, c, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c[a];
    }
    function crypto_scalarmult(q2, n, p2) {
      var z2 = new Uint8Array(32);
      var x2 = new Float64Array(80), r3, i;
      var a = gf2(), b2 = gf2(), c = gf2(), d2 = gf2(), e = gf2(), f2 = gf2();
      for (i = 0; i < 31; i++)
        z2[i] = n[i];
      z2[31] = n[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x2, p2);
      for (i = 0; i < 16; i++) {
        b2[i] = x2[i];
        d2[i] = a[i] = c[i] = 0;
      }
      a[0] = d2[0] = 1;
      for (i = 254; i >= 0; --i) {
        r3 = z2[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b2, r3);
        sel25519(c, d2, r3);
        A2(e, a, c);
        Z(a, a, c);
        A2(c, b2, d2);
        Z(b2, b2, d2);
        S2(d2, e);
        S2(f2, a);
        M(a, c, a);
        M(c, b2, e);
        A2(e, a, c);
        Z(a, a, c);
        S2(b2, a);
        Z(c, d2, f2);
        M(a, c, _121665);
        A2(a, a, d2);
        M(c, c, a);
        M(a, d2, f2);
        M(d2, b2, x2);
        S2(b2, e);
        sel25519(a, b2, r3);
        sel25519(c, d2, r3);
      }
      for (i = 0; i < 16; i++) {
        x2[i + 16] = a[i];
        x2[i + 32] = c[i];
        x2[i + 48] = b2[i];
        x2[i + 64] = d2[i];
      }
      var x32 = x2.subarray(32);
      var x16 = x2.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y2, x2) {
      randombytes(x2, 32);
      return crypto_scalarmult_base(y2, x2);
    }
    function crypto_box_beforenm(k2, y2, x2) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x2, y2);
      return crypto_core_hsalsa20(k2, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m2, d2, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_afternm(c, m2, d2, n, k2);
    }
    function crypto_box_open(m2, c, d2, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_open_afternm(m2, c, d2, n, k2);
    }
    var K5 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh2, hl, m2, n) {
      var wh2 = new Int32Array(16), wl2 = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j2, h2, l, a, b2, c, d2;
      var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j2 = 8 * i + pos;
          wh2[i] = m2[j2 + 0] << 24 | m2[j2 + 1] << 16 | m2[j2 + 2] << 8 | m2[j2 + 3];
          wl2[i] = m2[j2 + 4] << 24 | m2[j2 + 5] << 16 | m2[j2 + 6] << 8 | m2[j2 + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l = al7;
          a = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = K5[i * 2];
          l = K5[i * 2 + 1];
          a += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = wh2[i % 16];
          l = wl2[i % 16];
          a += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c += b2 >>> 16;
          d2 += c >>> 16;
          th = c & 65535 | d2 << 16;
          tl = a & 65535 | b2 << 16;
          h2 = th;
          l = tl;
          a = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c += b2 >>> 16;
          d2 += c >>> 16;
          bh7 = c & 65535 | d2 << 16;
          bl7 = a & 65535 | b2 << 16;
          h2 = bh3;
          l = bl3;
          a = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = th;
          l = tl;
          a += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c += b2 >>> 16;
          d2 += c >>> 16;
          bh3 = c & 65535 | d2 << 16;
          bl3 = a & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j2 = 0; j2 < 16; j2++) {
              h2 = wh2[j2];
              l = wl2[j2];
              a = l & 65535;
              b2 = l >>> 16;
              c = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = wh2[(j2 + 9) % 16];
              l = wl2[(j2 + 9) % 16];
              a += l & 65535;
              b2 += l >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              th = wh2[(j2 + 1) % 16];
              tl = wl2[(j2 + 1) % 16];
              h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b2 += l >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              th = wh2[(j2 + 14) % 16];
              tl = wl2[(j2 + 14) % 16];
              h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b2 += l >>> 16;
              c += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a >>> 16;
              c += b2 >>> 16;
              d2 += c >>> 16;
              wh2[j2] = c & 65535 | d2 << 16;
              wl2[j2] = a & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l = al0;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[0];
        l = hl[0];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[0] = ah0 = c & 65535 | d2 << 16;
        hl[0] = al0 = a & 65535 | b2 << 16;
        h2 = ah1;
        l = al1;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[1];
        l = hl[1];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[1] = ah1 = c & 65535 | d2 << 16;
        hl[1] = al1 = a & 65535 | b2 << 16;
        h2 = ah2;
        l = al2;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[2];
        l = hl[2];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[2] = ah2 = c & 65535 | d2 << 16;
        hl[2] = al2 = a & 65535 | b2 << 16;
        h2 = ah3;
        l = al3;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[3];
        l = hl[3];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[3] = ah3 = c & 65535 | d2 << 16;
        hl[3] = al3 = a & 65535 | b2 << 16;
        h2 = ah4;
        l = al4;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[4];
        l = hl[4];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[4] = ah4 = c & 65535 | d2 << 16;
        hl[4] = al4 = a & 65535 | b2 << 16;
        h2 = ah5;
        l = al5;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[5];
        l = hl[5];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[5] = ah5 = c & 65535 | d2 << 16;
        hl[5] = al5 = a & 65535 | b2 << 16;
        h2 = ah6;
        l = al6;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[6];
        l = hl[6];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[6] = ah6 = c & 65535 | d2 << 16;
        hl[6] = al6 = a & 65535 | b2 << 16;
        h2 = ah7;
        l = al7;
        a = l & 65535;
        b2 = l >>> 16;
        c = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[7];
        l = hl[7];
        a += l & 65535;
        b2 += l >>> 16;
        c += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c += b2 >>> 16;
        d2 += c >>> 16;
        hh2[7] = ah7 = c & 65535 | d2 << 16;
        hl[7] = al7 = a & 65535 | b2 << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m2, n) {
      var hh2 = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i, b2 = n;
      hh2[0] = 1779033703;
      hh2[1] = 3144134277;
      hh2[2] = 1013904242;
      hh2[3] = 2773480762;
      hh2[4] = 1359893119;
      hh2[5] = 2600822924;
      hh2[6] = 528734635;
      hh2[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh2, hl, m2, n);
      n %= 128;
      for (i = 0; i < n; i++)
        x2[i] = m2[b2 - n + i];
      x2[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x2[n - 9] = 0;
      ts64(x2, n - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh2, hl, x2, n);
      for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh2[i], hl[i]);
      return 0;
    }
    function add2(p2, q2) {
      var a = gf2(), b2 = gf2(), c = gf2(), d2 = gf2(), e = gf2(), f2 = gf2(), g5 = gf2(), h2 = gf2(), t = gf2();
      Z(a, p2[1], p2[0]);
      Z(t, q2[1], q2[0]);
      M(a, a, t);
      A2(b2, p2[0], p2[1]);
      A2(t, q2[0], q2[1]);
      M(b2, b2, t);
      M(c, p2[3], q2[3]);
      M(c, c, D22);
      M(d2, p2[2], q2[2]);
      A2(d2, d2, d2);
      Z(e, b2, a);
      Z(f2, d2, c);
      A2(g5, d2, c);
      A2(h2, b2, a);
      M(p2[0], e, f2);
      M(p2[1], h2, g5);
      M(p2[2], g5, f2);
      M(p2[3], e, h2);
    }
    function cswap(p2, q2, b2) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p2[i], q2[i], b2);
      }
    }
    function pack(r3, p2) {
      var tx2 = gf2(), ty = gf2(), zi = gf2();
      inv25519(zi, p2[2]);
      M(tx2, p2[0], zi);
      M(ty, p2[1], zi);
      pack25519(r3, ty);
      r3[31] ^= par25519(tx2) << 7;
    }
    function scalarmult(p2, q2, s) {
      var b2, i;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i = 255; i >= 0; --i) {
        b2 = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p2, q2, b2);
        add2(q2, p2);
        add2(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s) {
      var q2 = [gf2(), gf2(), gf2(), gf2()];
      set25519(q2[0], X2);
      set25519(q2[1], Y);
      set25519(q2[2], gf1);
      M(q2[3], X2, Y);
      scalarmult(p2, q2, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d2, sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk, p2);
      for (i = 0; i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r3, x2) {
      var carry, i, j2, k2;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j2 = i - 32, k2 = i - 12; j2 < k2; ++j2) {
          x2[j2] += carry - 16 * x2[i] * L2[j2 - (i - 32)];
          carry = Math.floor((x2[j2] + 128) / 256);
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; j2++) {
        x2[j2] += carry - (x2[31] >> 4) * L2[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; j2++)
        x2[j2] -= carry * L2[j2];
      for (i = 0; i < 32; i++) {
        x2[i + 1] += x2[i] >> 8;
        r3[i] = x2[i] & 255;
      }
    }
    function reduce(r3) {
      var x2 = new Float64Array(64), i;
      for (i = 0; i < 64; i++)
        x2[i] = r3[i];
      for (i = 0; i < 64; i++)
        r3[i] = 0;
      modL(r3, x2);
    }
    function crypto_sign(sm, m2, n, sk) {
      var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r3 = new Uint8Array(64);
      var i, j2, x2 = new Float64Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      crypto_hash(d2, sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++)
        sm[64 + i] = m2[i];
      for (i = 0; i < 32; i++)
        sm[32 + i] = d2[32 + i];
      crypto_hash(r3, sm.subarray(32), n + 32);
      reduce(r3);
      scalarbase(p2, r3);
      pack(sm, p2);
      for (i = 32; i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h2, sm, n + 64);
      reduce(h2);
      for (i = 0; i < 64; i++)
        x2[i] = 0;
      for (i = 0; i < 32; i++)
        x2[i] = r3[i];
      for (i = 0; i < 32; i++) {
        for (j2 = 0; j2 < 32; j2++) {
          x2[i + j2] += h2[i] * d2[j2];
        }
      }
      modL(sm.subarray(32), x2);
      return smlen;
    }
    function unpackneg(r3, p2) {
      var t = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r3[2], gf1);
      unpack25519(r3[1], p2);
      S2(num, r3[1]);
      M(den, num, D2);
      Z(num, num, r3[2]);
      A2(den, r3[2], den);
      S2(den2, den);
      S2(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r3[0], t, den);
      S2(chk, r3[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r3[0], r3[0], I);
      S2(chk, r3[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r3[0]) === p2[31] >> 7)
        Z(r3[0], gf0, r3[0]);
      M(r3[3], r3[0], r3[1]);
      return 0;
    }
    function crypto_sign_open(m2, sm, n, pk) {
      var i;
      var t = new Uint8Array(32), h2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()], q2 = [gf2(), gf2(), gf2(), gf2()];
      if (n < 64)
        return -1;
      if (unpackneg(q2, pk))
        return -1;
      for (i = 0; i < n; i++)
        m2[i] = sm[i];
      for (i = 0; i < 32; i++)
        m2[i + 32] = pk[i];
      crypto_hash(h2, m2, n);
      reduce(h2);
      scalarmult(p2, q2, h2);
      scalarbase(q2, sm.subarray(32));
      add2(p2, q2);
      pack(t, p2);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++)
          m2[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++)
        m2[i] = sm[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl2.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf: gf2,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M,
      A: A2,
      S: S2,
      Z,
      pow2523,
      add: add2,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++)
        arr[i] = 0;
    }
    nacl2.randomBytes = function(n) {
      var b2 = new Uint8Array(n);
      randombytes(b2, n);
      return b2;
    };
    nacl2.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m2.length);
      for (var i = 0; i < msg.length; i++)
        m2[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m2, m2.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl2.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m2 = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32)
        return null;
      if (crypto_secretbox_open(m2, c, c.length, nonce, key) !== 0)
        return null;
      return m2.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl2.scalarMult = function(n, p2) {
      checkArrayTypes(n, p2);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p2.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p2);
      return q2;
    };
    nacl2.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl2.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl2.box.before(publicKey, secretKey);
      return nacl2.secretbox(msg, nonce, k2);
    };
    nacl2.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl2.box.after = nacl2.secretbox;
    nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl2.box.before(publicKey, secretKey);
      return nacl2.secretbox.open(msg, nonce, k2);
    };
    nacl2.box.open.after = nacl2.secretbox.open;
    nacl2.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl2.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl2.box.nonceLength = crypto_box_NONCEBYTES;
    nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
    nacl2.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl2.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m2 = new Uint8Array(mlen);
      for (var i = 0; i < m2.length; i++)
        m2[i] = tmp[i];
      return m2;
    };
    nacl2.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl2.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl2.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0; i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
    };
    nacl2.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl2.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl2.sign.signatureLength = crypto_sign_BYTES;
    nacl2.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl2.hash.hashLength = crypto_hash_BYTES;
    nacl2.verify = function(x2, y2) {
      checkArrayTypes(x2, y2);
      if (x2.length === 0 || y2.length === 0)
        return false;
      if (x2.length !== y2.length)
        return false;
      return vn2(x2, 0, y2, 0, x2.length) === 0 ? true : false;
    };
    nacl2.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl2.setPRNG(function(x2, n) {
          var i, v2 = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto2.getRandomValues(v2.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++)
            x2[i] = v2[i];
          cleanup(v2);
        });
      } else if (typeof commonjsRequire !== "undefined") {
        crypto2 = require$$0;
        if (crypto2 && crypto2.randomBytes) {
          nacl2.setPRNG(function(x2, n) {
            var i, v2 = crypto2.randomBytes(n);
            for (i = 0; i < n; i++)
              x2[i] = v2[i];
            cleanup(v2);
          });
        }
      }
    })();
  })(module.exports ? module.exports : self.nacl = self.nacl || {});
})(naclFast);
const nacl = naclFastExports;
var sha512Exports = {};
var sha512$1 = {
  get exports() {
    return sha512Exports;
  },
  set exports(v2) {
    sha512Exports = v2;
  }
};
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA512_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K5 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, bits) {
      return function(message) {
        return new Sha512(bits, true).update(message)[outputType]();
      };
    };
    var createMethod = function(bits) {
      var method = createOutputMethod("hex", bits);
      method.create = function() {
        return new Sha512(bits);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type, bits);
      }
      return method;
    };
    var createHmacOutputMethod = function(outputType, bits) {
      return function(key, message) {
        return new HmacSha512(key, bits, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(bits) {
      var method = createHmacOutputMethod("hex", bits);
      method.create = function(key) {
        return new HmacSha512(key, bits);
      };
      method.update = function(key, message) {
        return method.create(key).update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createHmacOutputMethod(type, bits);
      }
      return method;
    };
    function Sha512(bits, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (bits == 384) {
        this.h0h = 3418070365;
        this.h0l = 3238371032;
        this.h1h = 1654270250;
        this.h1l = 914150663;
        this.h2h = 2438529370;
        this.h2l = 812702999;
        this.h3h = 355462360;
        this.h3l = 4144912697;
        this.h4h = 1731405415;
        this.h4l = 4290775857;
        this.h5h = 2394180231;
        this.h5l = 1750603025;
        this.h6h = 3675008525;
        this.h6l = 1694076839;
        this.h7h = 1203062813;
        this.h7l = 3204075428;
      } else if (bits == 256) {
        this.h0h = 573645204;
        this.h0l = 4230739756;
        this.h1h = 2673172387;
        this.h1l = 3360449730;
        this.h2h = 596883563;
        this.h2l = 1867755857;
        this.h3h = 2520282905;
        this.h3l = 1497426621;
        this.h4h = 2519219938;
        this.h4l = 2827943907;
        this.h5h = 3193839141;
        this.h5l = 1401305490;
        this.h6h = 721525244;
        this.h6l = 746961066;
        this.h7h = 246885852;
        this.h7l = 2177182882;
      } else if (bits == 224) {
        this.h0h = 2352822216;
        this.h0l = 424955298;
        this.h1h = 1944164710;
        this.h1l = 2312950998;
        this.h2h = 502970286;
        this.h2l = 855612546;
        this.h3h = 1738396948;
        this.h3l = 1479516111;
        this.h4h = 258812777;
        this.h4l = 2077511080;
        this.h5h = 2011393907;
        this.h5l = 79989058;
        this.h6h = 1067287976;
        this.h6l = 1780299464;
        this.h7h = 286451373;
        this.h7l = 2446758561;
      } else {
        this.h0h = 1779033703;
        this.h0l = 4089235720;
        this.h1h = 3144134277;
        this.h1l = 2227873595;
        this.h2h = 1013904242;
        this.h2l = 4271175723;
        this.h3h = 2773480762;
        this.h3l = 1595750129;
        this.h4h = 1359893119;
        this.h4l = 2917565137;
        this.h5h = 2600822924;
        this.h5l = 725511199;
        this.h6h = 528734635;
        this.h6l = 4215389547;
        this.h7h = 1541459225;
        this.h7l = 327033209;
      }
      this.bits = bits;
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
    }
    Sha512.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var code2, index2 = 0, i, length = message.length, blocks2 = this.blocks;
      while (index2 < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        if (notString) {
          for (i = this.start; index2 < length && i < 128; ++index2) {
            blocks2[i >> 2] |= message[index2] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start; index2 < length && i < 128; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks2[i >> 2] |= code2 << SHIFT[i++ & 3];
            } else if (code2 < 2048) {
              blocks2[i >> 2] |= (192 | code2 >> 6) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks2[i >> 2] |= (224 | code2 >> 12) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i >> 2] |= (240 | code2 >> 18) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 128) {
          this.block = blocks2[32];
          this.start = i - 128;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha512.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i = this.lastByteIndex;
      blocks2[32] = this.block;
      blocks2[i >> 2] |= EXTRA[i & 3];
      this.block = blocks2[32];
      if (i >= 112) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
      }
      blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[31] = this.bytes << 3;
      this.hash();
    };
    Sha512.prototype.hash = function() {
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j2, s0h, s0l, s1h, s1l, c1, c2, c3, c42, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
      for (j2 = 32; j2 < 160; j2 += 2) {
        t1h = blocks2[j2 - 30];
        t1l = blocks2[j2 - 29];
        s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
        s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
        t1h = blocks2[j2 - 4];
        t1l = blocks2[j2 - 3];
        s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
        s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
        t1h = blocks2[j2 - 32];
        t1l = blocks2[j2 - 31];
        t2h = blocks2[j2 - 14];
        t2l = blocks2[j2 - 13];
        c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
        blocks2[j2] = c42 << 16 | c3 & 65535;
        blocks2[j2 + 1] = c2 << 16 | c1 & 65535;
      }
      var ah2 = h0h, al = h0l, bh2 = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh2 = h6h, gl2 = h6l, hh2 = h7h, hl = h7l;
      bch = bh2 & ch;
      bcl = bl & cl;
      for (j2 = 0; j2 < 160; j2 += 8) {
        s0h = (ah2 >>> 28 | al << 4) ^ (al >>> 2 | ah2 << 30) ^ (al >>> 7 | ah2 << 25);
        s0l = (al >>> 28 | ah2 << 4) ^ (ah2 >>> 2 | al << 30) ^ (ah2 >>> 7 | al << 25);
        s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
        s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
        abh = ah2 & bh2;
        abl = al & bl;
        majh = abh ^ ah2 & ch ^ bch;
        majl = abl ^ al & cl ^ bcl;
        chh = eh & fh ^ ~eh & gh2;
        chl = el & fl ^ ~el & gl2;
        t1h = blocks2[j2];
        t1l = blocks2[j2 + 1];
        t2h = K5[j2];
        t2l = K5[j2 + 1];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh2 & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh2 >>> 16) + (c3 >>> 16);
        t1h = c42 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c42 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (dl & 65535) + (t1l & 65535);
        c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        hh2 = c42 << 16 | c3 & 65535;
        hl = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        dh = c42 << 16 | c3 & 65535;
        dl = c2 << 16 | c1 & 65535;
        s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
        s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
        s1h = (hh2 >>> 14 | hl << 18) ^ (hh2 >>> 18 | hl << 14) ^ (hl >>> 9 | hh2 << 23);
        s1l = (hl >>> 14 | hh2 << 18) ^ (hl >>> 18 | hh2 << 14) ^ (hh2 >>> 9 | hl << 23);
        dah = dh & ah2;
        dal = dl & al;
        majh = dah ^ dh & bh2 ^ abh;
        majl = dal ^ dl & bl ^ abl;
        chh = hh2 & eh ^ ~hh2 & fh;
        chl = hl & el ^ ~hl & fl;
        t1h = blocks2[j2 + 2];
        t1l = blocks2[j2 + 3];
        t2h = K5[j2 + 2];
        t2l = K5[j2 + 3];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl2 & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl2 >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh2 & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh2 >>> 16) + (c3 >>> 16);
        t1h = c42 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c42 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (cl & 65535) + (t1l & 65535);
        c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        gh2 = c42 << 16 | c3 & 65535;
        gl2 = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        ch = c42 << 16 | c3 & 65535;
        cl = c2 << 16 | c1 & 65535;
        s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
        s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
        s1h = (gh2 >>> 14 | gl2 << 18) ^ (gh2 >>> 18 | gl2 << 14) ^ (gl2 >>> 9 | gh2 << 23);
        s1l = (gl2 >>> 14 | gh2 << 18) ^ (gl2 >>> 18 | gh2 << 14) ^ (gh2 >>> 9 | gl2 << 23);
        cdh = ch & dh;
        cdl = cl & dl;
        majh = cdh ^ ch & ah2 ^ dah;
        majl = cdl ^ cl & al ^ dal;
        chh = gh2 & hh2 ^ ~gh2 & eh;
        chl = gl2 & hl ^ ~gl2 & el;
        t1h = blocks2[j2 + 4];
        t1l = blocks2[j2 + 5];
        t2h = K5[j2 + 4];
        t2l = K5[j2 + 5];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        t1h = c42 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c42 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (bl & 65535) + (t1l & 65535);
        c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (bh2 & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (bh2 >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        fh = c42 << 16 | c3 & 65535;
        fl = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        bh2 = c42 << 16 | c3 & 65535;
        bl = c2 << 16 | c1 & 65535;
        s0h = (bh2 >>> 28 | bl << 4) ^ (bl >>> 2 | bh2 << 30) ^ (bl >>> 7 | bh2 << 25);
        s0l = (bl >>> 28 | bh2 << 4) ^ (bh2 >>> 2 | bl << 30) ^ (bh2 >>> 7 | bl << 25);
        s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
        s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
        bch = bh2 & ch;
        bcl = bl & cl;
        majh = bch ^ bh2 & dh ^ cdh;
        majl = bcl ^ bl & dl ^ cdl;
        chh = fh & gh2 ^ ~fh & hh2;
        chl = fl & gl2 ^ ~fl & hl;
        t1h = blocks2[j2 + 6];
        t1l = blocks2[j2 + 7];
        t2h = K5[j2 + 6];
        t2l = K5[j2 + 7];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        t1h = c42 << 16 | c3 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
        t2h = c42 << 16 | c3 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (al & 65535) + (t1l & 65535);
        c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (ah2 & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (ah2 >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        eh = c42 << 16 | c3 & 65535;
        el = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
        ah2 = c42 << 16 | c3 & 65535;
        al = c2 << 16 | c1 & 65535;
      }
      c1 = (h0l & 65535) + (al & 65535);
      c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
      c3 = (h0h & 65535) + (ah2 & 65535) + (c2 >>> 16);
      c42 = (h0h >>> 16) + (ah2 >>> 16) + (c3 >>> 16);
      this.h0h = c42 << 16 | c3 & 65535;
      this.h0l = c2 << 16 | c1 & 65535;
      c1 = (h1l & 65535) + (bl & 65535);
      c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
      c3 = (h1h & 65535) + (bh2 & 65535) + (c2 >>> 16);
      c42 = (h1h >>> 16) + (bh2 >>> 16) + (c3 >>> 16);
      this.h1h = c42 << 16 | c3 & 65535;
      this.h1l = c2 << 16 | c1 & 65535;
      c1 = (h2l & 65535) + (cl & 65535);
      c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
      c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
      c42 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
      this.h2h = c42 << 16 | c3 & 65535;
      this.h2l = c2 << 16 | c1 & 65535;
      c1 = (h3l & 65535) + (dl & 65535);
      c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
      c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
      c42 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
      this.h3h = c42 << 16 | c3 & 65535;
      this.h3l = c2 << 16 | c1 & 65535;
      c1 = (h4l & 65535) + (el & 65535);
      c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
      c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
      c42 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
      this.h4h = c42 << 16 | c3 & 65535;
      this.h4l = c2 << 16 | c1 & 65535;
      c1 = (h5l & 65535) + (fl & 65535);
      c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
      c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
      c42 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
      this.h5h = c42 << 16 | c3 & 65535;
      this.h5l = c2 << 16 | c1 & 65535;
      c1 = (h6l & 65535) + (gl2 & 65535);
      c2 = (h6l >>> 16) + (gl2 >>> 16) + (c1 >>> 16);
      c3 = (h6h & 65535) + (gh2 & 65535) + (c2 >>> 16);
      c42 = (h6h >>> 16) + (gh2 >>> 16) + (c3 >>> 16);
      this.h6h = c42 << 16 | c3 & 65535;
      this.h6l = c2 << 16 | c1 & 65535;
      c1 = (h7l & 65535) + (hl & 65535);
      c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
      c3 = (h7h & 65535) + (hh2 & 65535) + (c2 >>> 16);
      c42 = (h7h >>> 16) + (hh2 >>> 16) + (c3 >>> 16);
      this.h7h = c42 << 16 | c3 & 65535;
      this.h7l = c2 << 16 | c1 & 65535;
    };
    Sha512.prototype.hex = function() {
      this.finalize();
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
      var hex = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
      if (bits >= 256) {
        hex += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
      }
      if (bits >= 384) {
        hex += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
      }
      if (bits == 512) {
        hex += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
      }
      return hex;
    };
    Sha512.prototype.toString = Sha512.prototype.hex;
    Sha512.prototype.digest = function() {
      this.finalize();
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
      var arr = [
        h0h >> 24 & 255,
        h0h >> 16 & 255,
        h0h >> 8 & 255,
        h0h & 255,
        h0l >> 24 & 255,
        h0l >> 16 & 255,
        h0l >> 8 & 255,
        h0l & 255,
        h1h >> 24 & 255,
        h1h >> 16 & 255,
        h1h >> 8 & 255,
        h1h & 255,
        h1l >> 24 & 255,
        h1l >> 16 & 255,
        h1l >> 8 & 255,
        h1l & 255,
        h2h >> 24 & 255,
        h2h >> 16 & 255,
        h2h >> 8 & 255,
        h2h & 255,
        h2l >> 24 & 255,
        h2l >> 16 & 255,
        h2l >> 8 & 255,
        h2l & 255,
        h3h >> 24 & 255,
        h3h >> 16 & 255,
        h3h >> 8 & 255,
        h3h & 255
      ];
      if (bits >= 256) {
        arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
      }
      if (bits >= 384) {
        arr.push(
          h4h >> 24 & 255,
          h4h >> 16 & 255,
          h4h >> 8 & 255,
          h4h & 255,
          h4l >> 24 & 255,
          h4l >> 16 & 255,
          h4l >> 8 & 255,
          h4l & 255,
          h5h >> 24 & 255,
          h5h >> 16 & 255,
          h5h >> 8 & 255,
          h5h & 255,
          h5l >> 24 & 255,
          h5l >> 16 & 255,
          h5l >> 8 & 255,
          h5l & 255
        );
      }
      if (bits == 512) {
        arr.push(
          h6h >> 24 & 255,
          h6h >> 16 & 255,
          h6h >> 8 & 255,
          h6h & 255,
          h6l >> 24 & 255,
          h6l >> 16 & 255,
          h6l >> 8 & 255,
          h6l & 255,
          h7h >> 24 & 255,
          h7h >> 16 & 255,
          h7h >> 8 & 255,
          h7h & 255,
          h7l >> 24 & 255,
          h7l >> 16 & 255,
          h7l >> 8 & 255,
          h7l & 255
        );
      }
      return arr;
    };
    Sha512.prototype.array = Sha512.prototype.digest;
    Sha512.prototype.arrayBuffer = function() {
      this.finalize();
      var bits = this.bits;
      var buffer2 = new ArrayBuffer(bits / 8);
      var dataView = new DataView(buffer2);
      dataView.setUint32(0, this.h0h);
      dataView.setUint32(4, this.h0l);
      dataView.setUint32(8, this.h1h);
      dataView.setUint32(12, this.h1l);
      dataView.setUint32(16, this.h2h);
      dataView.setUint32(20, this.h2l);
      dataView.setUint32(24, this.h3h);
      if (bits >= 256) {
        dataView.setUint32(28, this.h3l);
      }
      if (bits >= 384) {
        dataView.setUint32(32, this.h4h);
        dataView.setUint32(36, this.h4l);
        dataView.setUint32(40, this.h5h);
        dataView.setUint32(44, this.h5l);
      }
      if (bits == 512) {
        dataView.setUint32(48, this.h6h);
        dataView.setUint32(52, this.h6l);
        dataView.setUint32(56, this.h7h);
        dataView.setUint32(60, this.h7l);
      }
      return buffer2;
    };
    Sha512.prototype.clone = function() {
      var hash = new Sha512(this.bits, false);
      this.copyTo(hash);
      return hash;
    };
    Sha512.prototype.copyTo = function(hash) {
      var i = 0, attrs = [
        "h0h",
        "h0l",
        "h1h",
        "h1l",
        "h2h",
        "h2l",
        "h3h",
        "h3l",
        "h4h",
        "h4l",
        "h5h",
        "h5l",
        "h6h",
        "h6l",
        "h7h",
        "h7l",
        "start",
        "bytes",
        "hBytes",
        "finalized",
        "hashed",
        "lastByteIndex"
      ];
      for (i = 0; i < attrs.length; ++i) {
        hash[attrs[i]] = this[attrs[i]];
      }
      for (i = 0; i < this.blocks.length; ++i) {
        hash.blocks[i] = this.blocks[i];
      }
    };
    function HmacSha512(key, bits, sharedMemory) {
      var notString, type = typeof key;
      if (type !== "string") {
        if (type === "object") {
          if (key === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
            key = new Uint8Array(key);
          } else if (!Array.isArray(key)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var length = key.length;
      if (!notString) {
        var bytes = [], length = key.length, index2 = 0, code2;
        for (var i = 0; i < length; ++i) {
          code2 = key.charCodeAt(i);
          if (code2 < 128) {
            bytes[index2++] = code2;
          } else if (code2 < 2048) {
            bytes[index2++] = 192 | code2 >> 6;
            bytes[index2++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes[index2++] = 224 | code2 >> 12;
            bytes[index2++] = 128 | code2 >> 6 & 63;
            bytes[index2++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i) & 1023);
            bytes[index2++] = 240 | code2 >> 18;
            bytes[index2++] = 128 | code2 >> 12 & 63;
            bytes[index2++] = 128 | code2 >> 6 & 63;
            bytes[index2++] = 128 | code2 & 63;
          }
        }
        key = bytes;
      }
      if (key.length > 128) {
        key = new Sha512(bits, true).update(key).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (var i = 0; i < 128; ++i) {
        var b2 = key[i] || 0;
        oKeyPad[i] = 92 ^ b2;
        iKeyPad[i] = 54 ^ b2;
      }
      Sha512.call(this, bits, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha512.prototype = new Sha512();
    HmacSha512.prototype.finalize = function() {
      Sha512.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha512.call(this, this.bits, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha512.prototype.finalize.call(this);
      }
    };
    HmacSha512.prototype.clone = function() {
      var hash = new HmacSha512([], this.bits, false);
      this.copyTo(hash);
      hash.inner = this.inner;
      for (var i = 0; i < this.oKeyPad.length; ++i) {
        hash.oKeyPad[i] = this.oKeyPad[i];
      }
      return hash;
    };
    var exports = createMethod(512);
    exports.sha512 = exports;
    exports.sha384 = createMethod(384);
    exports.sha512_256 = createMethod(256);
    exports.sha512_224 = createMethod(224);
    exports.sha512.hmac = createHmacMethod(512);
    exports.sha384.hmac = createHmacMethod(384);
    exports.sha512_256.hmac = createHmacMethod(256);
    exports.sha512_224.hmac = createHmacMethod(224);
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.sha512 = exports.sha512;
      root.sha384 = exports.sha384;
      root.sha512_256 = exports.sha512_256;
      root.sha512_224 = exports.sha512_224;
    }
  })();
})(sha512$1);
const sha512 = sha512Exports;
function genericHash(arr) {
  return sha512.sha512_256.array(arr);
}
function randomBytes(length) {
  return nacl.randomBytes(length);
}
function keyPairFromSeed(seed) {
  return nacl.sign.keyPair.fromSeed(seed);
}
function keyPair() {
  const seed = randomBytes(nacl.box.secretKeyLength);
  return keyPairFromSeed(seed);
}
function isValidSignatureLength(len) {
  return len === nacl.sign.signatureLength;
}
function keyPairFromSecretKey(sk) {
  return nacl.sign.keyPair.fromSecretKey(sk);
}
function sign(msg, secretKey) {
  return nacl.sign.detached(msg, secretKey);
}
function bytesEqual(a, b2) {
  return nacl.verify(a, b2);
}
function verify(message, signature, verifyKey) {
  return nacl.sign.detached.verify(message, signature, verifyKey);
}
const PUBLIC_KEY_LENGTH = nacl.sign.publicKeyLength;
nacl.sign.secretKeyLength;
const HASH_BYTES_LENGTH = 32;
const SEED_BTYES_LENGTH = 32;
var base32Exports = {};
var base32 = {
  get exports() {
    return base32Exports;
  },
  set exports(v2) {
    base32Exports = v2;
  }
};
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var root = typeof window === "object" ? window : {};
    var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    }
    var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && true && module.exports;
    var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
    var BASE32_DECODE_CHAR = {
      "A": 0,
      "B": 1,
      "C": 2,
      "D": 3,
      "E": 4,
      "F": 5,
      "G": 6,
      "H": 7,
      "I": 8,
      "J": 9,
      "K": 10,
      "L": 11,
      "M": 12,
      "N": 13,
      "O": 14,
      "P": 15,
      "Q": 16,
      "R": 17,
      "S": 18,
      "T": 19,
      "U": 20,
      "V": 21,
      "W": 22,
      "X": 23,
      "Y": 24,
      "Z": 25,
      "2": 26,
      "3": 27,
      "4": 28,
      "5": 29,
      "6": 30,
      "7": 31
    };
    var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
    var throwInvalidUtf8 = function(position, partial) {
      if (partial.length > 10) {
        partial = "..." + partial.substr(-10);
      }
      var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
      err.position = position;
      throw err;
    };
    var toUtf8String = function(bytes) {
      var str = "", length = bytes.length, i = 0, followingChars = 0, b2, c;
      while (i < length) {
        b2 = bytes[i++];
        if (b2 <= 127) {
          str += String.fromCharCode(b2);
          continue;
        } else if (b2 > 191 && b2 <= 223) {
          c = b2 & 31;
          followingChars = 1;
        } else if (b2 <= 239) {
          c = b2 & 15;
          followingChars = 2;
        } else if (b2 <= 247) {
          c = b2 & 7;
          followingChars = 3;
        } else {
          throwInvalidUtf8(i, str);
        }
        for (var j2 = 0; j2 < followingChars; ++j2) {
          b2 = bytes[i++];
          if (b2 < 128 || b2 > 191) {
            throwInvalidUtf8(i, str);
          }
          c <<= 6;
          c += b2 & 63;
        }
        if (c >= 55296 && c <= 57343) {
          throwInvalidUtf8(i, str);
        }
        if (c > 1114111) {
          throwInvalidUtf8(i, str);
        }
        if (c <= 65535) {
          str += String.fromCharCode(c);
        } else {
          c -= 65536;
          str += String.fromCharCode((c >> 10) + 55296);
          str += String.fromCharCode((c & 1023) + 56320);
        }
      }
      return str;
    };
    var decodeAsBytes = function(base32Str) {
      if (base32Str === "") {
        return [];
      } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
        throw new Error("Invalid base32 characters");
      }
      base32Str = base32Str.replace(/=/g, "");
      var v1, v2, v32, v42, v5, v6, v7, v8, bytes = [], index2 = 0, length = base32Str.length;
      for (var i = 0, count = length >> 3 << 3; i < count; ) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
        bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
        bytes[index2++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
        bytes[index2++] = (v7 << 5 | v8) & 255;
      }
      var remain = length - count;
      if (remain === 2) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
      } else if (remain === 4) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
      } else if (remain === 5) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
        bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
      } else if (remain === 7) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v1 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
        bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
        bytes[index2++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
      }
      return bytes;
    };
    var encodeAscii = function(str) {
      var v1, v2, v32, v42, v5, base32Str = "", length = str.length;
      for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v32 = str.charCodeAt(i++);
        v42 = str.charCodeAt(i++);
        v5 = str.charCodeAt(i++);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
      }
      var remain = length - count;
      if (remain === 1) {
        v1 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
      } else if (remain === 2) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
      } else if (remain === 3) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v32 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
      } else if (remain === 4) {
        v1 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v32 = str.charCodeAt(i++);
        v42 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
      }
      return base32Str;
    };
    var encodeUtf8 = function(str) {
      var v1, v2, v32, v42, v5, code2, end = false, base32Str = "", index2 = 0, i, start = 0, length = str.length;
      if (str === "") {
        return base32Str;
      }
      do {
        blocks[0] = blocks[5];
        blocks[1] = blocks[6];
        blocks[2] = blocks[7];
        for (i = start; index2 < length && i < 5; ++index2) {
          code2 = str.charCodeAt(index2);
          if (code2 < 128) {
            blocks[i++] = code2;
          } else if (code2 < 2048) {
            blocks[i++] = 192 | code2 >> 6;
            blocks[i++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            blocks[i++] = 224 | code2 >> 12;
            blocks[i++] = 128 | code2 >> 6 & 63;
            blocks[i++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++index2) & 1023);
            blocks[i++] = 240 | code2 >> 18;
            blocks[i++] = 128 | code2 >> 12 & 63;
            blocks[i++] = 128 | code2 >> 6 & 63;
            blocks[i++] = 128 | code2 & 63;
          }
        }
        start = i - 5;
        if (index2 === length) {
          ++index2;
        }
        if (index2 > length && i < 6) {
          end = true;
        }
        v1 = blocks[0];
        if (i > 4) {
          v2 = blocks[1];
          v32 = blocks[2];
          v42 = blocks[3];
          v5 = blocks[4];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        } else if (i === 1) {
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (i === 2) {
          v2 = blocks[1];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (i === 3) {
          v2 = blocks[1];
          v32 = blocks[2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
        } else {
          v2 = blocks[1];
          v32 = blocks[2];
          v42 = blocks[3];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
      } while (!end);
      return base32Str;
    };
    var encodeBytes = function(bytes) {
      var v1, v2, v32, v42, v5, base32Str = "", length = bytes.length;
      for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v32 = bytes[i++];
        v42 = bytes[i++];
        v5 = bytes[i++];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
      }
      var remain = length - count;
      if (remain === 1) {
        v1 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
      } else if (remain === 2) {
        v1 = bytes[i++];
        v2 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
      } else if (remain === 3) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v32 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
      } else if (remain === 4) {
        v1 = bytes[i++];
        v2 = bytes[i++];
        v32 = bytes[i++];
        v42 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
      }
      return base32Str;
    };
    var encode2 = function(input, asciiOnly) {
      var notString = typeof input !== "string";
      if (notString && input.constructor === ArrayBuffer) {
        input = new Uint8Array(input);
      }
      if (notString) {
        return encodeBytes(input);
      } else if (asciiOnly) {
        return encodeAscii(input);
      } else {
        return encodeUtf8(input);
      }
    };
    var decode2 = function(base32Str, asciiOnly) {
      if (!asciiOnly) {
        return toUtf8String(decodeAsBytes(base32Str));
      }
      if (base32Str === "") {
        return "";
      } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
        throw new Error("Invalid base32 characters");
      }
      var v1, v2, v32, v42, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
      if (length === -1) {
        length = base32Str.length;
      }
      for (var i = 0, count = length >> 3 << 3; i < count; ) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
      }
      var remain = length - count;
      if (remain === 2) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
      } else if (remain === 4) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255);
      } else if (remain === 5) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255);
      } else if (remain === 7) {
        v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
      }
      return str;
    };
    var exports = {
      encode: encode2,
      decode: decode2
    };
    decode2.asBytes = decodeAsBytes;
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.base32 = exports;
    }
  })();
})(base32);
var jsonBigintExports = {};
var jsonBigint = {
  get exports() {
    return jsonBigintExports;
  },
  set exports(v2) {
    jsonBigintExports = v2;
  }
};
var stringifyExports = {};
var stringify = {
  get exports() {
    return stringifyExports;
  },
  set exports(v2) {
    stringifyExports = v2;
  }
};
var bignumberExports = {};
var bignumber = {
  get exports() {
    return bignumberExports;
  },
  set exports(v2) {
    bignumberExports = v2;
  }
};
(function(module) {
  (function(globalObject) {
    var BigNumber2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P5 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber3(v2, b2) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x2 = this;
        if (!(x2 instanceof BigNumber3))
          return new BigNumber3(v2, b2);
        if (b2 == null) {
          if (v2 && v2._isBigNumber === true) {
            x2.s = v2.s;
            if (!v2.c || v2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (v2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = v2.e;
              x2.c = v2.c.slice();
            }
            return;
          }
          if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
            x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
            if (v2 === ~~v2) {
              for (e = 0, i = v2; i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x2.c = x2.e = null;
              } else {
                x2.e = e;
                x2.c = [v2];
              }
              return;
            }
            str = String(v2);
          } else {
            if (!isNumeric.test(str = String(v2)))
              return parseNumeric(x2, str, isNum);
            x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b2, 2, ALPHABET.length, "Base");
          if (b2 == 10 && alphabetHasNormalDecimalDigits) {
            x2 = new BigNumber3(v2);
            return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
          }
          str = String(v2);
          if (isNum = typeof v2 == "number") {
            if (v2 * 0 != 0)
              return parseNumeric(x2, str, isNum, b2);
            x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v2);
            }
          } else {
            x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b2);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x2, String(v2), isNum, b2);
            }
          }
          isNum = false;
          str = convertBase(str, b2, 10, x2.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber3.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
            throw Error(tooManyDigits + x2.s * v2);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (e < MIN_EXP) {
            x2.c = [x2.e = 0];
          } else {
            x2.e = e;
            x2.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x2.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x2.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0")
              ;
            x2.c.push(+str);
          }
        } else {
          x2.c = [x2.e = 0];
        }
      }
      BigNumber3.clone = clone;
      BigNumber3.ROUND_UP = 0;
      BigNumber3.ROUND_DOWN = 1;
      BigNumber3.ROUND_CEIL = 2;
      BigNumber3.ROUND_FLOOR = 3;
      BigNumber3.ROUND_HALF_UP = 4;
      BigNumber3.ROUND_HALF_DOWN = 5;
      BigNumber3.ROUND_HALF_EVEN = 6;
      BigNumber3.ROUND_HALF_CEIL = 7;
      BigNumber3.ROUND_HALF_FLOOR = 8;
      BigNumber3.EUCLID = 9;
      BigNumber3.config = BigNumber3.set = function(obj) {
        var p2, v2;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
              v2 = obj[p2];
              intCheck(v2, 0, MAX, p2);
              DECIMAL_PLACES = v2;
            }
            if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
              v2 = obj[p2];
              intCheck(v2, 0, 8, p2);
              ROUNDING_MODE = v2;
            }
            if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
              v2 = obj[p2];
              if (v2 && v2.pop) {
                intCheck(v2[0], -MAX, 0, p2);
                intCheck(v2[1], 0, MAX, p2);
                TO_EXP_NEG = v2[0];
                TO_EXP_POS = v2[1];
              } else {
                intCheck(v2, -MAX, MAX, p2);
                TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
              }
            }
            if (obj.hasOwnProperty(p2 = "RANGE")) {
              v2 = obj[p2];
              if (v2 && v2.pop) {
                intCheck(v2[0], -MAX, -1, p2);
                intCheck(v2[1], 1, MAX, p2);
                MIN_EXP = v2[0];
                MAX_EXP = v2[1];
              } else {
                intCheck(v2, -MAX, MAX, p2);
                if (v2) {
                  MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                } else {
                  throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                }
              }
            }
            if (obj.hasOwnProperty(p2 = "CRYPTO")) {
              v2 = obj[p2];
              if (v2 === !!v2) {
                if (v2) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v2;
                  } else {
                    CRYPTO = !v2;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v2;
                }
              } else {
                throw Error(bignumberError + p2 + " not true or false: " + v2);
              }
            }
            if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
              v2 = obj[p2];
              intCheck(v2, 0, 9, p2);
              MODULO_MODE = v2;
            }
            if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
              v2 = obj[p2];
              intCheck(v2, 0, MAX, p2);
              POW_PRECISION = v2;
            }
            if (obj.hasOwnProperty(p2 = "FORMAT")) {
              v2 = obj[p2];
              if (typeof v2 == "object")
                FORMAT = v2;
              else
                throw Error(bignumberError + p2 + " not an object: " + v2);
            }
            if (obj.hasOwnProperty(p2 = "ALPHABET")) {
              v2 = obj[p2];
              if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                ALPHABET = v2;
              } else {
                throw Error(bignumberError + p2 + " invalid: " + v2);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber3.isBigNumber = function(v2) {
        if (!v2 || v2._isBigNumber !== true)
          return false;
        if (!BigNumber3.DEBUG)
          return true;
        var i, n, c = v2.c, e = v2.e, s = v2.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v2);
      };
      BigNumber3.maximum = BigNumber3.max = function() {
        return maxOrMin(arguments, P5.lt);
      };
      BigNumber3.minimum = BigNumber3.min = function() {
        return maxOrMin(arguments, P5.gt);
      };
      BigNumber3.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b2, e, k2, v2, i = 0, c = [], rand = new BigNumber3(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k2 = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k2 *= 2));
              for (; i < k2; ) {
                v2 = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v2 >= 9e15) {
                  b2 = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b2[0];
                  a[i + 1] = b2[1];
                } else {
                  c.push(v2 % 1e14);
                  i += 2;
                }
              }
              i = k2 / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k2 *= 7);
              for (; i < k2; ) {
                v2 = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v2 >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v2 % 1e14);
                  i += 7;
                }
              }
              i = k2 / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k2; ) {
              v2 = random53bitInt();
              if (v2 < 9e15)
                c[i++] = v2 % 1e14;
            }
          }
          k2 = c[--i];
          dp %= LOG_BASE;
          if (k2 && dp) {
            v2 = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k2 / v2) * v2;
          }
          for (; c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v2 = c[0]; v2 >= 10; v2 /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber3.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber3(args[0]);
        for (; i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j2, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j2 = 0; j2 < arr.length; j2++) {
              if (arr[j2] > baseOut - 1) {
                if (arr[j2 + 1] == null)
                  arr[j2 + 1] = 0;
                arr[j2 + 1] += arr[j2] / baseOut | 0;
                arr[j2] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign2, callerIsToString) {
          var alphabet, d2, e, k2, r3, x2, xc2, y2, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k2 = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y2 = new BigNumber3(baseIn);
            x2 = y2.pow(str.length - i);
            POW_PRECISION = k2;
            y2.c = toBaseOut(
              toFixedPoint(coeffToString(x2.c), x2.e, "0"),
              10,
              baseOut,
              decimal
            );
            y2.e = y2.c.length;
          }
          xc2 = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k2 = xc2.length;
          for (; xc2[--k2] == 0; xc2.pop())
            ;
          if (!xc2[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x2.c = xc2;
            x2.e = e;
            x2.s = sign2;
            x2 = div(x2, y2, dp, rm, baseOut);
            xc2 = x2.c;
            r3 = x2.r;
            e = x2.e;
          }
          d2 = e + dp + 1;
          i = xc2[d2];
          k2 = baseOut / 2;
          r3 = r3 || d2 < 0 || xc2[d2 + 1] != null;
          r3 = rm < 4 ? (i != null || r3) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i > k2 || i == k2 && (rm == 4 || r3 || rm == 6 && xc2[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
          if (d2 < 1 || !xc2[0]) {
            str = r3 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc2.length = d2;
            if (r3) {
              for (--baseOut; ++xc2[--d2] > baseOut; ) {
                xc2[d2] = 0;
                if (!d2) {
                  ++e;
                  xc2 = [1].concat(xc2);
                }
              }
            }
            for (k2 = xc2.length; !xc2[--k2]; )
              ;
            for (i = 0, str = ""; i <= k2; str += alphabet.charAt(xc2[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x2, k2, base) {
          var m2, temp, xlo, xhi, carry = 0, i = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
          for (x2 = x2.slice(); i--; ) {
            xlo = x2[i] % SQRT_BASE;
            xhi = x2[i] / SQRT_BASE | 0;
            m2 = khi * xlo + xhi * klo;
            temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
            x2[i] = temp % base;
          }
          if (carry)
            x2 = [carry].concat(x2);
          return x2;
        }
        function compare2(a, b2, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b2[i]) {
                cmp = a[i] > b2[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b2, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b2[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b2[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x2, y2, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q2, qc2, rem, remL, rem0, xi2, xL, yc0, yL, yz, s = x2.s == y2.s ? 1 : -1, xc2 = x2.c, yc2 = y2.c;
          if (!xc2 || !xc2[0] || !yc2 || !yc2[0]) {
            return new BigNumber3(
              // Return NaN if either NaN, or both Infinity or 0.
              !x2.s || !y2.s || (xc2 ? yc2 && xc2[0] == yc2[0] : !yc2) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc2 && xc2[0] == 0 || !yc2 ? s * 0 : s / 0
              )
            );
          }
          q2 = new BigNumber3(s);
          qc2 = q2.c = [];
          e = x2.e - y2.e;
          s = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0; yc2[i] == (xc2[i] || 0); i++)
            ;
          if (yc2[i] > (xc2[i] || 0))
            e--;
          if (s < 0) {
            qc2.push(1);
            more = true;
          } else {
            xL = xc2.length;
            yL = yc2.length;
            i = 0;
            s += 2;
            n = mathfloor(base / (yc2[0] + 1));
            if (n > 1) {
              yc2 = multiply(yc2, n, base);
              xc2 = multiply(xc2, n, base);
              yL = yc2.length;
              xL = xc2.length;
            }
            xi2 = yL;
            rem = xc2.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc2.slice();
            yz = [0].concat(yz);
            yc0 = yc2[0];
            if (yc2[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare2(yc2, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc2, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc2, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc2.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc2, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc2, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc2[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc2[xi2] || 0;
              } else {
                rem = [xc2[xi2]];
                remL = 1;
              }
            } while ((xi2++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc2[0])
              qc2.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s = qc2[0]; s >= 10; s /= 10, i++)
              ;
            round(q2, dp + (q2.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q2.e = e;
            q2.r = +more;
          }
          return q2;
        };
      }();
      function format(n, i, rm, id2) {
        var c0, e, ne2, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne2 = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id2 == 1 || id2 == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
        } else {
          n = round(new BigNumber3(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id2 == 1 || id2 == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne2;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += "."; i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (; i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, method) {
        var n, i = 1, m2 = new BigNumber3(args[0]);
        for (; i < args.length; i++) {
          n = new BigNumber3(args[i]);
          if (!n.s) {
            m2 = n;
            break;
          } else if (method.call(m2, n)) {
            m2 = n;
          }
        }
        return m2;
      }
      function normalise(n, c, e) {
        var i = 1, j2 = c.length;
        for (; !c[--j2]; c.pop())
          ;
        for (j2 = c[0]; j2 >= 10; j2 /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x2, str, isNum, b2) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x2.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m2, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b2 || b2 == base ? p1 : m2;
              });
              if (b2) {
                base = b2;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s)
                return new BigNumber3(s, base);
            }
            if (BigNumber3.DEBUG) {
              throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
            }
            x2.s = null;
          }
          x2.c = x2.e = null;
        };
      }();
      function round(x2, sd, rm, r3) {
        var d2, i, j2, k2, n, ni, rd2, xc2 = x2.c, pows10 = POWS_TEN;
        if (xc2) {
          out: {
            for (d2 = 1, k2 = xc2[0]; k2 >= 10; k2 /= 10, d2++)
              ;
            i = sd - d2;
            if (i < 0) {
              i += LOG_BASE;
              j2 = sd;
              n = xc2[ni = 0];
              rd2 = n / pows10[d2 - j2 - 1] % 10 | 0;
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc2.length) {
                if (r3) {
                  for (; xc2.length <= ni; xc2.push(0))
                    ;
                  n = rd2 = 0;
                  d2 = 1;
                  i %= LOG_BASE;
                  j2 = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k2 = xc2[ni];
                for (d2 = 1; k2 >= 10; k2 /= 10, d2++)
                  ;
                i %= LOG_BASE;
                j2 = i - LOG_BASE + d2;
                rd2 = j2 < 0 ? 0 : n / pows10[d2 - j2 - 1] % 10 | 0;
              }
            }
            r3 = r3 || sd < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            xc2[ni + 1] != null || (j2 < 0 ? n : n % pows10[d2 - j2 - 1]);
            r3 = rm < 4 ? (rd2 || r3) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm == 4 || r3 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j2 > 0 ? n / pows10[d2 - j2] : 0 : xc2[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (sd < 1 || !xc2[0]) {
              xc2.length = 0;
              if (r3) {
                sd -= x2.e + 1;
                xc2[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x2.e = -sd || 0;
              } else {
                xc2[0] = x2.e = 0;
              }
              return x2;
            }
            if (i == 0) {
              xc2.length = ni;
              k2 = 1;
              ni--;
            } else {
              xc2.length = ni + 1;
              k2 = pows10[LOG_BASE - i];
              xc2[ni] = j2 > 0 ? mathfloor(n / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
            }
            if (r3) {
              for (; ; ) {
                if (ni == 0) {
                  for (i = 1, j2 = xc2[0]; j2 >= 10; j2 /= 10, i++)
                    ;
                  j2 = xc2[0] += k2;
                  for (k2 = 1; j2 >= 10; j2 /= 10, k2++)
                    ;
                  if (i != k2) {
                    x2.e++;
                    if (xc2[0] == BASE)
                      xc2[0] = 1;
                  }
                  break;
                } else {
                  xc2[ni] += k2;
                  if (xc2[ni] != BASE)
                    break;
                  xc2[ni--] = 0;
                  k2 = 1;
                }
              }
            }
            for (i = xc2.length; xc2[--i] === 0; xc2.pop())
              ;
          }
          if (x2.e > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (x2.e < MIN_EXP) {
            x2.c = [x2.e = 0];
          }
        }
        return x2;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P5.absoluteValue = P5.abs = function() {
        var x2 = new BigNumber3(this);
        if (x2.s < 0)
          x2.s = 1;
        return x2;
      };
      P5.comparedTo = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2));
      };
      P5.decimalPlaces = P5.dp = function(dp, rm) {
        var c, n, v2, x2 = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber3(x2), dp + x2.e + 1, rm);
        }
        if (!(c = x2.c))
          return null;
        n = ((v2 = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v2 = c[v2])
          for (; v2 % 10 == 0; v2 /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P5.dividedBy = P5.div = function(y2, b2) {
        return div(this, new BigNumber3(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P5.dividedToIntegerBy = P5.idiv = function(y2, b2) {
        return div(this, new BigNumber3(y2, b2), 0, 1);
      };
      P5.exponentiatedBy = P5.pow = function(n, m2) {
        var half, isModExp, i, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
        n = new BigNumber3(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m2 != null)
          m2 = new BigNumber3(m2);
        nIsBig = n.e > 14;
        if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n.c || !n.c[0]) {
          y2 = new BigNumber3(Math.pow(+valueOf(x2), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m2 ? y2.mod(m2) : y2;
        }
        nIsNeg = n.s < 0;
        if (m2) {
          if (m2.c ? !m2.c[0] : !m2.s)
            return new BigNumber3(NaN);
          isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
          if (isModExp)
            x2 = x2.mod(m2);
        } else if (n.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
          k2 = x2.s < 0 && isOdd(n) ? -0 : 0;
          if (x2.e > -1)
            k2 = 1 / k2;
          return new BigNumber3(nIsNeg ? 1 / k2 : k2);
        } else if (POW_PRECISION) {
          k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber3(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y2 = new BigNumber3(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y2 = y2.times(x2);
            if (!y2.c)
              break;
            if (k2) {
              if (y2.c.length > k2)
                y2.c.length = k2;
            } else if (isModExp) {
              y2 = y2.mod(m2);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x2 = x2.times(x2);
          if (k2) {
            if (x2.c && x2.c.length > k2)
              x2.c.length = k2;
          } else if (isModExp) {
            x2 = x2.mod(m2);
          }
        }
        if (isModExp)
          return y2;
        if (nIsNeg)
          y2 = ONE.div(y2);
        return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
      };
      P5.integerValue = function(rm) {
        var n = new BigNumber3(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P5.isEqualTo = P5.eq = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) === 0;
      };
      P5.isFinite = function() {
        return !!this.c;
      };
      P5.isGreaterThan = P5.gt = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) > 0;
      };
      P5.isGreaterThanOrEqualTo = P5.gte = function(y2, b2) {
        return (b2 = compare(this, new BigNumber3(y2, b2))) === 1 || b2 === 0;
      };
      P5.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P5.isLessThan = P5.lt = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) < 0;
      };
      P5.isLessThanOrEqualTo = P5.lte = function(y2, b2) {
        return (b2 = compare(this, new BigNumber3(y2, b2))) === -1 || b2 === 0;
      };
      P5.isNaN = function() {
        return !this.s;
      };
      P5.isNegative = function() {
        return this.s < 0;
      };
      P5.isPositive = function() {
        return this.s > 0;
      };
      P5.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P5.minus = function(y2, b2) {
        var i, j2, t, xLTy, x2 = this, a = x2.s;
        y2 = new BigNumber3(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber3(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x2.plus(y2);
        }
        var xe2 = x2.e / LOG_BASE, ye = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
        if (!xe2 || !ye) {
          if (!xc2 || !yc2)
            return xc2 ? (y2.s = -b2, y2) : new BigNumber3(yc2 ? x2 : NaN);
          if (!xc2[0] || !yc2[0]) {
            return yc2[0] ? (y2.s = -b2, y2) : new BigNumber3(xc2[0] ? x2 : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0
            ));
          }
        }
        xe2 = bitFloor(xe2);
        ye = bitFloor(ye);
        xc2 = xc2.slice();
        if (a = xe2 - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc2;
          } else {
            ye = xe2;
            t = yc2;
          }
          t.reverse();
          for (b2 = a; b2--; t.push(0))
            ;
          t.reverse();
        } else {
          j2 = (xLTy = (a = xc2.length) < (b2 = yc2.length)) ? a : b2;
          for (a = b2 = 0; b2 < j2; b2++) {
            if (xc2[b2] != yc2[b2]) {
              xLTy = xc2[b2] < yc2[b2];
              break;
            }
          }
        }
        if (xLTy) {
          t = xc2;
          xc2 = yc2;
          yc2 = t;
          y2.s = -y2.s;
        }
        b2 = (j2 = yc2.length) - (i = xc2.length);
        if (b2 > 0)
          for (; b2--; xc2[i++] = 0)
            ;
        b2 = BASE - 1;
        for (; j2 > a; ) {
          if (xc2[--j2] < yc2[j2]) {
            for (i = j2; i && !xc2[--i]; xc2[i] = b2)
              ;
            --xc2[i];
            xc2[j2] += BASE;
          }
          xc2[j2] -= yc2[j2];
        }
        for (; xc2[0] == 0; xc2.splice(0, 1), --ye)
          ;
        if (!xc2[0]) {
          y2.s = ROUNDING_MODE == 3 ? -1 : 1;
          y2.c = [y2.e = 0];
          return y2;
        }
        return normalise(y2, xc2, ye);
      };
      P5.modulo = P5.mod = function(y2, b2) {
        var q2, s, x2 = this;
        y2 = new BigNumber3(y2, b2);
        if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
          return new BigNumber3(NaN);
        } else if (!y2.c || x2.c && !x2.c[0]) {
          return new BigNumber3(x2);
        }
        if (MODULO_MODE == 9) {
          s = y2.s;
          y2.s = 1;
          q2 = div(x2, y2, 0, 3);
          y2.s = s;
          q2.s *= s;
        } else {
          q2 = div(x2, y2, 0, MODULO_MODE);
        }
        y2 = x2.minus(q2.times(y2));
        if (!y2.c[0] && MODULO_MODE == 1)
          y2.s = x2.s;
        return y2;
      };
      P5.multipliedBy = P5.times = function(y2, b2) {
        var c, e, i, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base, sqrtBase, x2 = this, xc2 = x2.c, yc2 = (y2 = new BigNumber3(y2, b2)).c;
        if (!xc2 || !yc2 || !xc2[0] || !yc2[0]) {
          if (!x2.s || !y2.s || xc2 && !xc2[0] && !yc2 || yc2 && !yc2[0] && !xc2) {
            y2.c = y2.e = y2.s = null;
          } else {
            y2.s *= x2.s;
            if (!xc2 || !yc2) {
              y2.c = y2.e = null;
            } else {
              y2.c = [0];
              y2.e = 0;
            }
          }
          return y2;
        }
        e = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
        y2.s *= x2.s;
        xcL = xc2.length;
        ycL = yc2.length;
        if (xcL < ycL) {
          zc2 = xc2;
          xc2 = yc2;
          yc2 = zc2;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc2 = []; i--; zc2.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc2[i] % sqrtBase;
          yhi = yc2[i] / sqrtBase | 0;
          for (k2 = xcL, j2 = i + k2; j2 > i; ) {
            xlo = xc2[--k2] % sqrtBase;
            xhi = xc2[k2] / sqrtBase | 0;
            m2 = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc2[j2] + c;
            c = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
            zc2[j2--] = xlo % base;
          }
          zc2[j2] = c;
        }
        if (c) {
          ++e;
        } else {
          zc2.splice(0, 1);
        }
        return normalise(y2, zc2, e);
      };
      P5.negated = function() {
        var x2 = new BigNumber3(this);
        x2.s = -x2.s || null;
        return x2;
      };
      P5.plus = function(y2, b2) {
        var t, x2 = this, a = x2.s;
        y2 = new BigNumber3(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber3(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x2.minus(y2);
        }
        var xe2 = x2.e / LOG_BASE, ye = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
        if (!xe2 || !ye) {
          if (!xc2 || !yc2)
            return new BigNumber3(a / 0);
          if (!xc2[0] || !yc2[0])
            return yc2[0] ? y2 : new BigNumber3(xc2[0] ? x2 : a * 0);
        }
        xe2 = bitFloor(xe2);
        ye = bitFloor(ye);
        xc2 = xc2.slice();
        if (a = xe2 - ye) {
          if (a > 0) {
            ye = xe2;
            t = yc2;
          } else {
            a = -a;
            t = xc2;
          }
          t.reverse();
          for (; a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc2.length;
        b2 = yc2.length;
        if (a - b2 < 0) {
          t = yc2;
          yc2 = xc2;
          xc2 = t;
          b2 = a;
        }
        for (a = 0; b2; ) {
          a = (xc2[--b2] = xc2[b2] + yc2[b2] + a) / BASE | 0;
          xc2[b2] = BASE === xc2[b2] ? 0 : xc2[b2] % BASE;
        }
        if (a) {
          xc2 = [a].concat(xc2);
          ++ye;
        }
        return normalise(y2, xc2, ye);
      };
      P5.precision = P5.sd = function(sd, rm) {
        var c, n, v2, x2 = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber3(x2), sd, rm);
        }
        if (!(c = x2.c))
          return null;
        v2 = c.length - 1;
        n = v2 * LOG_BASE + 1;
        if (v2 = c[v2]) {
          for (; v2 % 10 == 0; v2 /= 10, n--)
            ;
          for (v2 = c[0]; v2 >= 10; v2 /= 10, n++)
            ;
        }
        if (sd && x2.e + 1 > n)
          n = x2.e + 1;
        return n;
      };
      P5.shiftedBy = function(k2) {
        intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k2);
      };
      P5.squareRoot = P5.sqrt = function() {
        var m2, n, r3, rep, t, x2 = this, c = x2.c, s = x2.s, e = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
        if (s !== 1 || !c || !c[0]) {
          return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x2 : 1 / 0);
        }
        s = Math.sqrt(+valueOf(x2));
        if (s == 0 || s == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r3 = new BigNumber3(n);
        } else {
          r3 = new BigNumber3(s + "");
        }
        if (r3.c[0]) {
          e = r3.e;
          s = e + dp;
          if (s < 3)
            s = 0;
          for (; ; ) {
            t = r3;
            r3 = half.times(t.plus(div(x2, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r3.c)).slice(0, s)) {
              if (r3.e < e)
                --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x2)) {
                    r3 = t;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r3, r3.e + DECIMAL_PLACES + 2, 1);
                  m2 = !r3.times(r3).eq(x2);
                }
                break;
              }
            }
          }
        }
        return round(r3, r3.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
      };
      P5.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P5.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P5.toFormat = function(dp, rm, format2) {
        var str, x2 = this;
        if (format2 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x2.toFixed(dp, rm);
        if (x2.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g22) {
            i = g1;
            g1 = g22;
            g22 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g22 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
            new RegExp("\\d{" + g22 + "}\\B", "g"),
            "$&" + (format2.fractionGroupSeparator || "")
          ) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P5.toFraction = function(md) {
        var d2, d0, d1, d22, e, exp, n, n02, n12, q2, r3, s, x2 = this, xc2 = x2.c;
        if (md != null) {
          n = new BigNumber3(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc2)
          return new BigNumber3(x2);
        d2 = new BigNumber3(ONE);
        n12 = d0 = new BigNumber3(ONE);
        d1 = n02 = new BigNumber3(ONE);
        s = coeffToString(xc2);
        e = d2.e = s.length - x2.e - 1;
        d2.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d2) > 0 ? e > 0 ? d2 : n12 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber3(s);
        n02.c[0] = 0;
        for (; ; ) {
          q2 = div(n, d2, 0, 1);
          d22 = d0.plus(q2.times(d1));
          if (d22.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d22;
          n12 = n02.plus(q2.times(d22 = n12));
          n02 = d22;
          d2 = n.minus(q2.times(d22 = d2));
          n = d22;
        }
        d22 = div(md.minus(d0), d1, 0, 1);
        n02 = n02.plus(d22.times(n12));
        d0 = d0.plus(d22.times(d1));
        n02.s = n12.s = x2.s;
        e = e * 2;
        r3 = div(n12, d1, e, ROUNDING_MODE).minus(x2).abs().comparedTo(
          div(n02, d0, e, ROUNDING_MODE).minus(x2).abs()
        ) < 1 ? [n12, d1] : [n02, d0];
        MAX_EXP = exp;
        return r3;
      };
      P5.toNumber = function() {
        return +valueOf(this);
      };
      P5.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P5.toString = function(b2) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) {
          if (s) {
            str = "Infinity";
            if (s < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b2 == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b2, s, true);
          }
          if (s < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P5.valueOf = P5.toJSON = function() {
        return valueOf(this);
      };
      P5._isBigNumber = true;
      if (configObject != null)
        BigNumber3.set(configObject);
      return BigNumber3;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z2, i = 1, j2 = a.length, r3 = a[0] + "";
      for (; i < j2; ) {
        s = a[i++] + "";
        z2 = LOG_BASE - s.length;
        for (; z2--; s = "0" + s)
          ;
        r3 += s;
      }
      for (j2 = r3.length; r3.charCodeAt(--j2) === 48; )
        ;
      return r3.slice(0, j2 + 1 || 1);
    }
    function compare(x2, y2) {
      var a, b2, xc2 = x2.c, yc2 = y2.c, i = x2.s, j2 = y2.s, k2 = x2.e, l = y2.e;
      if (!i || !j2)
        return null;
      a = xc2 && !xc2[0];
      b2 = yc2 && !yc2[0];
      if (a || b2)
        return a ? b2 ? 0 : -j2 : i;
      if (i != j2)
        return i;
      a = i < 0;
      b2 = k2 == l;
      if (!xc2 || !yc2)
        return b2 ? 0 : !xc2 ^ a ? 1 : -1;
      if (!b2)
        return k2 > l ^ a ? 1 : -1;
      j2 = (k2 = xc2.length) < (l = yc2.length) ? k2 : l;
      for (i = 0; i < j2; i++)
        if (xc2[i] != yc2[i])
          return xc2[i] > yc2[i] ^ a ? 1 : -1;
      return k2 == l ? 0 : k2 > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k2 = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k2 && n.c[k2] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z2) {
      var len, zs2;
      if (e < 0) {
        for (zs2 = z2 + "."; ++e; zs2 += z2)
          ;
        str = zs2 + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs2 = z2, e -= len; --e; zs2 += z2)
            ;
          str += zs2;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber2 = clone();
    BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
    if (module.exports) {
      module.exports = BigNumber2;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber2;
    }
  })(commonjsGlobal);
})(bignumber);
(function(module) {
  var BigNumber2 = bignumberExports;
  var JSON2 = module.exports;
  (function() {
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c = meta[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i, k2, v2, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber2 || BigNumber2.isBigNumber(value));
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          if (isBigNumber) {
            return value;
          } else {
            return quote(value);
          }
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value) || "null";
            }
            v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v2;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              if (typeof rep[i] === "string") {
                k2 = rep[i];
                v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              }
            }
          } else {
            Object.keys(value).forEach(function(k5) {
              var v5 = str(k5, value);
              if (v5) {
                partial.push(quote(k5) + (gap ? ": " : ":") + v5);
              }
            });
          }
          v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v2;
      }
    }
    if (typeof JSON2.stringify !== "function") {
      JSON2.stringify = function(value, replacer2, space) {
        var i;
        gap = "";
        indent = "";
        if (typeof space === "number") {
          for (i = 0; i < space; i += 1) {
            indent += " ";
          }
        } else if (typeof space === "string") {
          indent = space;
        }
        rep = replacer2;
        if (replacer2 && typeof replacer2 !== "function" && (typeof replacer2 !== "object" || typeof replacer2.length !== "number")) {
          throw new Error("JSON.stringify");
        }
        return str("", { "": value });
      };
    }
  })();
})(stringify);
var BigNumber = null;
const suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
const suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
var json_parse$1 = function(options) {
  var _options = {
    strict: false,
    // not being strict means do not generate syntax errors for "duplicate key"
    storeAsString: false,
    // toggles whether the values should be stored as BigNumber (default) or a string
    alwaysParseAsBig: false,
    // toggles whether all numbers should be Big
    useNativeBigInt: false,
    // toggles whether to use native BigInt instead of bignumber.js
    protoAction: "error",
    constructorAction: "error"
  };
  if (options !== void 0 && options !== null) {
    if (options.strict === true) {
      _options.strict = true;
    }
    if (options.storeAsString === true) {
      _options.storeAsString = true;
    }
    _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
    _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
    if (typeof options.constructorAction !== "undefined") {
      if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
        _options.constructorAction = options.constructorAction;
      } else {
        throw new Error(
          `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
        );
      }
    }
    if (typeof options.protoAction !== "undefined") {
      if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
        _options.protoAction = options.protoAction;
      } else {
        throw new Error(
          `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
        );
      }
    }
  }
  var at, ch, escapee = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	"
  }, text, error = function(m2) {
    throw {
      name: "SyntaxError",
      message: m2,
      at,
      text
    };
  }, next = function(c) {
    if (c && c !== ch) {
      error("Expected '" + c + "' instead of '" + ch + "'");
    }
    ch = text.charAt(at);
    at += 1;
    return ch;
  }, number = function() {
    var number2, string2 = "";
    if (ch === "-") {
      string2 = "-";
      next("-");
    }
    while (ch >= "0" && ch <= "9") {
      string2 += ch;
      next();
    }
    if (ch === ".") {
      string2 += ".";
      while (next() && ch >= "0" && ch <= "9") {
        string2 += ch;
      }
    }
    if (ch === "e" || ch === "E") {
      string2 += ch;
      next();
      if (ch === "-" || ch === "+") {
        string2 += ch;
        next();
      }
      while (ch >= "0" && ch <= "9") {
        string2 += ch;
        next();
      }
    }
    number2 = +string2;
    if (!isFinite(number2)) {
      error("Bad number");
    } else {
      if (BigNumber == null)
        BigNumber = bignumberExports;
      if (string2.length > 15)
        return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
      else
        return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
    }
  }, string = function() {
    var hex, i, string2 = "", uffff;
    if (ch === '"') {
      var startAt = at;
      while (next()) {
        if (ch === '"') {
          if (at - 1 > startAt)
            string2 += text.substring(startAt, at - 1);
          next();
          return string2;
        }
        if (ch === "\\") {
          if (at - 1 > startAt)
            string2 += text.substring(startAt, at - 1);
          next();
          if (ch === "u") {
            uffff = 0;
            for (i = 0; i < 4; i += 1) {
              hex = parseInt(next(), 16);
              if (!isFinite(hex)) {
                break;
              }
              uffff = uffff * 16 + hex;
            }
            string2 += String.fromCharCode(uffff);
          } else if (typeof escapee[ch] === "string") {
            string2 += escapee[ch];
          } else {
            break;
          }
          startAt = at;
        }
      }
    }
    error("Bad string");
  }, white = function() {
    while (ch && ch <= " ") {
      next();
    }
  }, word = function() {
    switch (ch) {
      case "t":
        next("t");
        next("r");
        next("u");
        next("e");
        return true;
      case "f":
        next("f");
        next("a");
        next("l");
        next("s");
        next("e");
        return false;
      case "n":
        next("n");
        next("u");
        next("l");
        next("l");
        return null;
    }
    error("Unexpected '" + ch + "'");
  }, value, array = function() {
    var array2 = [];
    if (ch === "[") {
      next("[");
      white();
      if (ch === "]") {
        next("]");
        return array2;
      }
      while (ch) {
        array2.push(value());
        white();
        if (ch === "]") {
          next("]");
          return array2;
        }
        next(",");
        white();
      }
    }
    error("Bad array");
  }, object = function() {
    var key, object2 = /* @__PURE__ */ Object.create(null);
    if (ch === "{") {
      next("{");
      white();
      if (ch === "}") {
        next("}");
        return object2;
      }
      while (ch) {
        key = string();
        white();
        next(":");
        if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
          error('Duplicate key "' + key + '"');
        }
        if (suspectProtoRx.test(key) === true) {
          if (_options.protoAction === "error") {
            error("Object contains forbidden prototype property");
          } else if (_options.protoAction === "ignore") {
            value();
          } else {
            object2[key] = value();
          }
        } else if (suspectConstructorRx.test(key) === true) {
          if (_options.constructorAction === "error") {
            error("Object contains forbidden constructor property");
          } else if (_options.constructorAction === "ignore") {
            value();
          } else {
            object2[key] = value();
          }
        } else {
          object2[key] = value();
        }
        white();
        if (ch === "}") {
          next("}");
          return object2;
        }
        next(",");
        white();
      }
    }
    error("Bad object");
  };
  value = function() {
    white();
    switch (ch) {
      case "{":
        return object();
      case "[":
        return array();
      case '"':
        return string();
      case "-":
        return number();
      default:
        return ch >= "0" && ch <= "9" ? number() : word();
    }
  };
  return function(source, reviver) {
    var result;
    text = source + "";
    at = 0;
    ch = " ";
    result = value();
    white();
    if (ch) {
      error("Syntax error");
    }
    return typeof reviver === "function" ? function walk(holder, key) {
      var v2, value2 = holder[key];
      if (value2 && typeof value2 === "object") {
        Object.keys(value2).forEach(function(k2) {
          v2 = walk(value2, k2);
          if (v2 !== void 0) {
            value2[k2] = v2;
          } else {
            delete value2[k2];
          }
        });
      }
      return reviver.call(holder, key, value2);
    }({ "": result }, "") : result;
  };
};
var parse = json_parse$1;
var json_stringify = stringifyExports.stringify;
var json_parse = parse;
jsonBigint.exports = function(options) {
  return {
    parse: json_parse(options),
    stringify: json_stringify
  };
};
jsonBigintExports.parse = json_parse();
jsonBigintExports.stringify = json_stringify;
var IntDecoding;
(function(IntDecoding2) {
  IntDecoding2["DEFAULT"] = "default";
  IntDecoding2["SAFE"] = "safe";
  IntDecoding2["MIXED"] = "mixed";
  IntDecoding2["BIGINT"] = "bigint";
})(IntDecoding || (IntDecoding = {}));
const IntDecoding$1 = IntDecoding;
const JSONbig = jsonBigintExports({ useNativeBigInt: true, strict: true });
function parseJSON(str, options) {
  const intDecoding = options && options.intDecoding ? options.intDecoding : IntDecoding$1.DEFAULT;
  return JSONbig.parse(str, (_, value) => {
    if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
      Object.setPrototypeOf(value, Object.prototype);
    }
    if (typeof value === "bigint") {
      if (intDecoding === "safe" && value > Number.MAX_SAFE_INTEGER) {
        throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
      }
      if (intDecoding === "bigint" || intDecoding === "mixed" && value > Number.MAX_SAFE_INTEGER) {
        return value;
      }
      return Number(value);
    }
    if (typeof value === "number") {
      if (intDecoding === "bigint" && Number.isInteger(value)) {
        return BigInt(value);
      }
    }
    return value;
  });
}
function arrayEqual(a, b2) {
  if (a.length !== b2.length) {
    return false;
  }
  return Array.from(a).every((val, i) => val === b2[i]);
}
function concatArrays(...arrs) {
  const size2 = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c = new Uint8Array(size2);
  let offset = 0;
  for (let i = 0; i < arrs.length; i++) {
    c.set(arrs[i], offset);
    offset += arrs[i].length;
  }
  return c;
}
function removeUndefinedProperties(obj) {
  const mutableCopy = { ...obj };
  Object.keys(mutableCopy).forEach((key) => {
    if (typeof mutableCopy[key] === "undefined")
      delete mutableCopy[key];
  });
  return mutableCopy;
}
function encodeUint64(num) {
  const isInteger = typeof num === "bigint" || Number.isInteger(num);
  if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
    throw new Error("Input is not a 64-bit unsigned integer");
  }
  const encoding = new Uint8Array(8);
  const view = new DataView(encoding.buffer);
  view.setBigUint64(0, BigInt(num));
  return encoding;
}
function decodeUint64(data, decodingMode = "safe") {
  if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
    throw new Error(`Unknown decodingMode option: ${decodingMode}`);
  }
  if (data.byteLength === 0 || data.byteLength > 8) {
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
  }
  const padding = new Uint8Array(8 - data.byteLength);
  const encoding = concatArrays(padding, data);
  const view = new DataView(encoding.buffer);
  const num = view.getBigUint64(0);
  const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);
  if (decodingMode === "safe") {
    if (isBig) {
      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    }
    return Number(num);
  }
  if (decodingMode === "mixed" && !isBig) {
    return Number(num);
  }
  return num;
}
const ALGORAND_ADDRESS_BYTE_LENGTH = 36;
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_ADDRESS_LENGTH = 58;
const ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
const MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
  77,
  117,
  108,
  116,
  105,
  115,
  105,
  103,
  65,
  100,
  100,
  114
]);
const APP_ID_PREFIX = buffer.Buffer.from("appID");
const MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
const CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
const INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
const INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
const INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
const UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
function decodeAddress(address) {
  if (typeof address !== "string" || address.length !== ALGORAND_ADDRESS_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const decoded = base32Exports.decode.asBytes(address.toString());
  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
  const checksum = genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH);
  if (!arrayEqual(checksum, cs))
    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
  return { publicKey: pk, checksum: cs };
}
function isValidAddress(address) {
  try {
    decodeAddress(address);
  } catch (e) {
    return false;
  }
  return true;
}
function encodeAddress(address) {
  const checksum = genericHash(address).slice(PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, PUBLIC_KEY_LENGTH);
  const addr = base32Exports.encode(concatArrays(address, checksum));
  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH);
}
function fromMultisigPreImg({ version: version2, threshold, pks }) {
  if (version2 !== 1 || version2 > 255 || version2 < 0) {
    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
  }
  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
  }
  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
  if (pkLen !== PUBLIC_KEY_LENGTH) {
    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
  }
  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
  merged.set([version2], MULTISIG_PREIMG2ADDR_PREFIX.length);
  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
  for (let i = 0; i < pks.length; i++) {
    if (pks[i].length !== pkLen) {
      throw new Error(INVALID_MSIG_PK_ERROR_MSG);
    }
    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);
  }
  return new Uint8Array(genericHash(merged));
}
function fromMultisigPreImgAddrs({ version: version2, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  return encodeAddress(fromMultisigPreImg({ version: version2, threshold, pks }));
}
function getApplicationAddress(appID) {
  const toBeSigned = concatArrays(APP_ID_PREFIX, encodeUint64(appID));
  const hash = genericHash(toBeSigned);
  return encodeAddress(new Uint8Array(hash));
}
var msgpack_minExports = {};
var msgpack_min = {
  get exports() {
    return msgpack_minExports;
  },
  set exports(v2) {
    msgpack_minExports = v2;
  }
};
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    return function(t) {
      var e = {};
      function r3(n) {
        if (e[n])
          return e[n].exports;
        var i = e[n] = { i: n, l: false, exports: {} };
        return t[n].call(i.exports, i, i.exports, r3), i.l = true, i.exports;
      }
      return r3.m = t, r3.c = e, r3.d = function(t2, e2, n) {
        r3.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
      }, r3.r = function(t2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, r3.t = function(t2, e2) {
        if (1 & e2 && (t2 = r3(t2)), 8 & e2)
          return t2;
        if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
          return t2;
        var n = /* @__PURE__ */ Object.create(null);
        if (r3.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
          for (var i in t2)
            r3.d(n, i, function(e5) {
              return t2[e5];
            }.bind(null, i));
        return n;
      }, r3.n = function(t2) {
        var e2 = t2 && t2.__esModule ? function() {
          return t2.default;
        } : function() {
          return t2;
        };
        return r3.d(e2, "a", e2), e2;
      }, r3.o = function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }, r3.p = "", r3(r3.s = 0);
    }([function(t, e, r3) {
      r3.r(e), r3.d(e, "encode", function() {
        return T;
      }), r3.d(e, "decode", function() {
        return V;
      }), r3.d(e, "decodeAsync", function() {
        return Y;
      }), r3.d(e, "decodeArrayStream", function() {
        return Z;
      }), r3.d(e, "decodeStream", function() {
        return $;
      }), r3.d(e, "Decoder", function() {
        return O2;
      }), r3.d(e, "Encoder", function() {
        return I;
      }), r3.d(e, "ExtensionCodec", function() {
        return S2;
      }), r3.d(e, "ExtData", function() {
        return p2;
      }), r3.d(e, "EXT_TIMESTAMP", function() {
        return w;
      }), r3.d(e, "encodeDateToTimeSpec", function() {
        return g5;
      }), r3.d(e, "encodeTimeSpecToTimestamp", function() {
        return v2;
      }), r3.d(e, "decodeTimestampToTimeSpec", function() {
        return U2;
      }), r3.d(e, "encodeTimestampExtension", function() {
        return b2;
      }), r3.d(e, "decodeTimestampExtension", function() {
        return m2;
      });
      var n = function(t2, e2) {
        var r5 = "function" == typeof Symbol && t2[Symbol.iterator];
        if (!r5)
          return t2;
        var n2, i2, o2 = r5.call(t2), s2 = [];
        try {
          for (; (void 0 === e2 || e2-- > 0) && !(n2 = o2.next()).done; )
            s2.push(n2.value);
        } catch (t5) {
          i2 = { error: t5 };
        } finally {
          try {
            n2 && !n2.done && (r5 = o2.return) && r5.call(o2);
          } finally {
            if (i2)
              throw i2.error;
          }
        }
        return s2;
      }, i = function() {
        for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
          t2 = t2.concat(n(arguments[e2]));
        return t2;
      }, o = "undefined" != typeof process && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
      function s(t2) {
        for (var e2 = t2.length, r5 = 0, n2 = 0; n2 < e2; ) {
          var i2 = t2.charCodeAt(n2++);
          if (0 != (4294967168 & i2))
            if (0 == (4294965248 & i2))
              r5 += 2;
            else {
              if (i2 >= 55296 && i2 <= 56319 && n2 < e2) {
                var o2 = t2.charCodeAt(n2);
                56320 == (64512 & o2) && (++n2, i2 = ((1023 & i2) << 10) + (1023 & o2) + 65536);
              }
              r5 += 0 == (4294901760 & i2) ? 3 : 4;
            }
          else
            r5++;
        }
        return r5;
      }
      var a = o ? new TextEncoder() : void 0, h2 = "undefined" != typeof process ? 200 : 0;
      var u3 = (null == a ? void 0 : a.encodeInto) ? function(t2, e2, r5) {
        a.encodeInto(t2, e2.subarray(r5));
      } : function(t2, e2, r5) {
        e2.set(a.encode(t2), r5);
      };
      function c(t2, e2, r5) {
        for (var n2 = e2, o2 = n2 + r5, s2 = [], a2 = ""; n2 < o2; ) {
          var h5 = t2[n2++];
          if (0 == (128 & h5))
            s2.push(h5);
          else if (192 == (224 & h5)) {
            var u5 = 63 & t2[n2++];
            s2.push((31 & h5) << 6 | u5);
          } else if (224 == (240 & h5)) {
            u5 = 63 & t2[n2++];
            var c2 = 63 & t2[n2++];
            s2.push((31 & h5) << 12 | u5 << 6 | c2);
          } else if (240 == (248 & h5)) {
            var f5 = (7 & h5) << 18 | (u5 = 63 & t2[n2++]) << 12 | (c2 = 63 & t2[n2++]) << 6 | 63 & t2[n2++];
            f5 > 65535 && (f5 -= 65536, s2.push(f5 >>> 10 & 1023 | 55296), f5 = 56320 | 1023 & f5), s2.push(f5);
          } else
            s2.push(h5);
          s2.length >= 4096 && (a2 += String.fromCharCode.apply(String, i(s2)), s2.length = 0);
        }
        return s2.length > 0 && (a2 += String.fromCharCode.apply(String, i(s2))), a2;
      }
      var f2 = o ? new TextDecoder() : null, l = "undefined" != typeof process ? 200 : 0;
      var p2 = function(t2, e2) {
        this.type = t2, this.data = e2;
      };
      function d2(t2, e2, r5) {
        var n2 = Math.floor(r5 / 4294967296), i2 = r5;
        t2.setUint32(e2, n2), t2.setUint32(e2 + 4, i2);
      }
      function y2(t2, e2) {
        var r5 = t2.getInt32(e2), n2 = t2.getUint32(e2 + 4), i2 = r5 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r5 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && 0 === n2, o2 = r5 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        return i2 || o2 ? BigInt(r5) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r5 + n2;
      }
      var w = -1;
      function v2(t2) {
        var e2 = t2.sec, r5 = t2.nsec;
        if (e2 >= 0 && r5 >= 0 && e2 <= 17179869183) {
          if (0 === r5 && e2 <= 4294967295) {
            var n2 = new Uint8Array(4);
            return (s2 = new DataView(n2.buffer)).setUint32(0, e2), n2;
          }
          var i2 = e2 / 4294967296, o2 = 4294967295 & e2;
          n2 = new Uint8Array(8);
          return (s2 = new DataView(n2.buffer)).setUint32(0, r5 << 2 | 3 & i2), s2.setUint32(4, o2), n2;
        }
        var s2;
        n2 = new Uint8Array(12);
        return (s2 = new DataView(n2.buffer)).setUint32(0, r5), d2(s2, 4, e2), n2;
      }
      function g5(t2) {
        var e2 = t2.getTime(), r5 = Math.floor(e2 / 1e3), n2 = 1e6 * (e2 - 1e3 * r5), i2 = Math.floor(n2 / 1e9);
        return { sec: r5 + i2, nsec: n2 - 1e9 * i2 };
      }
      function b2(t2) {
        return t2 instanceof Date ? v2(g5(t2)) : null;
      }
      function U2(t2) {
        var e2 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
        switch (t2.byteLength) {
          case 4:
            return { sec: e2.getUint32(0), nsec: 0 };
          case 8:
            var r5 = e2.getUint32(0);
            return { sec: 4294967296 * (3 & r5) + e2.getUint32(4), nsec: r5 >>> 2 };
          case 12:
            return { sec: y2(e2, 4), nsec: e2.getUint32(0) };
          default:
            throw new Error("Unrecognized data size for timestamp: " + t2.length);
        }
      }
      function m2(t2) {
        var e2 = U2(t2);
        return new Date(1e3 * e2.sec + e2.nsec / 1e6);
      }
      var x2 = { type: w, encode: b2, decode: m2 }, S2 = function() {
        function t2() {
          this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x2);
        }
        return t2.prototype.register = function(t5) {
          var e2 = t5.type, r5 = t5.encode, n2 = t5.decode;
          if (e2 >= 0)
            this.encoders[e2] = r5, this.decoders[e2] = n2;
          else {
            var i2 = 1 + e2;
            this.builtInEncoders[i2] = r5, this.builtInDecoders[i2] = n2;
          }
        }, t2.prototype.tryToEncode = function(t5, e2) {
          for (var r5 = 0; r5 < this.builtInEncoders.length; r5++) {
            if (null != (n2 = this.builtInEncoders[r5])) {
              if (null != (i2 = n2(t5, e2)))
                return new p2(-1 - r5, i2);
            }
          }
          for (r5 = 0; r5 < this.encoders.length; r5++) {
            var n2, i2;
            if (null != (n2 = this.encoders[r5])) {
              if (null != (i2 = n2(t5, e2)))
                return new p2(r5, i2);
            }
          }
          return t5 instanceof p2 ? t5 : null;
        }, t2.prototype.decode = function(t5, e2, r5) {
          var n2 = e2 < 0 ? this.builtInDecoders[-1 - e2] : this.decoders[e2];
          return n2 ? n2(t5, e2, r5) : new p2(e2, t5);
        }, t2.defaultCodec = new t2(), t2;
      }();
      function B2(t2) {
        return t2 instanceof Uint8Array ? t2 : ArrayBuffer.isView(t2) ? new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength) : t2 instanceof ArrayBuffer ? new Uint8Array(t2) : Uint8Array.from(t2);
      }
      var E2 = function(t2) {
        var e2 = "function" == typeof Symbol && Symbol.iterator, r5 = e2 && t2[e2], n2 = 0;
        if (r5)
          return r5.call(t2);
        if (t2 && "number" == typeof t2.length)
          return { next: function() {
            return t2 && n2 >= t2.length && (t2 = void 0), { value: t2 && t2[n2++], done: !t2 };
          } };
        throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, I = function() {
        function t2(t5, e2, r5, n2, i2, o2, s2, a2) {
          void 0 === t5 && (t5 = S2.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r5 && (r5 = 100), void 0 === n2 && (n2 = 2048), void 0 === i2 && (i2 = false), void 0 === o2 && (o2 = false), void 0 === s2 && (s2 = false), void 0 === a2 && (a2 = false), this.extensionCodec = t5, this.context = e2, this.maxDepth = r5, this.initialBufferSize = n2, this.sortKeys = i2, this.forceFloat32 = o2, this.ignoreUndefined = s2, this.forceIntegerToFloat = a2, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
        }
        return t2.prototype.getUint8Array = function() {
          return this.bytes.subarray(0, this.pos);
        }, t2.prototype.reinitializeState = function() {
          this.pos = 0;
        }, t2.prototype.encode = function(t5) {
          return this.reinitializeState(), this.doEncode(t5, 1), this.getUint8Array();
        }, t2.prototype.doEncode = function(t5, e2) {
          if (e2 > this.maxDepth)
            throw new Error("Too deep objects in depth " + e2);
          null == t5 ? this.encodeNil() : "boolean" == typeof t5 ? this.encodeBoolean(t5) : "number" == typeof t5 ? this.encodeNumber(t5) : "string" == typeof t5 ? this.encodeString(t5) : "bigint" == typeof t5 ? this.encodebigint(t5) : this.encodeObject(t5, e2);
        }, t2.prototype.ensureBufferSizeToWrite = function(t5) {
          var e2 = this.pos + t5;
          this.view.byteLength < e2 && this.resizeBuffer(2 * e2);
        }, t2.prototype.resizeBuffer = function(t5) {
          var e2 = new ArrayBuffer(t5), r5 = new Uint8Array(e2), n2 = new DataView(e2);
          r5.set(this.bytes), this.view = n2, this.bytes = r5;
        }, t2.prototype.encodeNil = function() {
          this.writeU8(192);
        }, t2.prototype.encodeBoolean = function(t5) {
          false === t5 ? this.writeU8(194) : this.writeU8(195);
        }, t2.prototype.encodeNumber = function(t5) {
          Number.isSafeInteger(t5) && !this.forceIntegerToFloat ? t5 >= 0 ? t5 < 128 ? this.writeU8(t5) : t5 < 256 ? (this.writeU8(204), this.writeU8(t5)) : t5 < 65536 ? (this.writeU8(205), this.writeU16(t5)) : t5 < 4294967296 ? (this.writeU8(206), this.writeU32(t5)) : (this.writeU8(207), this.writeU64(t5)) : t5 >= -32 ? this.writeU8(224 | t5 + 32) : t5 >= -128 ? (this.writeU8(208), this.writeI8(t5)) : t5 >= -32768 ? (this.writeU8(209), this.writeI16(t5)) : t5 >= -2147483648 ? (this.writeU8(210), this.writeI32(t5)) : (this.writeU8(211), this.writeI64(t5)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t5)) : (this.writeU8(203), this.writeF64(t5));
        }, t2.prototype.encodebigint = function(t5) {
          t5 >= BigInt(0) ? t5 < BigInt(128) ? this.writeU8(Number(t5)) : t5 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(t5))) : t5 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(t5))) : t5 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(t5))) : (this.writeU8(207), this.writeBig64(t5)) : t5 >= BigInt(-32) ? this.writeU8(224 | Number(t5) + 32) : t5 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(t5))) : t5 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(t5))) : t5 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(t5))) : (this.writeU8(211), this.writeBig64(t5));
        }, t2.prototype.writeStringHeader = function(t5) {
          if (t5 < 32)
            this.writeU8(160 + t5);
          else if (t5 < 256)
            this.writeU8(217), this.writeU8(t5);
          else if (t5 < 65536)
            this.writeU8(218), this.writeU16(t5);
          else {
            if (!(t5 < 4294967296))
              throw new Error("Too long string: " + t5 + " bytes in UTF-8");
            this.writeU8(219), this.writeU32(t5);
          }
        }, t2.prototype.encodeString = function(t5) {
          var e2 = t5.length;
          if (o && e2 > h2) {
            var r5 = s(t5);
            this.ensureBufferSizeToWrite(5 + r5), this.writeStringHeader(r5), u3(t5, this.bytes, this.pos), this.pos += r5;
          } else {
            r5 = s(t5);
            this.ensureBufferSizeToWrite(5 + r5), this.writeStringHeader(r5), function(t6, e5, r6) {
              for (var n2 = t6.length, i2 = r6, o2 = 0; o2 < n2; ) {
                var s2 = t6.charCodeAt(o2++);
                if (0 != (4294967168 & s2)) {
                  if (0 == (4294965248 & s2))
                    e5[i2++] = s2 >> 6 & 31 | 192;
                  else {
                    if (s2 >= 55296 && s2 <= 56319 && o2 < n2) {
                      var a2 = t6.charCodeAt(o2);
                      56320 == (64512 & a2) && (++o2, s2 = ((1023 & s2) << 10) + (1023 & a2) + 65536);
                    }
                    0 == (4294901760 & s2) ? (e5[i2++] = s2 >> 12 & 15 | 224, e5[i2++] = s2 >> 6 & 63 | 128) : (e5[i2++] = s2 >> 18 & 7 | 240, e5[i2++] = s2 >> 12 & 63 | 128, e5[i2++] = s2 >> 6 & 63 | 128);
                  }
                  e5[i2++] = 63 & s2 | 128;
                } else
                  e5[i2++] = s2;
              }
            }(t5, this.bytes, this.pos), this.pos += r5;
          }
        }, t2.prototype.encodeObject = function(t5, e2) {
          var r5 = this.extensionCodec.tryToEncode(t5, this.context);
          if (null != r5)
            this.encodeExtension(r5);
          else if (Array.isArray(t5))
            this.encodeArray(t5, e2);
          else if (ArrayBuffer.isView(t5))
            this.encodeBinary(t5);
          else {
            if ("object" != typeof t5)
              throw new Error("Unrecognized object: " + Object.prototype.toString.apply(t5));
            this.encodeMap(t5, e2);
          }
        }, t2.prototype.encodeBinary = function(t5) {
          var e2 = t5.byteLength;
          if (e2 < 256)
            this.writeU8(196), this.writeU8(e2);
          else if (e2 < 65536)
            this.writeU8(197), this.writeU16(e2);
          else {
            if (!(e2 < 4294967296))
              throw new Error("Too large binary: " + e2);
            this.writeU8(198), this.writeU32(e2);
          }
          var r5 = B2(t5);
          this.writeU8a(r5);
        }, t2.prototype.encodeArray = function(t5, e2) {
          var r5, n2, i2 = t5.length;
          if (i2 < 16)
            this.writeU8(144 + i2);
          else if (i2 < 65536)
            this.writeU8(220), this.writeU16(i2);
          else {
            if (!(i2 < 4294967296))
              throw new Error("Too large array: " + i2);
            this.writeU8(221), this.writeU32(i2);
          }
          try {
            for (var o2 = E2(t5), s2 = o2.next(); !s2.done; s2 = o2.next()) {
              var a2 = s2.value;
              this.doEncode(a2, e2 + 1);
            }
          } catch (t6) {
            r5 = { error: t6 };
          } finally {
            try {
              s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r5)
                throw r5.error;
            }
          }
        }, t2.prototype.countWithoutUndefined = function(t5, e2) {
          var r5, n2, i2 = 0;
          try {
            for (var o2 = E2(e2), s2 = o2.next(); !s2.done; s2 = o2.next()) {
              void 0 !== t5[s2.value] && i2++;
            }
          } catch (t6) {
            r5 = { error: t6 };
          } finally {
            try {
              s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r5)
                throw r5.error;
            }
          }
          return i2;
        }, t2.prototype.encodeMap = function(t5, e2) {
          var r5, n2, i2 = Object.keys(t5);
          this.sortKeys && i2.sort();
          var o2 = this.ignoreUndefined ? this.countWithoutUndefined(t5, i2) : i2.length;
          if (o2 < 16)
            this.writeU8(128 + o2);
          else if (o2 < 65536)
            this.writeU8(222), this.writeU16(o2);
          else {
            if (!(o2 < 4294967296))
              throw new Error("Too large map object: " + o2);
            this.writeU8(223), this.writeU32(o2);
          }
          try {
            for (var s2 = E2(i2), a2 = s2.next(); !a2.done; a2 = s2.next()) {
              var h5 = a2.value, u5 = t5[h5];
              this.ignoreUndefined && void 0 === u5 || (this.encodeString(h5), this.doEncode(u5, e2 + 1));
            }
          } catch (t6) {
            r5 = { error: t6 };
          } finally {
            try {
              a2 && !a2.done && (n2 = s2.return) && n2.call(s2);
            } finally {
              if (r5)
                throw r5.error;
            }
          }
        }, t2.prototype.encodeExtension = function(t5) {
          var e2 = t5.data.length;
          if (1 === e2)
            this.writeU8(212);
          else if (2 === e2)
            this.writeU8(213);
          else if (4 === e2)
            this.writeU8(214);
          else if (8 === e2)
            this.writeU8(215);
          else if (16 === e2)
            this.writeU8(216);
          else if (e2 < 256)
            this.writeU8(199), this.writeU8(e2);
          else if (e2 < 65536)
            this.writeU8(200), this.writeU16(e2);
          else {
            if (!(e2 < 4294967296))
              throw new Error("Too large extension object: " + e2);
            this.writeU8(201), this.writeU32(e2);
          }
          this.writeI8(t5.type), this.writeU8a(t5.data);
        }, t2.prototype.writeU8 = function(t5) {
          this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t5), this.pos++;
        }, t2.prototype.writeU8a = function(t5) {
          var e2 = t5.length;
          this.ensureBufferSizeToWrite(e2), this.bytes.set(t5, this.pos), this.pos += e2;
        }, t2.prototype.writeI8 = function(t5) {
          this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t5), this.pos++;
        }, t2.prototype.writeU16 = function(t5) {
          this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t5), this.pos += 2;
        }, t2.prototype.writeI16 = function(t5) {
          this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t5), this.pos += 2;
        }, t2.prototype.writeU32 = function(t5) {
          this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t5), this.pos += 4;
        }, t2.prototype.writeI32 = function(t5) {
          this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t5), this.pos += 4;
        }, t2.prototype.writeF32 = function(t5) {
          this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t5), this.pos += 4;
        }, t2.prototype.writeF64 = function(t5) {
          this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t5), this.pos += 8;
        }, t2.prototype.writeU64 = function(t5) {
          this.ensureBufferSizeToWrite(8), function(t6, e2, r5) {
            var n2 = r5 / 4294967296, i2 = r5;
            t6.setUint32(e2, n2), t6.setUint32(e2 + 4, i2);
          }(this.view, this.pos, t5), this.pos += 8;
        }, t2.prototype.writeI64 = function(t5) {
          this.ensureBufferSizeToWrite(8), d2(this.view, this.pos, t5), this.pos += 8;
        }, t2.prototype.writeBig64 = function(t5) {
          this.ensureBufferSizeToWrite(8), function(t6, e2, r5) {
            var n2 = Number(r5 / BigInt(4294967296)), i2 = Number(r5 % BigInt(4294967296));
            n2 < 0 && 0 !== i2 && (n2 -= 1), t6.setUint32(e2, n2), t6.setUint32(e2 + 4, i2);
          }(this.view, this.pos, t5), this.pos += 8;
        }, t2;
      }(), A2 = {};
      function T(t2, e2) {
        return void 0 === e2 && (e2 = A2), new I(e2.extensionCodec, e2.context, e2.maxDepth, e2.initialBufferSize, e2.sortKeys, e2.forceFloat32, e2.ignoreUndefined, e2.forceIntegerToFloat).encode(t2);
      }
      function L2(t2) {
        return (t2 < 0 ? "-" : "") + "0x" + Math.abs(t2).toString(16).padStart(2, "0");
      }
      var M = function() {
        function t2(t5, e2) {
          void 0 === t5 && (t5 = 16), void 0 === e2 && (e2 = 16), this.maxKeyLength = t5, this.maxLengthPerKey = e2, this.hit = 0, this.miss = 0, this.caches = [];
          for (var r5 = 0; r5 < this.maxKeyLength; r5++)
            this.caches.push([]);
        }
        return t2.prototype.canBeCached = function(t5) {
          return t5 > 0 && t5 <= this.maxKeyLength;
        }, t2.prototype.get = function(t5, e2, r5) {
          var n2 = this.caches[r5 - 1], i2 = n2.length;
          t:
            for (var o2 = 0; o2 < i2; o2++) {
              for (var s2 = n2[o2], a2 = s2.bytes, h5 = 0; h5 < r5; h5++)
                if (a2[h5] !== t5[e2 + h5])
                  continue t;
              return s2.value;
            }
          return null;
        }, t2.prototype.store = function(t5, e2) {
          var r5 = this.caches[t5.length - 1], n2 = { bytes: t5, value: e2 };
          r5.length >= this.maxLengthPerKey ? r5[Math.random() * r5.length | 0] = n2 : r5.push(n2);
        }, t2.prototype.decode = function(t5, e2, r5) {
          var n2 = this.get(t5, e2, r5);
          if (null != n2)
            return this.hit++, n2;
          this.miss++;
          var i2 = c(t5, e2, r5), o2 = Uint8Array.prototype.slice.call(t5, e2, e2 + r5);
          return this.store(o2, i2), i2;
        }, t2;
      }(), k2 = function(t2, e2, r5, n2) {
        return new (r5 || (r5 = Promise))(function(i2, o2) {
          function s2(t5) {
            try {
              h5(n2.next(t5));
            } catch (t6) {
              o2(t6);
            }
          }
          function a2(t5) {
            try {
              h5(n2.throw(t5));
            } catch (t6) {
              o2(t6);
            }
          }
          function h5(t5) {
            var e5;
            t5.done ? i2(t5.value) : (e5 = t5.value, e5 instanceof r5 ? e5 : new r5(function(t6) {
              t6(e5);
            })).then(s2, a2);
          }
          h5((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, z2 = function(t2, e2) {
        var r5, n2, i2, o2, s2 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o5) {
          return function(a3) {
            return function(o7) {
              if (r5)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r5 = 1, n2 && (i2 = 2 & o7[0] ? n2.return : o7[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o7[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o7 = [2 & o7[0], i2.value]), o7[0]) {
                    case 0:
                    case 1:
                      i2 = o7;
                      break;
                    case 4:
                      return s2.label++, { value: o7[1], done: false };
                    case 5:
                      s2.label++, n2 = o7[1], o7 = [0];
                      continue;
                    case 7:
                      o7 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o7[0] && 2 !== o7[0])) {
                        s2 = 0;
                        continue;
                      }
                      if (3 === o7[0] && (!i2 || o7[1] > i2[0] && o7[1] < i2[3])) {
                        s2.label = o7[1];
                        break;
                      }
                      if (6 === o7[0] && s2.label < i2[1]) {
                        s2.label = i2[1], i2 = o7;
                        break;
                      }
                      if (i2 && s2.label < i2[2]) {
                        s2.label = i2[2], s2.ops.push(o7);
                        break;
                      }
                      i2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  o7 = e2.call(t2, s2);
                } catch (t5) {
                  o7 = [6, t5], n2 = 0;
                } finally {
                  r5 = i2 = 0;
                }
              if (5 & o7[0])
                throw o7[1];
              return { value: o7[0] ? o7[1] : void 0, done: true };
            }([o5, a3]);
          };
        }
      }, D2 = function(t2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var e2, r5 = t2[Symbol.asyncIterator];
        return r5 ? r5.call(t2) : (t2 = "function" == typeof __values ? __values(t2) : t2[Symbol.iterator](), e2 = {}, n2("next"), n2("throw"), n2("return"), e2[Symbol.asyncIterator] = function() {
          return this;
        }, e2);
        function n2(r6) {
          e2[r6] = t2[r6] && function(e5) {
            return new Promise(function(n3, i2) {
              (function(t5, e6, r7, n5) {
                Promise.resolve(n5).then(function(e7) {
                  t5({ value: e7, done: r7 });
                }, e6);
              })(n3, i2, (e5 = t2[r6](e5)).done, e5.value);
            });
          };
        }
      }, N2 = function(t2) {
        return this instanceof N2 ? (this.v = t2, this) : new N2(t2);
      }, C2 = function(t2, e2, r5) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var n2, i2 = r5.apply(t2, e2 || []), o2 = [];
        return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
          return this;
        }, n2;
        function s2(t5) {
          i2[t5] && (n2[t5] = function(e5) {
            return new Promise(function(r6, n3) {
              o2.push([t5, e5, r6, n3]) > 1 || a2(t5, e5);
            });
          });
        }
        function a2(t5, e5) {
          try {
            (r6 = i2[t5](e5)).value instanceof N2 ? Promise.resolve(r6.value.v).then(h5, u5) : c2(o2[0][2], r6);
          } catch (t6) {
            c2(o2[0][3], t6);
          }
          var r6;
        }
        function h5(t5) {
          a2("next", t5);
        }
        function u5(t5) {
          a2("throw", t5);
        }
        function c2(t5, e5) {
          t5(e5), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
        }
      }, P5 = new DataView(new ArrayBuffer(0)), F2 = new Uint8Array(P5.buffer), j2 = function() {
        try {
          P5.getInt8(0);
        } catch (t2) {
          return t2.constructor;
        }
        throw new Error("never reached");
      }(), _ = new j2("Insufficient data"), W5 = new M(), O2 = function() {
        function t2(t5, e2, r5, n2, i2, o2, s2, a2) {
          void 0 === t5 && (t5 = S2.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r5 && (r5 = 4294967295), void 0 === n2 && (n2 = 4294967295), void 0 === i2 && (i2 = 4294967295), void 0 === o2 && (o2 = 4294967295), void 0 === s2 && (s2 = 4294967295), void 0 === a2 && (a2 = W5), this.extensionCodec = t5, this.context = e2, this.maxStrLength = r5, this.maxBinLength = n2, this.maxArrayLength = i2, this.maxMapLength = o2, this.maxExtLength = s2, this.keyDecoder = a2, this.totalPos = 0, this.pos = 0, this.view = P5, this.bytes = F2, this.headByte = -1, this.stack = [];
        }
        return t2.prototype.reinitializeState = function() {
          this.totalPos = 0, this.headByte = -1;
        }, t2.prototype.setBuffer = function(t5) {
          this.bytes = B2(t5), this.view = function(t6) {
            if (t6 instanceof ArrayBuffer)
              return new DataView(t6);
            var e2 = B2(t6);
            return new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
          }(this.bytes), this.pos = 0;
        }, t2.prototype.appendBuffer = function(t5) {
          if (-1 !== this.headByte || this.hasRemaining()) {
            var e2 = this.bytes.subarray(this.pos), r5 = B2(t5), n2 = new Uint8Array(e2.length + r5.length);
            n2.set(e2), n2.set(r5, e2.length), this.setBuffer(n2);
          } else
            this.setBuffer(t5);
        }, t2.prototype.hasRemaining = function(t5) {
          return void 0 === t5 && (t5 = 1), this.view.byteLength - this.pos >= t5;
        }, t2.prototype.createNoExtraBytesError = function(t5) {
          var e2 = this.view, r5 = this.pos;
          return new RangeError("Extra " + (e2.byteLength - r5) + " of " + e2.byteLength + " byte(s) found at buffer[" + t5 + "]");
        }, t2.prototype.decode = function(t5) {
          return this.reinitializeState(), this.setBuffer(t5), this.doDecodeSingleSync();
        }, t2.prototype.doDecodeSingleSync = function() {
          var t5 = this.doDecodeSync();
          if (this.hasRemaining())
            throw this.createNoExtraBytesError(this.pos);
          return t5;
        }, t2.prototype.decodeAsync = function(t5) {
          var e2, r5, n2, i2;
          return k2(this, void 0, void 0, function() {
            var o2, s2, a2, h5, u5, c2, f5, l2;
            return z2(this, function(p5) {
              switch (p5.label) {
                case 0:
                  o2 = false, p5.label = 1;
                case 1:
                  p5.trys.push([1, 6, 7, 12]), e2 = D2(t5), p5.label = 2;
                case 2:
                  return [4, e2.next()];
                case 3:
                  if ((r5 = p5.sent()).done)
                    return [3, 5];
                  if (a2 = r5.value, o2)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(a2);
                  try {
                    s2 = this.doDecodeSync(), o2 = true;
                  } catch (t6) {
                    if (!(t6 instanceof j2))
                      throw t6;
                  }
                  this.totalPos += this.pos, p5.label = 4;
                case 4:
                  return [3, 2];
                case 5:
                  return [3, 12];
                case 6:
                  return h5 = p5.sent(), n2 = { error: h5 }, [3, 12];
                case 7:
                  return p5.trys.push([7, , 10, 11]), r5 && !r5.done && (i2 = e2.return) ? [4, i2.call(e2)] : [3, 9];
                case 8:
                  p5.sent(), p5.label = 9;
                case 9:
                  return [3, 11];
                case 10:
                  if (n2)
                    throw n2.error;
                  return [7];
                case 11:
                  return [7];
                case 12:
                  if (o2) {
                    if (this.hasRemaining())
                      throw this.createNoExtraBytesError(this.totalPos);
                    return [2, s2];
                  }
                  throw c2 = (u5 = this).headByte, f5 = u5.pos, l2 = u5.totalPos, new RangeError("Insufficient data in parcing " + L2(c2) + " at " + l2 + " (" + f5 + " in the current buffer)");
              }
            });
          });
        }, t2.prototype.decodeArrayStream = function(t5) {
          return this.decodeMultiAsync(t5, true);
        }, t2.prototype.decodeStream = function(t5) {
          return this.decodeMultiAsync(t5, false);
        }, t2.prototype.decodeMultiAsync = function(t5, e2) {
          return C2(this, arguments, function() {
            var r5, n2, i2, o2, s2, a2, h5, u5, c2;
            return z2(this, function(f5) {
              switch (f5.label) {
                case 0:
                  r5 = e2, n2 = -1, f5.label = 1;
                case 1:
                  f5.trys.push([1, 13, 14, 19]), i2 = D2(t5), f5.label = 2;
                case 2:
                  return [4, N2(i2.next())];
                case 3:
                  if ((o2 = f5.sent()).done)
                    return [3, 12];
                  if (s2 = o2.value, e2 && 0 === n2)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(s2), r5 && (n2 = this.readArraySize(), r5 = false, this.complete()), f5.label = 4;
                case 4:
                  f5.trys.push([4, 9, , 10]), f5.label = 5;
                case 5:
                  return [4, N2(this.doDecodeSync())];
                case 6:
                  return [4, f5.sent()];
                case 7:
                  return f5.sent(), 0 == --n2 ? [3, 8] : [3, 5];
                case 8:
                  return [3, 10];
                case 9:
                  if (!((a2 = f5.sent()) instanceof j2))
                    throw a2;
                  return [3, 10];
                case 10:
                  this.totalPos += this.pos, f5.label = 11;
                case 11:
                  return [3, 2];
                case 12:
                  return [3, 19];
                case 13:
                  return h5 = f5.sent(), u5 = { error: h5 }, [3, 19];
                case 14:
                  return f5.trys.push([14, , 17, 18]), o2 && !o2.done && (c2 = i2.return) ? [4, N2(c2.call(i2))] : [3, 16];
                case 15:
                  f5.sent(), f5.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  if (u5)
                    throw u5.error;
                  return [7];
                case 18:
                  return [7];
                case 19:
                  return [2];
              }
            });
          });
        }, t2.prototype.doDecodeSync = function() {
          t:
            for (; ; ) {
              var t5 = this.readHeadByte(), e2 = void 0;
              if (t5 >= 224)
                e2 = t5 - 256;
              else if (t5 < 192)
                if (t5 < 128)
                  e2 = t5;
                else if (t5 < 144) {
                  if (0 !== (n2 = t5 - 128)) {
                    this.pushMapState(n2), this.complete();
                    continue t;
                  }
                  e2 = {};
                } else if (t5 < 160) {
                  if (0 !== (n2 = t5 - 144)) {
                    this.pushArrayState(n2), this.complete();
                    continue t;
                  }
                  e2 = [];
                } else {
                  var r5 = t5 - 160;
                  e2 = this.decodeUtf8String(r5, 0);
                }
              else if (192 === t5)
                e2 = null;
              else if (194 === t5)
                e2 = false;
              else if (195 === t5)
                e2 = true;
              else if (202 === t5)
                e2 = this.readF32();
              else if (203 === t5)
                e2 = this.readF64();
              else if (204 === t5)
                e2 = this.readU8();
              else if (205 === t5)
                e2 = this.readU16();
              else if (206 === t5)
                e2 = this.readU32();
              else if (207 === t5)
                e2 = this.readU64();
              else if (208 === t5)
                e2 = this.readI8();
              else if (209 === t5)
                e2 = this.readI16();
              else if (210 === t5)
                e2 = this.readI32();
              else if (211 === t5)
                e2 = this.readI64();
              else if (217 === t5) {
                r5 = this.lookU8();
                e2 = this.decodeUtf8String(r5, 1);
              } else if (218 === t5) {
                r5 = this.lookU16();
                e2 = this.decodeUtf8String(r5, 2);
              } else if (219 === t5) {
                r5 = this.lookU32();
                e2 = this.decodeUtf8String(r5, 4);
              } else if (220 === t5) {
                if (0 !== (n2 = this.readU16())) {
                  this.pushArrayState(n2), this.complete();
                  continue t;
                }
                e2 = [];
              } else if (221 === t5) {
                if (0 !== (n2 = this.readU32())) {
                  this.pushArrayState(n2), this.complete();
                  continue t;
                }
                e2 = [];
              } else if (222 === t5) {
                if (0 !== (n2 = this.readU16())) {
                  this.pushMapState(n2), this.complete();
                  continue t;
                }
                e2 = {};
              } else if (223 === t5) {
                if (0 !== (n2 = this.readU32())) {
                  this.pushMapState(n2), this.complete();
                  continue t;
                }
                e2 = {};
              } else if (196 === t5) {
                var n2 = this.lookU8();
                e2 = this.decodeBinary(n2, 1);
              } else if (197 === t5) {
                n2 = this.lookU16();
                e2 = this.decodeBinary(n2, 2);
              } else if (198 === t5) {
                n2 = this.lookU32();
                e2 = this.decodeBinary(n2, 4);
              } else if (212 === t5)
                e2 = this.decodeExtension(1, 0);
              else if (213 === t5)
                e2 = this.decodeExtension(2, 0);
              else if (214 === t5)
                e2 = this.decodeExtension(4, 0);
              else if (215 === t5)
                e2 = this.decodeExtension(8, 0);
              else if (216 === t5)
                e2 = this.decodeExtension(16, 0);
              else if (199 === t5) {
                n2 = this.lookU8();
                e2 = this.decodeExtension(n2, 1);
              } else if (200 === t5) {
                n2 = this.lookU16();
                e2 = this.decodeExtension(n2, 2);
              } else {
                if (201 !== t5)
                  throw new Error("Unrecognized type byte: " + L2(t5));
                n2 = this.lookU32();
                e2 = this.decodeExtension(n2, 4);
              }
              this.complete();
              for (var i2 = this.stack; i2.length > 0; ) {
                var o2 = i2[i2.length - 1];
                if (0 === o2.type) {
                  if (o2.array[o2.position] = e2, o2.position++, o2.position !== o2.size)
                    continue t;
                  i2.pop(), e2 = o2.array;
                } else {
                  if (1 === o2.type) {
                    if (s2 = void 0, "string" !== (s2 = typeof e2) && "number" !== s2)
                      throw new Error("The type of key must be string or number but " + typeof e2);
                    o2.key = e2, o2.type = 2;
                    continue t;
                  }
                  if (o2.map[o2.key] = e2, o2.readCount++, o2.readCount !== o2.size) {
                    o2.key = null, o2.type = 1;
                    continue t;
                  }
                  i2.pop(), e2 = o2.map;
                }
              }
              return e2;
            }
          var s2;
        }, t2.prototype.readHeadByte = function() {
          return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
        }, t2.prototype.complete = function() {
          this.headByte = -1;
        }, t2.prototype.readArraySize = function() {
          var t5 = this.readHeadByte();
          switch (t5) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default:
              if (t5 < 160)
                return t5 - 144;
              throw new Error("Unrecognized array type byte: " + L2(t5));
          }
        }, t2.prototype.pushMapState = function(t5) {
          if (t5 > this.maxMapLength)
            throw new Error("Max length exceeded: map length (" + t5 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
          this.stack.push({ type: 1, size: t5, key: null, readCount: 0, map: {} });
        }, t2.prototype.pushArrayState = function(t5) {
          if (t5 > this.maxArrayLength)
            throw new Error("Max length exceeded: array length (" + t5 + ") > maxArrayLength (" + this.maxArrayLength + ")");
          this.stack.push({ type: 0, size: t5, array: new Array(t5), position: 0 });
        }, t2.prototype.decodeUtf8String = function(t5, e2) {
          var r5;
          if (t5 > this.maxStrLength)
            throw new Error("Max length exceeded: UTF-8 byte length (" + t5 + ") > maxStrLength (" + this.maxStrLength + ")");
          if (this.bytes.byteLength < this.pos + e2 + t5)
            throw _;
          var n2, i2 = this.pos + e2;
          return n2 = this.stateIsMapKey() && (null === (r5 = this.keyDecoder) || void 0 === r5 ? void 0 : r5.canBeCached(t5)) ? this.keyDecoder.decode(this.bytes, i2, t5) : o && t5 > l ? function(t6, e5, r6) {
            var n3 = t6.subarray(e5, e5 + r6);
            return f2.decode(n3);
          }(this.bytes, i2, t5) : c(this.bytes, i2, t5), this.pos += e2 + t5, n2;
        }, t2.prototype.stateIsMapKey = function() {
          return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
        }, t2.prototype.decodeBinary = function(t5, e2) {
          if (t5 > this.maxBinLength)
            throw new Error("Max length exceeded: bin length (" + t5 + ") > maxBinLength (" + this.maxBinLength + ")");
          if (!this.hasRemaining(t5 + e2))
            throw _;
          var r5 = this.pos + e2, n2 = this.bytes.subarray(r5, r5 + t5);
          return this.pos += e2 + t5, n2;
        }, t2.prototype.decodeExtension = function(t5, e2) {
          if (t5 > this.maxExtLength)
            throw new Error("Max length exceeded: ext length (" + t5 + ") > maxExtLength (" + this.maxExtLength + ")");
          var r5 = this.view.getInt8(this.pos + e2), n2 = this.decodeBinary(t5, e2 + 1);
          return this.extensionCodec.decode(n2, r5, this.context);
        }, t2.prototype.lookU8 = function() {
          return this.view.getUint8(this.pos);
        }, t2.prototype.lookU16 = function() {
          return this.view.getUint16(this.pos);
        }, t2.prototype.lookU32 = function() {
          return this.view.getUint32(this.pos);
        }, t2.prototype.readU8 = function() {
          var t5 = this.view.getUint8(this.pos);
          return this.pos++, t5;
        }, t2.prototype.readI8 = function() {
          var t5 = this.view.getInt8(this.pos);
          return this.pos++, t5;
        }, t2.prototype.readU16 = function() {
          var t5 = this.view.getUint16(this.pos);
          return this.pos += 2, t5;
        }, t2.prototype.readI16 = function() {
          var t5 = this.view.getInt16(this.pos);
          return this.pos += 2, t5;
        }, t2.prototype.readU32 = function() {
          var t5 = this.view.getUint32(this.pos);
          return this.pos += 4, t5;
        }, t2.prototype.readI32 = function() {
          var t5 = this.view.getInt32(this.pos);
          return this.pos += 4, t5;
        }, t2.prototype.readU64 = function() {
          var t5, e2, r5, n2, i2 = (t5 = this.view, e2 = this.pos, r5 = t5.getUint32(e2), n2 = t5.getUint32(e2 + 4), r5 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r5) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r5 + n2);
          return this.pos += 8, i2;
        }, t2.prototype.readI64 = function() {
          var t5 = y2(this.view, this.pos);
          return this.pos += 8, t5;
        }, t2.prototype.readF32 = function() {
          var t5 = this.view.getFloat32(this.pos);
          return this.pos += 4, t5;
        }, t2.prototype.readF64 = function() {
          var t5 = this.view.getFloat64(this.pos);
          return this.pos += 8, t5;
        }, t2;
      }(), R5 = {};
      function V(t2, e2) {
        return void 0 === e2 && (e2 = R5), new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decode(t2);
      }
      var K5 = function(t2, e2) {
        var r5, n2, i2, o2, s2 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o5) {
          return function(a3) {
            return function(o7) {
              if (r5)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r5 = 1, n2 && (i2 = 2 & o7[0] ? n2.return : o7[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o7[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o7 = [2 & o7[0], i2.value]), o7[0]) {
                    case 0:
                    case 1:
                      i2 = o7;
                      break;
                    case 4:
                      return s2.label++, { value: o7[1], done: false };
                    case 5:
                      s2.label++, n2 = o7[1], o7 = [0];
                      continue;
                    case 7:
                      o7 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o7[0] && 2 !== o7[0])) {
                        s2 = 0;
                        continue;
                      }
                      if (3 === o7[0] && (!i2 || o7[1] > i2[0] && o7[1] < i2[3])) {
                        s2.label = o7[1];
                        break;
                      }
                      if (6 === o7[0] && s2.label < i2[1]) {
                        s2.label = i2[1], i2 = o7;
                        break;
                      }
                      if (i2 && s2.label < i2[2]) {
                        s2.label = i2[2], s2.ops.push(o7);
                        break;
                      }
                      i2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  o7 = e2.call(t2, s2);
                } catch (t5) {
                  o7 = [6, t5], n2 = 0;
                } finally {
                  r5 = i2 = 0;
                }
              if (5 & o7[0])
                throw o7[1];
              return { value: o7[0] ? o7[1] : void 0, done: true };
            }([o5, a3]);
          };
        }
      }, G = function(t2) {
        return this instanceof G ? (this.v = t2, this) : new G(t2);
      }, H5 = function(t2, e2, r5) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var n2, i2 = r5.apply(t2, e2 || []), o2 = [];
        return n2 = {}, s2("next"), s2("throw"), s2("return"), n2[Symbol.asyncIterator] = function() {
          return this;
        }, n2;
        function s2(t5) {
          i2[t5] && (n2[t5] = function(e5) {
            return new Promise(function(r6, n3) {
              o2.push([t5, e5, r6, n3]) > 1 || a2(t5, e5);
            });
          });
        }
        function a2(t5, e5) {
          try {
            (r6 = i2[t5](e5)).value instanceof G ? Promise.resolve(r6.value.v).then(h5, u5) : c2(o2[0][2], r6);
          } catch (t6) {
            c2(o2[0][3], t6);
          }
          var r6;
        }
        function h5(t5) {
          a2("next", t5);
        }
        function u5(t5) {
          a2("throw", t5);
        }
        function c2(t5, e5) {
          t5(e5), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
        }
      };
      function X2(t2) {
        if (null == t2)
          throw new Error("Assertion Failure: value must not be null nor undefined");
      }
      function q2(t2) {
        return null != t2[Symbol.asyncIterator] ? t2 : function(t5) {
          return H5(this, arguments, function() {
            var e2, r5, n2, i2;
            return K5(this, function(o2) {
              switch (o2.label) {
                case 0:
                  e2 = t5.getReader(), o2.label = 1;
                case 1:
                  o2.trys.push([1, , 9, 10]), o2.label = 2;
                case 2:
                  return [4, G(e2.read())];
                case 3:
                  return r5 = o2.sent(), n2 = r5.done, i2 = r5.value, n2 ? [4, G(void 0)] : [3, 5];
                case 4:
                  return [2, o2.sent()];
                case 5:
                  return X2(i2), [4, G(i2)];
                case 6:
                  return [4, o2.sent()];
                case 7:
                  return o2.sent(), [3, 2];
                case 8:
                  return [3, 10];
                case 9:
                  return e2.releaseLock(), [7];
                case 10:
                  return [2];
              }
            });
          });
        }(t2);
      }
      var J5 = function(t2, e2, r5, n2) {
        return new (r5 || (r5 = Promise))(function(i2, o2) {
          function s2(t5) {
            try {
              h5(n2.next(t5));
            } catch (t6) {
              o2(t6);
            }
          }
          function a2(t5) {
            try {
              h5(n2.throw(t5));
            } catch (t6) {
              o2(t6);
            }
          }
          function h5(t5) {
            var e5;
            t5.done ? i2(t5.value) : (e5 = t5.value, e5 instanceof r5 ? e5 : new r5(function(t6) {
              t6(e5);
            })).then(s2, a2);
          }
          h5((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, Q2 = function(t2, e2) {
        var r5, n2, i2, o2, s2 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o5) {
          return function(a3) {
            return function(o7) {
              if (r5)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r5 = 1, n2 && (i2 = 2 & o7[0] ? n2.return : o7[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o7[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o7 = [2 & o7[0], i2.value]), o7[0]) {
                    case 0:
                    case 1:
                      i2 = o7;
                      break;
                    case 4:
                      return s2.label++, { value: o7[1], done: false };
                    case 5:
                      s2.label++, n2 = o7[1], o7 = [0];
                      continue;
                    case 7:
                      o7 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o7[0] && 2 !== o7[0])) {
                        s2 = 0;
                        continue;
                      }
                      if (3 === o7[0] && (!i2 || o7[1] > i2[0] && o7[1] < i2[3])) {
                        s2.label = o7[1];
                        break;
                      }
                      if (6 === o7[0] && s2.label < i2[1]) {
                        s2.label = i2[1], i2 = o7;
                        break;
                      }
                      if (i2 && s2.label < i2[2]) {
                        s2.label = i2[2], s2.ops.push(o7);
                        break;
                      }
                      i2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  o7 = e2.call(t2, s2);
                } catch (t5) {
                  o7 = [6, t5], n2 = 0;
                } finally {
                  r5 = i2 = 0;
                }
              if (5 & o7[0])
                throw o7[1];
              return { value: o7[0] ? o7[1] : void 0, done: true };
            }([o5, a3]);
          };
        }
      };
      function Y(t2, e2) {
        return void 0 === e2 && (e2 = R5), J5(this, void 0, void 0, function() {
          var r5;
          return Q2(this, function(n2) {
            return r5 = q2(t2), [2, new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeAsync(r5)];
          });
        });
      }
      function Z(t2, e2) {
        void 0 === e2 && (e2 = R5);
        var r5 = q2(t2);
        return new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeArrayStream(r5);
      }
      function $(t2, e2) {
        void 0 === e2 && (e2 = R5);
        var r5 = q2(t2);
        return new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeStream(r5);
      }
    }]);
  });
})(msgpack_min);
const ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function containsEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0) {
        return { containsEmpty: true, firstEmptyKey: key };
      }
    }
  }
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function encode(obj) {
  const emptyCheck = containsEmpty(obj);
  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  }
  const options = { sortKeys: true };
  return msgpack_minExports.encode(obj, options);
}
function decode$1(buffer2) {
  return msgpack_minExports.decode(buffer2);
}
function translateBoxReference(reference, foreignApps, appIndex) {
  const referenceId = reference.appIndex;
  const referenceName = reference.name;
  const isOwnReference = referenceId === 0 || referenceId === appIndex;
  let index2 = 0;
  if (foreignApps != null) {
    index2 = foreignApps.indexOf(referenceId) + 1;
  }
  if (index2 === 0 && !isOwnReference) {
    throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
  }
  return { i: index2, n: referenceName };
}
function translateBoxReferences(references, foreignApps, appIndex) {
  if (references == null)
    return [];
  return references.map((bx) => translateBoxReference(bx, foreignApps, appIndex));
}
var TransactionType;
(function(TransactionType2) {
  TransactionType2["pay"] = "pay";
  TransactionType2["keyreg"] = "keyreg";
  TransactionType2["acfg"] = "acfg";
  TransactionType2["axfer"] = "axfer";
  TransactionType2["afrz"] = "afrz";
  TransactionType2["appl"] = "appl";
  TransactionType2["stpf"] = "stpf";
})(TransactionType || (TransactionType = {}));
function isTransactionType(s) {
  return s === TransactionType.pay || s === TransactionType.keyreg || s === TransactionType.acfg || s === TransactionType.axfer || s === TransactionType.afrz || s === TransactionType.appl || s === TransactionType.stpf;
}
var OnApplicationComplete;
(function(OnApplicationComplete2) {
  OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
  OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
  OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
  OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
  OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
  OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
})(OnApplicationComplete || (OnApplicationComplete = {}));
const ALGORAND_TRANSACTION_LENGTH = 52;
const ALGORAND_MIN_TX_FEE = 1e3;
const ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
const ALGORAND_MAX_ASSET_DECIMALS = 19;
const NUM_ADDL_BYTES_AFTER_SIGNING = 75;
const ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH = 5;
const ALGORAND_TRANSACTION_ADDRESS_LENGTH = 32;
const ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH = 5;
const ASSET_METADATA_HASH_LENGTH = 32;
const KEYREG_VOTE_KEY_LENGTH = 32;
const KEYREG_SELECTION_KEY_LENGTH = 32;
const KEYREG_STATE_PROOF_KEY_LENGTH = 64;
function getKeyregKey(input, inputName, length) {
  if (input == null) {
    return void 0;
  }
  let inputAsBuffer;
  if (typeof input === "string") {
    inputAsBuffer = buffer.Buffer.from(input, "base64");
  } else if (input.constructor === Uint8Array) {
    inputAsBuffer = buffer.Buffer.from(input);
  } else if (buffer.Buffer.isBuffer(input)) {
    inputAsBuffer = input;
  }
  if (inputAsBuffer == null || inputAsBuffer.byteLength !== length) {
    throw Error(`${inputName} must be a ${length} byte Uint8Array or Buffer or base64 string.`);
  }
  return inputAsBuffer;
}
let Transaction$1 = class Transaction {
  constructor({ ...transaction }) {
    this.name = "Transaction";
    this.tag = buffer.Buffer.from("TX");
    const defaults = {
      type: TransactionType.pay,
      flatFee: false,
      nonParticipation: false
    };
    if (typeof transaction.type === "undefined") {
      transaction.type = defaults.type;
    }
    if (typeof transaction.flatFee === "undefined") {
      transaction.flatFee = defaults.flatFee;
    }
    if (transaction.type === TransactionType.keyreg && typeof transaction.voteKey !== "undefined" && typeof transaction.nonParticipation === "undefined") {
      transaction.nonParticipation = defaults.nonParticipation;
    }
    if (transaction.suggestedParams !== void 0) {
      const reference = transaction;
      reference.genesisHash = reference.suggestedParams.genesisHash;
      reference.fee = reference.suggestedParams.fee;
      if (reference.suggestedParams.flatFee !== void 0)
        reference.flatFee = reference.suggestedParams.flatFee;
      reference.firstRound = reference.suggestedParams.firstRound;
      reference.lastRound = reference.suggestedParams.lastRound;
      reference.genesisID = reference.suggestedParams.genesisID;
    }
    const txn = transaction;
    txn.from = decodeAddress(txn.from);
    if (txn.to !== void 0)
      txn.to = decodeAddress(txn.to);
    if (txn.closeRemainderTo !== void 0)
      txn.closeRemainderTo = decodeAddress(txn.closeRemainderTo);
    if (txn.assetManager !== void 0)
      txn.assetManager = decodeAddress(txn.assetManager);
    if (txn.assetReserve !== void 0)
      txn.assetReserve = decodeAddress(txn.assetReserve);
    if (txn.assetFreeze !== void 0)
      txn.assetFreeze = decodeAddress(txn.assetFreeze);
    if (txn.assetClawback !== void 0)
      txn.assetClawback = decodeAddress(txn.assetClawback);
    if (txn.assetRevocationTarget !== void 0)
      txn.assetRevocationTarget = decodeAddress(txn.assetRevocationTarget);
    if (txn.freezeAccount !== void 0)
      txn.freezeAccount = decodeAddress(txn.freezeAccount);
    if (txn.reKeyTo !== void 0)
      txn.reKeyTo = decodeAddress(txn.reKeyTo);
    if (txn.genesisHash === void 0)
      throw Error("genesis hash must be specified and in a base64 string.");
    txn.genesisHash = buffer.Buffer.from(txn.genesisHash, "base64");
    if (txn.amount !== void 0 && (!(Number.isSafeInteger(txn.amount) || typeof txn.amount === "bigint" && txn.amount <= BigInt("0xffffffffffffffff")) || txn.amount < 0))
      throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (!Number.isSafeInteger(txn.fee) || txn.fee < 0)
      throw Error("fee must be a positive number and smaller than 2^53-1");
    if (!Number.isSafeInteger(txn.firstRound) || txn.firstRound < 0)
      throw Error("firstRound must be a positive number");
    if (!Number.isSafeInteger(txn.lastRound) || txn.lastRound < 0)
      throw Error("lastRound must be a positive number");
    if (txn.extraPages !== void 0 && (!Number.isInteger(txn.extraPages) || txn.extraPages < 0 || txn.extraPages > 3))
      throw Error("extraPages must be an Integer between and including 0 to 3");
    if (txn.assetTotal !== void 0 && (!(Number.isSafeInteger(txn.assetTotal) || typeof txn.assetTotal === "bigint" && txn.assetTotal <= BigInt("0xffffffffffffffff")) || txn.assetTotal < 0))
      throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (txn.assetDecimals !== void 0 && (!Number.isSafeInteger(txn.assetDecimals) || txn.assetDecimals < 0 || txn.assetDecimals > ALGORAND_MAX_ASSET_DECIMALS))
      throw Error(`assetDecimals must be a positive number and smaller than ${ALGORAND_MAX_ASSET_DECIMALS.toString()}`);
    if (txn.assetIndex !== void 0 && (!Number.isSafeInteger(txn.assetIndex) || txn.assetIndex < 0))
      throw Error("Asset index must be a positive number and smaller than 2^53-1");
    if (txn.appIndex !== void 0 && (!Number.isSafeInteger(txn.appIndex) || txn.appIndex < 0))
      throw Error("Application index must be a positive number and smaller than 2^53-1");
    if (txn.appLocalInts !== void 0 && (!Number.isSafeInteger(txn.appLocalInts) || txn.appLocalInts < 0))
      throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
    if (txn.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appLocalByteSlices) || txn.appLocalByteSlices < 0))
      throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalInts !== void 0 && (!Number.isSafeInteger(txn.appGlobalInts) || txn.appGlobalInts < 0))
      throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appGlobalByteSlices) || txn.appGlobalByteSlices < 0))
      throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appApprovalProgram !== void 0) {
      if (txn.appApprovalProgram.constructor !== Uint8Array)
        throw Error("appApprovalProgram must be a Uint8Array.");
    }
    if (txn.appClearProgram !== void 0) {
      if (txn.appClearProgram.constructor !== Uint8Array)
        throw Error("appClearProgram must be a Uint8Array.");
    }
    if (txn.appArgs !== void 0) {
      if (!Array.isArray(txn.appArgs))
        throw Error("appArgs must be an Array of Uint8Array.");
      txn.appArgs = txn.appArgs.slice();
      txn.appArgs.forEach((arg) => {
        if (arg.constructor !== Uint8Array)
          throw Error("each element of AppArgs must be a Uint8Array.");
      });
    } else {
      txn.appArgs = [];
    }
    if (txn.appAccounts !== void 0) {
      if (!Array.isArray(txn.appAccounts))
        throw Error("appAccounts must be an Array of addresses.");
      txn.appAccounts = txn.appAccounts.map((addressAsString) => decodeAddress(addressAsString));
    }
    if (txn.appForeignApps !== void 0) {
      if (!Array.isArray(txn.appForeignApps))
        throw Error("appForeignApps must be an Array of integers.");
      txn.appForeignApps = txn.appForeignApps.slice();
      txn.appForeignApps.forEach((foreignAppIndex) => {
        if (!Number.isSafeInteger(foreignAppIndex) || foreignAppIndex < 0)
          throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.appForeignAssets !== void 0) {
      if (!Array.isArray(txn.appForeignAssets))
        throw Error("appForeignAssets must be an Array of integers.");
      txn.appForeignAssets = txn.appForeignAssets.slice();
      txn.appForeignAssets.forEach((foreignAssetIndex) => {
        if (!Number.isSafeInteger(foreignAssetIndex) || foreignAssetIndex < 0)
          throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.boxes !== void 0) {
      if (!Array.isArray(txn.boxes))
        throw Error("boxes must be an Array of BoxReference.");
      txn.boxes = txn.boxes.slice();
      txn.boxes.forEach((box) => {
        if (!Number.isSafeInteger(box.appIndex) || box.name.constructor !== Uint8Array)
          throw Error("box app index must be a number and name must be an Uint8Array.");
      });
    }
    if (txn.assetMetadataHash !== void 0 && txn.assetMetadataHash.length !== 0) {
      if (typeof txn.assetMetadataHash === "string") {
        txn.assetMetadataHash = new Uint8Array(buffer.Buffer.from(txn.assetMetadataHash));
      }
      if (txn.assetMetadataHash.constructor !== Uint8Array || txn.assetMetadataHash.byteLength !== ASSET_METADATA_HASH_LENGTH) {
        throw Error(`assetMetadataHash must be a ${ASSET_METADATA_HASH_LENGTH} byte Uint8Array or string.`);
      }
      if (txn.assetMetadataHash.every((value) => value === 0)) {
        txn.assetMetadataHash = void 0;
      }
    } else {
      txn.assetMetadataHash = void 0;
    }
    if (txn.note !== void 0) {
      if (txn.note.constructor !== Uint8Array)
        throw Error("note must be a Uint8Array.");
    } else {
      txn.note = new Uint8Array(0);
    }
    if (txn.lease !== void 0) {
      if (txn.lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (txn.lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      if (txn.lease.every((value) => value === 0)) {
        txn.lease = new Uint8Array(0);
      }
    } else {
      txn.lease = new Uint8Array(0);
    }
    txn.voteKey = getKeyregKey(txn.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH);
    txn.selectionKey = getKeyregKey(txn.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH);
    txn.stateProofKey = getKeyregKey(txn.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH);
    if (txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.stateProofKey || txn.voteLast || txn.voteKeyDilution)) {
      throw new Error("nonParticipation is true but participation params are present.");
    }
    if (!txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.stateProofKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution) && !(txn.voteKey && txn.selectionKey && txn.voteFirst && txn.voteLast && txn.voteKeyDilution)) {
      throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
    }
    delete txn.suggestedParams;
    Object.assign(this, removeUndefinedProperties(txn));
    if (!txn.flatFee) {
      this.fee *= this.estimateSize();
      if (this.fee < ALGORAND_MIN_TX_FEE) {
        this.fee = ALGORAND_MIN_TX_FEE;
      }
    }
    this.group = void 0;
    if (txn.stateProofType !== void 0 && (!Number.isSafeInteger(txn.stateProofType) || txn.stateProofType < 0))
      throw Error("State Proof type must be a positive number and smaller than 2^53-1");
    if (txn.stateProofMessage !== void 0) {
      if (txn.stateProofMessage.constructor !== Uint8Array)
        throw Error("stateProofMessage must be a Uint8Array.");
    } else {
      txn.stateProofMessage = new Uint8Array(0);
    }
    if (txn.stateProof !== void 0) {
      if (txn.stateProof.constructor !== Uint8Array)
        throw Error("stateProof must be a Uint8Array.");
    } else {
      txn.stateProof = new Uint8Array(0);
    }
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    if (this.type === "pay") {
      const txn = {
        amt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: "pay",
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group
      };
      if (this.closeRemainderTo !== void 0 && encodeAddress(this.closeRemainderTo.publicKey) !== ALGORAND_ZERO_ADDRESS_STRING) {
        txn.close = buffer.Buffer.from(this.closeRemainderTo.publicKey);
      }
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.to !== void 0)
        txn.rcv = buffer.Buffer.from(this.to.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.rekey)
        delete txn.rekey;
      return txn;
    }
    if (this.type === "keyreg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        votekey: this.voteKey,
        selkey: this.selectionKey,
        sprfkey: this.stateProofKey,
        votefst: this.voteFirst,
        votelst: this.voteLast,
        votekd: this.voteKeyDilution
      };
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.nonParticipation) {
        txn.nonpart = true;
      }
      if (!txn.selkey)
        delete txn.selkey;
      if (!txn.votekey)
        delete txn.votekey;
      if (!txn.sprfkey)
        delete txn.sprfkey;
      if (!txn.votefst)
        delete txn.votefst;
      if (!txn.votelst)
        delete txn.votelst;
      if (!txn.votekd)
        delete txn.votekd;
      return txn;
    }
    if (this.type === "acfg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        caid: this.assetIndex,
        apar: {
          t: this.assetTotal,
          df: this.assetDefaultFrozen,
          dc: this.assetDecimals
        }
      };
      if (this.assetManager !== void 0)
        txn.apar.m = buffer.Buffer.from(this.assetManager.publicKey);
      if (this.assetReserve !== void 0)
        txn.apar.r = buffer.Buffer.from(this.assetReserve.publicKey);
      if (this.assetFreeze !== void 0)
        txn.apar.f = buffer.Buffer.from(this.assetFreeze.publicKey);
      if (this.assetClawback !== void 0)
        txn.apar.c = buffer.Buffer.from(this.assetClawback.publicKey);
      if (this.assetName !== void 0)
        txn.apar.an = this.assetName;
      if (this.assetUnitName !== void 0)
        txn.apar.un = this.assetUnitName;
      if (this.assetURL !== void 0)
        txn.apar.au = this.assetURL;
      if (this.assetMetadataHash !== void 0)
        txn.apar.am = buffer.Buffer.from(this.assetMetadataHash);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (!txn.caid)
        delete txn.caid;
      if (!txn.apar.t && !txn.apar.un && !txn.apar.an && !txn.apar.df && !txn.apar.m && !txn.apar.r && !txn.apar.f && !txn.apar.c && !txn.apar.au && !txn.apar.am && !txn.apar.dc) {
        delete txn.apar;
      } else {
        if (!txn.apar.t)
          delete txn.apar.t;
        if (!txn.apar.dc)
          delete txn.apar.dc;
        if (!txn.apar.un)
          delete txn.apar.un;
        if (!txn.apar.an)
          delete txn.apar.an;
        if (!txn.apar.df)
          delete txn.apar.df;
        if (!txn.apar.m)
          delete txn.apar.m;
        if (!txn.apar.r)
          delete txn.apar.r;
        if (!txn.apar.f)
          delete txn.apar.f;
        if (!txn.apar.c)
          delete txn.apar.c;
        if (!txn.apar.au)
          delete txn.apar.au;
        if (!txn.apar.am)
          delete txn.apar.am;
      }
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "axfer") {
      const txn = {
        aamt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        arcv: buffer.Buffer.from(this.to.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        xaid: this.assetIndex
      };
      if (this.closeRemainderTo !== void 0)
        txn.aclose = buffer.Buffer.from(this.closeRemainderTo.publicKey);
      if (this.assetRevocationTarget !== void 0)
        txn.asnd = buffer.Buffer.from(this.assetRevocationTarget.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.aamt)
        delete txn.aamt;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.aclose)
        delete txn.aclose;
      if (!txn.asnd)
        delete txn.asnd;
      if (!txn.rekey)
        delete txn.rekey;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "afrz") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        faid: this.assetIndex,
        afrz: this.freezeState
      };
      if (this.freezeAccount !== void 0)
        txn.fadd = buffer.Buffer.from(this.freezeAccount.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.afrz)
        delete txn.afrz;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "appl") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        apid: this.appIndex,
        apan: this.appOnComplete,
        apls: {
          nui: this.appLocalInts,
          nbs: this.appLocalByteSlices
        },
        apgs: {
          nui: this.appGlobalInts,
          nbs: this.appGlobalByteSlices
        },
        apfa: this.appForeignApps,
        apas: this.appForeignAssets,
        apep: this.extraPages,
        apbx: translateBoxReferences(this.boxes, this.appForeignApps, this.appIndex)
      };
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.appApprovalProgram !== void 0) {
        txn.apap = buffer.Buffer.from(this.appApprovalProgram);
      }
      if (this.appClearProgram !== void 0) {
        txn.apsu = buffer.Buffer.from(this.appClearProgram);
      }
      if (this.appArgs !== void 0) {
        txn.apaa = this.appArgs.map((arg) => buffer.Buffer.from(arg));
      }
      if (this.appAccounts !== void 0) {
        txn.apat = this.appAccounts.map((decodedAddress) => buffer.Buffer.from(decodedAddress.publicKey));
      }
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apls.nui)
        delete txn.apls.nui;
      if (!txn.apls.nbs)
        delete txn.apls.nbs;
      if (!txn.apls.nui && !txn.apls.nbs)
        delete txn.apls;
      if (!txn.apgs.nui)
        delete txn.apgs.nui;
      if (!txn.apgs.nbs)
        delete txn.apgs.nbs;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apgs.nui && !txn.apgs.nbs)
        delete txn.apgs;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      for (const box of txn.apbx) {
        if (!box.i)
          delete box.i;
        if (!box.n || !box.n.length)
          delete box.n;
      }
      if (!txn.apbx || !txn.apbx.length)
        delete txn.apbx;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "stpf") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        sptype: this.stateProofType,
        spmsg: buffer.Buffer.from(this.stateProofMessage),
        sp: buffer.Buffer.from(this.stateProof)
      };
      if (!txn.sptype)
        delete txn.sptype;
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    return void 0;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txnForEnc) {
    const txn = Object.create(this.prototype);
    txn.name = "Transaction";
    txn.tag = buffer.Buffer.from("TX");
    txn.genesisID = txnForEnc.gen;
    txn.genesisHash = buffer.Buffer.from(txnForEnc.gh);
    if (!isTransactionType(txnForEnc.type)) {
      throw new Error(`Unrecognized transaction type: ${txnForEnc.type}`);
    }
    txn.type = txnForEnc.type;
    txn.fee = txnForEnc.fee;
    txn.firstRound = txnForEnc.fv;
    txn.lastRound = txnForEnc.lv;
    txn.note = new Uint8Array(txnForEnc.note);
    txn.lease = new Uint8Array(txnForEnc.lx);
    txn.from = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.snd)));
    if (txnForEnc.grp !== void 0)
      txn.group = buffer.Buffer.from(txnForEnc.grp);
    if (txnForEnc.rekey !== void 0)
      txn.reKeyTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rekey)));
    if (txnForEnc.type === "pay") {
      txn.amount = txnForEnc.amt;
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rcv)));
      if (txnForEnc.close !== void 0)
        txn.closeRemainderTo = decodeAddress(encodeAddress(txnForEnc.close));
    } else if (txnForEnc.type === "keyreg") {
      if (txnForEnc.votekey !== void 0) {
        txn.voteKey = buffer.Buffer.from(txnForEnc.votekey);
      }
      if (txnForEnc.selkey !== void 0) {
        txn.selectionKey = buffer.Buffer.from(txnForEnc.selkey);
      }
      if (txnForEnc.sprfkey !== void 0) {
        txn.stateProofKey = buffer.Buffer.from(txnForEnc.sprfkey);
      }
      if (txnForEnc.votekd !== void 0) {
        txn.voteKeyDilution = txnForEnc.votekd;
      }
      if (txnForEnc.votefst !== void 0) {
        txn.voteFirst = txnForEnc.votefst;
      }
      if (txnForEnc.votelst !== void 0) {
        txn.voteLast = txnForEnc.votelst;
      }
      if (txnForEnc.nonpart !== void 0) {
        txn.nonParticipation = txnForEnc.nonpart;
      }
    } else if (txnForEnc.type === "acfg") {
      if (txnForEnc.caid !== void 0) {
        txn.assetIndex = txnForEnc.caid;
      }
      if (txnForEnc.apar !== void 0) {
        txn.assetTotal = txnForEnc.apar.t;
        txn.assetDefaultFrozen = txnForEnc.apar.df;
        if (txnForEnc.apar.dc !== void 0)
          txn.assetDecimals = txnForEnc.apar.dc;
        if (txnForEnc.apar.m !== void 0)
          txn.assetManager = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.m)));
        if (txnForEnc.apar.r !== void 0)
          txn.assetReserve = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.r)));
        if (txnForEnc.apar.f !== void 0)
          txn.assetFreeze = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.f)));
        if (txnForEnc.apar.c !== void 0)
          txn.assetClawback = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.c)));
        if (txnForEnc.apar.un !== void 0)
          txn.assetUnitName = txnForEnc.apar.un;
        if (txnForEnc.apar.an !== void 0)
          txn.assetName = txnForEnc.apar.an;
        if (txnForEnc.apar.au !== void 0)
          txn.assetURL = txnForEnc.apar.au;
        if (txnForEnc.apar.am !== void 0)
          txn.assetMetadataHash = txnForEnc.apar.am;
      }
    } else if (txnForEnc.type === "axfer") {
      if (txnForEnc.xaid !== void 0) {
        txn.assetIndex = txnForEnc.xaid;
      }
      if (txnForEnc.aamt !== void 0)
        txn.amount = txnForEnc.aamt;
      if (txnForEnc.aclose !== void 0) {
        txn.closeRemainderTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.aclose)));
      }
      if (txnForEnc.asnd !== void 0) {
        txn.assetRevocationTarget = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.asnd)));
      }
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.arcv)));
    } else if (txnForEnc.type === "afrz") {
      if (txnForEnc.afrz !== void 0) {
        txn.freezeState = txnForEnc.afrz;
      }
      if (txnForEnc.faid !== void 0) {
        txn.assetIndex = txnForEnc.faid;
      }
      txn.freezeAccount = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.fadd)));
    } else if (txnForEnc.type === "appl") {
      if (txnForEnc.apid !== void 0) {
        txn.appIndex = txnForEnc.apid;
      }
      if (txnForEnc.apan !== void 0) {
        txn.appOnComplete = txnForEnc.apan;
      }
      if (txnForEnc.apls !== void 0) {
        if (txnForEnc.apls.nui !== void 0)
          txn.appLocalInts = txnForEnc.apls.nui;
        if (txnForEnc.apls.nbs !== void 0)
          txn.appLocalByteSlices = txnForEnc.apls.nbs;
      }
      if (txnForEnc.apgs !== void 0) {
        if (txnForEnc.apgs.nui !== void 0)
          txn.appGlobalInts = txnForEnc.apgs.nui;
        if (txnForEnc.apgs.nbs !== void 0)
          txn.appGlobalByteSlices = txnForEnc.apgs.nbs;
      }
      if (txnForEnc.apep !== void 0) {
        txn.extraPages = txnForEnc.apep;
      }
      if (txnForEnc.apap !== void 0) {
        txn.appApprovalProgram = new Uint8Array(txnForEnc.apap);
      }
      if (txnForEnc.apsu !== void 0) {
        txn.appClearProgram = new Uint8Array(txnForEnc.apsu);
      }
      if (txnForEnc.apaa !== void 0) {
        txn.appArgs = txnForEnc.apaa.map((arg) => new Uint8Array(arg));
      }
      if (txnForEnc.apat !== void 0) {
        txn.appAccounts = txnForEnc.apat.map((addressBytes) => decodeAddress(encodeAddress(new Uint8Array(addressBytes))));
      }
      if (txnForEnc.apfa !== void 0) {
        txn.appForeignApps = txnForEnc.apfa;
      }
      if (txnForEnc.apas !== void 0) {
        txn.appForeignAssets = txnForEnc.apas;
      }
      if (txnForEnc.apbx !== void 0) {
        txn.boxes = txnForEnc.apbx.map((box) => ({
          // We return 0 for the app ID so that it's guaranteed translateBoxReferences will
          // translate the app index back to 0. If we instead returned the called app ID,
          // translateBoxReferences would translate the app index to a nonzero value if the called
          // app is also in the foreign app array.
          appIndex: box.i ? txn.appForeignApps[box.i - 1] : 0,
          name: box.n
        }));
      }
    } else if (txnForEnc.type === "stpf") {
      if (txnForEnc.sptype !== void 0) {
        txn.stateProofType = txnForEnc.sptype;
      }
      if (txnForEnc.sp !== void 0) {
        txn.stateProof = txnForEnc.sp;
      }
      if (txnForEnc.spmsg !== void 0) {
        txn.stateProofMessage = txnForEnc.spmsg;
      }
    }
    return txn;
  }
  estimateSize() {
    return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
  }
  bytesToSign() {
    const encodedMsg = this.toByte();
    return buffer.Buffer.from(concatArrays(this.tag, encodedMsg));
  }
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
  // returns the raw signature
  rawSignTxn(sk) {
    const toBeSigned = this.bytesToSign();
    const sig = sign(toBeSigned, sk);
    return buffer.Buffer.from(sig);
  }
  signTxn(sk) {
    const sTxn = {
      sig: this.rawSignTxn(sk),
      txn: this.get_obj_for_encoding()
    };
    const keypair = keyPairFromSecretKey(sk);
    const pubKeyFromSk = keypair.publicKey;
    if (encodeAddress(pubKeyFromSk) !== encodeAddress(this.from.publicKey)) {
      sTxn.sgnr = buffer.Buffer.from(pubKeyFromSk);
    }
    return new Uint8Array(encode(sTxn));
  }
  attachSignature(signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error("Invalid signature length");
    }
    const sTxn = {
      sig: buffer.Buffer.from(signature),
      txn: this.get_obj_for_encoding()
    };
    if (signerAddr !== encodeAddress(this.from.publicKey)) {
      const signerPublicKey = decodeAddress(signerAddr).publicKey;
      sTxn.sgnr = buffer.Buffer.from(signerPublicKey);
    }
    return new Uint8Array(encode(sTxn));
  }
  rawTxID() {
    const enMsg = this.toByte();
    const gh2 = buffer.Buffer.from(concatArrays(this.tag, enMsg));
    return buffer.Buffer.from(genericHash(gh2));
  }
  txID() {
    const hash = this.rawTxID();
    return base32Exports.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
  }
  // add a lease to a transaction not yet having
  // supply feePerByte to increment fee accordingly
  addLease(lease, feePerByte = 0) {
    let mutableLease;
    if (lease !== void 0) {
      if (lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      mutableLease = new Uint8Array(lease);
    } else {
      mutableLease = new Uint8Array(0);
    }
    this.lease = mutableLease;
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH + ALGORAND_TRANSACTION_LEASE_LENGTH) * feePerByte;
    }
  }
  // add the rekey-to field to a transaction not yet having it
  // supply feePerByte to increment fee accordingly
  addRekey(reKeyTo, feePerByte = 0) {
    if (reKeyTo !== void 0) {
      this.reKeyTo = decodeAddress(reKeyTo);
    }
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH + ALGORAND_TRANSACTION_ADDRESS_LENGTH) * feePerByte;
    }
  }
  // build display dict for prettyPrint and toString
  // eslint-disable-next-line no-underscore-dangle
  _getDictForDisplay() {
    const forPrinting = {
      ...this
    };
    forPrinting.tag = forPrinting.tag.toString();
    forPrinting.from = encodeAddress(forPrinting.from.publicKey);
    if (forPrinting.to !== void 0)
      forPrinting.to = encodeAddress(forPrinting.to.publicKey);
    if (forPrinting.freezeAccount !== void 0)
      forPrinting.freezeAccount = encodeAddress(forPrinting.freezeAccount.publicKey);
    if (forPrinting.closeRemainderTo !== void 0)
      forPrinting.closeRemainderTo = encodeAddress(forPrinting.closeRemainderTo.publicKey);
    if (forPrinting.assetManager !== void 0)
      forPrinting.assetManager = encodeAddress(forPrinting.assetManager.publicKey);
    if (forPrinting.assetReserve !== void 0)
      forPrinting.assetReserve = encodeAddress(forPrinting.assetReserve.publicKey);
    if (forPrinting.assetFreeze !== void 0)
      forPrinting.assetFreeze = encodeAddress(forPrinting.assetFreeze.publicKey);
    if (forPrinting.assetClawback !== void 0)
      forPrinting.assetClawback = encodeAddress(forPrinting.assetClawback.publicKey);
    if (forPrinting.assetRevocationTarget !== void 0)
      forPrinting.assetRevocationTarget = encodeAddress(forPrinting.assetRevocationTarget.publicKey);
    if (forPrinting.reKeyTo !== void 0)
      forPrinting.reKeyTo = encodeAddress(forPrinting.reKeyTo.publicKey);
    forPrinting.genesisHash = forPrinting.genesisHash.toString("base64");
    return forPrinting;
  }
  // pretty print the transaction to console
  prettyPrint() {
    console.log(this._getDictForDisplay());
  }
  // get string representation
  toString() {
    return JSON.stringify(this._getDictForDisplay());
  }
};
function encodeUnsignedTransaction(transactionObject) {
  const objToEncode = transactionObject.get_obj_for_encoding();
  return encode(objToEncode);
}
function decodeUnsignedTransaction(transactionBuffer) {
  const partlyDecodedObject = decode$1(transactionBuffer);
  return Transaction$1.from_obj_for_encoding(partlyDecodedObject);
}
function decodeSignedTransaction(transactionBuffer) {
  const stxnDecoded = decode$1(transactionBuffer);
  const stxn = {
    ...stxnDecoded,
    txn: Transaction$1.from_obj_for_encoding(stxnDecoded.txn)
  };
  return stxn;
}
function instantiateTxnIfNeeded(transactionLike) {
  return transactionLike instanceof Transaction$1 ? transactionLike : new Transaction$1(transactionLike);
}
class Bid {
  constructor({ bidderKey, bidAmount, bidID, auctionKey, auctionID, maxPrice }) {
    this.name = "Bid";
    this.tag = buffer.Buffer.from([97, 66]);
    const decodedBidderKey = decodeAddress(bidderKey);
    const decodedAuctionKey = decodeAddress(auctionKey);
    if (!Number.isSafeInteger(bidAmount) || bidAmount < 0)
      throw Error("Bid amount must be positive and 2^53-1");
    if (!Number.isSafeInteger(bidID) || bidID < 0)
      throw Error("BidID must be positive and 2^53-1");
    if (!Number.isSafeInteger(auctionID) || auctionID < 0)
      throw Error("auctionID must be positive");
    Object.assign(this, {
      bidderKey: decodedBidderKey,
      bidAmount,
      bidID,
      auctionKey: decodedAuctionKey,
      auctionID,
      maxPrice
    });
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    return {
      bidder: buffer.Buffer.from(this.bidderKey.publicKey),
      cur: this.bidAmount,
      price: this.maxPrice,
      id: this.bidID,
      auc: buffer.Buffer.from(this.auctionKey.publicKey),
      aid: this.auctionID
    };
  }
  signBid(sk) {
    const encodedMsg = encode(this.get_obj_for_encoding());
    const toBeSigned = buffer.Buffer.from(concatArrays(this.tag, encodedMsg));
    const sig = sign(toBeSigned, sk);
    const sBid = {
      sig: buffer.Buffer.from(sig),
      bid: this.get_obj_for_encoding()
    };
    const note = {
      t: "b",
      b: sBid
    };
    return new Uint8Array(encode(note));
  }
}
const MICROALGOS_TO_ALGOS_RATIO = 1e6;
const INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
function microalgosToAlgos(microalgos) {
  if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
    throw new Error(INVALID_MICROALGOS_ERROR_MSG);
  }
  return microalgos / MICROALGOS_TO_ALGOS_RATIO;
}
function algosToMicroalgos(algos) {
  const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
  return Math.round(microalgos);
}
var browserPonyfillExports = {};
var browserPonyfill = {
  get exports() {
    return browserPonyfillExports;
  },
  set exports(v2) {
    browserPonyfillExports = v2;
  }
};
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F2.prototype = global2;
    return new F2();
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports2.Headers = Headers;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfillExports);
class URLTokenBaseHTTPError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "URLTokenBaseHTTPError";
    this.response = response;
  }
}
class URLTokenBaseHTTPClient {
  constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
    this.defaultHeaders = defaultHeaders;
    const fixedBaseServer = baseServer.endsWith("/") ? baseServer : `${baseServer}/`;
    const baseServerURL = new URL(fixedBaseServer);
    if (typeof port !== "undefined") {
      baseServerURL.port = port.toString();
    }
    if (baseServerURL.protocol.length === 0) {
      throw new Error("Invalid base server URL, protocol must be defined.");
    }
    this.baseURL = baseServerURL;
    this.tokenHeader = tokenHeader;
  }
  /**
   * Compute the URL for a path relative to the instance's address
   * @param relativePath - A path string
   * @param query - An optional key-value object of query parameters to add to the URL. If the
   *   relativePath already has query parameters on it, the additional parameters defined here will
   *   be added to the URL without modifying those (unless a key collision occurs).
   * @returns A URL string
   */
  getURL(relativePath, query) {
    let fixedRelativePath;
    if (relativePath.startsWith("./")) {
      fixedRelativePath = relativePath;
    } else if (relativePath.startsWith("/")) {
      fixedRelativePath = `.${relativePath}`;
    } else {
      fixedRelativePath = `./${relativePath}`;
    }
    const address = new URL(fixedRelativePath, this.baseURL);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        address.searchParams.set(key, value);
      }
    }
    return address.toString();
  }
  static formatFetchResponseHeaders(headers) {
    const headersObj = {};
    headers.forEach((key, value) => {
      headersObj[key] = value;
    });
    return headersObj;
  }
  static async checkHttpError(res) {
    if (res.ok) {
      return;
    }
    let body = null;
    let bodyErrorMessage = null;
    try {
      body = new Uint8Array(await res.arrayBuffer());
      const decoded = JSON.parse(buffer.Buffer.from(body).toString());
      if (decoded.message) {
        bodyErrorMessage = decoded.message;
      }
    } catch (_) {
    }
    let message = `Network request error. Received status ${res.status} (${res.statusText})`;
    if (bodyErrorMessage) {
      message += `: ${bodyErrorMessage}`;
    }
    throw new URLTokenBaseHTTPError(message, {
      body,
      status: res.status,
      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    });
  }
  static async formatFetchResponse(res) {
    await this.checkHttpError(res);
    return {
      body: new Uint8Array(await res.arrayBuffer()),
      status: res.status,
      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    };
  }
  async get(relativePath, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await browserPonyfillExports.fetch(this.getURL(relativePath, query), {
      mode: "cors",
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async post(relativePath, data, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await browserPonyfillExports.fetch(this.getURL(relativePath, query), {
      method: "POST",
      mode: "cors",
      body: data,
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async delete(relativePath, data, query, requestHeaders = {}) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders
    };
    const res = await browserPonyfillExports.fetch(this.getURL(relativePath, query), {
      method: "DELETE",
      mode: "cors",
      body: data,
      headers
    });
    return URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
}
function removeFalsyOrEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0)
        delete obj[key];
    }
  }
  return obj;
}
function tolowerCaseKeys(o) {
  return Object.keys(o).reduce((c, k2) => (c[k2.toLowerCase()] = o[k2], c), {});
}
function getAcceptFormat(query) {
  if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
    switch (query.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  } else
    return "application/json";
}
class HTTPClient {
  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
    if (baseServer !== void 0) {
      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
    } else {
      this.bc = bcOrTokenHeader;
    }
  }
  /**
   * Parse JSON using either the built-in JSON.parse or utils.parseJSON
   * depending on whether jsonOptions are provided or not
   *
   * @param text - JSON data
   * @param status - Status of the response (used in case parseJSON fails)
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   */
  static parseJSON(text, status, jsonOptions = {}) {
    try {
      if (Object.keys(jsonOptions).length === 0) {
        return text && JSON.parse(text);
      }
      return text && parseJSON(text, jsonOptions);
    } catch (err_) {
      const err = err_;
      err.rawResponse = text || null;
      err.statusCode = status;
      throw err;
    }
  }
  /**
   * Serialize the data according to the requestHeaders
   * Assumes that requestHeaders contain a key "content-type"
   * If the content-type is "application/json", data is JSON serialized
   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
   * or an Uint8Array
   * @private
   */
  static serializeData(data, requestHeaders) {
    if (!data) {
      return new Uint8Array(0);
    }
    if (requestHeaders["content-type"] === "application/json") {
      return new Uint8Array(buffer.Buffer.from(JSON.stringify(data)));
    }
    if (typeof data === "string") {
      return new Uint8Array(buffer.Buffer.from(data));
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  /**
   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
   * Parse the body in
   * Modifies in place res and return the result
   */
  static prepareResponse(res, format, parseBody, jsonOptions = {}) {
    let { body } = res;
    let text;
    if (format !== "application/msgpack") {
      text = body && buffer.Buffer.from(body).toString() || "";
    }
    if (parseBody && format === "application/json") {
      body = HTTPClient.parseJSON(text, res.status, jsonOptions);
    }
    return {
      ...res,
      body,
      text,
      ok: Math.trunc(res.status / 100) === 2
    };
  }
  /**
   * Prepare an error with a response
   * (the type of errors BaseHTTPClient are supposed to throw)
   * by adding the status and preparing the internal response
   * @private
   */
  static prepareResponseError(err) {
    if (err.response) {
      err.response = HTTPClient.prepareResponse(err.response, "application/json", true);
      err.status = err.response.status;
    }
    return err;
  }
  /**
   * Send a GET request.
   * @param relativePath - The path of the request.
   * @param query - An object containing the query parameters of the request.
   * @param requestHeaders - An object containing additional request headers to use.
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   * @param parseBody - An optional boolean indicating whether the response body should be parsed
   *   or not.
   * @returns Response object.
   */
  async get(relativePath, query, requestHeaders = {}, jsonOptions = {}, parseBody = true) {
    const format = getAcceptFormat(query);
    const fullHeaders = { ...requestHeaders, accept: format };
    try {
      const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);
      return HTTPClient.prepareResponse(res, format, parseBody, jsonOptions);
    } catch (err) {
      throw HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a POST request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   */
  async post(relativePath, data, requestHeaders = {}, query, parseBody = true) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders)
    };
    try {
      const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders);
      return HTTPClient.prepareResponse(res, "application/json", parseBody);
    } catch (err) {
      throw HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a DELETE request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   */
  async delete(relativePath, data, requestHeaders = {}, parseBody = true) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders)
    };
    const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
    return HTTPClient.prepareResponse(res, "application/json", parseBody);
  }
}
function convertTokenStringToTokenHeader(token = "", headerIdentifier) {
  const tokenHeader = {};
  tokenHeader[headerIdentifier] = token;
  return tokenHeader;
}
function isBaseHTTPClient(tbc) {
  return typeof tbc.get === "function";
}
class ServiceClient {
  constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
    if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
      this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
    } else {
      let tokenHeader;
      if (typeof tokenHeaderOrStrOrBaseClient === "string") {
        tokenHeader = convertTokenStringToTokenHeader(tokenHeaderOrStrOrBaseClient, tokenHeaderIdentifier);
      } else {
        tokenHeader = tokenHeaderOrStrOrBaseClient;
      }
      this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
    }
    this.intDecoding = IntDecoding$1.DEFAULT;
  }
  /**
   * Set the default int decoding method for all JSON requests this client creates.
   * @param method - \{"default" | "safe" | "mixed" | "bigint"\} method The method to use when parsing the
   *   response for request. Must be one of "default", "safe", "mixed", or "bigint". See
   *   JSONRequest.setIntDecoding for more details about what each method does.
   */
  setIntEncoding(method) {
    this.intDecoding = method;
  }
  /**
   * Get the default int decoding method for all JSON requests this client creates.
   */
  getIntEncoding() {
    return this.intDecoding;
  }
}
class JSONRequest {
  /**
   * @param client - HTTPClient object.
   * @param intDecoding - The method to use
   *   for decoding integers from this request's response. See the setIntDecoding method for more
   *   details.
   */
  constructor(client, intDecoding) {
    this.c = client;
    this.query = {};
    this.intDecoding = intDecoding || IntDecoding$1.DEFAULT;
  }
  /**
   * Prepare a JSON response before returning it.
   *
   * Use this method to change and restructure response
   * data as needed after receiving it from the `do()` method.
   * @param body - Response body received
   * @category JSONRequest
   */
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return body;
  }
  /**
   * Execute the request.
   * @param headers - Additional headers to send in the request. Optional.
   * @returns A promise which resolves to the parsed response data.
   * @category JSONRequest
   */
  async do(headers = {}) {
    const jsonOptions = {};
    if (this.intDecoding !== "default") {
      jsonOptions.intDecoding = this.intDecoding;
    }
    const res = await this.c.get(this.path(), this.query, headers, jsonOptions);
    return this.prepare(res.body);
  }
  /**
   * Execute the request, but do not process the response data in any way.
   * @param headers - Additional headers to send in the request. Optional.
   * @returns A promise which resolves to the raw response data, exactly as returned by the server.
   * @category JSONRequest
   */
  async doRaw(headers = {}) {
    const res = await this.c.get(this.path(), this.query, headers, {}, false);
    return res.body;
  }
  /**
   * Configure how integers in this request's JSON response will be decoded.
   *
   * The options are:
   * * "default": Integers will be decoded according to JSON.parse, meaning they will all be
   *   Numbers and any values greater than Number.MAX_SAFE_INTEGER will lose precision.
   * * "safe": All integers will be decoded as Numbers, but if any values are greater than
   *   Number.MAX_SAFE_INTEGER an error will be thrown.
   * * "mixed": Integers will be decoded as Numbers if they are less than or equal to
   *   Number.MAX_SAFE_INTEGER, otherwise they will be decoded as BigInts.
   * * "bigint": All integers will be decoded as BigInts.
   *
   * @param method - The method to use when parsing the
   *   response for this request. Must be one of "default", "safe", "mixed", or "bigint".
   * @category JSONRequest
   */
  setIntDecoding(method) {
    if (method !== "default" && method !== "safe" && method !== "mixed" && method !== "bigint")
      throw new Error(`Invalid method for int decoding: ${method}`);
    this.intDecoding = method;
    return this;
  }
}
class AccountInformation extends JSONRequest {
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Exclude assets and application data from results
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address)
   *        .exclude('all')
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
}
class AccountAssetInformation extends JSONRequest {
  constructor(c, intDecoding, account, assetID) {
    super(c, intDecoding);
    this.account = account;
    this.assetID = assetID;
    this.account = account;
    this.assetID = assetID;
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
}
class AccountApplicationInformation extends JSONRequest {
  constructor(c, intDecoding, account, applicationID) {
    super(c, intDecoding);
    this.account = account;
    this.applicationID = applicationID;
    this.account = account;
    this.applicationID = applicationID;
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
}
let Block$1 = class Block extends JSONRequest {
  constructor(c, roundNumber) {
    super(c);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
    this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
};
function setHeaders$1(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
class Compile extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/compile`;
  }
  sourcemap(map = true) {
    this.query.sourcemap = map;
    return this;
  }
  /**
   * Executes compile
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders$1(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.source), txHeaders, this.query);
    return res.body;
  }
}
class Dryrun extends JSONRequest {
  constructor(c, dr2) {
    super(c);
    this.blob = encode(dr2.get_obj_for_encoding(true));
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/teal/dryrun";
  }
  /**
   * Executes dryrun
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders$1(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.blob), txHeaders);
    return res.body;
  }
}
class Genesis extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/genesis";
  }
}
class GetAssetByID extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
}
class GetApplicationByID extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
}
class GetBlockHash extends JSONRequest {
  constructor(c, intDecoding, roundNumber) {
    super(c, intDecoding);
    if (!Number.isInteger(roundNumber))
      throw Error("roundNumber should be an integer");
    this.round = roundNumber;
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
}
function _is_primitive(val) {
  return val === void 0 || val == null || typeof val !== "object" && typeof val !== "function";
}
function _get_obj_for_encoding(val, binary) {
  let targetPropValue;
  if (val instanceof Uint8Array) {
    targetPropValue = binary ? val : buffer.Buffer.from(val).toString("base64");
  } else if (typeof val.get_obj_for_encoding === "function") {
    targetPropValue = val.get_obj_for_encoding(binary);
  } else if (Array.isArray(val)) {
    targetPropValue = [];
    for (const elem of val) {
      targetPropValue.push(_get_obj_for_encoding(elem, binary));
    }
  } else if (typeof val === "object") {
    const obj = {};
    for (const prop of Object.keys(val)) {
      obj[prop] = _get_obj_for_encoding(val[prop], binary);
    }
    targetPropValue = obj;
  } else if (_is_primitive(val)) {
    targetPropValue = val;
  } else {
    throw new Error(`Unsupported value: ${String(val)}`);
  }
  return targetPropValue;
}
class BaseModel {
  /**
   * Get an object ready for encoding to either JSON or msgpack.
   * @param binary - Use true to indicate that the encoding can handle raw binary objects
   *   (Uint8Arrays). Use false to indicate that raw binary objects should be converted to base64
   *   strings. True should be used for objects that will be encoded with msgpack, and false should
   *   be used for objects that will be encoded with JSON.
   */
  get_obj_for_encoding(binary = false) {
    const obj = {};
    for (const prop of Object.keys(this.attribute_map)) {
      const name = this.attribute_map[prop];
      const value = this[prop];
      if (typeof value !== "undefined") {
        obj[name] = value === null ? null : _get_obj_for_encoding(value, binary);
      }
    }
    return obj;
  }
}
let Account$1 = class Account extends BaseModel {
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param minBalance - MicroAlgo balance required by the account.
   * The requirement grows based on asset and application usage.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param createdApps - (appp) parameters of applications created by this account including app global
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * @param totalBoxBytes - (tbxb) The total number of bytes used by this account's app's box keys and
   * values.
   * @param totalBoxes - (tbx) The number of existing boxes created by this account's app.
   */
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, participation, rewardBase, sigType, totalBoxBytes, totalBoxes }) {
    super();
    this.address = address;
    this.amount = amount;
    this.amountWithoutPendingRewards = amountWithoutPendingRewards;
    this.minBalance = minBalance;
    this.pendingRewards = pendingRewards;
    this.rewards = rewards;
    this.round = round;
    this.status = status;
    this.totalAppsOptedIn = totalAppsOptedIn;
    this.totalAssetsOptedIn = totalAssetsOptedIn;
    this.totalCreatedApps = totalCreatedApps;
    this.totalCreatedAssets = totalCreatedAssets;
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = appsTotalExtraPages;
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = authAddr;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.participation = participation;
    this.rewardBase = rewardBase;
    this.sigType = sigType;
    this.totalBoxBytes = totalBoxBytes;
    this.totalBoxes = totalBoxes;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      amountWithoutPendingRewards: "amount-without-pending-rewards",
      minBalance: "min-balance",
      pendingRewards: "pending-rewards",
      rewards: "rewards",
      round: "round",
      status: "status",
      totalAppsOptedIn: "total-apps-opted-in",
      totalAssetsOptedIn: "total-assets-opted-in",
      totalCreatedApps: "total-created-apps",
      totalCreatedAssets: "total-created-assets",
      appsLocalState: "apps-local-state",
      appsTotalExtraPages: "apps-total-extra-pages",
      appsTotalSchema: "apps-total-schema",
      assets: "assets",
      authAddr: "auth-addr",
      createdApps: "created-apps",
      createdAssets: "created-assets",
      participation: "participation",
      rewardBase: "reward-base",
      sigType: "sig-type",
      totalBoxBytes: "total-box-bytes",
      totalBoxes: "total-boxes"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["amount-without-pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${data}`);
    if (typeof data["min-balance"] === "undefined")
      throw new Error(`Response is missing required field 'min-balance': ${data}`);
    if (typeof data["pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${data}`);
    if (typeof data["rewards"] === "undefined")
      throw new Error(`Response is missing required field 'rewards': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["status"] === "undefined")
      throw new Error(`Response is missing required field 'status': ${data}`);
    if (typeof data["total-apps-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${data}`);
    if (typeof data["total-assets-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${data}`);
    if (typeof data["total-created-apps"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${data}`);
    if (typeof data["total-created-assets"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${data}`);
    return new Account({
      address: data["address"],
      amount: data["amount"],
      amountWithoutPendingRewards: data["amount-without-pending-rewards"],
      minBalance: data["min-balance"],
      pendingRewards: data["pending-rewards"],
      rewards: data["rewards"],
      round: data["round"],
      status: data["status"],
      totalAppsOptedIn: data["total-apps-opted-in"],
      totalAssetsOptedIn: data["total-assets-opted-in"],
      totalCreatedApps: data["total-created-apps"],
      totalCreatedAssets: data["total-created-assets"],
      appsLocalState: typeof data["apps-local-state"] !== "undefined" ? data["apps-local-state"].map(ApplicationLocalState$1.from_obj_for_encoding) : void 0,
      appsTotalExtraPages: data["apps-total-extra-pages"],
      appsTotalSchema: typeof data["apps-total-schema"] !== "undefined" ? ApplicationStateSchema$1.from_obj_for_encoding(data["apps-total-schema"]) : void 0,
      assets: typeof data["assets"] !== "undefined" ? data["assets"].map(AssetHolding$1.from_obj_for_encoding) : void 0,
      authAddr: data["auth-addr"],
      createdApps: typeof data["created-apps"] !== "undefined" ? data["created-apps"].map(Application$1.from_obj_for_encoding) : void 0,
      createdAssets: typeof data["created-assets"] !== "undefined" ? data["created-assets"].map(Asset$1.from_obj_for_encoding) : void 0,
      participation: typeof data["participation"] !== "undefined" ? AccountParticipation$1.from_obj_for_encoding(data["participation"]) : void 0,
      rewardBase: data["reward-base"],
      sigType: data["sig-type"],
      totalBoxBytes: data["total-box-bytes"],
      totalBoxes: data["total-boxes"]
    });
  }
};
class AccountApplicationResponse extends BaseModel {
  /**
   * Creates a new `AccountApplicationResponse` object.
   * @param round - The round for which this information is relevant.
   * @param appLocalState - (appl) the application local data stored in this account.
   * The raw account uses `AppLocalState` for this type.
   * @param createdApp - (appp) parameters of the application created by this account including app
   * global data.
   * The raw account uses `AppParams` for this type.
   */
  constructor({ round, appLocalState, createdApp }) {
    super();
    this.round = round;
    this.appLocalState = appLocalState;
    this.createdApp = createdApp;
    this.attribute_map = {
      round: "round",
      appLocalState: "app-local-state",
      createdApp: "created-app"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    return new AccountApplicationResponse({
      round: data["round"],
      appLocalState: typeof data["app-local-state"] !== "undefined" ? ApplicationLocalState$1.from_obj_for_encoding(data["app-local-state"]) : void 0,
      createdApp: typeof data["created-app"] !== "undefined" ? ApplicationParams$1.from_obj_for_encoding(data["created-app"]) : void 0
    });
  }
}
class AccountAssetResponse extends BaseModel {
  /**
   * Creates a new `AccountAssetResponse` object.
   * @param round - The round for which this information is relevant.
   * @param assetHolding - (asset) Details about the asset held by this account.
   * The raw account uses `AssetHolding` for this type.
   * @param createdAsset - (apar) parameters of the asset created by this account.
   * The raw account uses `AssetParams` for this type.
   */
  constructor({ round, assetHolding, createdAsset }) {
    super();
    this.round = round;
    this.assetHolding = assetHolding;
    this.createdAsset = createdAsset;
    this.attribute_map = {
      round: "round",
      assetHolding: "asset-holding",
      createdAsset: "created-asset"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    return new AccountAssetResponse({
      round: data["round"],
      assetHolding: typeof data["asset-holding"] !== "undefined" ? AssetHolding$1.from_obj_for_encoding(data["asset-holding"]) : void 0,
      createdAsset: typeof data["created-asset"] !== "undefined" ? AssetParams$1.from_obj_for_encoding(data["created-asset"]) : void 0
    });
  }
}
let AccountParticipation$1 = class AccountParticipation extends BaseModel {
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    super();
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(buffer.Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.attribute_map = {
      selectionParticipationKey: "selection-participation-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key",
      stateProofKey: "state-proof-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["selection-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${data}`);
    if (typeof data["vote-first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${data}`);
    if (typeof data["vote-key-dilution"] === "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${data}`);
    if (typeof data["vote-last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${data}`);
    if (typeof data["vote-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${data}`);
    return new AccountParticipation({
      selectionParticipationKey: data["selection-participation-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"],
      stateProofKey: data["state-proof-key"]
    });
  }
};
let AccountStateDelta$1 = class AccountStateDelta extends BaseModel {
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    super();
    this.address = address;
    this.delta = delta;
    this.attribute_map = {
      address: "address",
      delta: "delta"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (!Array.isArray(data["delta"]))
      throw new Error(`Response is missing required array field 'delta': ${data}`);
    return new AccountStateDelta({
      address: data["address"],
      delta: data["delta"].map(EvalDeltaKeyValue$1.from_obj_for_encoding)
    });
  }
};
let Application$1 = class Application extends BaseModel {
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   */
  constructor({ id: id2, params }) {
    super();
    this.id = id2;
    this.params = params;
    this.attribute_map = {
      id: "id",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Application({
      id: data["id"],
      params: ApplicationParams$1.from_obj_for_encoding(data["params"])
    });
  }
};
let ApplicationLocalState$1 = class ApplicationLocalState extends BaseModel {
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param keyValue - (tkv) storage.
   */
  constructor({ id: id2, schema, keyValue }) {
    super();
    this.id = id2;
    this.schema = schema;
    this.keyValue = keyValue;
    this.attribute_map = {
      id: "id",
      schema: "schema",
      keyValue: "key-value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["schema"] === "undefined")
      throw new Error(`Response is missing required field 'schema': ${data}`);
    return new ApplicationLocalState({
      id: data["id"],
      schema: ApplicationStateSchema$1.from_obj_for_encoding(data["schema"]),
      keyValue: typeof data["key-value"] !== "undefined" ? data["key-value"].map(TealKeyValue$1.from_obj_for_encoding) : void 0
    });
  }
};
let ApplicationParams$1 = class ApplicationParams extends BaseModel {
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - [\gs) global schema
   * @param globalStateSchema - [\gsch) global schema
   * @param localStateSchema - [\lsch) local schema
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
    super();
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(buffer.Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(buffer.Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.creator = creator;
    this.extraProgramPages = extraProgramPages;
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.attribute_map = {
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      creator: "creator",
      extraProgramPages: "extra-program-pages",
      globalState: "global-state",
      globalStateSchema: "global-state-schema",
      localStateSchema: "local-state-schema"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["approval-program"] === "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${data}`);
    if (typeof data["clear-state-program"] === "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${data}`);
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    return new ApplicationParams({
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      creator: data["creator"],
      extraProgramPages: data["extra-program-pages"],
      globalState: typeof data["global-state"] !== "undefined" ? data["global-state"].map(TealKeyValue$1.from_obj_for_encoding) : void 0,
      globalStateSchema: typeof data["global-state-schema"] !== "undefined" ? ApplicationStateSchema$1.from_obj_for_encoding(data["global-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? ApplicationStateSchema$1.from_obj_for_encoding(data["local-state-schema"]) : void 0
    });
  }
};
let ApplicationStateSchema$1 = class ApplicationStateSchema extends BaseModel {
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numUint - (nui) num of uints.
   * @param numByteSlice - (nbs) num of byte slices.
   */
  constructor({ numUint, numByteSlice }) {
    super();
    this.numUint = numUint;
    this.numByteSlice = numByteSlice;
    this.attribute_map = {
      numUint: "num-uint",
      numByteSlice: "num-byte-slice"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    return new ApplicationStateSchema({
      numUint: data["num-uint"],
      numByteSlice: data["num-byte-slice"]
    });
  }
};
let Asset$1 = class Asset extends BaseModel {
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ index: index2, params }) {
    super();
    this.index = index2;
    this.params = params;
    this.attribute_map = {
      index: "index",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Asset({
      index: data["index"],
      params: AssetParams$1.from_obj_for_encoding(data["params"])
    });
  }
};
let AssetHolding$1 = class AssetHolding extends BaseModel {
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   */
  constructor({ amount, assetId, isFrozen }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.isFrozen = isFrozen;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      isFrozen: "is-frozen"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new AssetHolding({
      amount: data["amount"],
      assetId: data["asset-id"],
      isFrozen: data["is-frozen"]
    });
  }
};
let AssetParams$1 = class AssetParams extends BaseModel {
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    super();
    this.creator = creator;
    this.decimals = decimals;
    this.total = total;
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(buffer.Buffer.from(metadataHash, "base64")) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(buffer.Buffer.from(nameB64, "base64")) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(buffer.Buffer.from(unitNameB64, "base64")) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(buffer.Buffer.from(urlB64, "base64")) : urlB64;
    this.attribute_map = {
      creator: "creator",
      decimals: "decimals",
      total: "total",
      clawback: "clawback",
      defaultFrozen: "default-frozen",
      freeze: "freeze",
      manager: "manager",
      metadataHash: "metadata-hash",
      name: "name",
      nameB64: "name-b64",
      reserve: "reserve",
      unitName: "unit-name",
      unitNameB64: "unit-name-b64",
      url: "url",
      urlB64: "url-b64"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    if (typeof data["decimals"] === "undefined")
      throw new Error(`Response is missing required field 'decimals': ${data}`);
    if (typeof data["total"] === "undefined")
      throw new Error(`Response is missing required field 'total': ${data}`);
    return new AssetParams({
      creator: data["creator"],
      decimals: data["decimals"],
      total: data["total"],
      clawback: data["clawback"],
      defaultFrozen: data["default-frozen"],
      freeze: data["freeze"],
      manager: data["manager"],
      metadataHash: data["metadata-hash"],
      name: data["name"],
      nameB64: data["name-b64"],
      reserve: data["reserve"],
      unitName: data["unit-name"],
      unitNameB64: data["unit-name-b64"],
      url: data["url"],
      urlB64: data["url-b64"]
    });
  }
};
class BlockHashResponse extends BaseModel {
  /**
   * Creates a new `BlockHashResponse` object.
   * @param blockhash - Block header hash.
   */
  constructor({ blockhash }) {
    super();
    this.blockhash = blockhash;
    this.attribute_map = {
      blockhash: "blockHash"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["blockHash"] === "undefined")
      throw new Error(`Response is missing required field 'blockHash': ${data}`);
    return new BlockHashResponse({
      blockhash: data["blockHash"]
    });
  }
}
class BlockResponse extends BaseModel {
  /**
   * Creates a new `BlockResponse` object.
   * @param block - Block header data.
   * @param cert - Optional certificate object. This is only included when the format is set to
   * message pack.
   */
  constructor({ block, cert }) {
    super();
    this.block = block;
    this.cert = cert;
    this.attribute_map = {
      block: "block",
      cert: "cert"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["block"] === "undefined")
      throw new Error(`Response is missing required field 'block': ${data}`);
    return new BlockResponse({
      block: data["block"],
      cert: data["cert"]
    });
  }
}
let Box$1 = class Box extends BaseModel {
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name, value }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.value = typeof value === "string" ? new Uint8Array(buffer.Buffer.from(value, "base64")) : value;
    this.attribute_map = {
      name: "name",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new Box({
      name: data["name"],
      value: data["value"]
    });
  }
};
let BoxDescriptor$1 = class BoxDescriptor extends BaseModel {
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.attribute_map = {
      name: "name"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    return new BoxDescriptor({
      name: data["name"]
    });
  }
};
let BoxesResponse$1 = class BoxesResponse extends BaseModel {
  /**
   * Creates a new `BoxesResponse` object.
   * @param boxes -
   */
  constructor({ boxes }) {
    super();
    this.boxes = boxes;
    this.attribute_map = {
      boxes: "boxes"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["boxes"]))
      throw new Error(`Response is missing required array field 'boxes': ${data}`);
    return new BoxesResponse({
      boxes: data["boxes"].map(BoxDescriptor$1.from_obj_for_encoding)
    });
  }
};
class BuildVersion extends BaseModel {
  /**
   * Creates a new `BuildVersion` object.
   * @param branch -
   * @param buildNumber -
   * @param channel -
   * @param commitHash -
   * @param major -
   * @param minor -
   */
  constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
    super();
    this.branch = branch;
    this.buildNumber = buildNumber;
    this.channel = channel;
    this.commitHash = commitHash;
    this.major = major;
    this.minor = minor;
    this.attribute_map = {
      branch: "branch",
      buildNumber: "build_number",
      channel: "channel",
      commitHash: "commit_hash",
      major: "major",
      minor: "minor"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["branch"] === "undefined")
      throw new Error(`Response is missing required field 'branch': ${data}`);
    if (typeof data["build_number"] === "undefined")
      throw new Error(`Response is missing required field 'build_number': ${data}`);
    if (typeof data["channel"] === "undefined")
      throw new Error(`Response is missing required field 'channel': ${data}`);
    if (typeof data["commit_hash"] === "undefined")
      throw new Error(`Response is missing required field 'commit_hash': ${data}`);
    if (typeof data["major"] === "undefined")
      throw new Error(`Response is missing required field 'major': ${data}`);
    if (typeof data["minor"] === "undefined")
      throw new Error(`Response is missing required field 'minor': ${data}`);
    return new BuildVersion({
      branch: data["branch"],
      buildNumber: data["build_number"],
      channel: data["channel"],
      commitHash: data["commit_hash"],
      major: data["major"],
      minor: data["minor"]
    });
  }
}
class CompileResponse extends BaseModel {
  /**
   * Creates a new `CompileResponse` object.
   * @param hash - base32 SHA512_256 of program bytes (Address style)
   * @param result - base64 encoded program bytes
   * @param sourcemap - JSON of the source map
   */
  constructor({ hash, result, sourcemap }) {
    super();
    this.hash = hash;
    this.result = result;
    this.sourcemap = sourcemap;
    this.attribute_map = {
      hash: "hash",
      result: "result",
      sourcemap: "sourcemap"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["hash"] === "undefined")
      throw new Error(`Response is missing required field 'hash': ${data}`);
    if (typeof data["result"] === "undefined")
      throw new Error(`Response is missing required field 'result': ${data}`);
    return new CompileResponse({
      hash: data["hash"],
      result: data["result"],
      sourcemap: data["sourcemap"]
    });
  }
}
class DisassembleResponse extends BaseModel {
  /**
   * Creates a new `DisassembleResponse` object.
   * @param result - disassembled Teal code
   */
  constructor({ result }) {
    super();
    this.result = result;
    this.attribute_map = {
      result: "result"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["result"] === "undefined")
      throw new Error(`Response is missing required field 'result': ${data}`);
    return new DisassembleResponse({
      result: data["result"]
    });
  }
}
class DryrunRequest extends BaseModel {
  /**
   * Creates a new `DryrunRequest` object.
   * @param accounts -
   * @param apps -
   * @param latestTimestamp - LatestTimestamp is available to some TEAL scripts. Defaults to the latest
   * confirmed timestamp this algod is attached to.
   * @param protocolVersion - ProtocolVersion specifies a specific version string to operate under, otherwise
   * whatever the current protocol of the network this algod is running in.
   * @param round - Round is available to some TEAL scripts. Defaults to the current round on the
   * network this algod is attached to.
   * @param sources -
   * @param txns -
   */
  constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
    super();
    this.accounts = accounts;
    this.apps = apps;
    this.latestTimestamp = latestTimestamp;
    this.protocolVersion = protocolVersion;
    this.round = round;
    this.sources = sources;
    this.txns = txns;
    this.attribute_map = {
      accounts: "accounts",
      apps: "apps",
      latestTimestamp: "latest-timestamp",
      protocolVersion: "protocol-version",
      round: "round",
      sources: "sources",
      txns: "txns"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["accounts"]))
      throw new Error(`Response is missing required array field 'accounts': ${data}`);
    if (!Array.isArray(data["apps"]))
      throw new Error(`Response is missing required array field 'apps': ${data}`);
    if (typeof data["latest-timestamp"] === "undefined")
      throw new Error(`Response is missing required field 'latest-timestamp': ${data}`);
    if (typeof data["protocol-version"] === "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (!Array.isArray(data["sources"]))
      throw new Error(`Response is missing required array field 'sources': ${data}`);
    if (!Array.isArray(data["txns"]))
      throw new Error(`Response is missing required array field 'txns': ${data}`);
    return new DryrunRequest({
      accounts: data["accounts"].map(Account$1.from_obj_for_encoding),
      apps: data["apps"].map(Application$1.from_obj_for_encoding),
      latestTimestamp: data["latest-timestamp"],
      protocolVersion: data["protocol-version"],
      round: data["round"],
      sources: data["sources"].map(DryrunSource.from_obj_for_encoding),
      txns: data["txns"]
    });
  }
}
class DryrunResponse extends BaseModel {
  /**
   * Creates a new `DryrunResponse` object.
   * @param error -
   * @param protocolVersion - Protocol version is the protocol version Dryrun was operated under.
   * @param txns -
   */
  constructor({ error, protocolVersion, txns }) {
    super();
    this.error = error;
    this.protocolVersion = protocolVersion;
    this.txns = txns;
    this.attribute_map = {
      error: "error",
      protocolVersion: "protocol-version",
      txns: "txns"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["error"] === "undefined")
      throw new Error(`Response is missing required field 'error': ${data}`);
    if (typeof data["protocol-version"] === "undefined")
      throw new Error(`Response is missing required field 'protocol-version': ${data}`);
    if (!Array.isArray(data["txns"]))
      throw new Error(`Response is missing required array field 'txns': ${data}`);
    return new DryrunResponse({
      error: data["error"],
      protocolVersion: data["protocol-version"],
      txns: data["txns"].map(DryrunTxnResult.from_obj_for_encoding)
    });
  }
}
class DryrunSource extends BaseModel {
  /**
   * Creates a new `DryrunSource` object.
   * @param fieldName - FieldName is what kind of sources this is. If lsig then it goes into the
   * transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the
   * Approval Program or Clear State Program of application[this.AppIndex].
   * @param source -
   * @param txnIndex -
   * @param appIndex -
   */
  constructor({ fieldName, source, txnIndex, appIndex }) {
    super();
    this.fieldName = fieldName;
    this.source = source;
    this.txnIndex = txnIndex;
    this.appIndex = appIndex;
    this.attribute_map = {
      fieldName: "field-name",
      source: "source",
      txnIndex: "txn-index",
      appIndex: "app-index"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["field-name"] === "undefined")
      throw new Error(`Response is missing required field 'field-name': ${data}`);
    if (typeof data["source"] === "undefined")
      throw new Error(`Response is missing required field 'source': ${data}`);
    if (typeof data["txn-index"] === "undefined")
      throw new Error(`Response is missing required field 'txn-index': ${data}`);
    if (typeof data["app-index"] === "undefined")
      throw new Error(`Response is missing required field 'app-index': ${data}`);
    return new DryrunSource({
      fieldName: data["field-name"],
      source: data["source"],
      txnIndex: data["txn-index"],
      appIndex: data["app-index"]
    });
  }
}
class DryrunState extends BaseModel {
  /**
   * Creates a new `DryrunState` object.
   * @param line - Line number
   * @param pc - Program counter
   * @param stack -
   * @param error - Evaluation error if any
   * @param scratch -
   */
  constructor({ line, pc: pc2, stack, error, scratch }) {
    super();
    this.line = line;
    this.pc = pc2;
    this.stack = stack;
    this.error = error;
    this.scratch = scratch;
    this.attribute_map = {
      line: "line",
      pc: "pc",
      stack: "stack",
      error: "error",
      scratch: "scratch"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["line"] === "undefined")
      throw new Error(`Response is missing required field 'line': ${data}`);
    if (typeof data["pc"] === "undefined")
      throw new Error(`Response is missing required field 'pc': ${data}`);
    if (!Array.isArray(data["stack"]))
      throw new Error(`Response is missing required array field 'stack': ${data}`);
    return new DryrunState({
      line: data["line"],
      pc: data["pc"],
      stack: data["stack"].map(TealValue$1.from_obj_for_encoding),
      error: data["error"],
      scratch: typeof data["scratch"] !== "undefined" ? data["scratch"].map(TealValue$1.from_obj_for_encoding) : void 0
    });
  }
}
class DryrunTxnResult extends BaseModel {
  /**
   * Creates a new `DryrunTxnResult` object.
   * @param disassembly - Disassembled program line by line.
   * @param appCallMessages -
   * @param appCallTrace -
   * @param budgetAdded - Budget added during execution of app call transaction.
   * @param budgetConsumed - Budget consumed during execution of app call transaction.
   * @param globalDelta - Application state delta.
   * @param localDeltas -
   * @param logicSigDisassembly - Disassembled lsig program line by line.
   * @param logicSigMessages -
   * @param logicSigTrace -
   * @param logs -
   */
  constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
    super();
    this.disassembly = disassembly;
    this.appCallMessages = appCallMessages;
    this.appCallTrace = appCallTrace;
    this.budgetAdded = budgetAdded;
    this.budgetConsumed = budgetConsumed;
    this.globalDelta = globalDelta;
    this.localDeltas = localDeltas;
    this.logicSigDisassembly = logicSigDisassembly;
    this.logicSigMessages = logicSigMessages;
    this.logicSigTrace = logicSigTrace;
    this.logs = logs;
    this.attribute_map = {
      disassembly: "disassembly",
      appCallMessages: "app-call-messages",
      appCallTrace: "app-call-trace",
      budgetAdded: "budget-added",
      budgetConsumed: "budget-consumed",
      globalDelta: "global-delta",
      localDeltas: "local-deltas",
      logicSigDisassembly: "logic-sig-disassembly",
      logicSigMessages: "logic-sig-messages",
      logicSigTrace: "logic-sig-trace",
      logs: "logs"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["disassembly"]))
      throw new Error(`Response is missing required array field 'disassembly': ${data}`);
    return new DryrunTxnResult({
      disassembly: data["disassembly"],
      appCallMessages: data["app-call-messages"],
      appCallTrace: typeof data["app-call-trace"] !== "undefined" ? data["app-call-trace"].map(DryrunState.from_obj_for_encoding) : void 0,
      budgetAdded: data["budget-added"],
      budgetConsumed: data["budget-consumed"],
      globalDelta: typeof data["global-delta"] !== "undefined" ? data["global-delta"].map(EvalDeltaKeyValue$1.from_obj_for_encoding) : void 0,
      localDeltas: typeof data["local-deltas"] !== "undefined" ? data["local-deltas"].map(AccountStateDelta$1.from_obj_for_encoding) : void 0,
      logicSigDisassembly: data["logic-sig-disassembly"],
      logicSigMessages: data["logic-sig-messages"],
      logicSigTrace: typeof data["logic-sig-trace"] !== "undefined" ? data["logic-sig-trace"].map(DryrunState.from_obj_for_encoding) : void 0,
      logs: data["logs"]
    });
  }
}
let ErrorResponse$1 = class ErrorResponse extends BaseModel {
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    super();
    this.message = message;
    this.data = data;
    this.attribute_map = {
      message: "message",
      data: "data"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    return new ErrorResponse({
      message: data["message"],
      data: data["data"]
    });
  }
};
let EvalDelta$1 = class EvalDelta extends BaseModel {
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    super();
    this.action = action;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      action: "action",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["action"] === "undefined")
      throw new Error(`Response is missing required field 'action': ${data}`);
    return new EvalDelta({
      action: data["action"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
};
let EvalDeltaKeyValue$1 = class EvalDeltaKeyValue extends BaseModel {
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new EvalDeltaKeyValue({
      key: data["key"],
      value: EvalDelta$1.from_obj_for_encoding(data["value"])
    });
  }
};
let LightBlockHeaderProof$1 = class LightBlockHeaderProof extends BaseModel {
  /**
   * Creates a new `LightBlockHeaderProof` object.
   * @param index - The index of the light block header in the vector commitment tree
   * @param proof - The encoded proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   */
  constructor({ index: index2, proof, treedepth }) {
    super();
    this.index = index2;
    this.proof = typeof proof === "string" ? new Uint8Array(buffer.Buffer.from(proof, "base64")) : proof;
    this.treedepth = treedepth;
    this.attribute_map = {
      index: "index",
      proof: "proof",
      treedepth: "treedepth"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["proof"] === "undefined")
      throw new Error(`Response is missing required field 'proof': ${data}`);
    if (typeof data["treedepth"] === "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${data}`);
    return new LightBlockHeaderProof({
      index: data["index"],
      proof: data["proof"],
      treedepth: data["treedepth"]
    });
  }
};
class NodeStatusResponse extends BaseModel {
  /**
   * Creates a new `NodeStatusResponse` object.
   * @param catchupTime - CatchupTime in nanoseconds
   * @param lastRound - LastRound indicates the last round seen
   * @param lastVersion - LastVersion indicates the last consensus version supported
   * @param nextVersion - NextVersion of consensus protocol to use
   * @param nextVersionRound - NextVersionRound is the round at which the next consensus version will apply
   * @param nextVersionSupported - NextVersionSupported indicates whether the next consensus version is supported
   * by this node
   * @param stoppedAtUnsupportedRound - StoppedAtUnsupportedRound indicates that the node does not support the new
   * rounds and has stopped making progress
   * @param timeSinceLastRound - TimeSinceLastRound in nanoseconds
   * @param catchpoint - The current catchpoint that is being caught up to
   * @param catchpointAcquiredBlocks - The number of blocks that have already been obtained by the node as part of the
   * catchup
   * @param catchpointProcessedAccounts - The number of accounts from the current catchpoint that have been processed so
   * far as part of the catchup
   * @param catchpointProcessedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * processed so far as part of the catchup
   * @param catchpointTotalAccounts - The total number of accounts included in the current catchpoint
   * @param catchpointTotalBlocks - The total number of blocks that are required to complete the current catchpoint
   * catchup
   * @param catchpointTotalKvs - The total number of key-values (KVs) included in the current catchpoint
   * @param catchpointVerifiedAccounts - The number of accounts from the current catchpoint that have been verified so
   * far as part of the catchup
   * @param catchpointVerifiedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * verified so far as part of the catchup
   * @param lastCatchpoint - The last catchpoint seen by the node
   */
  constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointProcessedKvs, catchpointTotalAccounts, catchpointTotalBlocks, catchpointTotalKvs, catchpointVerifiedAccounts, catchpointVerifiedKvs, lastCatchpoint }) {
    super();
    this.catchupTime = catchupTime;
    this.lastRound = lastRound;
    this.lastVersion = lastVersion;
    this.nextVersion = nextVersion;
    this.nextVersionRound = nextVersionRound;
    this.nextVersionSupported = nextVersionSupported;
    this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
    this.timeSinceLastRound = timeSinceLastRound;
    this.catchpoint = catchpoint;
    this.catchpointAcquiredBlocks = catchpointAcquiredBlocks;
    this.catchpointProcessedAccounts = catchpointProcessedAccounts;
    this.catchpointProcessedKvs = catchpointProcessedKvs;
    this.catchpointTotalAccounts = catchpointTotalAccounts;
    this.catchpointTotalBlocks = catchpointTotalBlocks;
    this.catchpointTotalKvs = catchpointTotalKvs;
    this.catchpointVerifiedAccounts = catchpointVerifiedAccounts;
    this.catchpointVerifiedKvs = catchpointVerifiedKvs;
    this.lastCatchpoint = lastCatchpoint;
    this.attribute_map = {
      catchupTime: "catchup-time",
      lastRound: "last-round",
      lastVersion: "last-version",
      nextVersion: "next-version",
      nextVersionRound: "next-version-round",
      nextVersionSupported: "next-version-supported",
      stoppedAtUnsupportedRound: "stopped-at-unsupported-round",
      timeSinceLastRound: "time-since-last-round",
      catchpoint: "catchpoint",
      catchpointAcquiredBlocks: "catchpoint-acquired-blocks",
      catchpointProcessedAccounts: "catchpoint-processed-accounts",
      catchpointProcessedKvs: "catchpoint-processed-kvs",
      catchpointTotalAccounts: "catchpoint-total-accounts",
      catchpointTotalBlocks: "catchpoint-total-blocks",
      catchpointTotalKvs: "catchpoint-total-kvs",
      catchpointVerifiedAccounts: "catchpoint-verified-accounts",
      catchpointVerifiedKvs: "catchpoint-verified-kvs",
      lastCatchpoint: "last-catchpoint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["catchup-time"] === "undefined")
      throw new Error(`Response is missing required field 'catchup-time': ${data}`);
    if (typeof data["last-round"] === "undefined")
      throw new Error(`Response is missing required field 'last-round': ${data}`);
    if (typeof data["last-version"] === "undefined")
      throw new Error(`Response is missing required field 'last-version': ${data}`);
    if (typeof data["next-version"] === "undefined")
      throw new Error(`Response is missing required field 'next-version': ${data}`);
    if (typeof data["next-version-round"] === "undefined")
      throw new Error(`Response is missing required field 'next-version-round': ${data}`);
    if (typeof data["next-version-supported"] === "undefined")
      throw new Error(`Response is missing required field 'next-version-supported': ${data}`);
    if (typeof data["stopped-at-unsupported-round"] === "undefined")
      throw new Error(`Response is missing required field 'stopped-at-unsupported-round': ${data}`);
    if (typeof data["time-since-last-round"] === "undefined")
      throw new Error(`Response is missing required field 'time-since-last-round': ${data}`);
    return new NodeStatusResponse({
      catchupTime: data["catchup-time"],
      lastRound: data["last-round"],
      lastVersion: data["last-version"],
      nextVersion: data["next-version"],
      nextVersionRound: data["next-version-round"],
      nextVersionSupported: data["next-version-supported"],
      stoppedAtUnsupportedRound: data["stopped-at-unsupported-round"],
      timeSinceLastRound: data["time-since-last-round"],
      catchpoint: data["catchpoint"],
      catchpointAcquiredBlocks: data["catchpoint-acquired-blocks"],
      catchpointProcessedAccounts: data["catchpoint-processed-accounts"],
      catchpointProcessedKvs: data["catchpoint-processed-kvs"],
      catchpointTotalAccounts: data["catchpoint-total-accounts"],
      catchpointTotalBlocks: data["catchpoint-total-blocks"],
      catchpointTotalKvs: data["catchpoint-total-kvs"],
      catchpointVerifiedAccounts: data["catchpoint-verified-accounts"],
      catchpointVerifiedKvs: data["catchpoint-verified-kvs"],
      lastCatchpoint: data["last-catchpoint"]
    });
  }
}
class PendingTransactionResponse extends BaseModel {
  /**
   * Creates a new `PendingTransactionResponse` object.
   * @param poolError - Indicates that the transaction was kicked out of this node's transaction pool
   * (and specifies why that happened). An empty string indicates the transaction
   * wasn't kicked out of this node's txpool due to an error.
   * @param txn - The raw signed transaction.
   * @param applicationIndex - The application index if the transaction was found and it created an
   * application.
   * @param assetClosingAmount - The number of the asset's unit that were transferred to the close-to address.
   * @param assetIndex - The asset index if the transaction was found and it created an asset.
   * @param closeRewards - Rewards in microalgos applied to the close remainder to account.
   * @param closingAmount - Closing amount for the transaction.
   * @param confirmedRound - The round where this transaction was confirmed, if present.
   * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
   * transaction.
   * @param innerTxns - Inner transactions produced by application execution.
   * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - (lg) Logs for the application being executed by this transaction.
   * @param receiverRewards - Rewards in microalgos applied to the receiver account.
   * @param senderRewards - Rewards in microalgos applied to the sender account.
   */
  constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
    super();
    this.poolError = poolError;
    this.txn = txn;
    this.applicationIndex = applicationIndex;
    this.assetClosingAmount = assetClosingAmount;
    this.assetIndex = assetIndex;
    this.closeRewards = closeRewards;
    this.closingAmount = closingAmount;
    this.confirmedRound = confirmedRound;
    this.globalStateDelta = globalStateDelta;
    this.innerTxns = innerTxns;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.receiverRewards = receiverRewards;
    this.senderRewards = senderRewards;
    this.attribute_map = {
      poolError: "pool-error",
      txn: "txn",
      applicationIndex: "application-index",
      assetClosingAmount: "asset-closing-amount",
      assetIndex: "asset-index",
      closeRewards: "close-rewards",
      closingAmount: "closing-amount",
      confirmedRound: "confirmed-round",
      globalStateDelta: "global-state-delta",
      innerTxns: "inner-txns",
      localStateDelta: "local-state-delta",
      logs: "logs",
      receiverRewards: "receiver-rewards",
      senderRewards: "sender-rewards"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["pool-error"] === "undefined")
      throw new Error(`Response is missing required field 'pool-error': ${data}`);
    if (typeof data["txn"] === "undefined")
      throw new Error(`Response is missing required field 'txn': ${data}`);
    return new PendingTransactionResponse({
      poolError: data["pool-error"],
      txn: data["txn"],
      applicationIndex: data["application-index"],
      assetClosingAmount: data["asset-closing-amount"],
      assetIndex: data["asset-index"],
      closeRewards: data["close-rewards"],
      closingAmount: data["closing-amount"],
      confirmedRound: data["confirmed-round"],
      globalStateDelta: typeof data["global-state-delta"] !== "undefined" ? data["global-state-delta"].map(EvalDeltaKeyValue$1.from_obj_for_encoding) : void 0,
      innerTxns: typeof data["inner-txns"] !== "undefined" ? data["inner-txns"].map(PendingTransactionResponse.from_obj_for_encoding) : void 0,
      localStateDelta: typeof data["local-state-delta"] !== "undefined" ? data["local-state-delta"].map(AccountStateDelta$1.from_obj_for_encoding) : void 0,
      logs: data["logs"],
      receiverRewards: data["receiver-rewards"],
      senderRewards: data["sender-rewards"]
    });
  }
}
class PendingTransactionsResponse extends BaseModel {
  /**
   * Creates a new `PendingTransactionsResponse` object.
   * @param topTransactions - An array of signed transaction objects.
   * @param totalTransactions - Total number of transactions in the pool.
   */
  constructor({ topTransactions, totalTransactions }) {
    super();
    this.topTransactions = topTransactions;
    this.totalTransactions = totalTransactions;
    this.attribute_map = {
      topTransactions: "top-transactions",
      totalTransactions: "total-transactions"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["top-transactions"]))
      throw new Error(`Response is missing required array field 'top-transactions': ${data}`);
    if (typeof data["total-transactions"] === "undefined")
      throw new Error(`Response is missing required field 'total-transactions': ${data}`);
    return new PendingTransactionsResponse({
      topTransactions: data["top-transactions"],
      totalTransactions: data["total-transactions"]
    });
  }
}
class PostTransactionsResponse extends BaseModel {
  /**
   * Creates a new `PostTransactionsResponse` object.
   * @param txid - encoding of the transaction hash.
   */
  constructor({ txid }) {
    super();
    this.txid = txid;
    this.attribute_map = {
      txid: "txId"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["txId"] === "undefined")
      throw new Error(`Response is missing required field 'txId': ${data}`);
    return new PostTransactionsResponse({
      txid: data["txId"]
    });
  }
}
let StateProof$1 = class StateProof extends BaseModel {
  /**
   * Creates a new `StateProof` object.
   * @param message - Represents the message that the state proofs are attesting to.
   * @param stateproof - The encoded StateProof for the message.
   */
  constructor({ message, stateproof }) {
    super();
    this.message = message;
    this.stateproof = typeof stateproof === "string" ? new Uint8Array(buffer.Buffer.from(stateproof, "base64")) : stateproof;
    this.attribute_map = {
      message: "Message",
      stateproof: "StateProof"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["Message"] === "undefined")
      throw new Error(`Response is missing required field 'Message': ${data}`);
    if (typeof data["StateProof"] === "undefined")
      throw new Error(`Response is missing required field 'StateProof': ${data}`);
    return new StateProof({
      message: StateProofMessage.from_obj_for_encoding(data["Message"]),
      stateproof: data["StateProof"]
    });
  }
};
class StateProofMessage extends BaseModel {
  /**
   * Creates a new `StateProofMessage` object.
   * @param blockheaderscommitment - The vector commitment root on all light block headers within a state proof
   * interval.
   * @param firstattestedround - The first round the message attests to.
   * @param lastattestedround - The last round the message attests to.
   * @param lnprovenweight - An integer value representing the natural log of the proven weight with 16 bits
   * of precision. This value would be used to verify the next state proof.
   * @param voterscommitment - The vector commitment root of the top N accounts to sign the next StateProof.
   */
  constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment }) {
    super();
    this.blockheaderscommitment = typeof blockheaderscommitment === "string" ? new Uint8Array(buffer.Buffer.from(blockheaderscommitment, "base64")) : blockheaderscommitment;
    this.firstattestedround = firstattestedround;
    this.lastattestedround = lastattestedround;
    this.lnprovenweight = lnprovenweight;
    this.voterscommitment = typeof voterscommitment === "string" ? new Uint8Array(buffer.Buffer.from(voterscommitment, "base64")) : voterscommitment;
    this.attribute_map = {
      blockheaderscommitment: "BlockHeadersCommitment",
      firstattestedround: "FirstAttestedRound",
      lastattestedround: "LastAttestedRound",
      lnprovenweight: "LnProvenWeight",
      voterscommitment: "VotersCommitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["BlockHeadersCommitment"] === "undefined")
      throw new Error(`Response is missing required field 'BlockHeadersCommitment': ${data}`);
    if (typeof data["FirstAttestedRound"] === "undefined")
      throw new Error(`Response is missing required field 'FirstAttestedRound': ${data}`);
    if (typeof data["LastAttestedRound"] === "undefined")
      throw new Error(`Response is missing required field 'LastAttestedRound': ${data}`);
    if (typeof data["LnProvenWeight"] === "undefined")
      throw new Error(`Response is missing required field 'LnProvenWeight': ${data}`);
    if (typeof data["VotersCommitment"] === "undefined")
      throw new Error(`Response is missing required field 'VotersCommitment': ${data}`);
    return new StateProofMessage({
      blockheaderscommitment: data["BlockHeadersCommitment"],
      firstattestedround: data["FirstAttestedRound"],
      lastattestedround: data["LastAttestedRound"],
      lnprovenweight: data["LnProvenWeight"],
      voterscommitment: data["VotersCommitment"]
    });
  }
}
class SupplyResponse extends BaseModel {
  /**
   * Creates a new `SupplyResponse` object.
   * @param currentRound - Round
   * @param onlineMoney - OnlineMoney
   * @param totalMoney - TotalMoney
   */
  constructor({ currentRound, onlineMoney, totalMoney }) {
    super();
    this.currentRound = currentRound;
    this.onlineMoney = onlineMoney;
    this.totalMoney = totalMoney;
    this.attribute_map = {
      currentRound: "current_round",
      onlineMoney: "online-money",
      totalMoney: "total-money"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current_round"] === "undefined")
      throw new Error(`Response is missing required field 'current_round': ${data}`);
    if (typeof data["online-money"] === "undefined")
      throw new Error(`Response is missing required field 'online-money': ${data}`);
    if (typeof data["total-money"] === "undefined")
      throw new Error(`Response is missing required field 'total-money': ${data}`);
    return new SupplyResponse({
      currentRound: data["current_round"],
      onlineMoney: data["online-money"],
      totalMoney: data["total-money"]
    });
  }
}
let TealKeyValue$1 = class TealKeyValue extends BaseModel {
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new TealKeyValue({
      key: data["key"],
      value: TealValue$1.from_obj_for_encoding(data["value"])
    });
  }
};
let TealValue$1 = class TealValue extends BaseModel {
  /**
   * Creates a new `TealValue` object.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param bytes - (tb) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ type, bytes, uint }) {
    super();
    this.type = type;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      type: "type",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["type"] === "undefined")
      throw new Error(`Response is missing required field 'type': ${data}`);
    if (typeof data["bytes"] === "undefined")
      throw new Error(`Response is missing required field 'bytes': ${data}`);
    if (typeof data["uint"] === "undefined")
      throw new Error(`Response is missing required field 'uint': ${data}`);
    return new TealValue({
      type: data["type"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
};
class TransactionParametersResponse extends BaseModel {
  /**
   * Creates a new `TransactionParametersResponse` object.
   * @param consensusVersion - ConsensusVersion indicates the consensus protocol version
   * as of LastRound.
   * @param fee - Fee is the suggested transaction fee
   * Fee is in units of micro-Algos per byte.
   * Fee may fall to zero but transactions must still have a fee of
   * at least MinTxnFee for the current network protocol.
   * @param genesisHash - GenesisHash is the hash of the genesis block.
   * @param genesisId - GenesisID is an ID listed in the genesis block.
   * @param lastRound - LastRound indicates the last round seen
   * @param minFee - The minimum transaction fee (not per byte) required for the
   * txn to validate for the current network protocol.
   */
  constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
    super();
    this.consensusVersion = consensusVersion;
    this.fee = fee;
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(buffer.Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.lastRound = lastRound;
    this.minFee = minFee;
    this.attribute_map = {
      consensusVersion: "consensus-version",
      fee: "fee",
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      lastRound: "last-round",
      minFee: "min-fee"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["consensus-version"] === "undefined")
      throw new Error(`Response is missing required field 'consensus-version': ${data}`);
    if (typeof data["fee"] === "undefined")
      throw new Error(`Response is missing required field 'fee': ${data}`);
    if (typeof data["genesis-hash"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${data}`);
    if (typeof data["genesis-id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${data}`);
    if (typeof data["last-round"] === "undefined")
      throw new Error(`Response is missing required field 'last-round': ${data}`);
    if (typeof data["min-fee"] === "undefined")
      throw new Error(`Response is missing required field 'min-fee': ${data}`);
    return new TransactionParametersResponse({
      consensusVersion: data["consensus-version"],
      fee: data["fee"],
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      lastRound: data["last-round"],
      minFee: data["min-fee"]
    });
  }
}
class TransactionProofResponse extends BaseModel {
  /**
   * Creates a new `TransactionProofResponse` object.
   * @param idx - Index of the transaction in the block's payset.
   * @param proof - Proof of transaction membership.
   * @param stibhash - Hash of SignedTxnInBlock for verifying proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   * @param hashtype - The type of hash function used to create the proof, must be one of:
   * * sha512_256
   * * sha256
   */
  constructor({ idx, proof, stibhash, treedepth, hashtype }) {
    super();
    this.idx = idx;
    this.proof = typeof proof === "string" ? new Uint8Array(buffer.Buffer.from(proof, "base64")) : proof;
    this.stibhash = typeof stibhash === "string" ? new Uint8Array(buffer.Buffer.from(stibhash, "base64")) : stibhash;
    this.treedepth = treedepth;
    this.hashtype = hashtype;
    this.attribute_map = {
      idx: "idx",
      proof: "proof",
      stibhash: "stibhash",
      treedepth: "treedepth",
      hashtype: "hashtype"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["idx"] === "undefined")
      throw new Error(`Response is missing required field 'idx': ${data}`);
    if (typeof data["proof"] === "undefined")
      throw new Error(`Response is missing required field 'proof': ${data}`);
    if (typeof data["stibhash"] === "undefined")
      throw new Error(`Response is missing required field 'stibhash': ${data}`);
    if (typeof data["treedepth"] === "undefined")
      throw new Error(`Response is missing required field 'treedepth': ${data}`);
    return new TransactionProofResponse({
      idx: data["idx"],
      proof: data["proof"],
      stibhash: data["stibhash"],
      treedepth: data["treedepth"],
      hashtype: data["hashtype"]
    });
  }
}
class Version extends BaseModel {
  /**
   * Creates a new `Version` object.
   * @param build -
   * @param genesisHashB64 -
   * @param genesisId -
   * @param versions -
   */
  constructor({ build, genesisHashB64, genesisId, versions }) {
    super();
    this.build = build;
    this.genesisHashB64 = typeof genesisHashB64 === "string" ? new Uint8Array(buffer.Buffer.from(genesisHashB64, "base64")) : genesisHashB64;
    this.genesisId = genesisId;
    this.versions = versions;
    this.attribute_map = {
      build: "build",
      genesisHashB64: "genesis_hash_b64",
      genesisId: "genesis_id",
      versions: "versions"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["build"] === "undefined")
      throw new Error(`Response is missing required field 'build': ${data}`);
    if (typeof data["genesis_hash_b64"] === "undefined")
      throw new Error(`Response is missing required field 'genesis_hash_b64': ${data}`);
    if (typeof data["genesis_id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis_id': ${data}`);
    if (!Array.isArray(data["versions"]))
      throw new Error(`Response is missing required array field 'versions': ${data}`);
    return new Version({
      build: BuildVersion.from_obj_for_encoding(data["build"]),
      genesisHashB64: data["genesis_hash_b64"],
      genesisId: data["genesis_id"],
      versions: data["versions"]
    });
  }
}
const types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account: Account$1,
  AccountApplicationResponse,
  AccountAssetResponse,
  AccountParticipation: AccountParticipation$1,
  AccountStateDelta: AccountStateDelta$1,
  Application: Application$1,
  ApplicationLocalState: ApplicationLocalState$1,
  ApplicationParams: ApplicationParams$1,
  ApplicationStateSchema: ApplicationStateSchema$1,
  Asset: Asset$1,
  AssetHolding: AssetHolding$1,
  AssetParams: AssetParams$1,
  BlockHashResponse,
  BlockResponse,
  Box: Box$1,
  BoxDescriptor: BoxDescriptor$1,
  BoxesResponse: BoxesResponse$1,
  BuildVersion,
  CompileResponse,
  DisassembleResponse,
  DryrunRequest,
  DryrunResponse,
  DryrunSource,
  DryrunState,
  DryrunTxnResult,
  ErrorResponse: ErrorResponse$1,
  EvalDelta: EvalDelta$1,
  EvalDeltaKeyValue: EvalDeltaKeyValue$1,
  LightBlockHeaderProof: LightBlockHeaderProof$1,
  NodeStatusResponse,
  PendingTransactionResponse,
  PendingTransactionsResponse,
  PostTransactionsResponse,
  StateProof: StateProof$1,
  StateProofMessage,
  SupplyResponse,
  TealKeyValue: TealKeyValue$1,
  TealValue: TealValue$1,
  TransactionParametersResponse,
  TransactionProofResponse,
  Version
}, Symbol.toStringTag, { value: "Module" }));
class GetApplicationBoxByName extends JSONRequest {
  constructor(c, intDecoding, index2, name) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    const encodedName = buffer.Buffer.from(name).toString("base64");
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return Box$1.from_obj_for_encoding(body);
  }
}
class GetApplicationBoxes extends JSONRequest {
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    this.query.max = 0;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResult = await algodClient
   *        .GetApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  max(max) {
    this.query.max = max;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return BoxesResponse$1.from_obj_for_encoding(body);
  }
}
let HealthCheck$1 = class HealthCheck extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
  async do(headers = {}) {
    const res = await this.c.get(this.path(), {}, headers);
    if (!res.ok) {
      throw new Error(`Health response: ${res.status}`);
    }
    return {};
  }
};
class PendingTransactionInformation extends JSONRequest {
  constructor(c, txid) {
    super(c);
    this.txid = txid;
    this.txid = txid;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
}
class PendingTransactions extends JSONRequest {
  constructor(c) {
    super(c);
    this.query.format = "msgpack";
  }
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/pending";
  }
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
  /* eslint-enable class-methods-use-this */
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
}
class PendingTransactionsByAddress extends JSONRequest {
  constructor(c, address) {
    super(c);
    this.address = address;
    this.address = address;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    if (body && body.byteLength > 0) {
      return decode$1(body);
    }
    return void 0;
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
}
class GetTransactionProof extends JSONRequest {
  constructor(c, intDecoding, round, txID) {
    super(c, intDecoding);
    this.round = round;
    this.txID = txID;
    this.round = round;
    this.txID = txID;
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  /**
   * Exclude assets and application data from results
   * The type of hash function used to create the proof, must be one of: "sha512_256", "sha256"
   *
   * #### Example
   * ```typescript
   * const hashType = "sha256";
   * const round = 123456;
   * const txId = "abc123;
   * const txProof = await algodClient.getTransactionProof(round, txId)
   *        .hashType(hashType)
   *        .do();
   * ```
   *
   * @param hashType
   * @category query
   */
  hashType(hashType) {
    this.query.hashtype = hashType;
    return this;
  }
}
function setSendTransactionHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/x-binary";
  }
  return hdrs;
}
function isByteArray(array) {
  return array && array.byteLength !== void 0;
}
class SendRawTransaction extends JSONRequest {
  constructor(c, stxOrStxs) {
    super(c);
    let forPosting = stxOrStxs;
    if (Array.isArray(stxOrStxs)) {
      if (!stxOrStxs.every(isByteArray)) {
        throw new TypeError("Array elements must be byte arrays");
      }
      forPosting = concatArrays(...stxOrStxs);
    } else if (!isByteArray(forPosting)) {
      throw new TypeError("Argument must be byte array");
    }
    this.txnBytesToPost = forPosting;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  async do(headers = {}) {
    const txHeaders = setSendTransactionHeaders(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.txnBytesToPost), txHeaders);
    return res.body;
  }
}
class Status extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/status";
  }
}
class StatusAfterBlock extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    if (!Number.isInteger(round))
      throw Error("round should be an integer");
    this.round = round;
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
}
class SuggestedParamsRequest extends JSONRequest {
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/params";
  }
  prepare(body) {
    return {
      flatFee: false,
      fee: body.fee,
      firstRound: body["last-round"],
      lastRound: body["last-round"] + 1e3,
      genesisID: body["genesis-id"],
      genesisHash: body["genesis-hash"]
    };
  }
}
class Supply extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/ledger/supply";
  }
}
class Versions extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/versions";
  }
}
class LightBlockHeaderProof2 extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
}
class StateProof2 extends JSONRequest {
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
}
function setHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
class Disassemble extends JSONRequest {
  constructor(c, source) {
    super(c);
    this.source = source;
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/disassemble`;
  }
  /**
   * Executes disassemble
   * @param headers - A headers object
   */
  async do(headers = {}) {
    const txHeaders = setHeaders(headers);
    const res = await this.c.post(this.path(), buffer.Buffer.from(this.source), txHeaders, this.query);
    return res.body;
  }
}
class AlgodClient extends ServiceClient {
  /**
   * Create an AlgodClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
   * const server = "http://localhost";
   * const port   = 4001;
   * const algodClient = new algosdk.Algodv2(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The algod token from the Algorand node you are interacting with
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer, port, headers = {}) {
    super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns OK if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await algodClient.healthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-health)
   * @category GET
   */
  healthCheck() {
    return new HealthCheck$1(this.c);
  }
  /**
   * Retrieves the supported API versions, binary build versions, and genesis information.
   *
   * #### Example
   * ```typescript
   * const versionsDetails = await algodClient.versionsCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-versions)
   * @category GET
   */
  versionsCheck() {
    return new Versions(this.c);
  }
  /**
   * Broadcasts a raw transaction to the network.
   *
   * #### Example
   * ```typescript
   * const { txId } = await algodClient.sendRawTransaction(signedTxns).do();
   * const result = await waitForConfirmation(algodClient, txid, 3);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2transactions)
   *
   * @remarks
   * Often used with {@linkcode waitForConfirmation}
   * @param stxOrStxs - Signed transactions
   * @category POST
   */
  sendRawTransaction(stxOrStxs) {
    return new SendRawTransaction(this.c, stxOrStxs);
  }
  /**
   * Returns the given account's status, balance and spendable amounts.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @category GET
   */
  accountInformation(account) {
    return new AccountInformation(this.c, this.intDecoding, account);
  }
  /**
   * Returns the given account's asset information for a specific asset.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountAssetInfo = await algodClient.accountAssetInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The asset ID to look up.
   * @category GET
   */
  accountAssetInformation(account, index2) {
    return new AccountAssetInformation(this.c, this.intDecoding, account, index2);
  }
  /**
   * Returns the given account's application information for a specific application.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountInfo = await algodClient.accountApplicationInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The application ID to look up.
   * @category GET
   */
  accountApplicationInformation(account, index2) {
    return new AccountApplicationInformation(this.c, this.intDecoding, account, index2);
  }
  /**
   * Gets the block info for the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.block(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksround)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  block(roundNumber) {
    return new Block$1(this.c, roundNumber);
  }
  /**
   * Get the block hash for the block on the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.getBlockHash(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksroundhash)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  getBlockHash(roundNumber) {
    return new GetBlockHash(this.c, this.intDecoding, roundNumber);
  }
  /**
   * Returns the transaction information for a specific pending transaction.
   *
   * #### Example
   * ```typescript
   * const txId = "DRJS6R745A7GFVMXEXWP4TGVDGKW7VILFTA7HC2BR2GRLHNY5CTA";
   * const pending = await algodClient.pendingTransactionInformation(txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2transactionspendingtxid)
   *
   * @remarks
   * <br><br>
   * There are several cases when this might succeed:
   * - transaction committed (committed round > 0)
   * - transaction still in the pool (committed round = 0, pool error = "")
   * - transaction removed from pool due to error (committed round = 0, pool error != "")
   *
   * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
   *
   * @param txid - The TxID string of the pending transaction to look up.
   * @category GET
   */
  pendingTransactionInformation(txid) {
    return new PendingTransactionInformation(this.c, txid);
  }
  /**
   * Returns the list of pending transactions in the pool, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const pendingTxns = await algodClient.pendingTransactionsInformation().do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const pendingTxns = await algodClient
   *     .pendingTransactionsInformation()
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2transactionspending)
   * @category GET
   */
  pendingTransactionsInformation() {
    return new PendingTransactions(this.c);
  }
  /**
   * Returns the list of pending transactions sent by the address, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxnsByAddr = await algodClient.pendingTransactionByAddress(address).do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxns = await algodClient
   *     .pendingTransactionByAddress(address)
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2accountsaddresstransactionspending)
   * @param address - The address of the sender.
   * @category GET
   */
  pendingTransactionByAddress(address) {
    return new PendingTransactionsByAddress(this.c, address);
  }
  /**
   * Retrieves the StatusResponse from the running node.
   *
   * #### Example
   * ```typescript
   * const status = await algodClient.status().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2status)
   * @category GET
   */
  status() {
    return new Status(this.c, this.intDecoding);
  }
  /**
   * Waits for a specific round to occur then returns the `StatusResponse` for that round.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const statusAfterBlock = await algodClient.statusAfterBlock(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2statuswait-for-block-afterround)
   * @param round - The number of the round to wait for.
   * @category GET
   */
  statusAfterBlock(round) {
    return new StatusAfterBlock(this.c, this.intDecoding, round);
  }
  /**
   * Returns the common needed parameters for a new transaction.
   *
   * #### Example
   * ```typescript
   * const suggestedParams = await algodClient.getTransactionParams().do();
   * const amountInMicroAlgos = algosdk.algosToMicroalgos(2); // 2 Algos
   * const unsignedTxn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
   *   from: senderAddress,
   *   to: receiverAddress,
   *   amount: amountInMicroAlgos,
   *   suggestedParams: suggestedParams,
   * });
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2transactionsparams)
   *
   * @remarks
   * Often used with
   * {@linkcode makePaymentTxnWithSuggestedParamsFromObject}, {@linkcode algosToMicroalgos}
   * @category GET
   */
  getTransactionParams() {
    return new SuggestedParamsRequest(this.c);
  }
  /**
   * Returns the supply details for the specified node's ledger.
   *
   * #### Example
   * ```typescript
   * const supplyDetails = await algodClient.supply().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2ledgersupply)
   * @category GET
   */
  supply() {
    return new Supply(this.c, this.intDecoding);
  }
  /**
   * Compiles TEAL source code to binary, returns base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style).
   *
   * #### Example
   * ```typescript
   * const source = "TEAL SOURCE CODE";
   * const compiledSmartContract = await algodClient.compile(source).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2tealcompile)
   * @remarks
   * This endpoint is only enabled when a node's configuration file sets `EnableDeveloperAPI` to true.
   * @param source
   * @category POST
   */
  compile(source) {
    return new Compile(this.c, source);
  }
  /**
   * Given the program bytes, return the TEAL source code in plain text.
   *
   * #### Example
   * ```typescript
   * const bytecode = "TEAL bytecode";
   * const disassembledSource = await algodClient.disassemble(bytecode).do();
   * ```
   *
   * @remarks This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
   * @param source
   */
  disassemble(source) {
    return new Disassemble(this.c, source);
  }
  /**
   * Provides debugging information for a transaction (or group).
   *
   * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configureation file sets `EnableDeveloperAPI` to true.
   *
   * #### Example
   * ```typescript
   * const dryRunResult = await algodClient.dryrun(dr).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#post-v2tealdryrun)
   * @param dr
   * @category POST
   */
  dryrun(dr2) {
    return new Dryrun(this.c, dr2);
  }
  /**
   * Given an asset ID, return asset information including creator, name, total supply and
   * special addresses.
   *
   * #### Example
   * ```typescript
   * const asset_id = 163650;
   * const asset = await algodClient.getAssetByID(asset_id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   * @category GET
   */
  getAssetByID(index2) {
    return new GetAssetByID(this.c, this.intDecoding, index2);
  }
  /**
   * Given an application ID, return the application information including creator, approval
   * and clear programs, global and local schemas, and global state.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const app = await algodClient.getApplicationByID(index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2applicationsapplication-id)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationByID(index2) {
    return new GetApplicationByID(this.c, this.intDecoding, index2);
  }
  /**
   * Given an application ID and the box name (key), return the value stored in the box.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxName = Buffer.from("foo");
   * const boxResponse = await algodClient.getApplicationBoxByName(index, boxName).do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2applicationsapplication-idbox)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxByName(index2, boxName) {
    return new GetApplicationBoxByName(this.c, this.intDecoding, index2, boxName);
  }
  /**
   * Given an application ID, return all the box names associated with the app.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxesResponse = await algodClient.getApplicationBoxes(index).max(3).do();
   * const boxNames = boxesResponse.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2applicationsapplication-idboxes)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxes(index2) {
    return new GetApplicationBoxes(this.c, this.intDecoding, index2);
  }
  /**
   * Returns the entire genesis file.
   *
   * #### Example
   * ```typescript
   * const genesis = await algodClient.genesis().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-genesis)
   * @category GET
   */
  genesis() {
    return new Genesis(this.c, this.intDecoding);
  }
  /**
   * Returns a Merkle proof for a given transaction in a block.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const proof = await algodClient.getTransactionProof(round, txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2/#get-v2blocksroundtransactionstxidproof)
   * @param round - The round in which the transaction appears.
   * @param txID - The transaction ID for which to generate a proof.
   * @category GET
   */
  getTransactionProof(round, txID) {
    return new GetTransactionProof(this.c, this.intDecoding, round, txID);
  }
  /**
   * Gets a proof for a given light block header inside a state proof commitment.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const lightBlockHeaderProof = await algodClient.getLightBlockHeaderProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2blocksroundlightheaderproof)
   * @param round
   */
  getLightBlockHeaderProof(round) {
    return new LightBlockHeaderProof2(this.c, this.intDecoding, round);
  }
  /**
   * Gets a state proof that covers a given round.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const stateProof = await algodClient.getStateProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2stateproofsround)
   * @param round
   */
  getStateProof(round) {
    return new StateProof2(this.c, this.intDecoding, round);
  }
}
class Kmd extends ServiceClient {
  constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
    super("X-KMD-API-Token", token, baseServer, port, headers);
  }
  /**
   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
   */
  async versions() {
    const res = await this.c.get("/versions");
    return res.body;
  }
  /**
   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
   */
  async listWallets() {
    const res = await this.c.get("/v1/wallets");
    return res.body;
  }
  /**
   * createWallet creates a wallet with the specified name, password, driver,
   * and master derivation key. If the master derivation key is blank, one is
   * generated internally to kmd. CreateWallet returns a CreateWalletResponse
   * containing information about the new wallet.
   * @param walletName
   * @param walletPassword
   * @param walletDriverName
   * @param walletMDK
   */
  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = "sqlite") {
    const req = {
      wallet_name: walletName,
      wallet_driver_name: walletDriverName,
      wallet_password: walletPassword,
      master_derivation_key: buffer.Buffer.from(walletMDK).toString("base64")
    };
    const res = await this.c.post("/v1/wallet", req);
    return res.body;
  }
  /**
   * initWalletHandle accepts a wallet ID and a wallet password, and returns an
   * initWalletHandleResponse containing a wallet handle token. This wallet
   * handle token can be used for subsequent operations on this wallet, like key
   * generation, transaction signing, etc.. WalletHandleTokens expire after a
   * configurable number of seconds, and must be renewed periodically with
   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
   * you're done interacting with this wallet.
   * @param walletID
   * @param walletPassword
   */
  async initWalletHandle(walletID, walletPassword) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/wallet/init", req);
    return res.body;
  }
  /**
   * releaseWalletHandle invalidates the passed wallet handle token, making
   * it unusuable for subsequent wallet operations.
   * @param walletHandle
   */
  async releaseWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/release", req);
    return res.body;
  }
  /**
   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
   * the expiration time to some number of seconds in the future. It returns a
   * RenewWalletHandleResponse containing the walletHandle and the number of
   * seconds until expiration
   * @param walletHandle
   */
  async renewWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/renew", req);
    return res.body;
  }
  /**
   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
   * and renames the underlying wallet.
   * @param walletID
   * @param walletPassword
   * @param newWalletName
   */
  async renameWallet(walletID, walletPassword, newWalletName) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword,
      wallet_name: newWalletName
    };
    const res = await this.c.post("/v1/wallet/rename", req);
    return res.body;
  }
  /**
   * getWallet accepts a wallet handle and returns high level information about
   * this wallet in a GetWalletResponse.
   * @param walletHandle
   */
  async getWallet(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/wallet/info", req);
    return res.body;
  }
  /**
   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
   * returns an ExportMasterDerivationKeyResponse containing the master
   * derivation key. This key can be used as an argument to CreateWallet in
   * order to recover the keys generated by this wallet. The master derivation
   * key can be encoded as a sequence of words using the mnemonic library, and
   * @param walletHandle
   * @param walletPassword
   */
  async exportMasterDerivationKey(walletHandle, walletPassword) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/master-key/export", req);
    return {
      master_derivation_key: buffer.Buffer.from(res.body.master_derivation_key, "base64")
    };
  }
  /**
   * importKey accepts a wallet handle and an ed25519 private key, and imports
   * the key into the wallet. It returns an ImportKeyResponse containing the
   * address corresponding to this private key.
   * @param walletHandle
   * @param secretKey
   */
  async importKey(walletHandle, secretKey) {
    const req = {
      wallet_handle_token: walletHandle,
      private_key: buffer.Buffer.from(secretKey).toString("base64")
    };
    const res = await this.c.post("/v1/key/import", req);
    return res.body;
  }
  /**
   * exportKey accepts a wallet handle, wallet password, and address, and returns
   * an ExportKeyResponse containing the ed25519 private key corresponding to the
   * address stored in the wallet.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.post("/v1/key/export", req);
    return { private_key: buffer.Buffer.from(res.body.private_key, "base64") };
  }
  /**
   * generateKey accepts a wallet handle, and then generates the next key in the
   * wallet using its internal master derivation key. Two wallets with the same
   * master derivation key will generate the same sequence of keys.
   * @param walletHandle
   */
  async generateKey(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle,
      display_mnemonic: false
    };
    const res = await this.c.post("/v1/key", req);
    return res.body;
  }
  /**
   * deleteKey accepts a wallet handle, wallet password, and address, and deletes
   * the information about this address from the wallet (including address and
   * secret key). If DeleteKey is called on a key generated using GenerateKey,
   * the same key will not be generated again. However, if a wallet is recovered
   * using the master derivation key, a key generated in this way can be
   * recovered.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/key", req);
    return res.body;
  }
  /**
   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
   * all of the addresses for which this wallet contains secret keys.
   * @param walletHandle
   */
  async listKeys(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/key/list", req);
    return res.body;
  }
  /**
   * signTransaction accepts a wallet handle, wallet password, and a transaction,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * Sender field.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   */
  async signTransaction(walletHandle, walletPassword, transaction) {
    const tx2 = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: buffer.Buffer.from(tx2.toByte()).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return buffer.Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  /**
   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * publicKey arg.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)
   */
  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
    const tx2 = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: buffer.Buffer.from(tx2.toByte()).toString("base64"),
      public_key: buffer.Buffer.from(publicKey).toString("base64")
    };
    const res = await this.c.post("/v1/transaction/sign", req);
    if (res.status === 200) {
      return buffer.Buffer.from(res.body.signed_transaction, "base64");
    }
    return res.body;
  }
  /**
   * listMultisig accepts a wallet handle and returns a ListMultisigResponse
   * containing the multisig addresses whose preimages are stored in this wallet.
   * A preimage is the information needed to reconstruct this multisig address,
   * including multisig version information, threshold information, and a list
   * of public keys.
   * @param walletHandle
   */
  async listMultisig(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    const res = await this.c.post("/v1/multisig/list", req);
    return res.body;
  }
  /**
   * importMultisig accepts a wallet handle and the information required to
   * generate a multisig address. It derives this address, and stores all of the
   * information within the wallet. It returns a ImportMultisigResponse with the
   * derived address.
   * @param walletHandle
   * @param version
   * @param threshold
   * @param pks
   */
  async importMultisig(walletHandle, version2, threshold, pks) {
    const req = {
      wallet_handle_token: walletHandle,
      multisig_version: version2,
      threshold,
      pks
    };
    const res = await this.c.post("/v1/multisig/import", req);
    return res.body;
  }
  /**
   * exportMultisig accepts a wallet handle, wallet password, and multisig
   * address, and returns an ExportMultisigResponse containing the stored
   * multisig preimage. The preimage contains all of the information necessary
   * to derive the multisig address, including version, threshold, and a list of
   * public keys.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportMultisig(walletHandle, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr
    };
    const res = await this.c.post("/v1/multisig/export", req);
    return res.body;
  }
  /**
   * signMultisigTransaction accepts a wallet handle, wallet password,
   * transaction, public key (*not* an address), and an optional partial
   * MultisigSig. It looks up the secret key corresponding to the public key, and
   * returns a SignMultisigTransactionResponse containing a MultisigSig with a
   * signature by the secret key included.
   * @param walletHandle
   * @param pw
   * @param tx
   * @param pk
   * @param partial
   */
  async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
    const tx2 = instantiateTxnIfNeeded(transaction);
    const req = {
      wallet_handle_token: walletHandle,
      transaction: buffer.Buffer.from(tx2.toByte()).toString("base64"),
      public_key: buffer.Buffer.from(pk).toString("base64"),
      partial_multisig: partial,
      wallet_password: pw
    };
    const res = await this.c.post("/v1/multisig/sign", req);
    return res.body;
  }
  /**
   * deleteMultisig accepts a wallet handle, wallet password, and multisig
   * address, and deletes the information about this multisig address from the
   * wallet (including address and secret key).
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteMultisig(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.c.delete("/v1/multisig", req);
    return res.body;
  }
}
class MakeHealthCheck extends JSONRequest {
  /**
   * @returns `/health`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
}
class LookupAssetBalances extends JSONRequest {
  /**
   * Returns the list of accounts which hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}/balances`
   */
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filtered results should have an asset balance greater than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const minBalance = 1000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyGreaterThan(minBalance)
   *        .do();
   * ```
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an asset balance less than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxBalance = 2000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyLessThan(maxBalance)
   *        .do();
   * ```
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   *
   * const assetBalancesPage1 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetBalancesPage2 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetBalancesPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
function base64StringFunnel(data) {
  if (typeof data === "string") {
    return data;
  }
  return buffer.Buffer.from(data).toString("base64");
}
class LookupAccountTransactions extends JSONRequest {
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/transactions`
   */
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txType("appl")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .sigType("msig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id2) {
    this.query["asset-id"] = id2;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * The next page of results. Use the next token provided by the previous results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   *
   * const accountTxnsPage1 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountTxnsPage2 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .nextToken(accountTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
}
class LookupAssetTransactions extends JSONRequest {
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}/transactions`
   */
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txType("axfer")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .sigType("lsig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const minBalance = 300000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const maxBalance = 500000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "sender";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .do();
   * ```
   *
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address;
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   *
   * const assetTxnsPage1 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetTxnsPage2 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
}
class LookupBlock extends JSONRequest {
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  constructor(c, intDecoding, round) {
    super(c, intDecoding);
    this.round = round;
    this.round = round;
  }
  /**
   * @returns `/v2/blocks/${round}`
   */
  path() {
    return `/v2/blocks/${this.round}`;
  }
  /**
   * Header only flag. When this is set to true, returned block does not contain the
   * transactions.
   */
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
}
class LookupTransactionByID extends JSONRequest {
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  constructor(c, intDecoding, txID) {
    super(c, intDecoding);
    this.txID = txID;
    this.txID = txID;
  }
  /**
   * @returns `/v2/transactions/${txID}`
   */
  path() {
    return `/v2/transactions/${this.txID}`;
  }
}
class LookupAccountByID extends JSONRequest {
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}`
   */
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll()
   *        .do();
   * ```
   * @param value
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
}
class LookupAccountAssets extends JSONRequest {
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/assets`
   */
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .assetId(assetId)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetId(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
}
class LookupAccountCreatedAssets extends JSONRequest {
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/created-assets`
   */
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetID(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
}
class LookupAccountAppLocalStates extends JSONRequest {
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/apps-local-state`
   */
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index2) {
    this.query["application-id"] = index2;
    return this;
  }
}
class LookupAccountCreatedApplications extends JSONRequest {
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c, intDecoding, account) {
    super(c, intDecoding);
    this.account = account;
    this.account = account;
  }
  /**
   * @returns `/v2/accounts/${account}/created-applications`
   */
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index2) {
    this.query["application-id"] = index2;
    return this;
  }
}
class LookupAssetByID extends JSONRequest {
  /**
   * Returns asset information of the queried asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/assets/${index}`
   */
  path() {
    return `/v2/assets/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class LookupApplications extends JSONRequest {
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/applications/${index}`
   */
  path() {
    return `/v2/applications/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class LookupApplicationLogs extends JSONRequest {
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  constructor(c, intDecoding, appID) {
    super(c, intDecoding);
    this.appID = appID;
    this.appID = appID;
  }
  /**
   * @returns `/v2/applications/${appID}/logs`
   */
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const appLogsPage1 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   *
   * const appLogsPage2 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .nextToken(appLogsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Only include transactions with this sender address.
   *
   * #### Example
   * ```typescript
   * const sender = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .sender(sender)
   *        .do();
   * ```
   *
   * @param senderAddress
   * @category query
   */
  sender(senderAddress) {
    this.query["sender-address"] = senderAddress;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
}
class Account2 extends BaseModel {
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalBoxBytes - For app-accounts only. The total number of bytes allocated for the keys and
   * values of boxes which belong to the associated application.
   * @param totalBoxes - For app-accounts only. The total number of boxes which belong to the associated
   * application.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param closedAtRound - Round during which this account was most recently closed.
   * @param createdApps - (appp) parameters of applications created by this account including app global
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param createdAtRound - Round during which this account first appeared in a transaction.
   * @param deleted - Whether or not this account is currently closed.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * * or null if unknown
   */
  constructor({ address, amount, amountWithoutPendingRewards, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalBoxBytes, totalBoxes, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, closedAtRound, createdApps, createdAssets, createdAtRound, deleted, participation, rewardBase, sigType }) {
    super();
    this.address = address;
    this.amount = amount;
    this.amountWithoutPendingRewards = amountWithoutPendingRewards;
    this.pendingRewards = pendingRewards;
    this.rewards = rewards;
    this.round = round;
    this.status = status;
    this.totalAppsOptedIn = totalAppsOptedIn;
    this.totalAssetsOptedIn = totalAssetsOptedIn;
    this.totalBoxBytes = totalBoxBytes;
    this.totalBoxes = totalBoxes;
    this.totalCreatedApps = totalCreatedApps;
    this.totalCreatedAssets = totalCreatedAssets;
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = appsTotalExtraPages;
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = authAddr;
    this.closedAtRound = closedAtRound;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.participation = participation;
    this.rewardBase = rewardBase;
    this.sigType = sigType;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      amountWithoutPendingRewards: "amount-without-pending-rewards",
      pendingRewards: "pending-rewards",
      rewards: "rewards",
      round: "round",
      status: "status",
      totalAppsOptedIn: "total-apps-opted-in",
      totalAssetsOptedIn: "total-assets-opted-in",
      totalBoxBytes: "total-box-bytes",
      totalBoxes: "total-boxes",
      totalCreatedApps: "total-created-apps",
      totalCreatedAssets: "total-created-assets",
      appsLocalState: "apps-local-state",
      appsTotalExtraPages: "apps-total-extra-pages",
      appsTotalSchema: "apps-total-schema",
      assets: "assets",
      authAddr: "auth-addr",
      closedAtRound: "closed-at-round",
      createdApps: "created-apps",
      createdAssets: "created-assets",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      participation: "participation",
      rewardBase: "reward-base",
      sigType: "sig-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["amount-without-pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${data}`);
    if (typeof data["pending-rewards"] === "undefined")
      throw new Error(`Response is missing required field 'pending-rewards': ${data}`);
    if (typeof data["rewards"] === "undefined")
      throw new Error(`Response is missing required field 'rewards': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["status"] === "undefined")
      throw new Error(`Response is missing required field 'status': ${data}`);
    if (typeof data["total-apps-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${data}`);
    if (typeof data["total-assets-opted-in"] === "undefined")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${data}`);
    if (typeof data["total-box-bytes"] === "undefined")
      throw new Error(`Response is missing required field 'total-box-bytes': ${data}`);
    if (typeof data["total-boxes"] === "undefined")
      throw new Error(`Response is missing required field 'total-boxes': ${data}`);
    if (typeof data["total-created-apps"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-apps': ${data}`);
    if (typeof data["total-created-assets"] === "undefined")
      throw new Error(`Response is missing required field 'total-created-assets': ${data}`);
    return new Account2({
      address: data["address"],
      amount: data["amount"],
      amountWithoutPendingRewards: data["amount-without-pending-rewards"],
      pendingRewards: data["pending-rewards"],
      rewards: data["rewards"],
      round: data["round"],
      status: data["status"],
      totalAppsOptedIn: data["total-apps-opted-in"],
      totalAssetsOptedIn: data["total-assets-opted-in"],
      totalBoxBytes: data["total-box-bytes"],
      totalBoxes: data["total-boxes"],
      totalCreatedApps: data["total-created-apps"],
      totalCreatedAssets: data["total-created-assets"],
      appsLocalState: typeof data["apps-local-state"] !== "undefined" ? data["apps-local-state"].map(ApplicationLocalState2.from_obj_for_encoding) : void 0,
      appsTotalExtraPages: data["apps-total-extra-pages"],
      appsTotalSchema: typeof data["apps-total-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["apps-total-schema"]) : void 0,
      assets: typeof data["assets"] !== "undefined" ? data["assets"].map(AssetHolding2.from_obj_for_encoding) : void 0,
      authAddr: data["auth-addr"],
      closedAtRound: data["closed-at-round"],
      createdApps: typeof data["created-apps"] !== "undefined" ? data["created-apps"].map(Application2.from_obj_for_encoding) : void 0,
      createdAssets: typeof data["created-assets"] !== "undefined" ? data["created-assets"].map(Asset2.from_obj_for_encoding) : void 0,
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      participation: typeof data["participation"] !== "undefined" ? AccountParticipation2.from_obj_for_encoding(data["participation"]) : void 0,
      rewardBase: data["reward-base"],
      sigType: data["sig-type"]
    });
  }
}
class AccountParticipation2 extends BaseModel {
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    super();
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(buffer.Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.attribute_map = {
      selectionParticipationKey: "selection-participation-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key",
      stateProofKey: "state-proof-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["selection-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'selection-participation-key': ${data}`);
    if (typeof data["vote-first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-first-valid': ${data}`);
    if (typeof data["vote-key-dilution"] === "undefined")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${data}`);
    if (typeof data["vote-last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'vote-last-valid': ${data}`);
    if (typeof data["vote-participation-key"] === "undefined")
      throw new Error(`Response is missing required field 'vote-participation-key': ${data}`);
    return new AccountParticipation2({
      selectionParticipationKey: data["selection-participation-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"],
      stateProofKey: data["state-proof-key"]
    });
  }
}
class AccountResponse extends BaseModel {
  /**
   * Creates a new `AccountResponse` object.
   * @param account - Account information at a given round.
   * Definition:
   * data/basics/userBalance.go : AccountData
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ account, currentRound }) {
    super();
    this.account = account;
    this.currentRound = currentRound;
    this.attribute_map = {
      account: "account",
      currentRound: "current-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["account"] === "undefined")
      throw new Error(`Response is missing required field 'account': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AccountResponse({
      account: Account2.from_obj_for_encoding(data["account"]),
      currentRound: data["current-round"]
    });
  }
}
class AccountStateDelta2 extends BaseModel {
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    super();
    this.address = address;
    this.delta = delta;
    this.attribute_map = {
      address: "address",
      delta: "delta"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (!Array.isArray(data["delta"]))
      throw new Error(`Response is missing required array field 'delta': ${data}`);
    return new AccountStateDelta2({
      address: data["address"],
      delta: data["delta"].map(EvalDeltaKeyValue2.from_obj_for_encoding)
    });
  }
}
class AccountsResponse extends BaseModel {
  /**
   * Creates a new `AccountsResponse` object.
   * @param accounts -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ accounts, currentRound, nextToken }) {
    super();
    this.accounts = accounts;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      accounts: "accounts",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["accounts"]))
      throw new Error(`Response is missing required array field 'accounts': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AccountsResponse({
      accounts: data["accounts"].map(Account2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class Application2 extends BaseModel {
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   * @param createdAtRound - Round when this application was created.
   * @param deleted - Whether or not this application is currently deleted.
   * @param deletedAtRound - Round when this application was deleted.
   */
  constructor({ id: id2, params, createdAtRound, deleted, deletedAtRound }) {
    super();
    this.id = id2;
    this.params = params;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.deletedAtRound = deletedAtRound;
    this.attribute_map = {
      id: "id",
      params: "params",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      deletedAtRound: "deleted-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Application2({
      id: data["id"],
      params: ApplicationParams2.from_obj_for_encoding(data["params"]),
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      deletedAtRound: data["deleted-at-round"]
    });
  }
}
class ApplicationLocalState2 extends BaseModel {
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param closedOutAtRound - Round when account closed out of the application.
   * @param deleted - Whether or not the application local state is currently deleted from its
   * account.
   * @param keyValue - (tkv) storage.
   * @param optedInAtRound - Round when the account opted into the application.
   */
  constructor({ id: id2, schema, closedOutAtRound, deleted, keyValue, optedInAtRound }) {
    super();
    this.id = id2;
    this.schema = schema;
    this.closedOutAtRound = closedOutAtRound;
    this.deleted = deleted;
    this.keyValue = keyValue;
    this.optedInAtRound = optedInAtRound;
    this.attribute_map = {
      id: "id",
      schema: "schema",
      closedOutAtRound: "closed-out-at-round",
      deleted: "deleted",
      keyValue: "key-value",
      optedInAtRound: "opted-in-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["id"] === "undefined")
      throw new Error(`Response is missing required field 'id': ${data}`);
    if (typeof data["schema"] === "undefined")
      throw new Error(`Response is missing required field 'schema': ${data}`);
    return new ApplicationLocalState2({
      id: data["id"],
      schema: ApplicationStateSchema2.from_obj_for_encoding(data["schema"]),
      closedOutAtRound: data["closed-out-at-round"],
      deleted: data["deleted"],
      keyValue: typeof data["key-value"] !== "undefined" ? data["key-value"].map(TealKeyValue2.from_obj_for_encoding) : void 0,
      optedInAtRound: data["opted-in-at-round"]
    });
  }
}
class ApplicationLocalStatesResponse extends BaseModel {
  /**
   * Creates a new `ApplicationLocalStatesResponse` object.
   * @param appsLocalStates -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ appsLocalStates, currentRound, nextToken }) {
    super();
    this.appsLocalStates = appsLocalStates;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      appsLocalStates: "apps-local-states",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["apps-local-states"]))
      throw new Error(`Response is missing required array field 'apps-local-states': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationLocalStatesResponse({
      appsLocalStates: data["apps-local-states"].map(ApplicationLocalState2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class ApplicationLogData extends BaseModel {
  /**
   * Creates a new `ApplicationLogData` object.
   * @param logs - (lg) Logs for the application being executed by the transaction.
   * @param txid - Transaction ID
   */
  constructor({ logs, txid }) {
    super();
    this.logs = logs;
    this.txid = txid;
    this.attribute_map = {
      logs: "logs",
      txid: "txid"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["logs"]))
      throw new Error(`Response is missing required array field 'logs': ${data}`);
    if (typeof data["txid"] === "undefined")
      throw new Error(`Response is missing required field 'txid': ${data}`);
    return new ApplicationLogData({
      logs: data["logs"],
      txid: data["txid"]
    });
  }
}
class ApplicationLogsResponse extends BaseModel {
  /**
   * Creates a new `ApplicationLogsResponse` object.
   * @param applicationId - (appidx) application index.
   * @param currentRound - Round at which the results were computed.
   * @param logData -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, currentRound, logData, nextToken }) {
    super();
    this.applicationId = applicationId;
    this.currentRound = currentRound;
    this.logData = logData;
    this.nextToken = nextToken;
    this.attribute_map = {
      applicationId: "application-id",
      currentRound: "current-round",
      logData: "log-data",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationLogsResponse({
      applicationId: data["application-id"],
      currentRound: data["current-round"],
      logData: typeof data["log-data"] !== "undefined" ? data["log-data"].map(ApplicationLogData.from_obj_for_encoding) : void 0,
      nextToken: data["next-token"]
    });
  }
}
class ApplicationParams2 extends BaseModel {
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - [\gs) global schema
   * @param globalStateSchema - [\gsch) global schema
   * @param localStateSchema - [\lsch) local schema
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
    super();
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(buffer.Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(buffer.Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.creator = creator;
    this.extraProgramPages = extraProgramPages;
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.attribute_map = {
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      creator: "creator",
      extraProgramPages: "extra-program-pages",
      globalState: "global-state",
      globalStateSchema: "global-state-schema",
      localStateSchema: "local-state-schema"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["approval-program"] === "undefined")
      throw new Error(`Response is missing required field 'approval-program': ${data}`);
    if (typeof data["clear-state-program"] === "undefined")
      throw new Error(`Response is missing required field 'clear-state-program': ${data}`);
    return new ApplicationParams2({
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      creator: data["creator"],
      extraProgramPages: data["extra-program-pages"],
      globalState: typeof data["global-state"] !== "undefined" ? data["global-state"].map(TealKeyValue2.from_obj_for_encoding) : void 0,
      globalStateSchema: typeof data["global-state-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["global-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? ApplicationStateSchema2.from_obj_for_encoding(data["local-state-schema"]) : void 0
    });
  }
}
class ApplicationResponse extends BaseModel {
  /**
   * Creates a new `ApplicationResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param application - Application index and its parameters
   */
  constructor({ currentRound, application }) {
    super();
    this.currentRound = currentRound;
    this.application = application;
    this.attribute_map = {
      currentRound: "current-round",
      application: "application"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationResponse({
      currentRound: data["current-round"],
      application: typeof data["application"] !== "undefined" ? Application2.from_obj_for_encoding(data["application"]) : void 0
    });
  }
}
class ApplicationStateSchema2 extends BaseModel {
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numByteSlice - (nbs) num of byte slices.
   * @param numUint - (nui) num of uints.
   */
  constructor({ numByteSlice, numUint }) {
    super();
    this.numByteSlice = numByteSlice;
    this.numUint = numUint;
    this.attribute_map = {
      numByteSlice: "num-byte-slice",
      numUint: "num-uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    return new ApplicationStateSchema2({
      numByteSlice: data["num-byte-slice"],
      numUint: data["num-uint"]
    });
  }
}
class ApplicationsResponse extends BaseModel {
  /**
   * Creates a new `ApplicationsResponse` object.
   * @param applications -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applications, currentRound, nextToken }) {
    super();
    this.applications = applications;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      applications: "applications",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["applications"]))
      throw new Error(`Response is missing required array field 'applications': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new ApplicationsResponse({
      applications: data["applications"].map(Application2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class Asset2 extends BaseModel {
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   * @param createdAtRound - Round during which this asset was created.
   * @param deleted - Whether or not this asset is currently deleted.
   * @param destroyedAtRound - Round during which this asset was destroyed.
   */
  constructor({ index: index2, params, createdAtRound, deleted, destroyedAtRound }) {
    super();
    this.index = index2;
    this.params = params;
    this.createdAtRound = createdAtRound;
    this.deleted = deleted;
    this.destroyedAtRound = destroyedAtRound;
    this.attribute_map = {
      index: "index",
      params: "params",
      createdAtRound: "created-at-round",
      deleted: "deleted",
      destroyedAtRound: "destroyed-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["index"] === "undefined")
      throw new Error(`Response is missing required field 'index': ${data}`);
    if (typeof data["params"] === "undefined")
      throw new Error(`Response is missing required field 'params': ${data}`);
    return new Asset2({
      index: data["index"],
      params: AssetParams2.from_obj_for_encoding(data["params"]),
      createdAtRound: data["created-at-round"],
      deleted: data["deleted"],
      destroyedAtRound: data["destroyed-at-round"]
    });
  }
}
class AssetBalancesResponse extends BaseModel {
  /**
   * Creates a new `AssetBalancesResponse` object.
   * @param balances -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ balances, currentRound, nextToken }) {
    super();
    this.balances = balances;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      balances: "balances",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["balances"]))
      throw new Error(`Response is missing required array field 'balances': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetBalancesResponse({
      balances: data["balances"].map(MiniAssetHolding.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class AssetHolding2 extends BaseModel {
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   * @param deleted - Whether or not the asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into this asset holding.
   * @param optedOutAtRound - Round during which the account opted out of this asset holding.
   */
  constructor({ amount, assetId, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = optedInAtRound;
    this.optedOutAtRound = optedOutAtRound;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      isFrozen: "is-frozen",
      deleted: "deleted",
      optedInAtRound: "opted-in-at-round",
      optedOutAtRound: "opted-out-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new AssetHolding2({
      amount: data["amount"],
      assetId: data["asset-id"],
      isFrozen: data["is-frozen"],
      deleted: data["deleted"],
      optedInAtRound: data["opted-in-at-round"],
      optedOutAtRound: data["opted-out-at-round"]
    });
  }
}
class AssetHoldingsResponse extends BaseModel {
  /**
   * Creates a new `AssetHoldingsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    super();
    this.assets = assets;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      assets: "assets",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["assets"]))
      throw new Error(`Response is missing required array field 'assets': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetHoldingsResponse({
      assets: data["assets"].map(AssetHolding2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class AssetParams2 extends BaseModel {
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    super();
    this.creator = creator;
    this.decimals = decimals;
    this.total = total;
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(buffer.Buffer.from(metadataHash, "base64")) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(buffer.Buffer.from(nameB64, "base64")) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(buffer.Buffer.from(unitNameB64, "base64")) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(buffer.Buffer.from(urlB64, "base64")) : urlB64;
    this.attribute_map = {
      creator: "creator",
      decimals: "decimals",
      total: "total",
      clawback: "clawback",
      defaultFrozen: "default-frozen",
      freeze: "freeze",
      manager: "manager",
      metadataHash: "metadata-hash",
      name: "name",
      nameB64: "name-b64",
      reserve: "reserve",
      unitName: "unit-name",
      unitNameB64: "unit-name-b64",
      url: "url",
      urlB64: "url-b64"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["creator"] === "undefined")
      throw new Error(`Response is missing required field 'creator': ${data}`);
    if (typeof data["decimals"] === "undefined")
      throw new Error(`Response is missing required field 'decimals': ${data}`);
    if (typeof data["total"] === "undefined")
      throw new Error(`Response is missing required field 'total': ${data}`);
    return new AssetParams2({
      creator: data["creator"],
      decimals: data["decimals"],
      total: data["total"],
      clawback: data["clawback"],
      defaultFrozen: data["default-frozen"],
      freeze: data["freeze"],
      manager: data["manager"],
      metadataHash: data["metadata-hash"],
      name: data["name"],
      nameB64: data["name-b64"],
      reserve: data["reserve"],
      unitName: data["unit-name"],
      unitNameB64: data["unit-name-b64"],
      url: data["url"],
      urlB64: data["url-b64"]
    });
  }
}
class AssetResponse extends BaseModel {
  /**
   * Creates a new `AssetResponse` object.
   * @param asset - Specifies both the unique identifier and the parameters for an asset
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ asset, currentRound }) {
    super();
    this.asset = asset;
    this.currentRound = currentRound;
    this.attribute_map = {
      asset: "asset",
      currentRound: "current-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["asset"] === "undefined")
      throw new Error(`Response is missing required field 'asset': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetResponse({
      asset: Asset2.from_obj_for_encoding(data["asset"]),
      currentRound: data["current-round"]
    });
  }
}
class AssetsResponse extends BaseModel {
  /**
   * Creates a new `AssetsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    super();
    this.assets = assets;
    this.currentRound = currentRound;
    this.nextToken = nextToken;
    this.attribute_map = {
      assets: "assets",
      currentRound: "current-round",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (!Array.isArray(data["assets"]))
      throw new Error(`Response is missing required array field 'assets': ${data}`);
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    return new AssetsResponse({
      assets: data["assets"].map(Asset2.from_obj_for_encoding),
      currentRound: data["current-round"],
      nextToken: data["next-token"]
    });
  }
}
class Block2 extends BaseModel {
  /**
   * Creates a new `Block` object.
   * @param genesisHash - (gh) hash to which this block belongs.
   * @param genesisId - (gen) ID to which this block belongs.
   * @param previousBlockHash - (prev) Previous block hash.
   * @param round - (rnd) Current round on which this block was appended to the chain.
   * @param seed - (seed) Sortition seed.
   * @param timestamp - (ts) Block creation timestamp in seconds since eposh
   * @param transactionsRoot - (txn) TransactionsRoot authenticates the set of transactions appearing in the
   * block. More specifically, it's the root of a merkle tree whose leaves are the
   * block's Txids, in lexicographic order. For the empty block, it's 0. Note that
   * the TxnRoot does not authenticate the signatures on the transactions, only the
   * transactions themselves. Two blocks with the same transactions but in a
   * different order and with different signatures will have the same TxnRoot.
   * @param transactionsRootSha256 - (txn256) TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a
   * vector commitment instead of a merkle tree, and SHA256 hash function instead of
   * the default SHA512_256. This commitment can be used on environments where only
   * the SHA256 function exists.
   * @param participationUpdates - Participation account data that needs to be checked/acted on by the network.
   * @param rewards - Fields relating to rewards,
   * @param stateProofTracking - Tracks the status of state proofs.
   * @param transactions - (txns) list of transactions corresponding to a given round.
   * @param txnCounter - (tc) TxnCounter counts the number of transactions committed in the ledger, from
   * the time at which support for this feature was introduced.
   * Specifically, TxnCounter is the number of the next transaction that will be
   * committed after this block. It is 0 when no transactions have ever been
   * committed (since TxnCounter started being supported).
   * @param upgradeState - Fields relating to a protocol upgrade.
   * @param upgradeVote - Fields relating to voting for a protocol upgrade.
   */
  constructor({ genesisHash, genesisId, previousBlockHash, round, seed, timestamp, transactionsRoot, transactionsRootSha256, participationUpdates, rewards, stateProofTracking, transactions, txnCounter, upgradeState, upgradeVote }) {
    super();
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(buffer.Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.previousBlockHash = typeof previousBlockHash === "string" ? new Uint8Array(buffer.Buffer.from(previousBlockHash, "base64")) : previousBlockHash;
    this.round = round;
    this.seed = typeof seed === "string" ? new Uint8Array(buffer.Buffer.from(seed, "base64")) : seed;
    this.timestamp = timestamp;
    this.transactionsRoot = typeof transactionsRoot === "string" ? new Uint8Array(buffer.Buffer.from(transactionsRoot, "base64")) : transactionsRoot;
    this.transactionsRootSha256 = typeof transactionsRootSha256 === "string" ? new Uint8Array(buffer.Buffer.from(transactionsRootSha256, "base64")) : transactionsRootSha256;
    this.participationUpdates = participationUpdates;
    this.rewards = rewards;
    this.stateProofTracking = stateProofTracking;
    this.transactions = transactions;
    this.txnCounter = txnCounter;
    this.upgradeState = upgradeState;
    this.upgradeVote = upgradeVote;
    this.attribute_map = {
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      previousBlockHash: "previous-block-hash",
      round: "round",
      seed: "seed",
      timestamp: "timestamp",
      transactionsRoot: "transactions-root",
      transactionsRootSha256: "transactions-root-sha256",
      participationUpdates: "participation-updates",
      rewards: "rewards",
      stateProofTracking: "state-proof-tracking",
      transactions: "transactions",
      txnCounter: "txn-counter",
      upgradeState: "upgrade-state",
      upgradeVote: "upgrade-vote"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["genesis-hash"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-hash': ${data}`);
    if (typeof data["genesis-id"] === "undefined")
      throw new Error(`Response is missing required field 'genesis-id': ${data}`);
    if (typeof data["previous-block-hash"] === "undefined")
      throw new Error(`Response is missing required field 'previous-block-hash': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["seed"] === "undefined")
      throw new Error(`Response is missing required field 'seed': ${data}`);
    if (typeof data["timestamp"] === "undefined")
      throw new Error(`Response is missing required field 'timestamp': ${data}`);
    if (typeof data["transactions-root"] === "undefined")
      throw new Error(`Response is missing required field 'transactions-root': ${data}`);
    if (typeof data["transactions-root-sha256"] === "undefined")
      throw new Error(`Response is missing required field 'transactions-root-sha256': ${data}`);
    return new Block2({
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      previousBlockHash: data["previous-block-hash"],
      round: data["round"],
      seed: data["seed"],
      timestamp: data["timestamp"],
      transactionsRoot: data["transactions-root"],
      transactionsRootSha256: data["transactions-root-sha256"],
      participationUpdates: typeof data["participation-updates"] !== "undefined" ? ParticipationUpdates.from_obj_for_encoding(data["participation-updates"]) : void 0,
      rewards: typeof data["rewards"] !== "undefined" ? BlockRewards.from_obj_for_encoding(data["rewards"]) : void 0,
      stateProofTracking: typeof data["state-proof-tracking"] !== "undefined" ? data["state-proof-tracking"].map(StateProofTracking.from_obj_for_encoding) : void 0,
      transactions: typeof data["transactions"] !== "undefined" ? data["transactions"].map(Transaction2.from_obj_for_encoding) : void 0,
      txnCounter: data["txn-counter"],
      upgradeState: typeof data["upgrade-state"] !== "undefined" ? BlockUpgradeState.from_obj_for_encoding(data["upgrade-state"]) : void 0,
      upgradeVote: typeof data["upgrade-vote"] !== "undefined" ? BlockUpgradeVote.from_obj_for_encoding(data["upgrade-vote"]) : void 0
    });
  }
}
class BlockRewards extends BaseModel {
  /**
   * Creates a new `BlockRewards` object.
   * @param feeSink - (fees) accepts transaction fees, it can only spend to the incentive pool.
   * @param rewardsCalculationRound - (rwcalr) number of leftover MicroAlgos after the distribution of rewards-rate
   * MicroAlgos for every reward unit in the next round.
   * @param rewardsLevel - (earn) How many rewards, in MicroAlgos, have been distributed to each RewardUnit
   * of MicroAlgos since genesis.
   * @param rewardsPool - (rwd) accepts periodic injections from the fee-sink and continually
   * redistributes them as rewards.
   * @param rewardsRate - (rate) Number of new MicroAlgos added to the participation stake from rewards at
   * the next round.
   * @param rewardsResidue - (frac) Number of leftover MicroAlgos after the distribution of
   * RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
   */
  constructor({ feeSink, rewardsCalculationRound, rewardsLevel, rewardsPool, rewardsRate, rewardsResidue }) {
    super();
    this.feeSink = feeSink;
    this.rewardsCalculationRound = rewardsCalculationRound;
    this.rewardsLevel = rewardsLevel;
    this.rewardsPool = rewardsPool;
    this.rewardsRate = rewardsRate;
    this.rewardsResidue = rewardsResidue;
    this.attribute_map = {
      feeSink: "fee-sink",
      rewardsCalculationRound: "rewards-calculation-round",
      rewardsLevel: "rewards-level",
      rewardsPool: "rewards-pool",
      rewardsRate: "rewards-rate",
      rewardsResidue: "rewards-residue"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["fee-sink"] === "undefined")
      throw new Error(`Response is missing required field 'fee-sink': ${data}`);
    if (typeof data["rewards-calculation-round"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-calculation-round': ${data}`);
    if (typeof data["rewards-level"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-level': ${data}`);
    if (typeof data["rewards-pool"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-pool': ${data}`);
    if (typeof data["rewards-rate"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-rate': ${data}`);
    if (typeof data["rewards-residue"] === "undefined")
      throw new Error(`Response is missing required field 'rewards-residue': ${data}`);
    return new BlockRewards({
      feeSink: data["fee-sink"],
      rewardsCalculationRound: data["rewards-calculation-round"],
      rewardsLevel: data["rewards-level"],
      rewardsPool: data["rewards-pool"],
      rewardsRate: data["rewards-rate"],
      rewardsResidue: data["rewards-residue"]
    });
  }
}
class BlockUpgradeState extends BaseModel {
  /**
   * Creates a new `BlockUpgradeState` object.
   * @param currentProtocol - (proto) The current protocol version.
   * @param nextProtocol - (nextproto) The next proposed protocol version.
   * @param nextProtocolApprovals - (nextyes) Number of blocks which approved the protocol upgrade.
   * @param nextProtocolSwitchOn - (nextswitch) Round on which the protocol upgrade will take effect.
   * @param nextProtocolVoteBefore - (nextbefore) Deadline round for this protocol upgrade (No votes will be consider
   * after this round).
   */
  constructor({ currentProtocol, nextProtocol, nextProtocolApprovals, nextProtocolSwitchOn, nextProtocolVoteBefore }) {
    super();
    this.currentProtocol = currentProtocol;
    this.nextProtocol = nextProtocol;
    this.nextProtocolApprovals = nextProtocolApprovals;
    this.nextProtocolSwitchOn = nextProtocolSwitchOn;
    this.nextProtocolVoteBefore = nextProtocolVoteBefore;
    this.attribute_map = {
      currentProtocol: "current-protocol",
      nextProtocol: "next-protocol",
      nextProtocolApprovals: "next-protocol-approvals",
      nextProtocolSwitchOn: "next-protocol-switch-on",
      nextProtocolVoteBefore: "next-protocol-vote-before"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-protocol"] === "undefined")
      throw new Error(`Response is missing required field 'current-protocol': ${data}`);
    return new BlockUpgradeState({
      currentProtocol: data["current-protocol"],
      nextProtocol: data["next-protocol"],
      nextProtocolApprovals: data["next-protocol-approvals"],
      nextProtocolSwitchOn: data["next-protocol-switch-on"],
      nextProtocolVoteBefore: data["next-protocol-vote-before"]
    });
  }
}
class BlockUpgradeVote extends BaseModel {
  /**
   * Creates a new `BlockUpgradeVote` object.
   * @param upgradeApprove - (upgradeyes) Indicates a yes vote for the current proposal.
   * @param upgradeDelay - (upgradedelay) Indicates the time between acceptance and execution.
   * @param upgradePropose - (upgradeprop) Indicates a proposed upgrade.
   */
  constructor({ upgradeApprove, upgradeDelay, upgradePropose }) {
    super();
    this.upgradeApprove = upgradeApprove;
    this.upgradeDelay = upgradeDelay;
    this.upgradePropose = upgradePropose;
    this.attribute_map = {
      upgradeApprove: "upgrade-approve",
      upgradeDelay: "upgrade-delay",
      upgradePropose: "upgrade-propose"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new BlockUpgradeVote({
      upgradeApprove: data["upgrade-approve"],
      upgradeDelay: data["upgrade-delay"],
      upgradePropose: data["upgrade-propose"]
    });
  }
}
class Box2 extends BaseModel {
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name, value }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.value = typeof value === "string" ? new Uint8Array(buffer.Buffer.from(value, "base64")) : value;
    this.attribute_map = {
      name: "name",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new Box2({
      name: data["name"],
      value: data["value"]
    });
  }
}
class BoxDescriptor2 extends BaseModel {
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    super();
    this.name = typeof name === "string" ? new Uint8Array(buffer.Buffer.from(name, "base64")) : name;
    this.attribute_map = {
      name: "name"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["name"] === "undefined")
      throw new Error(`Response is missing required field 'name': ${data}`);
    return new BoxDescriptor2({
      name: data["name"]
    });
  }
}
class BoxesResponse2 extends BaseModel {
  /**
   * Creates a new `BoxesResponse` object.
   * @param applicationId - (appidx) application index.
   * @param boxes -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, boxes, nextToken }) {
    super();
    this.applicationId = applicationId;
    this.boxes = boxes;
    this.nextToken = nextToken;
    this.attribute_map = {
      applicationId: "application-id",
      boxes: "boxes",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    if (!Array.isArray(data["boxes"]))
      throw new Error(`Response is missing required array field 'boxes': ${data}`);
    return new BoxesResponse2({
      applicationId: data["application-id"],
      boxes: data["boxes"].map(BoxDescriptor2.from_obj_for_encoding),
      nextToken: data["next-token"]
    });
  }
}
class ErrorResponse2 extends BaseModel {
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    super();
    this.message = message;
    this.data = data;
    this.attribute_map = {
      message: "message",
      data: "data"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    return new ErrorResponse2({
      message: data["message"],
      data: data["data"]
    });
  }
}
class EvalDelta2 extends BaseModel {
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    super();
    this.action = action;
    this.bytes = bytes;
    this.uint = uint;
    this.attribute_map = {
      action: "action",
      bytes: "bytes",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["action"] === "undefined")
      throw new Error(`Response is missing required field 'action': ${data}`);
    return new EvalDelta2({
      action: data["action"],
      bytes: data["bytes"],
      uint: data["uint"]
    });
  }
}
class EvalDeltaKeyValue2 extends BaseModel {
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new EvalDeltaKeyValue2({
      key: data["key"],
      value: EvalDelta2.from_obj_for_encoding(data["value"])
    });
  }
}
class HashFactory extends BaseModel {
  /**
   * Creates a new `HashFactory` object.
   * @param hashType - (t)
   */
  constructor({ hashType }) {
    super();
    this.hashType = hashType;
    this.attribute_map = {
      hashType: "hash-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new HashFactory({
      hashType: data["hash-type"]
    });
  }
}
class HealthCheck2 extends BaseModel {
  /**
   * Creates a new `HealthCheck` object.
   * @param dbAvailable -
   * @param isMigrating -
   * @param message -
   * @param round -
   * @param version - Current version.
   * @param data -
   * @param errors -
   */
  constructor({ dbAvailable, isMigrating, message, round, version: version2, data, errors }) {
    super();
    this.dbAvailable = dbAvailable;
    this.isMigrating = isMigrating;
    this.message = message;
    this.round = round;
    this.version = version2;
    this.data = data;
    this.errors = errors;
    this.attribute_map = {
      dbAvailable: "db-available",
      isMigrating: "is-migrating",
      message: "message",
      round: "round",
      version: "version",
      data: "data",
      errors: "errors"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["db-available"] === "undefined")
      throw new Error(`Response is missing required field 'db-available': ${data}`);
    if (typeof data["is-migrating"] === "undefined")
      throw new Error(`Response is missing required field 'is-migrating': ${data}`);
    if (typeof data["message"] === "undefined")
      throw new Error(`Response is missing required field 'message': ${data}`);
    if (typeof data["round"] === "undefined")
      throw new Error(`Response is missing required field 'round': ${data}`);
    if (typeof data["version"] === "undefined")
      throw new Error(`Response is missing required field 'version': ${data}`);
    return new HealthCheck2({
      dbAvailable: data["db-available"],
      isMigrating: data["is-migrating"],
      message: data["message"],
      round: data["round"],
      version: data["version"],
      data: data["data"],
      errors: data["errors"]
    });
  }
}
class IndexerStateProofMessage extends BaseModel {
  /**
   * Creates a new `IndexerStateProofMessage` object.
   * @param blockHeadersCommitment - (b)
   * @param firstAttestedRound - (f)
   * @param latestAttestedRound - (l)
   * @param lnProvenWeight - (P)
   * @param votersCommitment - (v)
   */
  constructor({ blockHeadersCommitment, firstAttestedRound, latestAttestedRound, lnProvenWeight, votersCommitment }) {
    super();
    this.blockHeadersCommitment = typeof blockHeadersCommitment === "string" ? new Uint8Array(buffer.Buffer.from(blockHeadersCommitment, "base64")) : blockHeadersCommitment;
    this.firstAttestedRound = firstAttestedRound;
    this.latestAttestedRound = latestAttestedRound;
    this.lnProvenWeight = lnProvenWeight;
    this.votersCommitment = typeof votersCommitment === "string" ? new Uint8Array(buffer.Buffer.from(votersCommitment, "base64")) : votersCommitment;
    this.attribute_map = {
      blockHeadersCommitment: "block-headers-commitment",
      firstAttestedRound: "first-attested-round",
      latestAttestedRound: "latest-attested-round",
      lnProvenWeight: "ln-proven-weight",
      votersCommitment: "voters-commitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new IndexerStateProofMessage({
      blockHeadersCommitment: data["block-headers-commitment"],
      firstAttestedRound: data["first-attested-round"],
      latestAttestedRound: data["latest-attested-round"],
      lnProvenWeight: data["ln-proven-weight"],
      votersCommitment: data["voters-commitment"]
    });
  }
}
class MerkleArrayProof extends BaseModel {
  /**
   * Creates a new `MerkleArrayProof` object.
   * @param hashFactory -
   * @param path - (pth)
   * @param treeDepth - (td)
   */
  constructor({ hashFactory, path, treeDepth }) {
    super();
    this.hashFactory = hashFactory;
    this.path = path;
    this.treeDepth = treeDepth;
    this.attribute_map = {
      hashFactory: "hash-factory",
      path: "path",
      treeDepth: "tree-depth"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new MerkleArrayProof({
      hashFactory: typeof data["hash-factory"] !== "undefined" ? HashFactory.from_obj_for_encoding(data["hash-factory"]) : void 0,
      path: data["path"],
      treeDepth: data["tree-depth"]
    });
  }
}
class MiniAssetHolding extends BaseModel {
  /**
   * Creates a new `MiniAssetHolding` object.
   * @param address -
   * @param amount -
   * @param isFrozen -
   * @param deleted - Whether or not this asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into the asset.
   * @param optedOutAtRound - Round during which the account opted out of the asset.
   */
  constructor({ address, amount, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    super();
    this.address = address;
    this.amount = amount;
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = optedInAtRound;
    this.optedOutAtRound = optedOutAtRound;
    this.attribute_map = {
      address: "address",
      amount: "amount",
      isFrozen: "is-frozen",
      deleted: "deleted",
      optedInAtRound: "opted-in-at-round",
      optedOutAtRound: "opted-out-at-round"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["is-frozen"] === "undefined")
      throw new Error(`Response is missing required field 'is-frozen': ${data}`);
    return new MiniAssetHolding({
      address: data["address"],
      amount: data["amount"],
      isFrozen: data["is-frozen"],
      deleted: data["deleted"],
      optedInAtRound: data["opted-in-at-round"],
      optedOutAtRound: data["opted-out-at-round"]
    });
  }
}
class ParticipationUpdates extends BaseModel {
  /**
   * Creates a new `ParticipationUpdates` object.
   * @param expiredParticipationAccounts - (partupdrmv) a list of online accounts that needs to be converted to offline
   * since their participation key expired.
   */
  constructor({ expiredParticipationAccounts }) {
    super();
    this.expiredParticipationAccounts = expiredParticipationAccounts;
    this.attribute_map = {
      expiredParticipationAccounts: "expired-participation-accounts"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new ParticipationUpdates({
      expiredParticipationAccounts: data["expired-participation-accounts"]
    });
  }
}
class StateProofFields extends BaseModel {
  /**
   * Creates a new `StateProofFields` object.
   * @param partProofs - (P)
   * @param positionsToReveal - (pr) Sequence of reveal positions.
   * @param reveals - (r) Note that this is actually stored as a map[uint64] - Reveal in the actual
   * msgp
   * @param saltVersion - (v) Salt version of the merkle signature.
   * @param sigCommit - (c)
   * @param sigProofs - (S)
   * @param signedWeight - (w)
   */
  constructor({ partProofs, positionsToReveal, reveals, saltVersion, sigCommit, sigProofs, signedWeight }) {
    super();
    this.partProofs = partProofs;
    this.positionsToReveal = positionsToReveal;
    this.reveals = reveals;
    this.saltVersion = saltVersion;
    this.sigCommit = typeof sigCommit === "string" ? new Uint8Array(buffer.Buffer.from(sigCommit, "base64")) : sigCommit;
    this.sigProofs = sigProofs;
    this.signedWeight = signedWeight;
    this.attribute_map = {
      partProofs: "part-proofs",
      positionsToReveal: "positions-to-reveal",
      reveals: "reveals",
      saltVersion: "salt-version",
      sigCommit: "sig-commit",
      sigProofs: "sig-proofs",
      signedWeight: "signed-weight"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofFields({
      partProofs: typeof data["part-proofs"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["part-proofs"]) : void 0,
      positionsToReveal: data["positions-to-reveal"],
      reveals: typeof data["reveals"] !== "undefined" ? data["reveals"].map(StateProofReveal.from_obj_for_encoding) : void 0,
      saltVersion: data["salt-version"],
      sigCommit: data["sig-commit"],
      sigProofs: typeof data["sig-proofs"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["sig-proofs"]) : void 0,
      signedWeight: data["signed-weight"]
    });
  }
}
class StateProofParticipant extends BaseModel {
  /**
   * Creates a new `StateProofParticipant` object.
   * @param verifier - (p)
   * @param weight - (w)
   */
  constructor({ verifier, weight }) {
    super();
    this.verifier = verifier;
    this.weight = weight;
    this.attribute_map = {
      verifier: "verifier",
      weight: "weight"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofParticipant({
      verifier: typeof data["verifier"] !== "undefined" ? StateProofVerifier.from_obj_for_encoding(data["verifier"]) : void 0,
      weight: data["weight"]
    });
  }
}
class StateProofReveal extends BaseModel {
  /**
   * Creates a new `StateProofReveal` object.
   * @param participant - (p)
   * @param position - The position in the signature and participants arrays corresponding to this
   * entry.
   * @param sigSlot - (s)
   */
  constructor({ participant, position, sigSlot }) {
    super();
    this.participant = participant;
    this.position = position;
    this.sigSlot = sigSlot;
    this.attribute_map = {
      participant: "participant",
      position: "position",
      sigSlot: "sig-slot"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofReveal({
      participant: typeof data["participant"] !== "undefined" ? StateProofParticipant.from_obj_for_encoding(data["participant"]) : void 0,
      position: data["position"],
      sigSlot: typeof data["sig-slot"] !== "undefined" ? StateProofSigSlot.from_obj_for_encoding(data["sig-slot"]) : void 0
    });
  }
}
class StateProofSigSlot extends BaseModel {
  /**
   * Creates a new `StateProofSigSlot` object.
   * @param lowerSigWeight - (l) The total weight of signatures in the lower-numbered slots.
   * @param signature -
   */
  constructor({ lowerSigWeight, signature }) {
    super();
    this.lowerSigWeight = lowerSigWeight;
    this.signature = signature;
    this.attribute_map = {
      lowerSigWeight: "lower-sig-weight",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofSigSlot({
      lowerSigWeight: data["lower-sig-weight"],
      signature: typeof data["signature"] !== "undefined" ? StateProofSignature.from_obj_for_encoding(data["signature"]) : void 0
    });
  }
}
class StateProofSignature extends BaseModel {
  /**
   * Creates a new `StateProofSignature` object.
   * @param falconSignature -
   * @param merkleArrayIndex -
   * @param proof -
   * @param verifyingKey - (vkey)
   */
  constructor({ falconSignature, merkleArrayIndex, proof, verifyingKey }) {
    super();
    this.falconSignature = typeof falconSignature === "string" ? new Uint8Array(buffer.Buffer.from(falconSignature, "base64")) : falconSignature;
    this.merkleArrayIndex = merkleArrayIndex;
    this.proof = proof;
    this.verifyingKey = typeof verifyingKey === "string" ? new Uint8Array(buffer.Buffer.from(verifyingKey, "base64")) : verifyingKey;
    this.attribute_map = {
      falconSignature: "falcon-signature",
      merkleArrayIndex: "merkle-array-index",
      proof: "proof",
      verifyingKey: "verifying-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofSignature({
      falconSignature: data["falcon-signature"],
      merkleArrayIndex: data["merkle-array-index"],
      proof: typeof data["proof"] !== "undefined" ? MerkleArrayProof.from_obj_for_encoding(data["proof"]) : void 0,
      verifyingKey: data["verifying-key"]
    });
  }
}
class StateProofTracking extends BaseModel {
  /**
   * Creates a new `StateProofTracking` object.
   * @param nextRound - (n) Next round for which we will accept a state proof transaction.
   * @param onlineTotalWeight - (t) The total number of microalgos held by the online accounts during the
   * StateProof round.
   * @param type - State Proof Type. Note the raw object uses map with this as key.
   * @param votersCommitment - (v) Root of a vector commitment containing online accounts that will help sign
   * the proof.
   */
  constructor({ nextRound, onlineTotalWeight, type, votersCommitment }) {
    super();
    this.nextRound = nextRound;
    this.onlineTotalWeight = onlineTotalWeight;
    this.type = type;
    this.votersCommitment = typeof votersCommitment === "string" ? new Uint8Array(buffer.Buffer.from(votersCommitment, "base64")) : votersCommitment;
    this.attribute_map = {
      nextRound: "next-round",
      onlineTotalWeight: "online-total-weight",
      type: "type",
      votersCommitment: "voters-commitment"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofTracking({
      nextRound: data["next-round"],
      onlineTotalWeight: data["online-total-weight"],
      type: data["type"],
      votersCommitment: data["voters-commitment"]
    });
  }
}
class StateProofVerifier extends BaseModel {
  /**
   * Creates a new `StateProofVerifier` object.
   * @param commitment - (cmt) Represents the root of the vector commitment tree.
   * @param keyLifetime - (lf) Key lifetime.
   */
  constructor({ commitment, keyLifetime }) {
    super();
    this.commitment = typeof commitment === "string" ? new Uint8Array(buffer.Buffer.from(commitment, "base64")) : commitment;
    this.keyLifetime = keyLifetime;
    this.attribute_map = {
      commitment: "commitment",
      keyLifetime: "key-lifetime"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new StateProofVerifier({
      commitment: data["commitment"],
      keyLifetime: data["key-lifetime"]
    });
  }
}
class StateSchema extends BaseModel {
  /**
   * Creates a new `StateSchema` object.
   * @param numByteSlice - Maximum number of TEAL byte slices that may be stored in the key/value store.
   * @param numUint - Maximum number of TEAL uints that may be stored in the key/value store.
   */
  constructor({ numByteSlice, numUint }) {
    super();
    this.numByteSlice = numByteSlice;
    this.numUint = numUint;
    this.attribute_map = {
      numByteSlice: "num-byte-slice",
      numUint: "num-uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["num-byte-slice"] === "undefined")
      throw new Error(`Response is missing required field 'num-byte-slice': ${data}`);
    if (typeof data["num-uint"] === "undefined")
      throw new Error(`Response is missing required field 'num-uint': ${data}`);
    return new StateSchema({
      numByteSlice: data["num-byte-slice"],
      numUint: data["num-uint"]
    });
  }
}
class TealKeyValue2 extends BaseModel {
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    super();
    this.key = key;
    this.value = value;
    this.attribute_map = {
      key: "key",
      value: "value"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["key"] === "undefined")
      throw new Error(`Response is missing required field 'key': ${data}`);
    if (typeof data["value"] === "undefined")
      throw new Error(`Response is missing required field 'value': ${data}`);
    return new TealKeyValue2({
      key: data["key"],
      value: TealValue2.from_obj_for_encoding(data["value"])
    });
  }
}
class TealValue2 extends BaseModel {
  /**
   * Creates a new `TealValue` object.
   * @param bytes - (tb) bytes value.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param uint - (ui) uint value.
   */
  constructor({ bytes, type, uint }) {
    super();
    this.bytes = bytes;
    this.type = type;
    this.uint = uint;
    this.attribute_map = {
      bytes: "bytes",
      type: "type",
      uint: "uint"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["bytes"] === "undefined")
      throw new Error(`Response is missing required field 'bytes': ${data}`);
    if (typeof data["type"] === "undefined")
      throw new Error(`Response is missing required field 'type': ${data}`);
    if (typeof data["uint"] === "undefined")
      throw new Error(`Response is missing required field 'uint': ${data}`);
    return new TealValue2({
      bytes: data["bytes"],
      type: data["type"],
      uint: data["uint"]
    });
  }
}
class Transaction2 extends BaseModel {
  /**
   * Creates a new `Transaction` object.
   * @param fee - (fee) Transaction fee.
   * @param firstValid - (fv) First valid round for this transaction.
   * @param lastValid - (lv) Last valid round for this transaction.
   * @param sender - (snd) Sender's address.
   * @param applicationTransaction - Fields for application transactions.
   * Definition:
   * data/transactions/application.go : ApplicationCallTxnFields
   * @param assetConfigTransaction - Fields for asset allocation, re-configuration, and destruction.
   * A zero value for asset-id indicates asset creation.
   * A zero value for the params indicates asset destruction.
   * Definition:
   * data/transactions/asset.go : AssetConfigTxnFields
   * @param assetFreezeTransaction - Fields for an asset freeze transaction.
   * Definition:
   * data/transactions/asset.go : AssetFreezeTxnFields
   * @param assetTransferTransaction - Fields for an asset transfer transaction.
   * Definition:
   * data/transactions/asset.go : AssetTransferTxnFields
   * @param authAddr - (sgnr) this is included with signed transactions when the signing address does
   * not equal the sender. The backend can use this to ensure that auth addr is equal
   * to the accounts auth addr.
   * @param closeRewards - (rc) rewards applied to close-remainder-to account.
   * @param closingAmount - (ca) closing amount for transaction.
   * @param confirmedRound - Round when the transaction was confirmed.
   * @param createdApplicationIndex - Specifies an application index (ID) if an application was created with this
   * transaction.
   * @param createdAssetIndex - Specifies an asset index (ID) if an asset was created with this transaction.
   * @param genesisHash - (gh) Hash of genesis block.
   * @param genesisId - (gen) genesis block ID.
   * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
   * transaction.
   * @param group - (grp) Base64 encoded byte array of a sha512/256 digest. When present indicates
   * that this transaction is part of a transaction group and the value is the
   * sha512/256 hash of the transactions in that group.
   * @param id - Transaction ID
   * @param innerTxns - Inner transactions produced by application execution.
   * @param intraRoundOffset - Offset into the round where this transaction was confirmed.
   * @param keyregTransaction - Fields for a keyreg transaction.
   * Definition:
   * data/transactions/keyreg.go : KeyregTxnFields
   * @param lease - (lx) Base64 encoded 32-byte array. Lease enforces mutual exclusion of
   * transactions. If this field is nonzero, then once the transaction is confirmed,
   * it acquires the lease identified by the (Sender, Lease) pair of the transaction
   * until the LastValid round passes. While this transaction possesses the lease, no
   * other transaction specifying this lease can be confirmed.
   * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - (lg) Logs for the application being executed by this transaction.
   * @param note - (note) Free form data.
   * @param paymentTransaction - Fields for a payment transaction.
   * Definition:
   * data/transactions/payment.go : PaymentTxnFields
   * @param receiverRewards - (rr) rewards applied to receiver account.
   * @param rekeyTo - (rekey) when included in a valid transaction, the accounts auth addr will be
   * updated with this value and future signatures must be signed with the key
   * represented by this address.
   * @param roundTime - Time when the block this transaction is in was confirmed.
   * @param senderRewards - (rs) rewards applied to sender account.
   * @param signature - Validation signature associated with some data. Only one of the signatures
   * should be provided.
   * @param stateProofTransaction - Fields for a state proof transaction.
   * Definition:
   * data/transactions/stateproof.go : StateProofTxnFields
   * @param txType - (type) Indicates what type of transaction this is. Different types have
   * different fields.
   * Valid types, and where their fields are stored:
   * * (pay) payment-transaction
   * * (keyreg) keyreg-transaction
   * * (acfg) asset-config-transaction
   * * (axfer) asset-transfer-transaction
   * * (afrz) asset-freeze-transaction
   * * (appl) application-transaction
   * * (stpf) state-proof-transaction
   */
  constructor({ fee, firstValid, lastValid, sender, applicationTransaction, assetConfigTransaction, assetFreezeTransaction, assetTransferTransaction, authAddr, closeRewards, closingAmount, confirmedRound, createdApplicationIndex, createdAssetIndex, genesisHash, genesisId, globalStateDelta, group, id: id2, innerTxns, intraRoundOffset, keyregTransaction, lease, localStateDelta, logs, note, paymentTransaction, receiverRewards, rekeyTo, roundTime, senderRewards, signature, stateProofTransaction, txType }) {
    super();
    this.fee = fee;
    this.firstValid = firstValid;
    this.lastValid = lastValid;
    this.sender = sender;
    this.applicationTransaction = applicationTransaction;
    this.assetConfigTransaction = assetConfigTransaction;
    this.assetFreezeTransaction = assetFreezeTransaction;
    this.assetTransferTransaction = assetTransferTransaction;
    this.authAddr = authAddr;
    this.closeRewards = closeRewards;
    this.closingAmount = closingAmount;
    this.confirmedRound = confirmedRound;
    this.createdApplicationIndex = createdApplicationIndex;
    this.createdAssetIndex = createdAssetIndex;
    this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(buffer.Buffer.from(genesisHash, "base64")) : genesisHash;
    this.genesisId = genesisId;
    this.globalStateDelta = globalStateDelta;
    this.group = typeof group === "string" ? new Uint8Array(buffer.Buffer.from(group, "base64")) : group;
    this.id = id2;
    this.innerTxns = innerTxns;
    this.intraRoundOffset = intraRoundOffset;
    this.keyregTransaction = keyregTransaction;
    this.lease = typeof lease === "string" ? new Uint8Array(buffer.Buffer.from(lease, "base64")) : lease;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.note = typeof note === "string" ? new Uint8Array(buffer.Buffer.from(note, "base64")) : note;
    this.paymentTransaction = paymentTransaction;
    this.receiverRewards = receiverRewards;
    this.rekeyTo = rekeyTo;
    this.roundTime = roundTime;
    this.senderRewards = senderRewards;
    this.signature = signature;
    this.stateProofTransaction = stateProofTransaction;
    this.txType = txType;
    this.attribute_map = {
      fee: "fee",
      firstValid: "first-valid",
      lastValid: "last-valid",
      sender: "sender",
      applicationTransaction: "application-transaction",
      assetConfigTransaction: "asset-config-transaction",
      assetFreezeTransaction: "asset-freeze-transaction",
      assetTransferTransaction: "asset-transfer-transaction",
      authAddr: "auth-addr",
      closeRewards: "close-rewards",
      closingAmount: "closing-amount",
      confirmedRound: "confirmed-round",
      createdApplicationIndex: "created-application-index",
      createdAssetIndex: "created-asset-index",
      genesisHash: "genesis-hash",
      genesisId: "genesis-id",
      globalStateDelta: "global-state-delta",
      group: "group",
      id: "id",
      innerTxns: "inner-txns",
      intraRoundOffset: "intra-round-offset",
      keyregTransaction: "keyreg-transaction",
      lease: "lease",
      localStateDelta: "local-state-delta",
      logs: "logs",
      note: "note",
      paymentTransaction: "payment-transaction",
      receiverRewards: "receiver-rewards",
      rekeyTo: "rekey-to",
      roundTime: "round-time",
      senderRewards: "sender-rewards",
      signature: "signature",
      stateProofTransaction: "state-proof-transaction",
      txType: "tx-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["fee"] === "undefined")
      throw new Error(`Response is missing required field 'fee': ${data}`);
    if (typeof data["first-valid"] === "undefined")
      throw new Error(`Response is missing required field 'first-valid': ${data}`);
    if (typeof data["last-valid"] === "undefined")
      throw new Error(`Response is missing required field 'last-valid': ${data}`);
    if (typeof data["sender"] === "undefined")
      throw new Error(`Response is missing required field 'sender': ${data}`);
    return new Transaction2({
      fee: data["fee"],
      firstValid: data["first-valid"],
      lastValid: data["last-valid"],
      sender: data["sender"],
      applicationTransaction: typeof data["application-transaction"] !== "undefined" ? TransactionApplication.from_obj_for_encoding(data["application-transaction"]) : void 0,
      assetConfigTransaction: typeof data["asset-config-transaction"] !== "undefined" ? TransactionAssetConfig.from_obj_for_encoding(data["asset-config-transaction"]) : void 0,
      assetFreezeTransaction: typeof data["asset-freeze-transaction"] !== "undefined" ? TransactionAssetFreeze.from_obj_for_encoding(data["asset-freeze-transaction"]) : void 0,
      assetTransferTransaction: typeof data["asset-transfer-transaction"] !== "undefined" ? TransactionAssetTransfer.from_obj_for_encoding(data["asset-transfer-transaction"]) : void 0,
      authAddr: data["auth-addr"],
      closeRewards: data["close-rewards"],
      closingAmount: data["closing-amount"],
      confirmedRound: data["confirmed-round"],
      createdApplicationIndex: data["created-application-index"],
      createdAssetIndex: data["created-asset-index"],
      genesisHash: data["genesis-hash"],
      genesisId: data["genesis-id"],
      globalStateDelta: typeof data["global-state-delta"] !== "undefined" ? data["global-state-delta"].map(EvalDeltaKeyValue2.from_obj_for_encoding) : void 0,
      group: data["group"],
      id: data["id"],
      innerTxns: typeof data["inner-txns"] !== "undefined" ? data["inner-txns"].map(Transaction2.from_obj_for_encoding) : void 0,
      intraRoundOffset: data["intra-round-offset"],
      keyregTransaction: typeof data["keyreg-transaction"] !== "undefined" ? TransactionKeyreg.from_obj_for_encoding(data["keyreg-transaction"]) : void 0,
      lease: data["lease"],
      localStateDelta: typeof data["local-state-delta"] !== "undefined" ? data["local-state-delta"].map(AccountStateDelta2.from_obj_for_encoding) : void 0,
      logs: data["logs"],
      note: data["note"],
      paymentTransaction: typeof data["payment-transaction"] !== "undefined" ? TransactionPayment.from_obj_for_encoding(data["payment-transaction"]) : void 0,
      receiverRewards: data["receiver-rewards"],
      rekeyTo: data["rekey-to"],
      roundTime: data["round-time"],
      senderRewards: data["sender-rewards"],
      signature: typeof data["signature"] !== "undefined" ? TransactionSignature.from_obj_for_encoding(data["signature"]) : void 0,
      stateProofTransaction: typeof data["state-proof-transaction"] !== "undefined" ? TransactionStateProof.from_obj_for_encoding(data["state-proof-transaction"]) : void 0,
      txType: data["tx-type"]
    });
  }
}
class TransactionApplication extends BaseModel {
  /**
   * Creates a new `TransactionApplication` object.
   * @param applicationId - (apid) ID of the application being configured or empty if creating.
   * @param accounts - (apat) List of accounts in addition to the sender that may be accessed from the
   * application's approval-program and clear-state-program.
   * @param applicationArgs - (apaa) transaction specific arguments accessed from the application's
   * approval-program and clear-state-program.
   * @param approvalProgram - (apap) Logic executed for every application transaction, except when
   * on-completion is set to "clear". It can read and write global state for the
   * application, as well as account-specific local state. Approval programs may
   * reject the transaction.
   * @param clearStateProgram - (apsu) Logic executed for application transactions with on-completion set to
   * "clear". It can read and write global state for the application, as well as
   * account-specific local state. Clear state programs cannot reject the
   * transaction.
   * @param extraProgramPages - (epp) specifies the additional app program len requested in pages.
   * @param foreignApps - (apfa) Lists the applications in addition to the application-id whose global
   * states may be accessed by this application's approval-program and
   * clear-state-program. The access is read-only.
   * @param foreignAssets - (apas) lists the assets whose parameters may be accessed by this application's
   * ApprovalProgram and ClearStateProgram. The access is read-only.
   * @param globalStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param localStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param onCompletion - (apan) defines the what additional actions occur with the transaction.
   * Valid types:
   * * noop
   * * optin
   * * closeout
   * * clear
   * * update
   * * update
   * * delete
   */
  constructor({ applicationId, accounts, applicationArgs, approvalProgram, clearStateProgram, extraProgramPages, foreignApps, foreignAssets, globalStateSchema, localStateSchema, onCompletion }) {
    super();
    this.applicationId = applicationId;
    this.accounts = accounts;
    this.applicationArgs = applicationArgs;
    this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(buffer.Buffer.from(approvalProgram, "base64")) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(buffer.Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
    this.extraProgramPages = extraProgramPages;
    this.foreignApps = foreignApps;
    this.foreignAssets = foreignAssets;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.onCompletion = onCompletion;
    this.attribute_map = {
      applicationId: "application-id",
      accounts: "accounts",
      applicationArgs: "application-args",
      approvalProgram: "approval-program",
      clearStateProgram: "clear-state-program",
      extraProgramPages: "extra-program-pages",
      foreignApps: "foreign-apps",
      foreignAssets: "foreign-assets",
      globalStateSchema: "global-state-schema",
      localStateSchema: "local-state-schema",
      onCompletion: "on-completion"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["application-id"] === "undefined")
      throw new Error(`Response is missing required field 'application-id': ${data}`);
    return new TransactionApplication({
      applicationId: data["application-id"],
      accounts: data["accounts"],
      applicationArgs: data["application-args"],
      approvalProgram: data["approval-program"],
      clearStateProgram: data["clear-state-program"],
      extraProgramPages: data["extra-program-pages"],
      foreignApps: data["foreign-apps"],
      foreignAssets: data["foreign-assets"],
      globalStateSchema: typeof data["global-state-schema"] !== "undefined" ? StateSchema.from_obj_for_encoding(data["global-state-schema"]) : void 0,
      localStateSchema: typeof data["local-state-schema"] !== "undefined" ? StateSchema.from_obj_for_encoding(data["local-state-schema"]) : void 0,
      onCompletion: data["on-completion"]
    });
  }
}
class TransactionAssetConfig extends BaseModel {
  /**
   * Creates a new `TransactionAssetConfig` object.
   * @param assetId - (xaid) ID of the asset being configured or empty if creating.
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ assetId, params }) {
    super();
    this.assetId = assetId;
    this.params = params;
    this.attribute_map = {
      assetId: "asset-id",
      params: "params"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionAssetConfig({
      assetId: data["asset-id"],
      params: typeof data["params"] !== "undefined" ? AssetParams2.from_obj_for_encoding(data["params"]) : void 0
    });
  }
}
class TransactionAssetFreeze extends BaseModel {
  /**
   * Creates a new `TransactionAssetFreeze` object.
   * @param address - (fadd) Address of the account whose asset is being frozen or thawed.
   * @param assetId - (faid) ID of the asset being frozen or thawed.
   * @param newFreezeStatus - (afrz) The new freeze status.
   */
  constructor({ address, assetId, newFreezeStatus }) {
    super();
    this.address = address;
    this.assetId = assetId;
    this.newFreezeStatus = newFreezeStatus;
    this.attribute_map = {
      address: "address",
      assetId: "asset-id",
      newFreezeStatus: "new-freeze-status"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["address"] === "undefined")
      throw new Error(`Response is missing required field 'address': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["new-freeze-status"] === "undefined")
      throw new Error(`Response is missing required field 'new-freeze-status': ${data}`);
    return new TransactionAssetFreeze({
      address: data["address"],
      assetId: data["asset-id"],
      newFreezeStatus: data["new-freeze-status"]
    });
  }
}
class TransactionAssetTransfer extends BaseModel {
  /**
   * Creates a new `TransactionAssetTransfer` object.
   * @param amount - (aamt) Amount of asset to transfer. A zero amount transferred to self allocates
   * that asset in the account's Assets map.
   * @param assetId - (xaid) ID of the asset being transferred.
   * @param receiver - (arcv) Recipient address of the transfer.
   * @param closeAmount - Number of assets transfered to the close-to account as part of the transaction.
   * @param closeTo - (aclose) Indicates that the asset should be removed from the account's Assets
   * map, and specifies where the remaining asset holdings should be transferred.
   * It's always valid to transfer remaining asset holdings to the creator account.
   * @param sender - (asnd) The effective sender during a clawback transactions. If this is not a
   * zero value, the real transaction sender must be the Clawback address from the
   * AssetParams.
   */
  constructor({ amount, assetId, receiver, closeAmount, closeTo, sender }) {
    super();
    this.amount = amount;
    this.assetId = assetId;
    this.receiver = receiver;
    this.closeAmount = closeAmount;
    this.closeTo = closeTo;
    this.sender = sender;
    this.attribute_map = {
      amount: "amount",
      assetId: "asset-id",
      receiver: "receiver",
      closeAmount: "close-amount",
      closeTo: "close-to",
      sender: "sender"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["asset-id"] === "undefined")
      throw new Error(`Response is missing required field 'asset-id': ${data}`);
    if (typeof data["receiver"] === "undefined")
      throw new Error(`Response is missing required field 'receiver': ${data}`);
    return new TransactionAssetTransfer({
      amount: data["amount"],
      assetId: data["asset-id"],
      receiver: data["receiver"],
      closeAmount: data["close-amount"],
      closeTo: data["close-to"],
      sender: data["sender"]
    });
  }
}
class TransactionKeyreg extends BaseModel {
  /**
   * Creates a new `TransactionKeyreg` object.
   * @param nonParticipation - (nonpart) Mark the account as participating or non-participating.
   * @param selectionParticipationKey - (selkey) Public key used with the Verified Random Function (VRF) result during
   * committee selection.
   * @param stateProofKey - (sprfkey) State proof key used in key registration transactions.
   * @param voteFirstValid - (votefst) First round this participation key is valid.
   * @param voteKeyDilution - (votekd) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (votelst) Last round this participation key is valid.
   * @param voteParticipationKey - (votekey) Participation public key used in key registration transactions.
   */
  constructor({ nonParticipation, selectionParticipationKey, stateProofKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey }) {
    super();
    this.nonParticipation = nonParticipation;
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(buffer.Buffer.from(stateProofKey, "base64")) : stateProofKey;
    this.voteFirstValid = voteFirstValid;
    this.voteKeyDilution = voteKeyDilution;
    this.voteLastValid = voteLastValid;
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(buffer.Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
    this.attribute_map = {
      nonParticipation: "non-participation",
      selectionParticipationKey: "selection-participation-key",
      stateProofKey: "state-proof-key",
      voteFirstValid: "vote-first-valid",
      voteKeyDilution: "vote-key-dilution",
      voteLastValid: "vote-last-valid",
      voteParticipationKey: "vote-participation-key"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionKeyreg({
      nonParticipation: data["non-participation"],
      selectionParticipationKey: data["selection-participation-key"],
      stateProofKey: data["state-proof-key"],
      voteFirstValid: data["vote-first-valid"],
      voteKeyDilution: data["vote-key-dilution"],
      voteLastValid: data["vote-last-valid"],
      voteParticipationKey: data["vote-participation-key"]
    });
  }
}
class TransactionPayment extends BaseModel {
  /**
   * Creates a new `TransactionPayment` object.
   * @param amount - (amt) number of MicroAlgos intended to be transferred.
   * @param receiver - (rcv) receiver's address.
   * @param closeAmount - Number of MicroAlgos that were sent to the close-remainder-to address when
   * closing the sender account.
   * @param closeRemainderTo - (close) when set, indicates that the sending account should be closed and all
   * remaining funds be transferred to this address.
   */
  constructor({ amount, receiver, closeAmount, closeRemainderTo }) {
    super();
    this.amount = amount;
    this.receiver = receiver;
    this.closeAmount = closeAmount;
    this.closeRemainderTo = closeRemainderTo;
    this.attribute_map = {
      amount: "amount",
      receiver: "receiver",
      closeAmount: "close-amount",
      closeRemainderTo: "close-remainder-to"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["amount"] === "undefined")
      throw new Error(`Response is missing required field 'amount': ${data}`);
    if (typeof data["receiver"] === "undefined")
      throw new Error(`Response is missing required field 'receiver': ${data}`);
    return new TransactionPayment({
      amount: data["amount"],
      receiver: data["receiver"],
      closeAmount: data["close-amount"],
      closeRemainderTo: data["close-remainder-to"]
    });
  }
}
class TransactionResponse extends BaseModel {
  /**
   * Creates a new `TransactionResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transaction - Contains all fields common to all transactions and serves as an envelope to all
   * transactions type. Represents both regular and inner transactions.
   * Definition:
   * data/transactions/signedtxn.go : SignedTxn
   * data/transactions/transaction.go : Transaction
   */
  constructor({ currentRound, transaction }) {
    super();
    this.currentRound = currentRound;
    this.transaction = transaction;
    this.attribute_map = {
      currentRound: "current-round",
      transaction: "transaction"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    if (typeof data["transaction"] === "undefined")
      throw new Error(`Response is missing required field 'transaction': ${data}`);
    return new TransactionResponse({
      currentRound: data["current-round"],
      transaction: Transaction2.from_obj_for_encoding(data["transaction"])
    });
  }
}
class TransactionSignature extends BaseModel {
  /**
   * Creates a new `TransactionSignature` object.
   * @param logicsig - (lsig) Programatic transaction signature.
   * Definition:
   * data/transactions/logicsig.go
   * @param multisig - (msig) structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param sig - (sig) Standard ed25519 signature.
   */
  constructor({ logicsig, multisig, sig }) {
    super();
    this.logicsig = logicsig;
    this.multisig = multisig;
    this.sig = typeof sig === "string" ? new Uint8Array(buffer.Buffer.from(sig, "base64")) : sig;
    this.attribute_map = {
      logicsig: "logicsig",
      multisig: "multisig",
      sig: "sig"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignature({
      logicsig: typeof data["logicsig"] !== "undefined" ? TransactionSignatureLogicsig.from_obj_for_encoding(data["logicsig"]) : void 0,
      multisig: typeof data["multisig"] !== "undefined" ? TransactionSignatureMultisig.from_obj_for_encoding(data["multisig"]) : void 0,
      sig: data["sig"]
    });
  }
}
class TransactionSignatureLogicsig extends BaseModel {
  /**
   * Creates a new `TransactionSignatureLogicsig` object.
   * @param logic - (l) Program signed by a signature or multi signature, or hashed to be the
   * address of ana ccount. Base64 encoded TEAL program.
   * @param args - (arg) Logic arguments, base64 encoded.
   * @param multisigSignature - (msig) structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param signature - (sig) ed25519 signature.
   */
  constructor({ logic, args, multisigSignature, signature }) {
    super();
    this.logic = typeof logic === "string" ? new Uint8Array(buffer.Buffer.from(logic, "base64")) : logic;
    this.args = args;
    this.multisigSignature = multisigSignature;
    this.signature = typeof signature === "string" ? new Uint8Array(buffer.Buffer.from(signature, "base64")) : signature;
    this.attribute_map = {
      logic: "logic",
      args: "args",
      multisigSignature: "multisig-signature",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["logic"] === "undefined")
      throw new Error(`Response is missing required field 'logic': ${data}`);
    return new TransactionSignatureLogicsig({
      logic: data["logic"],
      args: data["args"],
      multisigSignature: typeof data["multisig-signature"] !== "undefined" ? TransactionSignatureMultisig.from_obj_for_encoding(data["multisig-signature"]) : void 0,
      signature: data["signature"]
    });
  }
}
class TransactionSignatureMultisig extends BaseModel {
  /**
   * Creates a new `TransactionSignatureMultisig` object.
   * @param subsignature - (subsig) holds pairs of public key and signatures.
   * @param threshold - (thr)
   * @param version - (v)
   */
  constructor({ subsignature, threshold, version: version2 }) {
    super();
    this.subsignature = subsignature;
    this.threshold = threshold;
    this.version = version2;
    this.attribute_map = {
      subsignature: "subsignature",
      threshold: "threshold",
      version: "version"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignatureMultisig({
      subsignature: typeof data["subsignature"] !== "undefined" ? data["subsignature"].map(TransactionSignatureMultisigSubsignature.from_obj_for_encoding) : void 0,
      threshold: data["threshold"],
      version: data["version"]
    });
  }
}
class TransactionSignatureMultisigSubsignature extends BaseModel {
  /**
   * Creates a new `TransactionSignatureMultisigSubsignature` object.
   * @param publicKey - (pk)
   * @param signature - (s)
   */
  constructor({ publicKey, signature }) {
    super();
    this.publicKey = typeof publicKey === "string" ? new Uint8Array(buffer.Buffer.from(publicKey, "base64")) : publicKey;
    this.signature = typeof signature === "string" ? new Uint8Array(buffer.Buffer.from(signature, "base64")) : signature;
    this.attribute_map = {
      publicKey: "public-key",
      signature: "signature"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionSignatureMultisigSubsignature({
      publicKey: data["public-key"],
      signature: data["signature"]
    });
  }
}
class TransactionStateProof extends BaseModel {
  /**
   * Creates a new `TransactionStateProof` object.
   * @param message - (spmsg)
   * @param stateProof - (sp) represents a state proof.
   * Definition:
   * crypto/stateproof/structs.go : StateProof
   * @param stateProofType - (sptype) Type of the state proof. Integer representing an entry defined in
   * protocol/stateproof.go
   */
  constructor({ message, stateProof, stateProofType }) {
    super();
    this.message = message;
    this.stateProof = stateProof;
    this.stateProofType = stateProofType;
    this.attribute_map = {
      message: "message",
      stateProof: "state-proof",
      stateProofType: "state-proof-type"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    return new TransactionStateProof({
      message: typeof data["message"] !== "undefined" ? IndexerStateProofMessage.from_obj_for_encoding(data["message"]) : void 0,
      stateProof: typeof data["state-proof"] !== "undefined" ? StateProofFields.from_obj_for_encoding(data["state-proof"]) : void 0,
      stateProofType: data["state-proof-type"]
    });
  }
}
class TransactionsResponse extends BaseModel {
  /**
   * Creates a new `TransactionsResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transactions -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ currentRound, transactions, nextToken }) {
    super();
    this.currentRound = currentRound;
    this.transactions = transactions;
    this.nextToken = nextToken;
    this.attribute_map = {
      currentRound: "current-round",
      transactions: "transactions",
      nextToken: "next-token"
    };
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(data) {
    if (typeof data["current-round"] === "undefined")
      throw new Error(`Response is missing required field 'current-round': ${data}`);
    if (!Array.isArray(data["transactions"]))
      throw new Error(`Response is missing required array field 'transactions': ${data}`);
    return new TransactionsResponse({
      currentRound: data["current-round"],
      transactions: data["transactions"].map(Transaction2.from_obj_for_encoding),
      nextToken: data["next-token"]
    });
  }
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account: Account2,
  AccountParticipation: AccountParticipation2,
  AccountResponse,
  AccountStateDelta: AccountStateDelta2,
  AccountsResponse,
  Application: Application2,
  ApplicationLocalState: ApplicationLocalState2,
  ApplicationLocalStatesResponse,
  ApplicationLogData,
  ApplicationLogsResponse,
  ApplicationParams: ApplicationParams2,
  ApplicationResponse,
  ApplicationStateSchema: ApplicationStateSchema2,
  ApplicationsResponse,
  Asset: Asset2,
  AssetBalancesResponse,
  AssetHolding: AssetHolding2,
  AssetHoldingsResponse,
  AssetParams: AssetParams2,
  AssetResponse,
  AssetsResponse,
  Block: Block2,
  BlockRewards,
  BlockUpgradeState,
  BlockUpgradeVote,
  Box: Box2,
  BoxDescriptor: BoxDescriptor2,
  BoxesResponse: BoxesResponse2,
  ErrorResponse: ErrorResponse2,
  EvalDelta: EvalDelta2,
  EvalDeltaKeyValue: EvalDeltaKeyValue2,
  HashFactory,
  HealthCheck: HealthCheck2,
  IndexerStateProofMessage,
  MerkleArrayProof,
  MiniAssetHolding,
  ParticipationUpdates,
  StateProofFields,
  StateProofParticipant,
  StateProofReveal,
  StateProofSigSlot,
  StateProofSignature,
  StateProofTracking,
  StateProofVerifier,
  StateSchema,
  TealKeyValue: TealKeyValue2,
  TealValue: TealValue2,
  Transaction: Transaction2,
  TransactionApplication,
  TransactionAssetConfig,
  TransactionAssetFreeze,
  TransactionAssetTransfer,
  TransactionKeyreg,
  TransactionPayment,
  TransactionResponse,
  TransactionSignature,
  TransactionSignatureLogicsig,
  TransactionSignatureMultisig,
  TransactionSignatureMultisigSubsignature,
  TransactionStateProof,
  TransactionsResponse
}, Symbol.toStringTag, { value: "Module" }));
class LookupApplicationBoxByIDandName extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, intDecoding, index2, boxName) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
    const encodedName = buffer.Buffer.from(boxName).toString("base64");
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return Box2.from_obj_for_encoding(body);
  }
}
class SearchAccounts extends JSONRequest {
  /**
   * @returns `/v2/accounts`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/accounts";
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for accounts with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude accounts with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id2) {
    this.query["asset-id"] = id2;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const accountsPage1 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   *
   * const accountsPage2 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .nextToken(accountsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks For performance reasons, this parameter may be disabled on some configurations.
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include accounts that use this spending key.
   *
   * #### Example
   * ```typescript
   * const authAddr = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .authAddr(authAddr)
   *        .do();
   * ```
   *
   * @param authAddr
   */
  authAddr(authAddr) {
    this.query["auth-addr"] = authAddr;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
}
class SearchForTransactions extends JSONRequest {
  /**
   * @returns `/v2/transactions`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txType("keyreg")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .sigType("sig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupBlock(targetBlock).do()`
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetTransactions(assetId).do()`
   * @param id
   * @category query
   */
  assetID(id2) {
    this.query["asset-id"] = id2;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for transactions with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude transactions with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater;
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "freeze-target";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAccountTransactions(address).do()`
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address;
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const txnsPage1 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   *
   * const txnsPage2 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .nextToken(txnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
}
class SearchForAssets extends JSONRequest {
  /**
   * @returns `/v2/assets`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/assets";
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filter just assets with the given creator address.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .creator(address)
   *        .do();
   * ```
   *
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  /**
   * Filter just assets with the given name.
   *
   * #### Example
   * ```typescript
   * const name = "Test Token";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .name(name)
   *        .do();
   * ```
   *
   * @param name
   * @category query
   */
  name(name) {
    this.query.name = name;
    return this;
  }
  /**
   * Filter just assets with the given unit.
   *
   * #### Example
   * ```typescript
   * const unit = "test";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .unit(unit)
   *        .do();
   * ```
   *
   * @param unit
   * @category query
   */
  unit(unit) {
    this.query.unit = unit;
    return this;
  }
  /**
   * Asset ID for filter, as int.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .index(assetId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetByID(assetId).do();`
   * @param index
   * @category query
   */
  index(index2) {
    this.query["asset-id"] = index2;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const assetsPage1 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   *
   * const assetsPage2 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .nextToken(assetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class SearchForApplications extends JSONRequest {
  /**
   * @returns `/v2/applications`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/applications";
  }
  /**
   * Application ID for filter, as int
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .index(appId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupApplications(appId).do()`
   * @param index
   * @category query
   */
  index(index2) {
    this.query["application-id"] = index2;
    return this;
  }
  /**
   * Creator for filter, as string
   *
   * #### Example
   * ```typescript
   * const creator = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .creator(creator)
   *        .do();
   * ```
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const appsPage1 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   *
   * const appsPage2 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .nextToken(appsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
}
class SearchForApplicationBoxes extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c, intDecoding, index2) {
    super(c, intDecoding);
    this.index = index2;
    this.index = index2;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResponse = await indexerClient
   *        .searchForApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(body) {
    return BoxesResponse2.from_obj_for_encoding(body);
  }
}
class IndexerClient extends ServiceClient {
  /**
   * Create an IndexerClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "";
   * const server = "http://localhost";
   * const port   = 8980;
   * const indexerClient = new algosdk.Indexer(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node with indexer, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The API token for the Indexer API
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
    super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns the health object for the service.
   * Returns 200 if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await indexerClient.makeHealthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-health)
   * @category GET
   */
  makeHealthCheck() {
    return new MakeHealthCheck(this.c, this.intDecoding);
  }
  /**
   * Returns the list of accounts who hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetBalances(index2) {
    return new LookupAssetBalances(this.c, this.intDecoding, index2);
  }
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetTransactions(index2) {
    return new LookupAssetTransactions(this.c, this.intDecoding, index2);
  }
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   * @category GET
   */
  lookupAccountTransactions(account) {
    return new LookupAccountTransactions(this.c, this.intDecoding, account);
  }
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  lookupBlock(round) {
    return new LookupBlock(this.c, this.intDecoding, round);
  }
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  lookupTransactionByID(txID) {
    return new LookupTransactionByID(this.c, this.intDecoding, txID);
  }
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountByID(account) {
    return new LookupAccountByID(this.c, this.intDecoding, account);
  }
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAssets(account) {
    return new LookupAccountAssets(this.c, this.intDecoding, account);
  }
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedAssets(account) {
    return new LookupAccountCreatedAssets(this.c, this.intDecoding, account);
  }
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAppLocalStates(account) {
    return new LookupAccountAppLocalStates(this.c, this.intDecoding, account);
  }
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedApplications(account) {
    return new LookupAccountCreatedApplications(this.c, this.intDecoding, account);
  }
  /**
   * Returns information about the passed asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The ID of the asset ot look up.
   * @category GET
   */
  lookupAssetByID(index2) {
    return new LookupAssetByID(this.c, this.intDecoding, index2);
  }
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  lookupApplications(index2) {
    return new LookupApplications(this.c, this.intDecoding, index2);
  }
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  lookupApplicationLogs(appID) {
    return new LookupApplicationLogs(this.c, this.intDecoding, appID);
  }
  /**
   * Returns information about indexed accounts.
   *
   * #### Example
   * ```typescript
   * const accounts = await indexerClient.searchAccounts().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accounts)
   * @category GET
   */
  searchAccounts() {
    return new SearchAccounts(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient.searchForTransactions().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactions)
   * @category GET
   */
  searchForTransactions() {
    return new SearchForTransactions(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed assets.
   *
   * #### Example
   * ```typescript
   * const assets = await indexerClient.searchForAssets().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assets)
   * @category GET
   */
  searchForAssets() {
    return new SearchForAssets(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed applications.
   *
   * #### Example
   * ```typescript
   * const apps = await indexerClient.searchForApplications().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applications)
   * @category GET
   */
  searchForApplications() {
    return new SearchForApplications(this.c, this.intDecoding);
  }
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  searchForApplicationBoxes(appID) {
    return new SearchForApplicationBoxes(this.c, this.intDecoding, appID);
  }
  /**
   * Returns information about the application box given its name.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  lookupApplicationBoxByIDandName(appID, boxName) {
    return new LookupApplicationBoxByIDandName(this.c, this.intDecoding, appID, boxName);
  }
}
async function waitForConfirmation(client, txid, waitRounds) {
  const status = await client.status().do();
  if (typeof status === "undefined") {
    throw new Error("Unable to get node status");
  }
  const startRound = status["last-round"] + 1;
  let currentRound = startRound;
  while (currentRound < startRound + waitRounds) {
    let poolError = false;
    try {
      const pendingInfo = await client.pendingTransactionInformation(txid).do();
      if (pendingInfo["confirmed-round"]) {
        return pendingInfo;
      }
      if (pendingInfo["pool-error"]) {
        poolError = true;
        throw new Error(`Transaction Rejected: ${pendingInfo["pool-error"]}`);
      }
    } catch (err) {
      if (poolError) {
        throw err;
      }
    }
    await client.statusAfterBlock(currentRound).do();
    currentRound += 1;
  }
  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
}
function bigIntToBytes(bi, size2) {
  let hex = bi.toString(16);
  if (hex.length !== size2 * 2) {
    hex = hex.padStart(size2 * 2, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i = 0, j2 = 0; i < hex.length / 2; i++, j2 += 2) {
    byteArray[i] = parseInt(hex.slice(j2, j2 + 2), 16);
  }
  return byteArray;
}
function bytesToBigInt(bytes) {
  let res = BigInt(0);
  const buf = buffer.Buffer.from(bytes);
  for (let i = 0; i < bytes.length; i++) {
    res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);
  }
  return res;
}
function generateAccount() {
  const keys = keyPair();
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
const english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
const FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
const NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
function toUint11Array(buffer8) {
  const buffer11 = [];
  let acc = 0;
  let accBits = 0;
  function add2(octet) {
    acc |= octet << accBits;
    accBits += 8;
    if (accBits >= 11) {
      buffer11.push(acc & 2047);
      acc >>= 11;
      accBits -= 11;
    }
  }
  function flush() {
    if (accBits) {
      buffer11.push(acc);
    }
  }
  buffer8.forEach(add2);
  flush();
  return buffer11;
}
function applyWords(nums) {
  return nums.map((n) => english[n]);
}
function computeChecksum(seed) {
  const hashBuffer = genericHash(seed);
  const uint11Hash = toUint11Array(hashBuffer);
  const words = applyWords(uint11Hash);
  return words[0];
}
function mnemonicFromSeed(seed) {
  if (seed.length !== SEED_BTYES_LENGTH) {
    throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
  }
  const uint11Array = toUint11Array(seed);
  const words = applyWords(uint11Array);
  const checksumWord = computeChecksum(seed);
  return `${words.join(" ")} ${checksumWord}`;
}
function toUint8Array(buffer11) {
  const buffer8 = [];
  let acc = 0;
  let accBits = 0;
  function add2(ui11) {
    acc |= ui11 << accBits;
    accBits += 11;
    while (accBits >= 8) {
      buffer8.push(acc & 255);
      acc >>= 8;
      accBits -= 8;
    }
  }
  function flush() {
    if (accBits) {
      buffer8.push(acc);
    }
  }
  buffer11.forEach(add2);
  flush();
  return new Uint8Array(buffer8);
}
function seedFromMnemonic(mnemonic) {
  const words = mnemonic.split(" ");
  const key = words.slice(0, 24);
  for (const w of key) {
    if (english.indexOf(w) === -1)
      throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
  }
  const checksum = words[words.length - 1];
  const uint11Array = key.map((word) => english.indexOf(word));
  let uint8Array = toUint8Array(uint11Array);
  if (uint8Array.length !== 33)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  if (uint8Array[uint8Array.length - 1] !== 0)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  uint8Array = uint8Array.slice(0, uint8Array.length - 1);
  const cs = computeChecksum(uint8Array);
  if (cs === checksum)
    return uint8Array;
  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
}
function mnemonicToSecretKey(mn2) {
  const seed = seedFromMnemonic(mn2);
  const keys = keyPairFromSeed(seed);
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
function secretKeyToMnemonic(sk) {
  const seed = sk.slice(0, SEED_BTYES_LENGTH);
  return mnemonicFromSeed(seed);
}
function mnemonicToMasterDerivationKey(mn2) {
  return seedFromMnemonic(mn2);
}
function masterDerivationKeyToMnemonic(mdk) {
  return mnemonicFromSeed(mdk);
}
const ALGORAND_MAX_TX_GROUP_SIZE = 16;
class TxGroup {
  constructor(hashes) {
    this.name = "Transaction group";
    this.tag = buffer.Buffer.from("TG");
    if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
      const errorMsg = `${hashes.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;
      throw Error(errorMsg);
    }
    this.txGroupHashes = hashes;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const txgroup = {
      txlist: this.txGroupHashes
    };
    return txgroup;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txgroupForEnc) {
    const txn = Object.create(this.prototype);
    txn.name = "Transaction group";
    txn.tag = buffer.Buffer.from("TG");
    txn.txGroupHashes = [];
    for (const hash of txgroupForEnc.txlist) {
      txn.txGroupHashes.push(buffer.Buffer.from(hash));
    }
    return txn;
  }
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
}
function computeGroupID(txns) {
  const hashes = [];
  for (const txn of txns) {
    const tx2 = instantiateTxnIfNeeded(txn);
    hashes.push(tx2.rawTxID());
  }
  const txgroup = new TxGroup(hashes);
  const bytes = txgroup.toByte();
  const toBeHashed = buffer.Buffer.from(concatArrays(txgroup.tag, bytes));
  const gid = genericHash(toBeHashed);
  return buffer.Buffer.from(gid);
}
function assignGroupID(txns, from) {
  const gid = computeGroupID(txns);
  const result = [];
  for (const txn of txns) {
    const tx2 = instantiateTxnIfNeeded(txn);
    if (!from || encodeAddress(tx2.from.publicKey) === from) {
      tx2.group = gid;
      result.push(tx2);
    }
  }
  return result;
}
const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
const MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
const MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
const MULTISIG_NO_MUTATE_ERROR_MSG = "Cannot mutate a multisig field as it would invalidate all existing signatures.";
const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.";
const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = "Cannot add multisig signature. Signature is not of the correct length.";
function createMultisigTransaction(txn, { version: version2, threshold, addrs }) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const subsigs = pks.map((pk) => ({ pk: buffer.Buffer.from(pk) }));
  const msig = {
    v: version2,
    thr: threshold,
    subsig: subsigs
  };
  const txnForEncoding = txn.get_obj_for_encoding();
  const signedTxn = {
    msig,
    txn: txnForEncoding
  };
  const msigAddr = fromMultisigPreImg({
    version: version2,
    threshold,
    pks
  });
  if (encodeAddress(txnForEncoding.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = buffer.Buffer.from(msigAddr);
  }
  return new Uint8Array(encode(signedTxn));
}
function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version: version2, threshold, pks }) {
  const encodedMsig = createMultisigTransaction(txn, {
    version: version2,
    threshold,
    addrs: pks.map((pk) => encodeAddress(pk))
  });
  const signedTxn = decode$1(encodedMsig);
  let keyExist = false;
  signedTxn.msig.subsig.forEach((subsig, i) => {
    if (bytesEqual(subsig.pk, myPk)) {
      keyExist = true;
      signedTxn.msig.subsig[i].s = rawSig;
    }
  });
  if (keyExist === false) {
    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
  }
  const msigAddr = fromMultisigPreImg({
    version: version2,
    threshold,
    pks
  });
  if (encodeAddress(signedTxn.txn.snd) !== encodeAddress(msigAddr)) {
    signedTxn.sgnr = buffer.Buffer.from(msigAddr);
  }
  return new Uint8Array(encode(signedTxn));
}
class MultisigTransaction extends Transaction$1 {
  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */
  /**
   * Override inherited method to throw an error, as mutating transactions are prohibited in this context
   */
  addLease() {
    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
  }
  /**
   * Override inherited method to throw an error, as mutating transactions are prohibited in this context
   */
  addRekey() {
    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);
  }
  signTxn(sk) {
    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);
  }
  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */
  /**
   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,
   * encoded with msgpack as a typed array.
   * @param version - multisig version
   * @param threshold - multisig threshold
   * @param pks - multisig public key list, order is important.
   * @param sk - an Algorand secret key to sign with.
   * @returns an encoded, partially signed multisig transaction.
   */
  partialSignTxn({ version: version2, threshold, pks }, sk) {
    const myPk = keyPairFromSecretKey(sk).publicKey;
    return createMultisigTransactionWithSignature(this, { rawSig: this.rawSignTxn(sk), myPk }, { version: version2, threshold, pks });
  }
  /**
   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns
   * a partially-signed multisig transaction, encoded with msgpack as a typed array.
   * @param metadata - multisig metadata
   * @param signerAddr - address of the signer
   * @param signature - raw multisig signature
   * @returns an encoded, partially signed multisig transaction.
   */
  partialSignWithMultisigSignature(metadata, signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
    }
    return createMultisigTransactionWithSignature(this, {
      rawSig: signature,
      myPk: decodeAddress(signerAddr).publicKey
    }, metadata);
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txnForEnc) {
    return super.from_obj_for_encoding(txnForEnc);
  }
}
function mergeMultisigTransactions(multisigTxnBlobs) {
  if (multisigTxnBlobs.length < 2) {
    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
  }
  const refSigTx = decode$1(multisigTxnBlobs[0]);
  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();
  const refAuthAddr = refSigTx.sgnr ? encodeAddress(refSigTx.sgnr) : void 0;
  const refPreImage = {
    version: refSigTx.msig.v,
    threshold: refSigTx.msig.thr,
    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
  };
  const refMsigAddr = encodeAddress(fromMultisigPreImg(refPreImage));
  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));
  for (let i = 1; i < multisigTxnBlobs.length; i++) {
    const unisig = decode$1(multisigTxnBlobs[i]);
    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);
    if (unisigAlgoTxn.txID() !== refTxID) {
      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
    }
    const authAddr = unisig.sgnr ? encodeAddress(unisig.sgnr) : void 0;
    if (refAuthAddr !== authAddr) {
      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
    }
    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    const preimg = {
      version: unisig.msig.v,
      threshold: unisig.msig.thr,
      pks: unisig.msig.subsig.map((subsig) => subsig.pk)
    };
    const msgigAddr = encodeAddress(fromMultisigPreImg(preimg));
    if (refMsigAddr !== msgigAddr) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    unisig.msig.subsig.forEach((uniSubsig, index2) => {
      if (!uniSubsig.s)
        return;
      const current = newSubsigs[index2];
      if (current.s && buffer.Buffer.compare(buffer.Buffer.from(uniSubsig.s), buffer.Buffer.from(current.s)) !== 0) {
        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
      }
      current.s = uniSubsig.s;
    });
  }
  const msig = {
    v: refSigTx.msig.v,
    thr: refSigTx.msig.thr,
    subsig: newSubsigs
  };
  const signedTxn = {
    msig,
    txn: refSigTx.txn
  };
  if (typeof refAuthAddr !== "undefined") {
    signedTxn.sgnr = buffer.Buffer.from(decodeAddress(refAuthAddr).publicKey);
  }
  return new Uint8Array(encode(signedTxn));
}
function verifyMultisig(toBeVerified, msig, publicKey) {
  const version2 = msig.v;
  const threshold = msig.thr;
  const subsigs = msig.subsig;
  const pks = subsigs.map((subsig) => subsig.pk);
  if (msig.subsig.length < threshold) {
    return false;
  }
  let pk;
  try {
    pk = fromMultisigPreImg({ version: version2, threshold, pks });
  } catch (e) {
    return false;
  }
  if (!arrayEqual(pk, publicKey)) {
    return false;
  }
  let counter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      counter += 1;
    }
  }
  if (counter < threshold) {
    return false;
  }
  let verifiedCounter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      if (verify(toBeVerified, subsig.s, subsig.pk)) {
        verifiedCounter += 1;
      }
    }
  }
  if (verifiedCounter < threshold) {
    return false;
  }
  return true;
}
function signMultisigTransaction(txn, { version: version2, threshold, addrs }, sk) {
  const expectedFromRaw = fromMultisigPreImgAddrs({
    version: version2,
    threshold,
    addrs
  });
  if (!Object.prototype.hasOwnProperty.call(txn, "from")) {
    txn.from = expectedFromRaw;
  }
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const txnAlreadyBuilt = txn instanceof Transaction$1;
  let algoTxn;
  let blob;
  if (txnAlreadyBuilt) {
    algoTxn = txn;
    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, { version: version2, threshold, pks }, sk);
  } else {
    algoTxn = new MultisigTransaction(txn);
    blob = algoTxn.partialSignTxn({ version: version2, threshold, pks }, sk);
  }
  return {
    txID: algoTxn.txID().toString(),
    blob
  };
}
function appendSignMultisigTransaction(multisigTxnBlob, { version: version2, threshold, addrs }, sk) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode$1(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignTxn({ version: version2, threshold, pks }, sk);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function appendSignRawMultisigSignature(multisigTxnBlob, { version: version2, threshold, addrs }, signerAddr, signature) {
  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
  const multisigTxObj = decode$1(multisigTxnBlob);
  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({ version: version2, threshold, pks }, signerAddr, signature);
  return {
    txID: msigTxn.txID().toString(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function multisigAddress({ version: version2, threshold, addrs }) {
  return fromMultisigPreImgAddrs({ version: version2, threshold, addrs });
}
function sanityCheckProgram(program) {
  if (!program || program.length === 0)
    throw new Error("empty program");
  const lineBreakOrd = "\n".charCodeAt(0);
  const blankSpaceOrd = " ".charCodeAt(0);
  const tildeOrd = "~".charCodeAt(0);
  const isPrintable = (x2) => blankSpaceOrd <= x2 && x2 <= tildeOrd;
  const isAsciiPrintable = program.every((x2) => x2 === lineBreakOrd || isPrintable(x2));
  if (isAsciiPrintable) {
    const programStr = buffer.Buffer.from(program).toString();
    if (isValidAddress(programStr))
      throw new Error("requesting program bytes, get Algorand address");
    if (buffer.Buffer.from(programStr, "base64").toString("base64") === programStr)
      throw new Error("program should not be b64 encoded");
    throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
class LogicSig {
  constructor(program, programArgs) {
    this.tag = buffer.Buffer.from("Program");
    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array || buffer.Buffer.isBuffer(arg)))) {
      throw new TypeError("Invalid arguments");
    }
    let args;
    if (programArgs != null)
      args = programArgs.map((arg) => new Uint8Array(arg));
    sanityCheckProgram(program);
    this.logic = program;
    this.args = args;
    this.sig = void 0;
    this.msig = void 0;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const obj = {
      l: this.logic
    };
    if (this.args) {
      obj.arg = this.args;
    }
    if (this.sig) {
      obj.sig = this.sig;
    } else if (this.msig) {
      obj.msig = this.msig;
    }
    return obj;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(encoded) {
    const lsig = new LogicSig(encoded.l, encoded.arg);
    lsig.sig = encoded.sig;
    lsig.msig = encoded.msig;
    return lsig;
  }
  /**
   * Performs signature verification
   * @param publicKey - Verification key (derived from sender address or escrow address)
   */
  verify(publicKey) {
    if (this.sig && this.msig) {
      return false;
    }
    try {
      sanityCheckProgram(this.logic);
    } catch (e) {
      return false;
    }
    const toBeSigned = concatArrays(this.tag, this.logic);
    if (!this.sig && !this.msig) {
      const hash = genericHash(toBeSigned);
      return arrayEqual(hash, publicKey);
    }
    if (this.sig) {
      return verify(toBeSigned, this.sig, publicKey);
    }
    return verifyMultisig(toBeSigned, this.msig, publicKey);
  }
  /**
   * Compute hash of the logic sig program (that is the same as escrow account address) as string address
   * @returns String representation of the address
   */
  address() {
    const toBeSigned = concatArrays(this.tag, this.logic);
    const hash = genericHash(toBeSigned);
    return encodeAddress(new Uint8Array(hash));
  }
  /**
   * Creates signature (if no msig provided) or multi signature otherwise
   * @param secretKey - Secret key to sign with
   * @param msig - Multisig account as \{version, threshold, addrs\}
   */
  sign(secretKey, msig) {
    if (msig == null) {
      this.sig = this.signProgram(secretKey);
    } else {
      const subsigs = msig.addrs.map((addr) => ({
        pk: decodeAddress(addr).publicKey
      }));
      this.msig = {
        v: msig.version,
        thr: msig.threshold,
        subsig: subsigs
      };
      const [sig, index2] = this.singleSignMultisig(secretKey, this.msig);
      this.msig.subsig[index2].s = sig;
    }
  }
  /**
   * Appends a signature to multi signature
   * @param secretKey - Secret key to sign with
   */
  appendToMultisig(secretKey) {
    if (this.msig === void 0) {
      throw new Error("no multisig present");
    }
    const [sig, index2] = this.singleSignMultisig(secretKey, this.msig);
    this.msig.subsig[index2].s = sig;
  }
  signProgram(secretKey) {
    const toBeSigned = concatArrays(this.tag, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  singleSignMultisig(secretKey, msig) {
    let index2 = -1;
    const myPk = keyPairFromSecretKey(secretKey).publicKey;
    for (let i = 0; i < msig.subsig.length; i++) {
      const { pk } = msig.subsig[i];
      if (arrayEqual(pk, myPk)) {
        index2 = i;
        break;
      }
    }
    if (index2 === -1) {
      throw new Error("invalid secret key");
    }
    const sig = this.signProgram(secretKey);
    return [sig, index2];
  }
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
  static fromByte(encoded) {
    const decodedObj = decode$1(encoded);
    return LogicSig.from_obj_for_encoding(decodedObj);
  }
}
class LogicSigAccount {
  /**
   * Create a new LogicSigAccount. By default this will create an escrow
   * LogicSig account. Call `sign` or `signMultisig` on the newly created
   * LogicSigAccount to make it a delegated account.
   *
   * @param program - The compiled TEAL program which contains the logic for
   *   this LogicSig.
   * @param args - An optional array of arguments for the program.
   */
  constructor(program, args) {
    this.lsig = new LogicSig(program, args);
    this.sigkey = void 0;
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    const obj = {
      lsig: this.lsig.get_obj_for_encoding()
    };
    if (this.sigkey) {
      obj.sigkey = this.sigkey;
    }
    return obj;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(encoded) {
    const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);
    lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);
    lsigAccount.sigkey = encoded.sigkey;
    return lsigAccount;
  }
  /**
   * Encode this object into msgpack.
   */
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
  /**
   * Decode a msgpack object into a LogicSigAccount.
   * @param encoded - The encoded LogicSigAccount.
   */
  static fromByte(encoded) {
    const decodedObj = decode$1(encoded);
    return LogicSigAccount.from_obj_for_encoding(decodedObj);
  }
  /**
   * Check if this LogicSigAccount has been delegated to another account with a
   * signature.
   *
   * Note this function only checks for the presence of a delegation signature.
   * To verify the delegation signature, use `verify`.
   */
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig);
  }
  /**
   * Verifies this LogicSig's program and signatures.
   * @returns true if and only if the LogicSig program and signatures are valid.
   */
  verify() {
    const addr = this.address();
    return this.lsig.verify(decodeAddress(addr).publicKey);
  }
  /**
   * Get the address of this LogicSigAccount.
   *
   * If the LogicSig is delegated to another account, this will return the
   * address of that account.
   *
   * If the LogicSig is not delegated to another account, this will return an
   *  escrow address that is the hash of the LogicSig's program code.
   */
  address() {
    if (this.lsig.sig && this.lsig.msig) {
      throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
    }
    if (this.lsig.sig) {
      if (!this.sigkey) {
        throw new Error("Signing key for delegated account is missing");
      }
      return encodeAddress(this.sigkey);
    }
    if (this.lsig.msig) {
      const msigMetadata = {
        version: this.lsig.msig.v,
        threshold: this.lsig.msig.thr,
        pks: this.lsig.msig.subsig.map((subsig) => subsig.pk)
      };
      return encodeAddress(fromMultisigPreImg(msigMetadata));
    }
    return this.lsig.address();
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. Use this function if the delegating account is a
   * multisig account.
   *
   * @param msig - The multisig delegating account
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account. Use `appendToMultisig` to add additional signatures
   *   from other members.
   */
  signMultisig(msig, secretKey) {
    this.lsig.sign(secretKey, msig);
  }
  /**
   * Adds an additional signature from a member of the delegating multisig
   * account.
   *
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account.
   */
  appendToMultisig(secretKey) {
    this.lsig.appendToMultisig(secretKey);
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. If the delegating account is a multisig account,
   * use `signMultisig` instead.
   *
   * @param secretKey - The secret key of the delegating account.
   */
  sign(secretKey) {
    this.lsig.sign(secretKey);
    this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
  }
}
function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
  if (!lsig.verify(lsigAddress)) {
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  }
  const signedTxn = {
    lsig: lsig.get_obj_for_encoding(),
    txn: txn.get_obj_for_encoding()
  };
  if (!bytesEqual(lsigAddress, txn.from.publicKey)) {
    signedTxn.sgnr = buffer.Buffer.from(lsigAddress);
  }
  return {
    txID: txn.txID().toString(),
    blob: encode(signedTxn)
  };
}
function signLogicSigTransactionObject(txn, lsigObject) {
  let lsig;
  let lsigAddress;
  if (lsigObject instanceof LogicSigAccount) {
    lsig = lsigObject.lsig;
    lsigAddress = decodeAddress(lsigObject.address()).publicKey;
  } else {
    lsig = lsigObject;
    if (lsig.sig) {
      lsigAddress = txn.from.publicKey;
    } else if (lsig.msig) {
      const msigMetadata = {
        version: lsig.msig.v,
        threshold: lsig.msig.thr,
        pks: lsig.msig.subsig.map((subsig) => subsig.pk)
      };
      lsigAddress = fromMultisigPreImg(msigMetadata);
    } else {
      lsigAddress = decodeAddress(lsig.address()).publicKey;
    }
  }
  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
}
function signLogicSigTransaction(txn, lsigObject) {
  const algoTxn = instantiateTxnIfNeeded(txn);
  return signLogicSigTransactionObject(algoTxn, lsigObject);
}
function logicSigFromByte(encoded) {
  return LogicSig.fromByte(encoded);
}
const SIGN_PROGRAM_DATA_PREFIX = buffer.Buffer.from("ProgData");
function tealSign(sk, data, programHash) {
  const parts = concatArrays(decodeAddress(programHash).publicKey, data);
  const toBeSigned = buffer.Buffer.from(concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));
  return sign(toBeSigned, sk);
}
function verifyTealSign(data, programHash, sig, pk) {
  const parts = concatArrays(decodeAddress(programHash).publicKey, data);
  const toBeSigned = buffer.Buffer.from(concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));
  return verify(toBeSigned, sig, pk);
}
function tealSignFromProgram(sk, data, program) {
  const lsig = new LogicSig(program);
  const contractAddress = lsig.address();
  return tealSign(sk, data, contractAddress);
}
let char_to_integer = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i) {
  char_to_integer[char] = i;
});
function decode(string) {
  let result = [];
  let shift = 0;
  let value = 0;
  for (let i = 0; i < string.length; i += 1) {
    let integer = char_to_integer[string[i]];
    if (integer === void 0) {
      throw new Error("Invalid character (" + string[i] + ")");
    }
    const has_continuation_bit = integer & 32;
    integer &= 31;
    value += integer << shift;
    if (has_continuation_bit) {
      shift += 5;
    } else {
      const should_negate = value & 1;
      value >>>= 1;
      if (should_negate) {
        result.push(value === 0 ? -2147483648 : -value);
      } else {
        result.push(value);
      }
      value = shift = 0;
    }
  }
  return result;
}
class SourceMap {
  constructor({ version: version2, sources, names, mappings }) {
    this.version = version2;
    this.sources = sources;
    this.names = names;
    this.mappings = mappings;
    if (this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    const pcList = this.mappings.split(";").map((m2) => {
      const decoded = decode(m2);
      if (decoded.length > 2)
        return decoded[2];
      return void 0;
    });
    this.pcToLine = {};
    this.lineToPc = {};
    let lastLine = 0;
    for (const [pc2, lineDelta] of pcList.entries()) {
      if (lineDelta !== void 0) {
        lastLine += lineDelta;
      }
      if (!(lastLine in this.lineToPc))
        this.lineToPc[lastLine] = [];
      this.lineToPc[lastLine].push(pc2);
      this.pcToLine[pc2] = lastLine;
    }
  }
  getLineForPc(pc2) {
    return this.pcToLine[pc2];
  }
  getPcsForLine(line) {
    return this.lineToPc[line];
  }
}
const defaultAppId = 1380011588;
const defaultMaxWidth = 30;
function decodePrograms(ap2) {
  ap2.params["approval-program"] = buffer.Buffer.from(ap2.params["approval-program"].toString(), "base64");
  ap2.params["clear-state-program"] = buffer.Buffer.from(ap2.params["clear-state-program"].toString(), "base64");
  return ap2;
}
async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
  const appInfos = [];
  const acctInfos = [];
  const apps = [];
  const assets = [];
  const accts = [];
  for (const t of txns) {
    if (t.txn.type === TransactionType.appl) {
      accts.push(encodeAddress(t.txn.from.publicKey));
      if (t.txn.appAccounts)
        accts.push(...t.txn.appAccounts.map((a) => encodeAddress(a.publicKey)));
      if (t.txn.appForeignApps) {
        apps.push(...t.txn.appForeignApps);
        accts.push(...t.txn.appForeignApps.map((aidx) => getApplicationAddress(aidx)));
      }
      if (t.txn.appForeignAssets)
        assets.push(...t.txn.appForeignAssets);
      if (t.txn.appIndex === void 0 || t.txn.appIndex === 0) {
        appInfos.push(new Application$1({
          id: defaultAppId,
          params: new ApplicationParams$1({
            creator: encodeAddress(t.txn.from.publicKey),
            approvalProgram: t.txn.appApprovalProgram,
            clearStateProgram: t.txn.appClearProgram,
            localStateSchema: new ApplicationStateSchema$1({
              numUint: t.txn.appLocalInts,
              numByteSlice: t.txn.appLocalByteSlices
            }),
            globalStateSchema: new ApplicationStateSchema$1({
              numUint: t.txn.appGlobalInts,
              numByteSlice: t.txn.appGlobalByteSlices
            })
          })
        }));
      } else {
        apps.push(t.txn.appIndex);
        accts.push(getApplicationAddress(t.txn.appIndex));
      }
    }
  }
  const assetPromises = [];
  for (const assetId of [...new Set(assets)]) {
    assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
      accts.push(assetInfo.params.creator);
    }));
  }
  await Promise.all(assetPromises);
  const appPromises = [];
  for (const appId of [...new Set(apps)]) {
    appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
      const ai = decodePrograms(appInfo);
      appInfos.push(ai);
      accts.push(ai.params.creator);
    }));
  }
  await Promise.all(appPromises);
  const acctPromises = [];
  for (const acct of [...new Set(accts)]) {
    acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
      if ("created-apps" in acctInfo) {
        acctInfo["created-apps"] = acctInfo["created-apps"].map((app2) => decodePrograms(app2));
      }
      acctInfos.push(acctInfo);
    }));
  }
  await Promise.all(acctPromises);
  return new DryrunRequest({
    txns: txns.map((st) => ({ ...st, txn: st.txn.get_obj_for_encoding() })),
    accounts: acctInfos,
    apps: appInfos,
    latestTimestamp,
    round,
    protocolVersion,
    sources
  });
}
class DryrunStackValue {
  constructor(sv) {
    this.type = 0;
    this.bytes = "";
    this.uint = 0;
    this.type = sv.type;
    this.bytes = sv.bytes;
    this.uint = sv.uint;
  }
  toString() {
    if (this.type === 1) {
      return `0x${buffer.Buffer.from(this.bytes, "base64").toString("hex")}`;
    }
    return this.uint.toString();
  }
}
class DryrunTraceLine {
  constructor(line) {
    this.error = "";
    this.line = 0;
    this.pc = 0;
    this.scratch = [];
    this.stack = [];
    this.error = line.error === void 0 ? "" : line.error;
    this.line = line.line;
    this.pc = line.pc;
    this.scratch = line.scratch;
    this.stack = line.stack.map((sv) => new DryrunStackValue(sv));
  }
}
class DryrunTrace {
  constructor(t) {
    this.trace = [];
    if (t == null)
      return;
    this.trace = t.map((line) => new DryrunTraceLine(line));
  }
}
function truncate(str, maxValueWidth) {
  if (str.length > maxValueWidth && maxValueWidth > 0) {
    return `${str.slice(0, maxValueWidth)}...`;
  }
  return str;
}
function scratchToString(prevScratch, currScratch) {
  if (currScratch.length === 0)
    return "";
  let newScratchIdx = null;
  for (let idx = 0; idx < currScratch.length; idx++) {
    if (idx > prevScratch.length) {
      newScratchIdx = idx;
      continue;
    }
    if (JSON.stringify(prevScratch[idx]) !== JSON.stringify(currScratch[idx])) {
      newScratchIdx = idx;
    }
  }
  if (newScratchIdx == null)
    return "";
  const newScratch = currScratch[newScratchIdx];
  if (newScratch.bytes.length > 0) {
    return `${newScratchIdx} = 0x${buffer.Buffer.from(newScratch.bytes, "base64").toString("hex")}`;
  }
  return `${newScratchIdx} = ${newScratch.uint.toString()}`;
}
function stackToString(stack, reverse) {
  const svs = reverse ? stack.reverse() : stack;
  return `[${svs.map((sv) => {
    switch (sv.type) {
      case 1:
        return `0x${buffer.Buffer.from(sv.bytes, "base64").toString("hex")}`;
      case 2:
        return `${sv.uint.toString()}`;
      default:
        return "";
    }
  }).join(", ")}]`;
}
class DryrunTransactionResult {
  constructor(dtr) {
    this.disassembly = [];
    this.appCallMessages = [];
    this.localDeltas = [];
    this.globalDelta = [];
    this.cost = 0;
    this.logicSigMessages = [];
    this.logicSigDisassembly = [];
    this.logs = [];
    this.appCallTrace = void 0;
    this.logicSigTrace = void 0;
    this.required = ["disassembly"];
    this.optionals = [
      "app-call-messages",
      "local-deltas",
      "global-delta",
      "cost",
      "logic-sig-messages",
      "logic-sig-disassembly",
      "logs"
    ];
    this.traces = ["app-call-trace", "logic-sig-trace"];
    this.disassembly = dtr.disassembly;
    this.appCallMessages = dtr["app-call-messages"];
    this.localDeltas = dtr["local-deltas"];
    this.globalDelta = dtr["global-delta"];
    this.cost = dtr.cost;
    this.logicSigMessages = dtr["logic-sig-messages"];
    this.logicSigDisassembly = dtr["logic-sig-disassembly"];
    this.logs = dtr.logs;
    this.appCallTrace = new DryrunTrace(dtr["app-call-trace"]);
    this.logicSigTrace = new DryrunTrace(dtr["logic-sig-trace"]);
  }
  appCallRejected() {
    return this.appCallMessages !== void 0 && this.appCallMessages.includes("REJECT");
  }
  logicSigRejected() {
    return this.logicSigMessages !== void 0 && this.logicSigMessages.includes("REJECT");
  }
  static trace(drt, disassembly, spc) {
    const maxWidth = spc.maxValueWidth || defaultMaxWidth;
    const lines = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let idx = 0; idx < drt.trace.length; idx++) {
      const { line, error, pc: pc2, scratch, stack } = drt.trace[idx];
      const currScratch = scratch !== void 0 ? scratch : [];
      const prevScratch = idx > 0 && drt.trace[idx - 1].scratch !== void 0 ? drt.trace[idx - 1].scratch : [];
      const src = error === "" ? disassembly[line] : `!! ${error} !!`;
      lines.push([
        pc2.toString().padEnd(3, " "),
        line.toString().padEnd(3, " "),
        truncate(src, maxWidth),
        truncate(scratchToString(prevScratch, currScratch), maxWidth),
        truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)
      ]);
    }
    const maxLengths = lines.reduce((prev, curr) => {
      const newVal = new Array(lines[0].length).fill(0);
      for (let idx = 0; idx < prev.length; idx++) {
        newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];
      }
      return newVal;
    }, new Array(lines[0].length).fill(0));
    return `${lines.map((line) => line.map((v2, idx) => v2.padEnd(maxLengths[idx] + 1, " ")).join("|").trim()).join("\n")}
`;
  }
  appTrace(spc) {
    if (this.appCallTrace === void 0 || !this.disassembly)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: false
      };
    return DryrunTransactionResult.trace(this.appCallTrace, this.disassembly, conf);
  }
  lsigTrace(spc) {
    if (this.logicSigTrace === void 0 || this.logicSigDisassembly === void 0)
      return "";
    let conf = spc;
    if (spc === void 0)
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: true
      };
    return DryrunTransactionResult.trace(this.logicSigTrace, this.logicSigDisassembly, conf);
  }
}
class DryrunResult {
  constructor(drrResp) {
    this.error = "";
    this.protocolVersion = "";
    this.txns = [];
    this.error = drrResp.error;
    this.protocolVersion = drrResp["protocol-version"];
    this.txns = drrResp.txns.map((txn) => new DryrunTransactionResult(txn));
  }
}
function makePaymentTxnWithSuggestedParams(from, to2, amount, closeRemainderTo, note, suggestedParams, rekeyTo) {
  const o = {
    from,
    to: to2,
    amount,
    closeRemainderTo,
    note,
    suggestedParams,
    type: TransactionType.pay,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makePaymentTxnWithSuggestedParamsFromObject(o) {
  return makePaymentTxnWithSuggestedParams(o.from, o.to, o.amount, o.closeRemainderTo, o.note, o.suggestedParams, o.rekeyTo);
}
function makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation = false, stateProofKey = void 0) {
  const o = {
    from,
    note,
    voteKey,
    selectionKey,
    voteFirst,
    voteLast,
    voteKeyDilution,
    suggestedParams,
    type: TransactionType.keyreg,
    reKeyTo: rekeyTo,
    nonParticipation,
    stateProofKey
  };
  return new Transaction$1(o);
}
function makeKeyRegistrationTxnWithSuggestedParamsFromObject(o) {
  return makeKeyRegistrationTxnWithSuggestedParams(o.from, o.note, o.voteKey, o.selectionKey, o.voteFirst, o.voteLast, o.voteKeyDilution, o.suggestedParams, o.rekeyTo, o.nonParticipation, o.stateProofKey);
}
function makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo) {
  const o = {
    from,
    note,
    suggestedParams,
    assetTotal: total,
    assetDecimals: decimals,
    assetDefaultFrozen: defaultFrozen,
    assetUnitName: unitName,
    assetName,
    assetURL,
    assetMetadataHash,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetCreateTxnWithSuggestedParamsFromObject(o) {
  return makeAssetCreateTxnWithSuggestedParams(o.from, o.note, o.total, o.decimals, o.defaultFrozen, o.manager, o.reserve, o.freeze, o.clawback, o.unitName, o.assetName, o.assetURL, o.assetMetadataHash, o.suggestedParams, o.rekeyTo);
}
function makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking = true, rekeyTo) {
  if (strictEmptyAddressChecking && (manager === void 0 || reserve === void 0 || freeze === void 0 || clawback === void 0)) {
    throw Error("strict empty address checking was turned on, but at least one empty address was provided");
  }
  const o = {
    from,
    suggestedParams,
    assetIndex,
    assetManager: manager,
    assetReserve: reserve,
    assetFreeze: freeze,
    assetClawback: clawback,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetConfigTxnWithSuggestedParamsFromObject(o) {
  return makeAssetConfigTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.manager, o.reserve, o.freeze, o.clawback, o.suggestedParams, o.strictEmptyAddressChecking, o.rekeyTo);
}
function makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    from,
    suggestedParams,
    assetIndex,
    type: TransactionType.acfg,
    note,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetDestroyTxnWithSuggestedParamsFromObject(o) {
  return makeAssetDestroyTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo) {
  const o = {
    from,
    type: TransactionType.afrz,
    freezeAccount: freezeTarget,
    assetIndex,
    freezeState,
    note,
    suggestedParams,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetFreezeTxnWithSuggestedParamsFromObject(o) {
  return makeAssetFreezeTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.freezeTarget, o.freezeState, o.suggestedParams, o.rekeyTo);
}
function makeAssetTransferTxnWithSuggestedParams(from, to2, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo) {
  const o = {
    type: TransactionType.axfer,
    from,
    to: to2,
    amount,
    suggestedParams,
    assetIndex,
    note,
    assetRevocationTarget: revocationTarget,
    closeRemainderTo,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeAssetTransferTxnWithSuggestedParamsFromObject(o) {
  return makeAssetTransferTxnWithSuggestedParams(o.from, o.to, o.closeRemainderTo, o.revocationTarget, o.amount, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
}
function makeApplicationCreateTxn(from, suggestedParams, onComplete, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, extraPages, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex: 0,
    appOnComplete: onComplete,
    appLocalInts: numLocalInts,
    appLocalByteSlices: numLocalByteSlices,
    appGlobalInts: numGlobalInts,
    appGlobalByteSlices: numGlobalByteSlices,
    appApprovalProgram: approvalProgram,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo,
    extraPages
  };
  return new Transaction$1(o);
}
function makeApplicationCreateTxnFromObject(o) {
  return makeApplicationCreateTxn(o.from, o.suggestedParams, o.onComplete, o.approvalProgram, o.clearProgram, o.numLocalInts, o.numLocalByteSlices, o.numGlobalInts, o.numGlobalByteSlices, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.extraPages, o.boxes);
}
function makeApplicationUpdateTxn(from, suggestedParams, appIndex, approvalProgram, clearProgram, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appApprovalProgram: approvalProgram,
    appOnComplete: OnApplicationComplete.UpdateApplicationOC,
    appClearProgram: clearProgram,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationUpdateTxnFromObject(o) {
  return makeApplicationUpdateTxn(o.from, o.suggestedParams, o.appIndex, o.approvalProgram, o.clearProgram, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationDeleteTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.DeleteApplicationOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationDeleteTxnFromObject(o) {
  return makeApplicationDeleteTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationOptInTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.OptInOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationOptInTxnFromObject(o) {
  return makeApplicationOptInTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationCloseOutTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.CloseOutOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationCloseOutTxnFromObject(o) {
  return makeApplicationCloseOutTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationClearStateTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.ClearStateOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationClearStateTxnFromObject(o) {
  return makeApplicationClearStateTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationNoOpTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, boxes) {
  const o = {
    type: TransactionType.appl,
    from,
    suggestedParams,
    appIndex,
    appOnComplete: OnApplicationComplete.NoOpOC,
    appArgs,
    appAccounts: accounts,
    appForeignApps: foreignApps,
    appForeignAssets: foreignAssets,
    boxes,
    note,
    lease,
    reKeyTo: rekeyTo
  };
  return new Transaction$1(o);
}
function makeApplicationNoOpTxnFromObject(o) {
  return makeApplicationNoOpTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.boxes);
}
function makeApplicationCallTxnFromObject(options) {
  const o = {
    type: TransactionType.appl,
    from: options.from,
    suggestedParams: options.suggestedParams,
    appIndex: options.appIndex,
    appOnComplete: options.onComplete,
    appLocalInts: options.numLocalInts,
    appLocalByteSlices: options.numLocalByteSlices,
    appGlobalInts: options.numGlobalInts,
    appGlobalByteSlices: options.numGlobalByteSlices,
    appApprovalProgram: options.approvalProgram,
    appClearProgram: options.clearProgram,
    appArgs: options.appArgs,
    appAccounts: options.accounts,
    appForeignApps: options.foreignApps,
    appForeignAssets: options.foreignAssets,
    boxes: options.boxes,
    note: options.note,
    lease: options.lease,
    reKeyTo: options.rekeyTo,
    extraPages: options.extraPages
  };
  return new Transaction$1(o);
}
function makeBasicAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      signed.push(txnGroup[index2].signTxn(account.sk));
    }
    return Promise.resolve(signed);
  };
}
function makeLogicSigAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      const { blob } = signLogicSigTransactionObject(txnGroup[index2], account);
      signed.push(blob);
    }
    return Promise.resolve(signed);
  };
}
function makeMultiSigAccountTransactionSigner(msig, sks) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index2 of indexesToSign) {
      const txn = txnGroup[index2];
      const partialSigs = [];
      for (const sk of sks) {
        const { blob } = signMultisigTransaction(txn, msig, sk);
        partialSigs.push(blob);
      }
      signed.push(mergeMultisigTransactions(partialSigs));
    }
    return Promise.resolve(signed);
  };
}
function isTransactionWithSigner(value) {
  return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
}
const MAX_LEN = 2 ** 16 - 1;
const ADDR_BYTE_SIZE = 32;
const SINGLE_BYTE_SIZE = 1;
const SINGLE_BOOL_SIZE = 1;
const LENGTH_ENCODE_BYTE_SIZE = 2;
const staticArrayRegexp = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/;
const ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
class ABIType {
  // De-serializes the ABI type from a string using the ABI specs
  static from(str) {
    if (str.endsWith("[]")) {
      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));
      return new ABIArrayDynamicType(arrayArgType);
    }
    if (str.endsWith("]")) {
      const stringMatches = str.match(staticArrayRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed static array string: ${str}`);
      }
      const arrayLengthStr = stringMatches[2];
      const arrayLength = parseInt(arrayLengthStr, 10);
      if (arrayLength > MAX_LEN) {
        throw new Error(`array length exceeds limit ${MAX_LEN}`);
      }
      const arrayType = ABIType.from(stringMatches[1]);
      return new ABIArrayStaticType(arrayType, arrayLength);
    }
    if (str.startsWith("uint")) {
      const digitsOnly = (string) => [...string].every((c) => "0123456789".includes(c));
      const typeSizeStr = str.slice(4, str.length);
      if (!digitsOnly(typeSizeStr)) {
        throw new Error(`malformed uint string: ${typeSizeStr}`);
      }
      const typeSize = parseInt(typeSizeStr, 10);
      if (typeSize > MAX_LEN) {
        throw new Error(`malformed uint string: ${typeSize}`);
      }
      return new ABIUintType(typeSize);
    }
    if (str === "byte") {
      return new ABIByteType();
    }
    if (str.startsWith("ufixed")) {
      const stringMatches = str.match(ufixedRegexp);
      if (stringMatches.length !== 3) {
        throw new Error(`malformed ufixed type: ${str}`);
      }
      const ufixedSize = parseInt(stringMatches[1], 10);
      const ufixedPrecision = parseInt(stringMatches[2], 10);
      return new ABIUfixedType(ufixedSize, ufixedPrecision);
    }
    if (str === "bool") {
      return new ABIBoolType();
    }
    if (str === "address") {
      return new ABIAddressType();
    }
    if (str === "string") {
      return new ABIStringType();
    }
    if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
      const tupleTypes = [];
      for (let i = 0; i < tupleContent.length; i++) {
        const ti = ABIType.from(tupleContent[i]);
        tupleTypes.push(ti);
      }
      return new ABITupleType(tupleTypes);
    }
    throw new Error(`cannot convert a string ${str} to an ABI type`);
  }
}
class ABIUintType extends ABIType {
  constructor(size2) {
    super();
    if (size2 % 8 !== 0 || size2 < 8 || size2 > 512) {
      throw new Error(`unsupported uint type bitSize: ${size2}`);
    }
    this.bitSize = size2;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(other) {
    return other instanceof ABIUintType && this.bitSize === other.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    }
    return bytesToBigInt(byteString);
  }
}
class ABIUfixedType extends ABIType {
  constructor(size2, denominator) {
    super();
    if (size2 % 8 !== 0 || size2 < 8 || size2 > 512) {
      throw new Error(`unsupported ufixed type bitSize: ${size2}`);
    }
    if (denominator > 160 || denominator < 1) {
      throw new Error(`unsupported ufixed type precision: ${denominator}`);
    }
    this.bitSize = size2;
    this.precision = denominator;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(other) {
    return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    }
    return bytesToBigInt(byteString);
  }
}
class ABIAddressType extends ABIType {
  toString() {
    return "address";
  }
  equals(other) {
    return other instanceof ABIAddressType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return ADDR_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (typeof value === "string") {
      const decodedAddress = decodeAddress(value);
      return decodedAddress.publicKey;
    }
    if (value.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return value;
  }
  decode(byteString) {
    if (byteString.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return encodeAddress(byteString);
  }
}
class ABIBoolType extends ABIType {
  toString() {
    return "bool";
  }
  equals(other) {
    return other instanceof ABIBoolType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BOOL_SIZE;
  }
  encode(value) {
    if (typeof value !== "boolean") {
      throw new Error(`Cannot encode value as bool: ${value}`);
    }
    if (value) {
      return new Uint8Array([128]);
    }
    return new Uint8Array([0]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`bool string must be 1 byte long`);
    }
    const value = byteString[0];
    if (value === 128) {
      return true;
    }
    if (value === 0) {
      return false;
    }
    throw new Error(`boolean could not be decoded from the byte string`);
  }
}
class ABIByteType extends ABIType {
  toString() {
    return "byte";
  }
  equals(other) {
    return other instanceof ABIByteType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "number" && typeof value !== "bigint") {
      throw new Error(`Cannot encode value as byte: ${value}`);
    }
    if (typeof value === "bigint") {
      value = Number(value);
    }
    if (value < 0 || value > 255) {
      throw new Error(`${value} cannot be encoded into a byte`);
    }
    return new Uint8Array([value]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`byte string must be 1 byte long`);
    }
    return byteString[0];
  }
}
class ABIStringType extends ABIType {
  toString() {
    return "string";
  }
  equals(other) {
    return other instanceof ABIStringType;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as string: ${value}`);
    }
    const encodedBytes = buffer.Buffer.from(value);
    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);
    mergedBytes.set(encodedLength);
    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
    return mergedBytes;
  }
  decode(byteString) {
    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
    }
    const buf = buffer.Buffer.from(byteString);
    const byteLength2 = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
    if (byteLength2 !== byteValue.length) {
      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength2}, got ${byteValue.length}`);
    }
    return buffer.Buffer.from(byteValue).toString("utf-8");
  }
}
class ABIArrayStaticType extends ABIType {
  constructor(argType, arrayLength) {
    super();
    if (arrayLength < 0) {
      throw new Error(`static array must have a non negative length: ${arrayLength}`);
    }
    this.childType = argType;
    this.staticLength = arrayLength;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(other) {
    return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    if (this.childType.constructor === ABIBoolType) {
      return Math.ceil(this.staticLength / 8);
    }
    return this.staticLength * this.childType.byteLen();
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value.length !== this.staticLength) {
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
    }
    const convertedTuple = this.toABITupleType();
    return convertedTuple.encode(value);
  }
  decode(byteString) {
    const convertedTuple = this.toABITupleType();
    return convertedTuple.decode(byteString);
  }
  toABITupleType() {
    return new ABITupleType(Array(this.staticLength).fill(this.childType));
  }
}
class ABIArrayDynamicType extends ABIType {
  constructor(argType) {
    super();
    this.childType = argType;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(other) {
    return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const convertedTuple = this.toABITupleType(value.length);
    const encodedTuple = convertedTuple.encode(value);
    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = concatArrays(encodedLength, encodedTuple);
    return mergedBytes;
  }
  decode(byteString) {
    const buf = buffer.Buffer.from(byteString);
    const byteLength2 = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);
    const convertedTuple = this.toABITupleType(byteLength2);
    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
  }
  toABITupleType(length) {
    return new ABITupleType(Array(length).fill(this.childType));
  }
}
class ABITupleType extends ABIType {
  constructor(argTypes) {
    super();
    if (argTypes.length >= MAX_LEN) {
      throw new Error("tuple type child type number larger than maximum uint16 error");
    }
    this.childTypes = argTypes;
  }
  toString() {
    const typeStrings = [];
    for (let i = 0; i < this.childTypes.length; i++) {
      typeStrings[i] = this.childTypes[i].toString();
    }
    return `(${typeStrings.join(",")})`;
  }
  equals(other) {
    return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index2) => child.equals(other.childTypes[index2]));
  }
  isDynamic() {
    const isDynamic = (child) => child.isDynamic();
    return this.childTypes.some(isDynamic);
  }
  byteLen() {
    let size2 = 0;
    for (let i = 0; i < this.childTypes.length; i++) {
      if (this.childTypes[i].constructor === ABIBoolType) {
        const after = findBoolLR(this.childTypes, i, 1);
        const boolNum = after + 1;
        i += after;
        size2 += Math.trunc((boolNum + 7) / 8);
      } else {
        const childByteSize = this.childTypes[i].byteLen();
        size2 += childByteSize;
      }
    }
    return size2;
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const values = Array.from(value);
    if (value.length > MAX_LEN) {
      throw new Error("length of tuple array should not exceed a uint16");
    }
    const tupleTypes = this.childTypes;
    const heads = [];
    const tails = [];
    const isDynamicIndex = /* @__PURE__ */ new Map();
    let i = 0;
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        isDynamicIndex.set(heads.length, true);
        heads.push(new Uint8Array([0, 0]));
        tails.push(tupleType.encode(values[i]));
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(tupleTypes, i, -1);
          let after = findBoolLR(tupleTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          }
          after = Math.min(7, after);
          const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));
          heads.push(bigIntToBytes(compressedInt, 1));
          i += after;
        } else {
          const encodedTupleValue = tupleType.encode(values[i]);
          heads.push(encodedTupleValue);
        }
        isDynamicIndex.set(i, false);
        tails.push(new Uint8Array());
      }
      i += 1;
    }
    let headLength = 0;
    for (const headElement of heads) {
      headLength += headElement.length;
    }
    let tailLength = 0;
    for (let j2 = 0; j2 < heads.length; j2++) {
      if (isDynamicIndex.get(j2)) {
        const headValue = headLength + tailLength;
        if (headValue > MAX_LEN) {
          throw new Error(`byte length of ${headValue} should not exceed a uint16`);
        }
        heads[j2] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
      }
      tailLength += tails[j2].length;
    }
    return concatArrays(...heads, ...tails);
  }
  decode(byteString) {
    const tupleTypes = this.childTypes;
    const dynamicSegments = [];
    const valuePartition = [];
    let i = 0;
    let iterIndex = 0;
    const buf = buffer.Buffer.from(byteString);
    while (i < tupleTypes.length) {
      const tupleType = tupleTypes[i];
      if (tupleType.isDynamic()) {
        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
          throw new Error("dynamic type in tuple is too short to be decoded");
        }
        const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);
        if (dynamicSegments.length > 0) {
          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
            throw new Error("dynamic index segment miscalculation: left is greater than right index");
          }
        }
        const seg = {
          left: dynamicIndex,
          right: -1
        };
        dynamicSegments.push(seg);
        valuePartition.push(null);
        iterIndex += LENGTH_ENCODE_BYTE_SIZE;
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(this.childTypes, i, -1);
          let after = findBoolLR(this.childTypes, i, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before bool number mod 8 === 0");
          }
          after = Math.min(7, after);
          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
            const boolMask = 128 >> boolIndex;
            if ((byteString[iterIndex] & boolMask) > 0) {
              valuePartition.push(new Uint8Array([128]));
            } else {
              valuePartition.push(new Uint8Array([0]));
            }
          }
          i += after;
          iterIndex += 1;
        } else {
          const currLen = tupleType.byteLen();
          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
          iterIndex += currLen;
        }
      }
      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
        throw new Error("input byte not enough to decode");
      }
      i += 1;
    }
    if (dynamicSegments.length > 0) {
      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
      iterIndex = byteString.length;
    }
    if (iterIndex < byteString.length) {
      throw new Error("input byte not fully consumed");
    }
    for (let j2 = 0; j2 < dynamicSegments.length; j2++) {
      const seg = dynamicSegments[j2];
      if (seg.left > seg.right) {
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      }
      if (j2 !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j2 + 1].left) {
        throw new Error("dynamic segment should be consecutive");
      }
    }
    let segIndex = 0;
    for (let j2 = 0; j2 < tupleTypes.length; j2++) {
      if (tupleTypes[j2].isDynamic()) {
        valuePartition[j2] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
        segIndex += 1;
      }
    }
    const returnValues = [];
    for (let j2 = 0; j2 < tupleTypes.length; j2++) {
      const valueTi = tupleTypes[j2].decode(valuePartition[j2]);
      returnValues.push(valueTi);
    }
    return returnValues;
  }
  static parseTupleContent(str) {
    if (str.length === 0) {
      return [];
    }
    if (str.endsWith(",") || str.startsWith(",")) {
      throw new Error("tuple string should not start with comma");
    }
    if (str.includes(",,")) {
      throw new Error("tuple string should not have consecutive commas");
    }
    const tupleStrings = [];
    let depth = 0;
    let word = "";
    for (const char of str) {
      word += char;
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        depth -= 1;
      } else if (char === ",") {
        if (depth === 0) {
          tupleStrings.push(word.slice(0, word.length - 1));
          word = "";
        }
      }
    }
    if (word.length !== 0) {
      tupleStrings.push(word);
    }
    if (depth !== 0) {
      throw new Error("tuple string has mismatched parentheses");
    }
    return tupleStrings;
  }
}
function compressMultipleBool(valueList) {
  let res = 0;
  if (valueList.length > 8) {
    throw new Error("value list passed in should be no greater than length 8");
  }
  for (let i = 0; i < valueList.length; i++) {
    const boolVal = valueList[i];
    if (typeof boolVal !== "boolean") {
      throw new Error("non-boolean values cannot be compressed into a byte");
    }
    if (boolVal) {
      res |= 1 << 7 - i;
    }
  }
  return res;
}
function findBoolLR(typeList, index2, delta) {
  let until = 0;
  while (true) {
    const curr = index2 + delta * until;
    if (typeList[curr].constructor === ABIBoolType) {
      if (curr !== typeList.length - 1 && delta === 1) {
        until += 1;
      } else if (curr > 0 && delta === -1) {
        until += 1;
      } else {
        break;
      }
    } else {
      until -= 1;
      break;
    }
  }
  return until;
}
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
function abiTypeIsTransaction(type) {
  return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
}
function abiCheckTransactionType(type, txn) {
  if (type === ABITransactionType.any) {
    return true;
  }
  return txn.type && txn.type.toString() === type.toString();
}
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
function abiTypeIsReference(type) {
  return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
}
function parseMethodSignature(signature) {
  const argsStart = signature.indexOf("(");
  if (argsStart === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  let argsEnd = -1;
  let depth = 0;
  for (let i = argsStart; i < signature.length; i++) {
    const char = signature[i];
    if (char === "(") {
      depth += 1;
    } else if (char === ")") {
      if (depth === 0) {
        break;
      }
      depth -= 1;
      if (depth === 0) {
        argsEnd = i;
        break;
      }
    }
  }
  if (argsEnd === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  return {
    name: signature.slice(0, argsStart),
    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
    returns: signature.slice(argsEnd + 1)
  };
}
class ABIMethod {
  constructor(params) {
    if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
      throw new Error("Invalid ABIMethod parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.args = params.args.map(({ type, name, desc }) => {
      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
        return {
          type,
          name,
          description: desc
        };
      }
      return {
        type: ABIType.from(type),
        name,
        description: desc
      };
    });
    this.returns = {
      type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
      description: params.returns.desc
    };
  }
  getSignature() {
    const args = this.args.map((arg) => arg.type.toString()).join(",");
    const returns = this.returns.type.toString();
    return `${this.name}(${args})${returns}`;
  }
  getSelector() {
    const hash = genericHash(this.getSignature());
    return new Uint8Array(hash.slice(0, 4));
  }
  txnCount() {
    let count = 1;
    for (const arg of this.args) {
      if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
        count += 1;
      }
    }
    return count;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      args: this.args.map(({ type, name, description }) => ({
        type: type.toString(),
        name,
        desc: description
      })),
      returns: {
        type: this.returns.type.toString(),
        desc: this.returns.description
      }
    };
  }
  static fromSignature(signature) {
    const { name, args, returns } = parseMethodSignature(signature);
    return new ABIMethod({
      name,
      args: args.map((arg) => ({ type: arg })),
      returns: { type: returns }
    });
  }
}
function getMethodByName(methods, name) {
  if (methods === null || !Array.isArray(methods) || !methods.every((item) => item instanceof ABIMethod))
    throw new Error("Methods list provided is null or not the correct type");
  const filteredMethods = methods.filter((m2) => m2.name === name);
  if (filteredMethods.length > 1)
    throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map((m2) => m2.getSignature()).join(",")}`);
  if (filteredMethods.length === 0)
    throw new Error(`found 0 methods with the name ${name}`);
  return filteredMethods[0];
}
class ABIContract {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
      throw new Error("Invalid ABIContract parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.networks = params.networks ? { ...params.networks } : {};
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      networks: this.networks,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
}
class ABIInterface {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
      throw new Error("Invalid ABIInterface parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
}
const RETURN_PREFIX = buffer.Buffer.from([21, 31, 124, 117]);
const MAX_APP_ARGS = 16;
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
function populateForeignArray(valueToAdd, array, zeroValue) {
  if (zeroValue != null && valueToAdd === zeroValue) {
    return 0;
  }
  const offset = zeroValue == null ? 0 : 1;
  for (let i = 0; i < array.length; i++) {
    if (valueToAdd === array[i]) {
      return i + offset;
    }
  }
  array.push(valueToAdd);
  return array.length - 1 + offset;
}
class AtomicTransactionComposer {
  constructor() {
    this.status = AtomicTransactionComposerStatus.BUILDING;
    this.transactions = [];
    this.methodCalls = /* @__PURE__ */ new Map();
    this.signedTxns = [];
    this.txIDs = [];
  }
  /**
   * Get the status of this composer's transaction group.
   */
  getStatus() {
    return this.status;
  }
  /**
   * Get the number of transactions currently in this atomic group.
   */
  count() {
    return this.transactions.length;
  }
  /**
   * Create a new composer with the same underlying transactions. The new composer's status will be
   * BUILDING, so additional transactions may be added to it.
   */
  clone() {
    const theClone = new AtomicTransactionComposer();
    theClone.transactions = this.transactions.map(({ txn, signer }) => ({
      // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)
      txn: Transaction$1.from_obj_for_encoding({
        ...txn.get_obj_for_encoding(),
        // erase the group ID
        grp: void 0
      }),
      signer
    }));
    theClone.methodCalls = new Map(this.methodCalls);
    return theClone;
  }
  /**
   * Add a transaction to this atomic group.
   *
   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is
   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.
   */
  addTransaction(txnAndSigner) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v2) => v2 !== 0)) {
      throw new Error("Cannot add a transaction with nonzero group ID");
    }
    this.transactions.push(txnAndSigner);
  }
  /**
   * Add a smart contract method call to this atomic group.
   *
   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction
   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid
   * for the given method.
   */
  addMethodCall({ appID, method, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, appAccounts, appForeignApps, appForeignAssets, boxes, note, lease, rekeyTo, signer }) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (appID === 0) {
      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
      }
    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
      if (approvalProgram == null || clearProgram == null) {
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      }
      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
      }
    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    }
    if (methodArgs == null) {
      methodArgs = [];
    }
    if (methodArgs.length !== method.args.length) {
      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);
    }
    let basicArgTypes = [];
    let basicArgValues = [];
    const txnArgs = [];
    const refArgTypes = [];
    const refArgValues = [];
    const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
    const boxReferences = !boxes ? [] : boxes;
    for (let i = 0; i < methodArgs.length; i++) {
      let argType = method.args[i].type;
      const argValue = methodArgs[i];
      if (abiTypeIsTransaction(argType)) {
        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
          throw new Error(`Expected ${argType} transaction for argument at index ${i}`);
        }
        if (argValue.txn.group && argValue.txn.group.some((v2) => v2 !== 0)) {
          throw new Error("Cannot add a transaction with nonzero group ID");
        }
        txnArgs.push(argValue);
        continue;
      }
      if (isTransactionWithSigner(argValue)) {
        throw new Error(`Expected non-transaction value for argument at index ${i}`);
      }
      if (abiTypeIsReference(argType)) {
        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
        refArgTypes.push(argType);
        refArgValues.push(argValue);
        argType = new ABIUintType(8);
      }
      if (typeof argType === "string") {
        throw new Error(`Unknown ABI type: ${argType}`);
      }
      basicArgTypes.push(argType);
      basicArgValues.push(argValue);
    }
    const resolvedRefIndexes = [];
    const foreignAccounts = appAccounts == null ? [] : appAccounts.slice();
    const foreignApps = appForeignApps == null ? [] : appForeignApps.slice();
    const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.slice();
    for (let i = 0; i < refArgTypes.length; i++) {
      const refType = refArgTypes[i];
      const refValue = refArgValues[i];
      let resolved = 0;
      switch (refType) {
        case ABIReferenceType.account: {
          const addressType = new ABIAddressType();
          const address = addressType.decode(addressType.encode(refValue));
          resolved = populateForeignArray(address, foreignAccounts, sender);
          break;
        }
        case ABIReferenceType.application: {
          const uint64Type = new ABIUintType(64);
          const refAppID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAppID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for application value, got ${refAppID}`);
          }
          resolved = populateForeignArray(Number(refAppID), foreignApps, appID);
          break;
        }
        case ABIReferenceType.asset: {
          const uint64Type = new ABIUintType(64);
          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAssetID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
          }
          resolved = populateForeignArray(Number(refAssetID), foreignAssets);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${refType}`);
      }
      resolvedRefIndexes.push(resolved);
    }
    for (let i = 0; i < resolvedRefIndexes.length; i++) {
      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);
      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];
    }
    if (basicArgTypes.length > MAX_APP_ARGS - 1) {
      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
      basicArgValues.push(lastArgTupleValues);
    }
    const appArgsEncoded = [method.getSelector()];
    for (let i = 0; i < basicArgTypes.length; i++) {
      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));
    }
    const appCall = {
      txn: makeApplicationCallTxnFromObject({
        from: sender,
        appIndex: appID,
        appArgs: appArgsEncoded,
        accounts: foreignAccounts,
        foreignApps,
        foreignAssets,
        boxes: boxReferences,
        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
        approvalProgram,
        clearProgram,
        numGlobalInts,
        numGlobalByteSlices,
        numLocalInts,
        numLocalByteSlices,
        extraPages,
        lease,
        note,
        rekeyTo,
        suggestedParams
      }),
      signer
    };
    this.transactions.push(...txnArgs, appCall);
    this.methodCalls.set(this.transactions.length - 1, method);
  }
  /**
   * Finalize the transaction group and returned the finalized transactions.
   *
   * The composer's status will be at least BUILT after executing this method.
   */
  buildGroup() {
    if (this.status === AtomicTransactionComposerStatus.BUILDING) {
      if (this.transactions.length === 0) {
        throw new Error("Cannot build a group with 0 transactions");
      }
      if (this.transactions.length > 1) {
        assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
      }
      this.status = AtomicTransactionComposerStatus.BUILT;
    }
    return this.transactions;
  }
  /**
   * Obtain signatures for each transaction in this group. If signatures have already been obtained,
   * this method will return cached versions of the signatures.
   *
   * The composer's status will be at least SIGNED after executing this method.
   *
   * An error will be thrown if signing any of the transactions fails.
   *
   * @returns A promise that resolves to an array of signed transactions.
   */
  async gatherSignatures() {
    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
      return this.signedTxns;
    }
    const txnsWithSigners = this.buildGroup();
    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
    const indexesPerSigner = /* @__PURE__ */ new Map();
    for (let i = 0; i < txnsWithSigners.length; i++) {
      const { signer } = txnsWithSigners[i];
      if (!indexesPerSigner.has(signer)) {
        indexesPerSigner.set(signer, []);
      }
      indexesPerSigner.get(signer).push(i);
    }
    const orderedSigners = Array.from(indexesPerSigner);
    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
    const signedTxns = txnsWithSigners.map(() => null);
    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
      const indexes = orderedSigners[signerIndex][1];
      const sigs = batchedSigs[signerIndex];
      for (let i = 0; i < indexes.length; i++) {
        signedTxns[indexes[i]] = sigs[i];
      }
    }
    if (!signedTxns.every((sig) => sig != null)) {
      throw new Error(`Missing signatures. Got ${signedTxns}`);
    }
    const txIDs = signedTxns.map((stxn, index2) => {
      try {
        return decodeSignedTransaction(stxn).txn.txID();
      } catch (err) {
        throw new Error(`Cannot decode signed transaction at index ${index2}. ${err}`);
      }
    });
    this.signedTxns = signedTxns;
    this.txIDs = txIDs;
    this.status = AtomicTransactionComposerStatus.SIGNED;
    return signedTxns;
  }
  /**
   * Send the transaction group to the network, but don't wait for it to be committed to a block. An
   * error will be thrown if submission fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method. If submission is
   * successful, this composer's status will update to SUBMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   *
   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.
   */
  async submit(client) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Transaction group cannot be resubmitted");
    }
    const stxns = await this.gatherSignatures();
    await client.sendRawTransaction(stxns).do();
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    return this.txIDs;
  }
  /**
   * Send the transaction group to the network and wait until it's committed to a block. An error
   * will be thrown if submission or execution fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method, since execution is
   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.
   * If the execution is also successful, this composer's status will update to COMMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation
   *
   * @returns A promise that, upon success, resolves to an object containing the confirmed round for
   *   this transaction, the txIDs of the submitted transactions, and an array of results containing
   *   one element for each method call transaction in this group.
   */
  async execute(client, waitRounds) {
    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
      throw new Error("Transaction group has already been executed successfully");
    }
    const txIDs = await this.submit(client);
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    const firstMethodCallIndex = this.transactions.findIndex((_, index2) => this.methodCalls.has(index2));
    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
    this.status = AtomicTransactionComposerStatus.COMMITTED;
    const confirmedRound = confirmedTxnInfo["confirmed-round"];
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = txIDs[txnIndex];
      const methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      try {
        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : (
          // eslint-disable-next-line no-await-in-loop
          await client.pendingTransactionInformation(txID).do()
        );
        methodResult.txInfo = pendingInfo;
        if (method.returns.type !== "void") {
          const logs = pendingInfo.logs || [];
          if (logs.length === 0) {
            throw new Error("App call transaction did not log a return value");
          }
          const lastLog = buffer.Buffer.from(logs[logs.length - 1], "base64");
          if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {
            throw new Error("App call transaction did not log a return value");
          }
          methodResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
          methodResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);
        }
      } catch (err) {
        methodResult.decodeError = err;
      }
      methodResults.push(methodResult);
    }
    return {
      confirmedRound,
      txIDs,
      methodResults
    };
  }
}
AtomicTransactionComposer.MAX_GROUP_SIZE = 16;
const SIGN_BYTES_PREFIX = buffer.Buffer.from([77, 88]);
const MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
function signTransaction(txn, sk) {
  if (typeof txn.from === "undefined") {
    const key = keyPairFromSecretKey(sk);
    txn.from = encodeAddress(key.publicKey);
  }
  const algoTxn = instantiateTxnIfNeeded(txn);
  return {
    txID: algoTxn.txID().toString(),
    blob: algoTxn.signTxn(sk)
  };
}
function signBid(bid, sk) {
  const signedBid = new Bid(bid);
  return signedBid.signBid(sk);
}
function signBytes(bytes, sk) {
  const toBeSigned = buffer.Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const sig = sign(toBeSigned, sk);
  return sig;
}
function verifyBytes(bytes, signature, addr) {
  const toBeVerified = buffer.Buffer.from(concatArrays(SIGN_BYTES_PREFIX, bytes));
  const pk = decodeAddress(addr).publicKey;
  return verify(toBeVerified, signature, pk);
}
function encodeObj(o) {
  return new Uint8Array(encode(o));
}
function decodeObj(o) {
  return decode$1(o);
}
const ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
const ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);
const algosdk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ABIAddressType,
  ABIArrayDynamicType,
  ABIArrayStaticType,
  ABIBoolType,
  ABIByteType,
  ABIContract,
  ABIInterface,
  ABIMethod,
  get ABIReferenceType() {
    return ABIReferenceType;
  },
  ABIStringType,
  get ABITransactionType() {
    return ABITransactionType;
  },
  ABITupleType,
  ABIType,
  ABIUfixedType,
  ABIUintType,
  ADDR_BYTE_SIZE,
  ALGORAND_MIN_TX_FEE,
  Algodv2: AlgodClient,
  AtomicTransactionComposer,
  get AtomicTransactionComposerStatus() {
    return AtomicTransactionComposerStatus;
  },
  DryrunResult,
  ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER,
  INVALID_MICROALGOS_ERROR_MSG,
  Indexer: IndexerClient,
  IntDecoding: IntDecoding$1,
  Kmd,
  LENGTH_ENCODE_BYTE_SIZE,
  LogicSig,
  LogicSigAccount,
  MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG,
  get OnApplicationComplete() {
    return OnApplicationComplete;
  },
  SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE,
  SourceMap,
  Transaction: Transaction$1,
  get TransactionType() {
    return TransactionType;
  },
  abiCheckTransactionType,
  abiTypeIsReference,
  abiTypeIsTransaction,
  algosToMicroalgos,
  appendSignMultisigTransaction,
  appendSignRawMultisigSignature,
  assignGroupID,
  bigIntToBytes,
  bytesToBigInt,
  computeGroupID,
  createDryrun,
  createMultisigTransaction,
  decodeAddress,
  decodeObj,
  decodeSignedTransaction,
  decodeUint64,
  decodeUnsignedTransaction,
  encodeAddress,
  encodeObj,
  encodeUint64,
  encodeUnsignedTransaction,
  generateAccount,
  getApplicationAddress,
  getMethodByName,
  indexerModels: types,
  instantiateTxnIfNeeded,
  isTransactionWithSigner,
  isValidAddress,
  logicSigFromByte,
  makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxn,
  makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxn,
  makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxn,
  makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxn,
  makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxn,
  makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxn,
  makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxn,
  makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxnWithSuggestedParams,
  makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxnWithSuggestedParams,
  makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxnWithSuggestedParams,
  makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxnWithSuggestedParams,
  makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxnWithSuggestedParams,
  makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBasicAccountTransactionSigner,
  makeKeyRegistrationTxnWithSuggestedParams,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner,
  makePaymentTxnWithSuggestedParams,
  makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic,
  mergeMultisigTransactions,
  microalgosToAlgos,
  mnemonicFromSeed,
  mnemonicToMasterDerivationKey,
  mnemonicToSecretKey,
  modelsv2: types$1,
  multisigAddress,
  secretKeyToMnemonic,
  seedFromMnemonic,
  signBid,
  signBytes,
  signLogicSigTransaction,
  signLogicSigTransactionObject,
  signMultisigTransaction,
  signTransaction,
  tealSign,
  tealSignFromProgram,
  verifyBytes,
  verifyMultisig,
  verifyTealSign,
  waitForConfirmation
}, Symbol.toStringTag, { value: "Module" }));
var X$1 = Object.defineProperty;
var oe = (i, t, e) => t in i ? X$1(i, t, { enumerable: true, configurable: true, writable: true, value: e }) : i[t] = e;
var d = (i, t) => X$1(i, "name", { value: t, configurable: true });
var g = (i, t, e) => (oe(i, typeof t != "symbol" ? t + "" : t, e), e);
function j() {
  let i = false;
  return typeof window !== void 0 && typeof window == "object" && "document" in window && typeof window.document == "object" && (i = true), i;
}
d(j, "isBrowser");
var m = { changedState: (i) => {
}, changedAccount: (i) => {
} }, F = "AW", K = d(() => {
  if (!j()) {
    console.warn("not in browser...");
    return;
  }
  d(() => {
    try {
      let t = localStorage.getItem(F);
      if (t)
        try {
          let e = JSON.parse(t);
          r.stored = e;
        } catch {
          console.warn("bad sLocalStorage parse");
        }
    } catch {
      console.warn("could not access localstorage");
    }
  }, "initLocalStorage")(), watch(() => r.stored, () => {
    try {
      localStorage.setItem(F, JSON.stringify(r.stored));
    } catch {
      console.warn("could not save to localstorage");
    }
  }, { deep: true }), watch(r, (t) => {
    m.changedState(t);
  }, { deep: true }), watch(() => r.stored.activeAccount, (t) => {
    m.changedAccount(t);
  }, { deep: true });
}, "startWatchers"), Ve = d((i, t = true) => {
  m.changedState = i, t && m.changedState(r);
}, "setChangedStateHandler"), Xe = d((i, t = true) => {
  m.changedAccount = i, t && m.changedAccount(r.stored.activeAccount);
}, "setChangedAccountHandler");
var u = class {
  constructor(t) {
  }
};
d(u, "BaseClient"), g(u, "metadata"), g(u, "init");
var se = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzcgMTg3Ij48cmVjdCB4PSItMTEuMzgiIHk9Ii0yNS45NyIgd2lkdGg9IjIwMC4wMiIgaGVpZ2h0PSIyMzEuNTMiIHN0eWxlPSJmaWxsOiNmZTU7Ii8+PHBhdGggZD0iTTk0LjA1LDU5LjYxYzIuMDUsOC40OCwxLjM2LDE1Ljk0LTEuNTUsMTYuNjYtMi45LC43Mi02LjkxLTUuNTctOC45Ni0xNC4wNS0yLjA1LTguNDgtMS4zNi0xNS45NCwxLjU1LTE2LjY2LDIuOS0uNzIsNi45MSw1LjU3LDguOTYsMTQuMDVaIiBzdHlsZT0iZmlsbDojMWMxYzFjOyIvPjxwYXRoIGQ9Ik0xMjcuODUsNjYuOWMtNC41My00LjgxLTEzLjU1LTMuNS0yMC4xNSwyLjkxLTYuNTksNi40MS04LjI2LDE1LjUtMy43MywyMC4zMSw0LjUzLDQuOCwxMy41NSwzLjUsMjAuMTUtMi45MXM4LjI2LTE1LjUsMy43My0yMC4zMVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTkxLjc5LDE0MC40N2MyLjktLjcyLDMuNDktOC42LDEuMzItMTcuNjEtMi4xNy05LTYuMjktMTUuNzEtOS4xOS0xNC45OS0yLjksLjcyLTMuNDksOC42LTEuMzIsMTcuNjEsMi4xNyw5LDYuMjksMTUuNzEsOS4xOSwxNC45OVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTYyLjIyLDcxLjNjOC4zNywyLjQ3LDE0LjQ4LDYuOCwxMy42Niw5LjY3LS44MywyLjg3LTguMjgsMy4yLTE2LjY1LC43My04LjM3LTIuNDctMTQuNDgtNi44LTEzLjY2LTkuNjcsLjgzLTIuODcsOC4yOC0zLjIsMTYuNjUtLjczWiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48cGF0aCBkPSJNMTE2LjU0LDEwMy43NGM4Ljg4LDIuNjIsMTUuNDEsNy4wNywxNC41OSw5Ljk0LS44MywyLjg3LTguNywzLjA4LTE3LjU4LC40Ni04Ljg4LTIuNjItMTUuNDEtNy4wNy0xNC41OS05Ljk0LC44My0yLjg3LDguNy0zLjA4LDE3LjU4LS40NloiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTcxLjY0LDk3LjcxYy0yLjA4LTIuMTUtOC44OCwuOTgtMTUuMiw2Ljk5LTYuMzIsNi4wMS05Ljc2LDEyLjYzLTcuNjksMTQuNzgsMi4wOCwyLjE1LDguODgtLjk4LDE1LjItNi45OSw2LjMyLTYuMDEsOS43Ni0xMi42Myw3LjY5LTE0Ljc4WiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48L3N2Zz4=", N$1 = { id: "pera", chain: "algorand", name: "Pera Wallet", icon: se, pkg: "@perawallet/connect" };
var P = class extends u {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let n, s = { shouldShowSignTxnToast: false };
        n = (t == null ? void 0 : t.config) || s;
        let a = await __vitePreload(() => import("./index-bc3d98d2.js").then((n2) => n2.i), true ? ["assets/index-bc3d98d2.js","assets/qr-code-styling-5f5f0e1c.js","assets/index-56481aea.js"] : void 0), I = a.PeraWalletConnect || a.default.PeraWalletConnect;
        e = new I(n);
      }
      return e = markRaw(e), new P({ sdk: e });
    } catch (e) {
      return console.error(`[${N$1.id}] Error initializing...`, e), null;
    }
  }
  async connect(t) {
    var _a2;
    let e = await this.sdk.connect();
    if ((_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e.length === 0)
      throw new Error(`No accounts found for ${N$1.id}`);
    let n = e.map((s, a) => ({ name: `Pera Wallet ${a + 1}`, address: s, walletId: N$1.id }));
    return { ...N$1, accounts: n };
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? { ...N$1, accounts: e.map((n, s) => ({ name: `Pera Wallet ${s + 1}`, address: n, walletId: N$1.id })) } : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let n = e.map((o) => decodeObj(o)), s = n.reduce((o, M, l) => (!("txn" in M) && t.includes(encodeAddress(M.snd)) ? o.push({ txn: decodeUnsignedTransaction(e[l]) }) : o.push({ txn: decodeSignedTransaction(e[l]).txn, signers: [] }), o), []), a = await this.sdk.signTransaction([s]);
    return n.reduce((o, M, l) => {
      if ("txn" in M)
        o.push(e[l]);
      else {
        let c = a.shift();
        c && o.push(c);
      }
      return o;
    }, []);
  }
}, x = P;
d(x, "PeraClient"), g(x, "metadata", N$1);
var Me = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA2MDAgNjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6IzE5MTkxOTt9Cgkuc3Qxe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxnPgoJPHBhdGggY2xhc3M9InN0MCIgZD0iTTQ2MCwwSDE0MEM2Mi43LDAsMCw2Mi43LDAsMTQwdjMyMGMwLDc3LjMsNjIuNywxNDAsMTQwLDE0MGg0Ny45TDMwMCw0ODcuOUw0MTIuMSw2MDBINDYwCgkJYzc3LjMsMCwxNDAtNjIuNywxNDAtMTQwVjE0MEM2MDAsNjIuNyw1MzcuMywwLDQ2MCwweiIvPgo8L2c+CjxnPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTc3LjEsMjM0Ljl2MTE0LjZINDEuNlYyMzQuOUg3Ny4xeiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTIwNi4yLDIzNC45djExNC42aC0zOC45bC0zMS4zLTU2LjhsLTcuMy0xNS41aC0wLjNsMC43LDIyLjZ2NDkuN0g5OC4yVjIzNC45SDEzN2wzMS4zLDU2LjhsNy41LDE1LjVoMC4yCgkJbC0wLjctMjIuNnYtNDkuN0gyMDYuMnoiLz4KCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMjk5LDM0OS41IDMzOS4xLDM0OS41IDI5OS41LDI4MC45IDMzNi4zLDIzNC45IDI5Ny45LDIzNC45IDI2Mi44LDI4MS43IDI2Mi44LDIzNC45IDIyNy40LDIzNC45IAoJCTIyNy40LDM0OS41IDI2Mi44LDM0OS41IDI2Mi44LDMxOC42IDI3NC41LDMwMy41IAkiLz4KCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0zNTAsMzQ5LjVWMjM0LjloOTIuNHYyNi42aC01Ni45VjI4MGg0NS41djI0LjdoLTQ1LjV2MTguMmg1OS4ydjI2LjZIMzUweiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTU2NiwyMzQuOWwtNDAuMSw3NHY0MC42aC0zNS42di00MC42bC00MC4zLTc0SDQ4NmwxMy45LDI4LjZsOC41LDIwbDguMy0yMGwxNC4xLTI4LjZINTY2eiIvPgo8L2c+Cjwvc3ZnPgo=", C = { id: "inkey", chain: "algorand", name: "Inkey Microwallet", icon: Me, pkg: "@thencc/inkey-client-js" };
var ge = d((i) => {
  if (typeof window == null)
    throw new Error("[inkey] cannot access window");
  for (var t = "", e = new Uint8Array(i), n = e.byteLength, s = 0; s < n; s++)
    t += String.fromCharCode(e[s]);
  return window.btoa(t);
}, "arrayBufferToBase64"), v = class extends u {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let n, s = { src: "https://inkey-staging.web.app", align: "center" };
        n = (t == null ? void 0 : t.config) || s;
        let a = await __vitePreload(() => import("./index.esm-c3f74de7.js"), true ? [] : void 0);
        e = await (a.createClient || a.default.createClient)(n);
      }
      return new v({ sdk: e });
    } catch (e) {
      return console.warn(`[${C.id}] Error initializing...`, e), null;
    }
  }
  async connect() {
    let t = await this.sdk.connect();
    if (!t)
      throw new Error("no inkeyAccounts");
    let e = t.map((s) => ({ address: s.address, name: s.username }));
    if (e.length === 0)
      throw new Error(`No accounts found for ${C.id}`);
    let n = e.map((s) => ({ name: s.name, address: s.address, walletId: C.id }));
    return { ...C, accounts: n };
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let n = e.map((l) => decodeObj(l)), a = n.reduce((l, c, w) => (!("txn" in c) && t.includes(encodeAddress(c.snd)) && l.push(e[w]), l), []).map((l) => ge(l)), I = await this.sdk.signTxns(a);
    if (!I.success)
      throw new Error("Error signing transactions");
    let o = I.signedTxns;
    return n.reduce((l, c, w) => {
      if ("txn" in c)
        l.push(e[w]);
      else {
        let T = o.shift();
        T && l.push(T);
      }
      return l;
    }, []);
  }
}, p = v;
d(p, "InkeyClient"), g(p, "metadata", C);
var we = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHBhdGggZmlsbD0iIzI0NUVDNiIgZD0iTTE2LDMyYy0zLjIsMC02LjItMC45LTguOS0yLjdjLTIuNi0xLjgtNC43LTQuMy01LjktNy4yQzAsMTkuMi0wLjMsMTYsMC4zLDEyLjlDMC45LDkuOCwyLjQsNyw0LjcsNC43IEM2LjIsMy4yLDcuOSwyLDkuOSwxLjJDMTEuOCwwLjQsMTMuOSwwLDE2LDBzNC4yLDAuNCw2LjEsMS4yYzEuOSwwLjgsMy43LDIsNS4yLDMuNXMyLjcsMy4zLDMuNSw1LjJjMC44LDEuOSwxLjIsNCwxLjIsNi4xIHMtMC40LDQuMi0xLjIsNi4xYy0wLjgsMS45LTIsMy43LTMuNSw1LjJjLTEuNSwxLjUtMy4yLDIuNy01LjIsMy41QzIwLjIsMzEuNiwxOC4xLDMyLDE2LDMyTDE2LDMyeiBNMjAuMiwxMS4ybDAuMSwwLjVsMi42LDkuNWgyLjEgTDIxLjUsOC45bC0wLjEtMC4zaC0xLjlsMCwwLjFsLTEuNywzLjFMMTYsMTQuOWwwLDAuMWwwLTAuMWwtMC4yLTAuOGwtMC42LTIuNGwtMC4xLTAuMmwtMC43LTIuNmwtMC4xLTAuM2gtMS45bDAsMC4xbC0xLjcsMy4xIGwtMS44LDMuMkw3LjEsMThsLTEuOCwzLjJoMi4xTDkuMiwxOGwxLjgtMy4ybDEuOC0zLjJsMC4zLTAuNWwwLjEsMC41bDAuNSwyLjFsMC43LDIuNmwwLjIsMC45TDE0LjIsMThsLTEuOCwzLjJoMi4xbDAuOC0xLjMgbDEuMy0yLjNsMS41LTIuN2wxLjgtMy4yTDIwLjIsMTEuMkwyMC4yLDExLjJ6Ii8+Cjwvc3ZnPgo=", E = { id: "myalgo", chain: "algorand", name: "MyAlgo", icon: we, pkg: "@randlabs/myalgo-connect" };
var J = class extends u {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let n, s = { disableLedgerNano: false };
        n = (t == null ? void 0 : t.config) || s;
        let a = await __vitePreload(() => Promise.resolve().then(() => index), true ? void 0 : void 0);
        window.Buffer || (window.Buffer = a.Buffer || a.default.Buffer);
        let o = (await __vitePreload(() => import("./index-c31e7e70.js").then((n2) => n2.i), true ? [] : void 0)).default;
        e = new o(n);
      }
      return e = markRaw(e), new J({ sdk: e });
    } catch (e) {
      return console.error(`[${E.id}] Error initializing...`, e), null;
    }
  }
  async connect() {
    let t = await this.sdk.connect();
    if (t.length === 0)
      throw new Error(`No accounts found for ${E.id}`);
    let e = t.map((n) => ({ ...n, walletId: E.id }));
    return { ...E, accounts: e };
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let n = e.map((o) => decodeObj(o)), s = n.reduce((o, M, l) => (!("txn" in M) && t.includes(encodeAddress(M.snd)) && o.push(e[l]), o), []), a = await this.sdk.signTransaction(s);
    return n.reduce((o, M, l) => {
      var _a2;
      if ("txn" in M)
        o.push(e[l]);
      else {
        let c = (_a2 = a.shift()) == null ? void 0 : _a2.blob;
        c && o.push(c);
      }
      return o;
    }, []);
  }
}, f = J;
d(f, "MyAlgoClient"), g(f, "metadata", E);
var Le = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjM4IiBoZWlnaHQ9IjIzOCIgdmlld0JveD0iMCAwIDIzOCAyMzgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01MS43MDUgMTQ1LjA0MkgxMTYuNzA1TDEwNy43MDUgMTU1LjA0Mkg1MS43MDVWMTQ1LjA0MloiIGZpbGw9IiNENjQ1MDAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNDcuNTE5IDE5MS41NTdMMTI5LjU3NyAxNDQuMzk0TDE0Mi40MDQgMTI3LjExMkwxNjcuODc1IDE5MS41NTdIMTQ3LjUxOVpNMTEwLjkzNiA5NS4zOTMyTDEyMC42MTMgMTIwLjgzMUwxMzMuMzU5IDEwNC4yMjhMMTE3LjQ3NSA2NC4wNDIyQzExNS45MjggNjAuMTI4IDExMi4xNDYgNTcuNTU2NSAxMDcuOTM4IDU3LjU1NjVDMTAzLjcyOSA1Ny41NTY1IDk5Ljk0NzQgNjAuMTI4IDk4LjQwMDMgNjQuMDQyMkw2Ny45NjU5IDE0MS4wNDJIODcuNzgwN0M5NS40MTUzIDEyMS4wMTEgMTAyLjg5MyAxMDEuMzk5IDEwNS4xOTggOTUuMzU0MUMxMDUuNjQxIDk0LjE5MTIgMTA2Ljc0MyA5My40NTk5IDEwNy45ODcgOTMuNDU5OUgxMDguMTMyQzEwOS4zNzggOTMuNDU5OSAxMTAuNDkzIDk0LjIyOTMgMTEwLjkzNiA5NS4zOTMyWk04MC45MjEgMTU5LjA0MkM3NC45Mjg5IDE3NC43NjggNjkuODY2MSAxODguMDYzIDY4LjU0NDcgMTkxLjU1N0g0OEw2MC44NTE0IDE1OS4wNDJIODAuOTIxWiIgZmlsbD0iIzIyMkI2MCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3Ni4wMjYgNTQuNzUwOUMxNzcuOTk3IDUyLjA4NzIgMTgxLjc1NCA1MS41MjU3IDE4NC40MTggNTMuNDk2N0MxODcuMDgyIDU1LjQ2NzggMTg3LjY0MyA1OS4yMjUxIDE4NS42NzIgNjEuODg4OEwxMzAuMDEzIDEzNy4xMDdDMTI5LjcxNCAxMzcuNTEyIDEyOS4zNDEgMTM3Ljg1NyAxMjguOTEzIDEzOC4xMjNMMTE3Ljg1NiAxNDUuMDEzQzExNy4wODcgMTQ1LjQ5MyAxMTYuMTI4IDE0NC43ODMgMTE2LjM2MSAxNDMuOTA3TDExOS43MTggMTMxLjMxOEMxMTkuODQ3IDEzMC44MzIgMTIwLjA2OCAxMzAuMzc0IDEyMC4zNjcgMTI5Ljk3TDE3MC42NyA2MS45ODlMMTY5LjkyOSA2MS40NDA1QzE2OS40ODUgNjEuMTEyIDE2OC44NTkgNjEuMjA1NiAxNjguNTMgNjEuNjQ5NkwxNTIuMzExIDgzLjU2ODhDMTUyLjU4NiA4NC4yMDIzIDE1Mi41MjQgODQuOTYxMiAxNTIuMDg0IDg1LjU1NjJMMTQ5LjExIDg5LjU3NTVDMTQ4LjQ1MyA5MC40NjM0IDE0Ny4yMDEgOTAuNjUwNiAxNDYuMzEzIDg5Ljk5MzZDMTQ1LjQyNSA4OS4zMzY2IDE0NS4yMzggODguMDg0MSAxNDUuODk1IDg3LjE5NjJMMTQ3LjY3OSA4NC43ODQ3TDE0OC44NjkgODMuMTc2OUwxNjcuMzA4IDU4LjI1NzRDMTY4LjYyMiA1Ni40ODE1IDE3MS4xMjcgNTYuMTA3MiAxNzIuOTAzIDU3LjQyMTJMMTczLjY0NCA1Ny45Njk3TDE3Ni4wMjYgNTQuNzUwOVoiIGZpbGw9IiNENjQ1MDAiLz4KPC9zdmc+Cg==", k$1 = { id: "algosigner", chain: "algorand", name: "AlgoSigner", icon: Le, pkg: "" };
var xe = d((i) => i === "betanet" ? "BetaNet" : i === "testnet" ? "TestNet" : i === "mainnet" ? "MainNet" : i, "getNetwork"), Q = class extends u {
  constructor({ sdk: t, network: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "network");
    this.sdk = t, this.network = e;
  }
  static async init(t) {
    var _a2;
    try {
      if (typeof window > "u" || window.AlgoSigner === void 0)
        throw new Error("AlgoSigner is not available.");
      let e = window.AlgoSigner, n = "mainnet";
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.network) && (t.config.network == "mainnet" || t.config.network == "testnet" || t.config.network == "betanet" ? n = t.config.network : console.warn(`invalid network in ${k$1.id} config`)), new Q({ sdk: e, network: n });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    await this.sdk.connect();
    let t = await this.sdk.accounts({ ledger: xe(this.network) });
    if (t.length === 0)
      throw new Error(`No accounts found for ${k$1.id}`);
    let e = t.map(({ address: n }, s) => ({ name: `AlgoSigner ${s + 1}`, address: n, walletId: k$1.id }));
    return { ...k$1, accounts: e };
  }
  async reconnect(t) {
    return (window === void 0 || window.AlgoSigner === void 0) && t(), null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let s = e.map((o) => decodeObj(o)).reduce((o, M, l) => {
      let c = { txn: this.sdk.encoding.msgpackToBase64(e[l]) };
      return ("txn" in M || !t.includes(encodeAddress(M.snd))) && (c.txn = this.sdk.encoding.msgpackToBase64(decodeSignedTransaction(e[l]).txn.toByte()), c.signers = []), o.push(c), o;
    }, []);
    return (await this.sdk.signTxn(s)).reduce((o, M, l) => (M ? o.push(new Uint8Array(buffer.Buffer.from(M.blob, "base64"))) : o.push(e[l]), o), []);
  }
}, z = Q;
d(z, "AlgoSignerClient"), g(z, "metadata", k$1);
var Ce$1 = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMDAgMzAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMDAgMzAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6dXJsKCNTVkdJRF8xXyk7fQoJLnN0MXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNDM0MjYxNjcxNDAxMDY1ODIyNzAwMDAwMDIxMzA3Njg5MDYwNzMxMTM0ODRfKTt9Cgkuc3Qye2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEwMjUxOTMxNjAxNTI3NjU4MTY0MDAwMDAxNjI3NDExMjM4MzE3NTY0MTc1OV8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTt9Cgkuc3Qze2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEzODU2MzM4MjQ2MjA4NjAyMDM1MDAwMDAxNDg3ODQ5MDI3MDc4MjA3MTIwN18pO30KCS5zdDR7bWFzazp1cmwoI21hc2swXzE2NjFfMjk1XzAwMDAwMDg4MTMyMjUxNTk3NDQxNTczNDkwMDAwMDExNjkzNjEyMDE4NTA2NjgxNDgxXyk7fQoJLnN0NXtmaWxsOnVybCgjU1ZHSURfMDAwMDAxMDYxMjA2MzI0NjE3OTI4NzExNjAwMDAwMDc0MzM5MTMwMzgzMzc3NjY1NzZfKTt9Cjwvc3R5bGU+CjxnPgoJCgkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDYuNjAzIiB5MT0iOS4yMjEyIiB4Mj0iMTc0LjE1OCIgeTI9IjMwOC41NDI2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xCgkJTDI3NC43LDkzLjl6Ii8+CgkKCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMjkuMzUxNiIgeTE9Ii0xOS4xNTczIiB4Mj0iNTYuOTA2NiIgeTI9IjI4MC4xNjQxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1Xyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCWw2OS4yLTQ1LjFWMjNMMjUuMyw5My45TDQzLDE1MC4xbC0xNy43LDU2LjJMMTMzLjcsMjc3di0zOS42bC02OS40LTQ1LjFMNzIuNSwxNjYuNHoiLz4KCTxkZWZzPgoJCTxmaWx0ZXIgaWQ9IkFkb2JlX09wYWNpdHlNYXNrRmlsdGVyIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ij4KCQkJPGZlQ29sb3JNYXRyaXggIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIxIDAgMCAwIDAgIDAgMSAwIDAgMCAgMCAwIDEgMCAwICAwIDAgMCAxIDAiLz4KCQk8L2ZpbHRlcj4KCTwvZGVmcz4KCQoJCTxtYXNrIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0IiBpZD0ibWFzazBfMTY2MV8yOTVfMDAwMDAwODgxMzIyNTE1OTc0NDE1NzM0OTAwMDAwMTE2OTM2MTIwMTg1MDY2ODE0ODFfIj4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjQ2LjYwMzgiIHkxPSI5LjIyMTQiIHgyPSIxNzQuMTU4OCIgeTI9IjMwOC41NDI4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwQjQ2RjkiLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JCRkJFMCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJPHBhdGggc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTsiIGQ9IgoJCQlNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xTDI3NC43LDkzLjl6Ii8+CgkJCgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMTk4MTE3MDc2MjE0NzI4MTQyNzAwMDAwMTA4Mjk2NTkzODM4NTEyMDI0OTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyOS4zNTIxIiB5MT0iLTE5LjE1NzEiIHgyPSI1Ni45MDcxIiB5Mj0iMjgwLjE2NDIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAzMDIpIj4KCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQkJGQkUwIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCQk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTE5ODExNzA3NjIxNDcyODE0MjcwMDAwMDEwODI5NjU5MzgzODUxMjAyNDkxXyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCQlsNjkuMi00NS4xVjIzTDI1LjMsOTMuOUw0MywxNTAuMWwtMTcuNyw1Ni4yTDEzMy43LDI3N3YtMzkuNmwtNjkuNC00NS4xTDcyLjUsMTY2LjR6Ii8+Cgk8L21hc2s+Cgk8ZyBjbGFzcz0ic3Q0Ij4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDEwOTAxOTkxODU1Nzc3MzA1MzQyMDAwMDAxNzYwMjQwNTkwODA2NzEyMDMwMF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDYuNDY2MiIgeTE9IjIyOC43NTU0IiB4Mj0iMTcxLjg2MzgiIHkyPSIxMzUuMTAzOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDMwMikiPgoJCQk8c3RvcCAgb2Zmc2V0PSIwLjExOTgiIHN0eWxlPSJzdG9wLWNvbG9yOiM4OTUyRkY7c3RvcC1vcGFjaXR5OjAuODciLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0RBQkRGRjtzdG9wLW9wYWNpdHk6MCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJCgkJCTxyZWN0IHg9IjI1LjQiIHk9IjIzIiBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTA5MDE5OTE4NTU3NzczMDUzNDIwMDAwMDE3NjAyNDA1OTA4MDY3MTIwMzAwXyk7IiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ii8+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", h = { id: "exodus", chain: "algorand", name: "Exodus", icon: Ce$1, pkg: "" };
var R = class extends u {
  constructor({ sdk: t, onlyIfTrusted: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "onlyIfTrusted");
    this.sdk = t, this.onlyIfTrusted = e;
  }
  static async init(t) {
    var _a2, _b;
    try {
      if (typeof window > "u" || window.exodus === void 0)
        throw new Error("Exodus is not available. Do you have the browser extension installed?");
      let e = window.exodus.algorand, n = false;
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.onlyIfTrusted) && (n = (_b = t == null ? void 0 : t.config) == null ? void 0 : _b.onlyIfTrusted), new R({ sdk: e, onlyIfTrusted: n });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    let t = "";
    try {
      let { address: n } = await window.exodus.algorand.connect({ onlyIfTrusted: this.onlyIfTrusted });
      t = n;
    } catch (n) {
      throw console.warn("err w exodus connect"), n;
    }
    if (!t)
      throw new Error(`No accounts found for ${h.id}`);
    let e = [{ name: "Exodus 1", address: t, walletId: h.id }];
    return { ...h, accounts: e };
  }
  async reconnect(t) {
    return (window === void 0 || window.exodus === void 0 || window.exodus.algorand.isConnected !== true) && t(), null;
  }
  async disconnect() {
    window.exodus.algorand.disconnect();
  }
  async signTransactions(t, e, n, s = true) {
    let a = e.map((c) => decodeObj(c)), I = [], o = a.reduce((c, w, T) => {
      let W5 = "txn" in w;
      return (n && n.length && n.includes(T) || !W5 && t.includes(encodeAddress(w.snd))) && (I.push(T), c.push(e[T])), c;
    }, []), M = await window.exodus.algorand.signTransaction(o);
    return e.reduce((c, w, T) => {
      if (I.includes(T)) {
        let W5 = M.shift();
        W5 && c.push(W5);
      } else
        s && c.push(e[T]);
      return c;
    }, []);
  }
}, S = R;
d(S, "ExodusClient"), g(S, "metadata", h);
var fe = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiLz4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNjgyMDksMCwwLDEuNjgyMDksMjI2LjM2OCwyMTIuODE4KSI+CiAgICAgICAgPHBhdGggZD0iTTMyNy4wNDksMjgwLjE5MkwxNjkuNTI0LDEzTDEyLDI4MC4xOTJMMTY5LjUyNCwxODkuMDg0TDMyNy4wNDksMjgwLjE5MloiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvOyIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS42ODIwOSwwLDAsMS42ODIwOSwyMjYuMzY4LDIxMi44MTgpIj4KICAgICAgICA8cGF0aCBkPSJNMjk5LjU0NiwzMDdMMTY5LjUyNSwyMzguNDczTDM5LjUwNCwzMDdMMTY5LjUyNSwyNjQuNjdMMjk5LjU0NiwzMDdaIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybzsiLz4KICAgIDwvZz4KPC9zdmc+Cg==", y = { id: "defly", chain: "algorand", name: "Defly", icon: fe, pkg: "@blockshake/defly-connect" };
var B = class extends u {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let n, s = { shouldShowSignTxnToast: false };
        n = (t == null ? void 0 : t.config) || s;
        let a = await __vitePreload(() => import("./index-e562a58f.js").then((n2) => n2.i), true ? ["assets/index-e562a58f.js","assets/qr-code-styling-5f5f0e1c.js","assets/lottie-3dd57f71.js"] : void 0), I = a.DeflyWalletConnect || a.default.DeflyWalletConnect;
        e = new I(n);
      }
      return new B({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect(t) {
    let e = await this.sdk.connect().catch(console.info);
    if (this.sdk.connector.on("disconnect", t), !e || e.length === 0)
      throw new Error(`No accounts found for ${y.id}`);
    let n = e.map((s, a) => ({ name: `Defly Wallet ${a + 1}`, address: s, walletId: y.id }));
    return { ...y, accounts: n };
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? { ...y, accounts: e.map((n, s) => ({ name: `Defly Wallet ${s + 1}`, address: n, walletId: y.id })) } : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let n = e.map((o) => decodeObj(o)), s = n.reduce((o, M, l) => (!("txn" in M) && t.includes(encodeAddress(M.snd)) ? o.push({ txn: decodeUnsignedTransaction(e[l]) }) : o.push({ txn: decodeSignedTransaction(e[l]).txn, signers: [] }), o), []), a = await this.sdk.signTransaction([s]);
    return n.reduce((o, M, l) => {
      if ("txn" in M)
        o.push(e[l]);
      else {
        let c = a.shift();
        c && o.push(c);
      }
      return o;
    }, []);
  }
}, O = B;
d(O, "DeflyClient"), g(O, "metadata", y);
var be = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e %3c!-- Generated by Pixelmator Pro 3.2.2 --%3e %3csvg width='409' height='210' viewBox='0 0 409 210' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctext id='MNEMONIC' xml:space='preserve' x='0' y='129' font-family='Helvetica' font-size='72' fill='black'%3eMNEMONIC%3c/text%3e%3c/svg%3e", U$1 = { id: "mnemonic", name: "Mnemonic", icon: be, chain: "algorand", pkg: "" };
var H = class extends u {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else if (t && t.config && t.config.mnemonic) {
        let n = t.config.mnemonic;
        e = mnemonicToSecretKey(n);
      }
      return new H({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    if (this.sdk == null) {
      let t = await this.requestMnemonic();
      if (!t)
        throw this.sdk = void 0, new Error("Mnemonic passphrase is required");
      let e = mnemonicToSecretKey(t);
      this.sdk = e;
    }
    return { ...U$1, accounts: [{ name: "Mnemonic Wallet 1", address: this.sdk.addr, walletId: U$1.id }] };
  }
  async disconnect() {
    this.sdk = void 0;
  }
  async reconnect() {
    return null;
  }
  async requestMnemonic() {
    if (j()) {
      let t = prompt("Enter mnemonic passphrase (25 words)");
      return t || "";
    } else
      throw new Error("Not used in a browser");
  }
  async signTransactions(t, e, n, s = true) {
    if (this.sdk || await this.connect(), !this.sdk)
      throw new Error("Client could not init");
    let a = e.map((c) => decodeObj(c)), I = [], o = [];
    for (let c in a) {
      let w = a[c], T = "txn" in w;
      if (I.push(e[c]), T)
        continue;
      if (n && n.length && !n.includes(Number(c)))
        continue;
      if (!t.includes(encodeAddress(w.snd)))
        continue;
      I[c] = new Uint8Array();
      let ie = Transaction$1.from_obj_for_encoding(w).signTxn(this.sdk.sk);
      o.push(ie);
    }
    let M = 0, l = I.reduce((c, w, T) => (w.length === 0 ? (c.push(o[M]), M += 1) : s && c.push(w), c), []);
    return Promise.resolve(l);
  }
}, b$1 = H;
d(b$1, "MnemonicClient"), g(b$1, "metadata", U$1);
var A = { ["pera"]: { client: x }, ["inkey"]: { client: p }, ["myalgo"]: { client: f }, ["algosigner"]: { client: z }, ["exodus"]: { client: S }, ["defly"]: { client: O }, ["mnemonic"]: { client: b$1 } };
Object.values(A).map((i) => i.client.metadata.id);
Object.values(A).map((i) => i.client.metadata.pkg).filter((i) => i !== "");
d((i) => {
  let t = [];
  for (let e of i)
    t.push(A[e].client.metadata.pkg);
  return t;
}, "excludeClients");
var L = d((i, t = true) => {
  let e = reactive({ id: i, metadata: A[i].client.metadata, client: null, initParams: t, inited: false, initing: false, signing: false, connecting: false, isReady: async () => (e.inited || (e.initing = true, typeof e.initParams == "object" && (e.initParams.config || e.initParams.sdk) ? e.client = await A[i].client.init(e.initParams) : t == true ? e.client = await A[i].client.init() : console.warn("bad/incomplete init params for wallet:", i), e.initing = false, e.inited = true), true), connect: async () => {
    e.connecting = true;
    try {
      await e.isReady();
      let { accounts: n } = await e.client.connect(() => {
      });
      return Ge(n), Ye(n[0]), n;
    } catch (n) {
      throw n;
    } finally {
      e.connecting = false;
    }
  }, disconnect: async () => {
    ee(i), await e.isReady();
    try {
      await e.client.disconnect();
    } catch (n) {
      console.warn(n);
    }
  }, reconnect: async () => {
    await e.isReady(), await e.client.reconnect(() => {
    });
  }, setAsActiveWallet: () => {
    let n = q(i);
    if (n)
      r.stored.activeAccount = n[0];
    else
      throw new Error("No accounts for this provider to set as active");
  }, removeAccounts: () => {
    ee(i);
  }, signTransactions: async (n) => {
    await e.isReady();
    let s = e.accounts.map((a) => a.address);
    s.length || (s = (await e.connect()).map((I) => I.address), await new Promise((I) => setTimeout(I, 1e3))), e.signing = true;
    try {
      return await e.client.signTransactions(s, n);
    } catch (a) {
      throw a;
    } finally {
      e.signing = false;
    }
  }, get accounts() {
    return readonly(computed$1(() => q(i)));
  }, get isActive() {
    return computed$1(() => {
      var _a2;
      return ((_a2 = r.stored.activeAccount) == null ? void 0 : _a2.walletId) === i;
    });
  }, get isConnected() {
    return readonly(computed$1(() => r.stored.connectedAccounts.some((n) => n.walletId === i)));
  } });
  return e;
}, "createWallet"), yn$1 = d((i = te) => {
  var _a2, _b;
  r.enabledWallets == null && (r.enabledWallets = {});
  for (let [e, n] of Object.entries(i)) {
    let s = e;
    r.allWallets[s].initParams = n, r.enabledWallets[s] = r.allWallets[s];
  }
  let t = (_a2 = r.stored.activeAccount) == null ? void 0 : _a2.walletId;
  return t && (new Set(Object.keys(i)).has(t) || ((_b = r.allWallets[t]) == null ? void 0 : _b.disconnect())), r.enabledWallets;
}, "enableWallets"), q = d((i) => r.stored.connectedAccounts.filter((t) => t.walletId === i), "getAccountsByWalletId"), ee = d((i) => {
  if (r.stored.activeAccount) {
    let e = r.stored.connectedAccounts.filter((n) => n.walletId == i);
    for (let n of e)
      if (n.address == r.stored.activeAccount.address && n.walletId == r.stored.activeAccount.walletId) {
        r.stored.activeAccount = null;
        break;
      }
  }
  let t = r.stored.connectedAccounts.filter((e) => e.walletId !== i);
  r.stored.connectedAccounts = t;
}, "removeAccountsByWalletId"), Ge = d((i) => {
  for (let t of i) {
    let e = false;
    for (let n of r.stored.connectedAccounts)
      t.walletId == n.walletId && t.address == n.address && (e = true);
    e || r.stored.connectedAccounts.push(t);
  }
}, "addConnectedAccounts"), Ye = d((i) => {
  r.stored.activeAccount = i;
}, "setAsActiveAccount"), An$1 = d(async (i) => {
  if (!r.enabledWallets)
    throw new Error("No wallets enabled, call enableWallets() first");
  let t = Object.keys(r.enabledWallets), e = r.activeWalletId;
  if (t.length == 1 && (e = t[0]), !e)
    throw new Error("No active wallet id");
  let n = r.enabledWallets[e];
  if (!n)
    throw new Error("No active wallet... how'd you get here.");
  return await n.signTransactions(i);
}, "signTransactions");
var D = ((o) => (o.PERA = "pera", o.INKEY = "inkey", o.MYALGO = "myalgo", o.ALGOSIGNER = "algosigner", o.EXODUS = "exodus", o.DEFLY = "defly", o.MNEMONIC = "mnemonic", o))(D || {}), te = { ["pera"]: true, ["inkey"]: true, ["myalgo"]: true, ["algosigner"]: true, ["exodus"]: true, ["defly"]: true }, ne = { ["pera"]: L("pera"), ["inkey"]: L("inkey"), ["myalgo"]: L("myalgo"), ["algosigner"]: L("algosigner"), ["exodus"]: L("exodus"), ["defly"]: L("defly"), ["mnemonic"]: L("mnemonic") };
var r = reactive({ allWallets: ne, enabledWallets: null, stored: { version: 0, connectedAccounts: [], activeAccount: null }, activeAddress: readonly(computed$1(() => {
  let i = "";
  return r.stored.activeAccount && (i = r.stored.activeAccount.address), i;
})), activeWalletId: readonly(computed$1(() => {
  let i = null;
  return r.stored.activeAccount && (i = r.stored.activeAccount.walletId), i;
})), activeWallet: readonly(computed$1(() => {
  let i;
  return r.activeWalletId !== null && r.enabledWallets !== null && (i = r.enabledWallets[r.activeWalletId]), i;
})), isSigning: readonly(computed$1(() => {
  let i = false;
  if (r.enabledWallets) {
    for (let [t, e] of Object.entries(r.enabledWallets))
      if (e.signing) {
        i = true;
        break;
      }
  }
  return i;
})) });
j() && K();
var Ur$1 = Object.create;
var X = Object.defineProperty;
var Tr = Object.getOwnPropertyDescriptor;
var Ir = Object.getOwnPropertyNames;
var dr$1 = Object.getPrototypeOf, Cr$1 = Object.prototype.hasOwnProperty;
var pt = ((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, { get: (r3, t) => (typeof require != "undefined" ? require : r3)[t] }) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var Lr = (e, r3) => () => (e && (r3 = e(e = 0)), r3);
var k = (e, r3) => () => (r3 || e((r3 = { exports: {} }).exports, r3), r3.exports), ct$1 = (e, r3) => {
  for (var t in r3)
    X(e, t, { get: r3[t], enumerable: true });
}, Sr = (e, r3, t, i) => {
  if (r3 && typeof r3 == "object" || typeof r3 == "function")
    for (let n of Ir(r3))
      !Cr$1.call(e, n) && n !== t && X(e, n, { get: () => r3[n], enumerable: !(i = Tr(r3, n)) || i.enumerable });
  return e;
};
var rr = (e, r3, t) => (t = e != null ? Ur$1(dr$1(e)) : {}, Sr(r3 || !e || !e.__esModule ? X(t, "default", { value: e, enumerable: true }) : t, e));
var ur = k((st, nr2) => {
  U();
  var s = nr2.exports = {}, F2, g5;
  function G() {
    throw new Error("setTimeout has not been defined");
  }
  function z2() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? F2 = setTimeout : F2 = G;
    } catch {
      F2 = G;
    }
    try {
      typeof clearTimeout == "function" ? g5 = clearTimeout : g5 = z2;
    } catch {
      g5 = z2;
    }
  })();
  function tr(e) {
    if (F2 === setTimeout)
      return setTimeout(e, 0);
    if ((F2 === G || !F2) && setTimeout)
      return F2 = setTimeout, setTimeout(e, 0);
    try {
      return F2(e, 0);
    } catch {
      try {
        return F2.call(null, e, 0);
      } catch {
        return F2.call(this, e, 0);
      }
    }
  }
  function Rr2(e) {
    if (g5 === clearTimeout)
      return clearTimeout(e);
    if ((g5 === z2 || !g5) && clearTimeout)
      return g5 = clearTimeout, clearTimeout(e);
    try {
      return g5(e);
    } catch {
      try {
        return g5.call(null, e);
      } catch {
        return g5.call(this, e);
      }
    }
  }
  var v2 = [], R5 = false, d2, D2 = -1;
  function _r() {
    !R5 || !d2 || (R5 = false, d2.length ? v2 = d2.concat(v2) : D2 = -1, v2.length && er());
  }
  function er() {
    if (!R5) {
      var e = tr(_r);
      R5 = true;
      for (var r3 = v2.length; r3; ) {
        for (d2 = v2, v2 = []; ++D2 < r3; )
          d2 && d2[D2].run();
        D2 = -1, r3 = v2.length;
      }
      d2 = null, R5 = false, Rr2(e);
    }
  }
  s.nextTick = function(e) {
    var r3 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var t = 1; t < arguments.length; t++)
        r3[t - 1] = arguments[t];
    v2.push(new ir(e, r3)), v2.length === 1 && !R5 && tr(er);
  };
  function ir(e, r3) {
    this.fun = e, this.array = r3;
  }
  ir.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  s.title = "browser";
  s.browser = true;
  s.env = {};
  s.argv = [];
  s.version = "";
  s.versions = {};
  function T() {
  }
  s.on = T;
  s.addListener = T;
  s.once = T;
  s.off = T;
  s.removeListener = T;
  s.removeAllListeners = T;
  s.emit = T;
  s.prependListener = T;
  s.prependOnceListener = T;
  s.listeners = function(e) {
    return [];
  };
  s.binding = function(e) {
    throw new Error("process.binding is not supported");
  };
  s.cwd = function() {
    return "/";
  };
  s.chdir = function(e) {
    throw new Error("process.chdir is not supported");
  };
  s.umask = function() {
    return 0;
  };
});
var b, W, Mr, N, U = Lr(() => {
  b = rr(or()), W = rr(ur()), Mr = function(e) {
    function r3() {
      var i = this || self;
      return delete e.prototype.__magic__, i;
    }
    if (typeof globalThis == "object")
      return globalThis;
    if (this)
      return r3();
    e.defineProperty(e.prototype, "__magic__", { configurable: true, get: r3 });
    var t = __magic__;
    return t;
  }(Object), N = Mr;
});
var fr = k((Y) => {
  U();
  Y.byteLength = Dr;
  Y.toByteArray = Nr2;
  Y.fromByteArray = qr;
  var B2 = [], m2 = [], kr2 = typeof Uint8Array < "u" ? Uint8Array : Array, J5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (C2 = 0, ar2 = J5.length; C2 < ar2; ++C2)
    B2[C2] = J5[C2], m2[J5.charCodeAt(C2)] = C2;
  var C2, ar2;
  m2["-".charCodeAt(0)] = 62;
  m2["_".charCodeAt(0)] = 63;
  function hr2(e) {
    var r3 = e.length;
    if (r3 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t = e.indexOf("=");
    t === -1 && (t = r3);
    var i = t === r3 ? 0 : 4 - t % 4;
    return [t, i];
  }
  function Dr(e) {
    var r3 = hr2(e), t = r3[0], i = r3[1];
    return (t + i) * 3 / 4 - i;
  }
  function br(e, r3, t) {
    return (r3 + t) * 3 / 4 - t;
  }
  function Nr2(e) {
    var r3, t = hr2(e), i = t[0], n = t[1], u3 = new kr2(br(e, i, n)), o = 0, h2 = n > 0 ? i - 4 : i, f2;
    for (f2 = 0; f2 < h2; f2 += 4)
      r3 = m2[e.charCodeAt(f2)] << 18 | m2[e.charCodeAt(f2 + 1)] << 12 | m2[e.charCodeAt(f2 + 2)] << 6 | m2[e.charCodeAt(f2 + 3)], u3[o++] = r3 >> 16 & 255, u3[o++] = r3 >> 8 & 255, u3[o++] = r3 & 255;
    return n === 2 && (r3 = m2[e.charCodeAt(f2)] << 2 | m2[e.charCodeAt(f2 + 1)] >> 4, u3[o++] = r3 & 255), n === 1 && (r3 = m2[e.charCodeAt(f2)] << 10 | m2[e.charCodeAt(f2 + 1)] << 4 | m2[e.charCodeAt(f2 + 2)] >> 2, u3[o++] = r3 >> 8 & 255, u3[o++] = r3 & 255), u3;
  }
  function Wr(e) {
    return B2[e >> 18 & 63] + B2[e >> 12 & 63] + B2[e >> 6 & 63] + B2[e & 63];
  }
  function Yr(e, r3, t) {
    for (var i, n = [], u3 = r3; u3 < t; u3 += 3)
      i = (e[u3] << 16 & 16711680) + (e[u3 + 1] << 8 & 65280) + (e[u3 + 2] & 255), n.push(Wr(i));
    return n.join("");
  }
  function qr(e) {
    for (var r3, t = e.length, i = t % 3, n = [], u3 = 16383, o = 0, h2 = t - i; o < h2; o += u3)
      n.push(Yr(e, o, o + u3 > h2 ? h2 : o + u3));
    return i === 1 ? (r3 = e[t - 1], n.push(B2[r3 >> 2] + B2[r3 << 4 & 63] + "==")) : i === 2 && (r3 = (e[t - 2] << 8) + e[t - 1], n.push(B2[r3 >> 10] + B2[r3 >> 4 & 63] + B2[r3 << 2 & 63] + "=")), n.join("");
  }
});
var pr = k((Q2) => {
  U();
  Q2.read = function(e, r3, t, i, n) {
    var u3, o, h2 = n * 8 - i - 1, f2 = (1 << h2) - 1, c = f2 >> 1, l = -7, p2 = t ? n - 1 : 0, E2 = t ? -1 : 1, x2 = e[r3 + p2];
    for (p2 += E2, u3 = x2 & (1 << -l) - 1, x2 >>= -l, l += h2; l > 0; u3 = u3 * 256 + e[r3 + p2], p2 += E2, l -= 8)
      ;
    for (o = u3 & (1 << -l) - 1, u3 >>= -l, l += i; l > 0; o = o * 256 + e[r3 + p2], p2 += E2, l -= 8)
      ;
    if (u3 === 0)
      u3 = 1 - c;
    else {
      if (u3 === f2)
        return o ? NaN : (x2 ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, i), u3 = u3 - c;
    }
    return (x2 ? -1 : 1) * o * Math.pow(2, u3 - i);
  };
  Q2.write = function(e, r3, t, i, n, u3) {
    var o, h2, f2, c = u3 * 8 - n - 1, l = (1 << c) - 1, p2 = l >> 1, E2 = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x2 = i ? 0 : u3 - 1, S2 = i ? 1 : -1, vr = r3 < 0 || r3 === 0 && 1 / r3 < 0 ? 1 : 0;
    for (r3 = Math.abs(r3), isNaN(r3) || r3 === 1 / 0 ? (h2 = isNaN(r3) ? 1 : 0, o = l) : (o = Math.floor(Math.log(r3) / Math.LN2), r3 * (f2 = Math.pow(2, -o)) < 1 && (o--, f2 *= 2), o + p2 >= 1 ? r3 += E2 / f2 : r3 += E2 * Math.pow(2, 1 - p2), r3 * f2 >= 2 && (o++, f2 /= 2), o + p2 >= l ? (h2 = 0, o = l) : o + p2 >= 1 ? (h2 = (r3 * f2 - 1) * Math.pow(2, n), o = o + p2) : (h2 = r3 * Math.pow(2, p2 - 1) * Math.pow(2, n), o = 0)); n >= 8; e[t + x2] = h2 & 255, x2 += S2, h2 /= 256, n -= 8)
      ;
    for (o = o << n | h2, c += n; c > 0; e[t + x2] = o & 255, x2 += S2, o /= 256, c -= 8)
      ;
    e[t + x2 - S2] |= vr * 128;
  };
});
var or = k((M) => {
  U();
  var V = fr(), _ = pr(), cr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  M.Buffer = a;
  M.SlowBuffer = Qr;
  M.INSPECT_MAX_BYTES = 50;
  var q2 = 2147483647;
  M.kMaxLength = q2;
  a.TYPED_ARRAY_SUPPORT = Hr2();
  !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Hr2() {
    try {
      var e = new Uint8Array(1), r3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r3, Uint8Array.prototype), Object.setPrototypeOf(e, r3), e.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a.prototype, "parent", { enumerable: true, get: function() {
    if (!!a.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(a.prototype, "offset", { enumerable: true, get: function() {
    if (!!a.isBuffer(this))
      return this.byteOffset;
  } });
  function I(e) {
    if (e > q2)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
    var r3 = new Uint8Array(e);
    return Object.setPrototypeOf(r3, a.prototype), r3;
  }
  function a(e, r3, t) {
    if (typeof e == "number") {
      if (typeof r3 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return $(e);
    }
    return wr(e, r3, t);
  }
  a.poolSize = 8192;
  function wr(e, r3, t) {
    if (typeof e == "string")
      return Gr(e, r3);
    if (ArrayBuffer.isView(e))
      return zr2(e);
    if (e == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    if (A2(e, ArrayBuffer) || e && A2(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (A2(e, SharedArrayBuffer) || e && A2(e.buffer, SharedArrayBuffer)))
      return O2(e, r3, t);
    if (typeof e == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var i = e.valueOf && e.valueOf();
    if (i != null && i !== e)
      return a.from(i, r3, t);
    var n = Jr(e);
    if (n)
      return n;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
      return a.from(e[Symbol.toPrimitive]("string"), r3, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
  }
  a.from = function(e, r3, t) {
    return wr(e, r3, t);
  };
  Object.setPrototypeOf(a.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(a, Uint8Array);
  function yr(e) {
    if (typeof e != "number")
      throw new TypeError('"size" argument must be of type number');
    if (e < 0)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
  }
  function Xr(e, r3, t) {
    return yr(e), e <= 0 ? I(e) : r3 !== void 0 ? typeof t == "string" ? I(e).fill(r3, t) : I(e).fill(r3) : I(e);
  }
  a.alloc = function(e, r3, t) {
    return Xr(e, r3, t);
  };
  function $(e) {
    return yr(e), I(e < 0 ? 0 : P5(e) | 0);
  }
  a.allocUnsafe = function(e) {
    return $(e);
  };
  a.allocUnsafeSlow = function(e) {
    return $(e);
  };
  function Gr(e, r3) {
    if ((typeof r3 != "string" || r3 === "") && (r3 = "utf8"), !a.isEncoding(r3))
      throw new TypeError("Unknown encoding: " + r3);
    var t = xr(e, r3) | 0, i = I(t), n = i.write(e, r3);
    return n !== t && (i = i.slice(0, n)), i;
  }
  function K5(e) {
    for (var r3 = e.length < 0 ? 0 : P5(e.length) | 0, t = I(r3), i = 0; i < r3; i += 1)
      t[i] = e[i] & 255;
    return t;
  }
  function zr2(e) {
    if (A2(e, Uint8Array)) {
      var r3 = new Uint8Array(e);
      return O2(r3.buffer, r3.byteOffset, r3.byteLength);
    }
    return K5(e);
  }
  function O2(e, r3, t) {
    if (r3 < 0 || e.byteLength < r3)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (e.byteLength < r3 + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var i;
    return r3 === void 0 && t === void 0 ? i = new Uint8Array(e) : t === void 0 ? i = new Uint8Array(e, r3) : i = new Uint8Array(e, r3, t), Object.setPrototypeOf(i, a.prototype), i;
  }
  function Jr(e) {
    if (a.isBuffer(e)) {
      var r3 = P5(e.length) | 0, t = I(r3);
      return t.length === 0 || e.copy(t, 0, 0, r3), t;
    }
    if (e.length !== void 0)
      return typeof e.length != "number" || j2(e.length) ? I(0) : K5(e);
    if (e.type === "Buffer" && Array.isArray(e.data))
      return K5(e.data);
  }
  function P5(e) {
    if (e >= q2)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + q2.toString(16) + " bytes");
    return e | 0;
  }
  function Qr(e) {
    return +e != e && (e = 0), a.alloc(+e);
  }
  a.isBuffer = function(r3) {
    return r3 != null && r3._isBuffer === true && r3 !== a.prototype;
  };
  a.compare = function(r3, t) {
    if (A2(r3, Uint8Array) && (r3 = a.from(r3, r3.offset, r3.byteLength)), A2(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), !a.isBuffer(r3) || !a.isBuffer(t))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (r3 === t)
      return 0;
    for (var i = r3.length, n = t.length, u3 = 0, o = Math.min(i, n); u3 < o; ++u3)
      if (r3[u3] !== t[u3]) {
        i = r3[u3], n = t[u3];
        break;
      }
    return i < n ? -1 : n < i ? 1 : 0;
  };
  a.isEncoding = function(r3) {
    switch (String(r3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  a.concat = function(r3, t) {
    if (!Array.isArray(r3))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r3.length === 0)
      return a.alloc(0);
    var i;
    if (t === void 0)
      for (t = 0, i = 0; i < r3.length; ++i)
        t += r3[i].length;
    var n = a.allocUnsafe(t), u3 = 0;
    for (i = 0; i < r3.length; ++i) {
      var o = r3[i];
      if (A2(o, Uint8Array))
        u3 + o.length > n.length ? a.from(o).copy(n, u3) : Uint8Array.prototype.set.call(n, o, u3);
      else if (a.isBuffer(o))
        o.copy(n, u3);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      u3 += o.length;
    }
    return n;
  };
  function xr(e, r3) {
    if (a.isBuffer(e))
      return e.length;
    if (ArrayBuffer.isView(e) || A2(e, ArrayBuffer))
      return e.byteLength;
    if (typeof e != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
    var t = e.length, i = arguments.length > 2 && arguments[2] === true;
    if (!i && t === 0)
      return 0;
    for (var n = false; ; )
      switch (r3) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return Z(e).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return Ar(e).length;
        default:
          if (n)
            return i ? -1 : Z(e).length;
          r3 = ("" + r3).toLowerCase(), n = true;
      }
  }
  a.byteLength = xr;
  function Vr(e, r3, t) {
    var i = false;
    if ((r3 === void 0 || r3 < 0) && (r3 = 0), r3 > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r3 >>>= 0, t <= r3))
      return "";
    for (e || (e = "utf8"); ; )
      switch (e) {
        case "hex":
          return it(this, r3, t);
        case "utf8":
        case "utf-8":
          return Er(this, r3, t);
        case "ascii":
          return tt(this, r3, t);
        case "latin1":
        case "binary":
          return et(this, r3, t);
        case "base64":
          return jr(this, r3, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return nt(this, r3, t);
        default:
          if (i)
            throw new TypeError("Unknown encoding: " + e);
          e = (e + "").toLowerCase(), i = true;
      }
  }
  a.prototype._isBuffer = true;
  function L2(e, r3, t) {
    var i = e[r3];
    e[r3] = e[t], e[t] = i;
  }
  a.prototype.swap16 = function() {
    var r3 = this.length;
    if (r3 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t = 0; t < r3; t += 2)
      L2(this, t, t + 1);
    return this;
  };
  a.prototype.swap32 = function() {
    var r3 = this.length;
    if (r3 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t = 0; t < r3; t += 4)
      L2(this, t, t + 3), L2(this, t + 1, t + 2);
    return this;
  };
  a.prototype.swap64 = function() {
    var r3 = this.length;
    if (r3 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t = 0; t < r3; t += 8)
      L2(this, t, t + 7), L2(this, t + 1, t + 6), L2(this, t + 2, t + 5), L2(this, t + 3, t + 4);
    return this;
  };
  a.prototype.toString = function() {
    var r3 = this.length;
    return r3 === 0 ? "" : arguments.length === 0 ? Er(this, 0, r3) : Vr.apply(this, arguments);
  };
  a.prototype.toLocaleString = a.prototype.toString;
  a.prototype.equals = function(r3) {
    if (!a.isBuffer(r3))
      throw new TypeError("Argument must be a Buffer");
    return this === r3 ? true : a.compare(this, r3) === 0;
  };
  a.prototype.inspect = function() {
    var r3 = "", t = M.INSPECT_MAX_BYTES;
    return r3 = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r3 += " ... "), "<Buffer " + r3 + ">";
  };
  cr && (a.prototype[cr] = a.prototype.inspect);
  a.prototype.compare = function(r3, t, i, n, u3) {
    if (A2(r3, Uint8Array) && (r3 = a.from(r3, r3.offset, r3.byteLength)), !a.isBuffer(r3))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r3);
    if (t === void 0 && (t = 0), i === void 0 && (i = r3 ? r3.length : 0), n === void 0 && (n = 0), u3 === void 0 && (u3 = this.length), t < 0 || i > r3.length || n < 0 || u3 > this.length)
      throw new RangeError("out of range index");
    if (n >= u3 && t >= i)
      return 0;
    if (n >= u3)
      return -1;
    if (t >= i)
      return 1;
    if (t >>>= 0, i >>>= 0, n >>>= 0, u3 >>>= 0, this === r3)
      return 0;
    for (var o = u3 - n, h2 = i - t, f2 = Math.min(o, h2), c = this.slice(n, u3), l = r3.slice(t, i), p2 = 0; p2 < f2; ++p2)
      if (c[p2] !== l[p2]) {
        o = c[p2], h2 = l[p2];
        break;
      }
    return o < h2 ? -1 : h2 < o ? 1 : 0;
  };
  function mr(e, r3, t, i, n) {
    if (e.length === 0)
      return -1;
    if (typeof t == "string" ? (i = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, j2(t) && (t = n ? 0 : e.length - 1), t < 0 && (t = e.length + t), t >= e.length) {
      if (n)
        return -1;
      t = e.length - 1;
    } else if (t < 0)
      if (n)
        t = 0;
      else
        return -1;
    if (typeof r3 == "string" && (r3 = a.from(r3, i)), a.isBuffer(r3))
      return r3.length === 0 ? -1 : lr2(e, r3, t, i, n);
    if (typeof r3 == "number")
      return r3 = r3 & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(e, r3, t) : Uint8Array.prototype.lastIndexOf.call(e, r3, t) : lr2(e, [r3], t, i, n);
    throw new TypeError("val must be string, number or Buffer");
  }
  function lr2(e, r3, t, i, n) {
    var u3 = 1, o = e.length, h2 = r3.length;
    if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
      if (e.length < 2 || r3.length < 2)
        return -1;
      u3 = 2, o /= 2, h2 /= 2, t /= 2;
    }
    function f2(x2, S2) {
      return u3 === 1 ? x2[S2] : x2.readUInt16BE(S2 * u3);
    }
    var c;
    if (n) {
      var l = -1;
      for (c = t; c < o; c++)
        if (f2(e, c) === f2(r3, l === -1 ? 0 : c - l)) {
          if (l === -1 && (l = c), c - l + 1 === h2)
            return l * u3;
        } else
          l !== -1 && (c -= c - l), l = -1;
    } else
      for (t + h2 > o && (t = o - h2), c = t; c >= 0; c--) {
        for (var p2 = true, E2 = 0; E2 < h2; E2++)
          if (f2(e, c + E2) !== f2(r3, E2)) {
            p2 = false;
            break;
          }
        if (p2)
          return c;
      }
    return -1;
  }
  a.prototype.includes = function(r3, t, i) {
    return this.indexOf(r3, t, i) !== -1;
  };
  a.prototype.indexOf = function(r3, t, i) {
    return mr(this, r3, t, i, true);
  };
  a.prototype.lastIndexOf = function(r3, t, i) {
    return mr(this, r3, t, i, false);
  };
  function Kr(e, r3, t, i) {
    t = Number(t) || 0;
    var n = e.length - t;
    i ? (i = Number(i), i > n && (i = n)) : i = n;
    var u3 = r3.length;
    i > u3 / 2 && (i = u3 / 2);
    for (var o = 0; o < i; ++o) {
      var h2 = parseInt(r3.substr(o * 2, 2), 16);
      if (j2(h2))
        return o;
      e[t + o] = h2;
    }
    return o;
  }
  function Or2(e, r3, t, i) {
    return H5(Z(r3, e.length - t), e, t, i);
  }
  function Zr(e, r3, t, i) {
    return H5(at(r3), e, t, i);
  }
  function $r2(e, r3, t, i) {
    return H5(Ar(r3), e, t, i);
  }
  function Pr(e, r3, t, i) {
    return H5(ht(r3, e.length - t), e, t, i);
  }
  a.prototype.write = function(r3, t, i, n) {
    if (t === void 0)
      n = "utf8", i = this.length, t = 0;
    else if (i === void 0 && typeof t == "string")
      n = t, i = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(i) ? (i = i >>> 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var u3 = this.length - t;
    if ((i === void 0 || i > u3) && (i = u3), r3.length > 0 && (i < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    n || (n = "utf8");
    for (var o = false; ; )
      switch (n) {
        case "hex":
          return Kr(this, r3, t, i);
        case "utf8":
        case "utf-8":
          return Or2(this, r3, t, i);
        case "ascii":
        case "latin1":
        case "binary":
          return Zr(this, r3, t, i);
        case "base64":
          return $r2(this, r3, t, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Pr(this, r3, t, i);
        default:
          if (o)
            throw new TypeError("Unknown encoding: " + n);
          n = ("" + n).toLowerCase(), o = true;
      }
  };
  a.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function jr(e, r3, t) {
    return r3 === 0 && t === e.length ? V.fromByteArray(e) : V.fromByteArray(e.slice(r3, t));
  }
  function Er(e, r3, t) {
    t = Math.min(e.length, t);
    for (var i = [], n = r3; n < t; ) {
      var u3 = e[n], o = null, h2 = u3 > 239 ? 4 : u3 > 223 ? 3 : u3 > 191 ? 2 : 1;
      if (n + h2 <= t) {
        var f2, c, l, p2;
        switch (h2) {
          case 1:
            u3 < 128 && (o = u3);
            break;
          case 2:
            f2 = e[n + 1], (f2 & 192) === 128 && (p2 = (u3 & 31) << 6 | f2 & 63, p2 > 127 && (o = p2));
            break;
          case 3:
            f2 = e[n + 1], c = e[n + 2], (f2 & 192) === 128 && (c & 192) === 128 && (p2 = (u3 & 15) << 12 | (f2 & 63) << 6 | c & 63, p2 > 2047 && (p2 < 55296 || p2 > 57343) && (o = p2));
            break;
          case 4:
            f2 = e[n + 1], c = e[n + 2], l = e[n + 3], (f2 & 192) === 128 && (c & 192) === 128 && (l & 192) === 128 && (p2 = (u3 & 15) << 18 | (f2 & 63) << 12 | (c & 63) << 6 | l & 63, p2 > 65535 && p2 < 1114112 && (o = p2));
        }
      }
      o === null ? (o = 65533, h2 = 1) : o > 65535 && (o -= 65536, i.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), i.push(o), n += h2;
    }
    return rt(i);
  }
  var sr2 = 4096;
  function rt(e) {
    var r3 = e.length;
    if (r3 <= sr2)
      return String.fromCharCode.apply(String, e);
    for (var t = "", i = 0; i < r3; )
      t += String.fromCharCode.apply(String, e.slice(i, i += sr2));
    return t;
  }
  function tt(e, r3, t) {
    var i = "";
    t = Math.min(e.length, t);
    for (var n = r3; n < t; ++n)
      i += String.fromCharCode(e[n] & 127);
    return i;
  }
  function et(e, r3, t) {
    var i = "";
    t = Math.min(e.length, t);
    for (var n = r3; n < t; ++n)
      i += String.fromCharCode(e[n]);
    return i;
  }
  function it(e, r3, t) {
    var i = e.length;
    (!r3 || r3 < 0) && (r3 = 0), (!t || t < 0 || t > i) && (t = i);
    for (var n = "", u3 = r3; u3 < t; ++u3)
      n += ft[e[u3]];
    return n;
  }
  function nt(e, r3, t) {
    for (var i = e.slice(r3, t), n = "", u3 = 0; u3 < i.length - 1; u3 += 2)
      n += String.fromCharCode(i[u3] + i[u3 + 1] * 256);
    return n;
  }
  a.prototype.slice = function(r3, t) {
    var i = this.length;
    r3 = ~~r3, t = t === void 0 ? i : ~~t, r3 < 0 ? (r3 += i, r3 < 0 && (r3 = 0)) : r3 > i && (r3 = i), t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), t < r3 && (t = r3);
    var n = this.subarray(r3, t);
    return Object.setPrototypeOf(n, a.prototype), n;
  };
  function w(e, r3, t) {
    if (e % 1 !== 0 || e < 0)
      throw new RangeError("offset is not uint");
    if (e + r3 > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(r3, t, i) {
    r3 = r3 >>> 0, t = t >>> 0, i || w(r3, t, this.length);
    for (var n = this[r3], u3 = 1, o = 0; ++o < t && (u3 *= 256); )
      n += this[r3 + o] * u3;
    return n;
  };
  a.prototype.readUintBE = a.prototype.readUIntBE = function(r3, t, i) {
    r3 = r3 >>> 0, t = t >>> 0, i || w(r3, t, this.length);
    for (var n = this[r3 + --t], u3 = 1; t > 0 && (u3 *= 256); )
      n += this[r3 + --t] * u3;
    return n;
  };
  a.prototype.readUint8 = a.prototype.readUInt8 = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 1, this.length), this[r3];
  };
  a.prototype.readUint16LE = a.prototype.readUInt16LE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 2, this.length), this[r3] | this[r3 + 1] << 8;
  };
  a.prototype.readUint16BE = a.prototype.readUInt16BE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 2, this.length), this[r3] << 8 | this[r3 + 1];
  };
  a.prototype.readUint32LE = a.prototype.readUInt32LE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 4, this.length), (this[r3] | this[r3 + 1] << 8 | this[r3 + 2] << 16) + this[r3 + 3] * 16777216;
  };
  a.prototype.readUint32BE = a.prototype.readUInt32BE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 4, this.length), this[r3] * 16777216 + (this[r3 + 1] << 16 | this[r3 + 2] << 8 | this[r3 + 3]);
  };
  a.prototype.readIntLE = function(r3, t, i) {
    r3 = r3 >>> 0, t = t >>> 0, i || w(r3, t, this.length);
    for (var n = this[r3], u3 = 1, o = 0; ++o < t && (u3 *= 256); )
      n += this[r3 + o] * u3;
    return u3 *= 128, n >= u3 && (n -= Math.pow(2, 8 * t)), n;
  };
  a.prototype.readIntBE = function(r3, t, i) {
    r3 = r3 >>> 0, t = t >>> 0, i || w(r3, t, this.length);
    for (var n = t, u3 = 1, o = this[r3 + --n]; n > 0 && (u3 *= 256); )
      o += this[r3 + --n] * u3;
    return u3 *= 128, o >= u3 && (o -= Math.pow(2, 8 * t)), o;
  };
  a.prototype.readInt8 = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 1, this.length), this[r3] & 128 ? (255 - this[r3] + 1) * -1 : this[r3];
  };
  a.prototype.readInt16LE = function(r3, t) {
    r3 = r3 >>> 0, t || w(r3, 2, this.length);
    var i = this[r3] | this[r3 + 1] << 8;
    return i & 32768 ? i | 4294901760 : i;
  };
  a.prototype.readInt16BE = function(r3, t) {
    r3 = r3 >>> 0, t || w(r3, 2, this.length);
    var i = this[r3 + 1] | this[r3] << 8;
    return i & 32768 ? i | 4294901760 : i;
  };
  a.prototype.readInt32LE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 4, this.length), this[r3] | this[r3 + 1] << 8 | this[r3 + 2] << 16 | this[r3 + 3] << 24;
  };
  a.prototype.readInt32BE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 4, this.length), this[r3] << 24 | this[r3 + 1] << 16 | this[r3 + 2] << 8 | this[r3 + 3];
  };
  a.prototype.readFloatLE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 4, this.length), _.read(this, r3, true, 23, 4);
  };
  a.prototype.readFloatBE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 4, this.length), _.read(this, r3, false, 23, 4);
  };
  a.prototype.readDoubleLE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 8, this.length), _.read(this, r3, true, 52, 8);
  };
  a.prototype.readDoubleBE = function(r3, t) {
    return r3 = r3 >>> 0, t || w(r3, 8, this.length), _.read(this, r3, false, 52, 8);
  };
  function y2(e, r3, t, i, n, u3) {
    if (!a.isBuffer(e))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r3 > n || r3 < u3)
      throw new RangeError('"value" argument is out of bounds');
    if (t + i > e.length)
      throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(r3, t, i, n) {
    if (r3 = +r3, t = t >>> 0, i = i >>> 0, !n) {
      var u3 = Math.pow(2, 8 * i) - 1;
      y2(this, r3, t, i, u3, 0);
    }
    var o = 1, h2 = 0;
    for (this[t] = r3 & 255; ++h2 < i && (o *= 256); )
      this[t + h2] = r3 / o & 255;
    return t + i;
  };
  a.prototype.writeUintBE = a.prototype.writeUIntBE = function(r3, t, i, n) {
    if (r3 = +r3, t = t >>> 0, i = i >>> 0, !n) {
      var u3 = Math.pow(2, 8 * i) - 1;
      y2(this, r3, t, i, u3, 0);
    }
    var o = i - 1, h2 = 1;
    for (this[t + o] = r3 & 255; --o >= 0 && (h2 *= 256); )
      this[t + o] = r3 / h2 & 255;
    return t + i;
  };
  a.prototype.writeUint8 = a.prototype.writeUInt8 = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 1, 255, 0), this[t] = r3 & 255, t + 1;
  };
  a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 2, 65535, 0), this[t] = r3 & 255, this[t + 1] = r3 >>> 8, t + 2;
  };
  a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 2, 65535, 0), this[t] = r3 >>> 8, this[t + 1] = r3 & 255, t + 2;
  };
  a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 4, 4294967295, 0), this[t + 3] = r3 >>> 24, this[t + 2] = r3 >>> 16, this[t + 1] = r3 >>> 8, this[t] = r3 & 255, t + 4;
  };
  a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 4, 4294967295, 0), this[t] = r3 >>> 24, this[t + 1] = r3 >>> 16, this[t + 2] = r3 >>> 8, this[t + 3] = r3 & 255, t + 4;
  };
  a.prototype.writeIntLE = function(r3, t, i, n) {
    if (r3 = +r3, t = t >>> 0, !n) {
      var u3 = Math.pow(2, 8 * i - 1);
      y2(this, r3, t, i, u3 - 1, -u3);
    }
    var o = 0, h2 = 1, f2 = 0;
    for (this[t] = r3 & 255; ++o < i && (h2 *= 256); )
      r3 < 0 && f2 === 0 && this[t + o - 1] !== 0 && (f2 = 1), this[t + o] = (r3 / h2 >> 0) - f2 & 255;
    return t + i;
  };
  a.prototype.writeIntBE = function(r3, t, i, n) {
    if (r3 = +r3, t = t >>> 0, !n) {
      var u3 = Math.pow(2, 8 * i - 1);
      y2(this, r3, t, i, u3 - 1, -u3);
    }
    var o = i - 1, h2 = 1, f2 = 0;
    for (this[t + o] = r3 & 255; --o >= 0 && (h2 *= 256); )
      r3 < 0 && f2 === 0 && this[t + o + 1] !== 0 && (f2 = 1), this[t + o] = (r3 / h2 >> 0) - f2 & 255;
    return t + i;
  };
  a.prototype.writeInt8 = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 1, 127, -128), r3 < 0 && (r3 = 255 + r3 + 1), this[t] = r3 & 255, t + 1;
  };
  a.prototype.writeInt16LE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 2, 32767, -32768), this[t] = r3 & 255, this[t + 1] = r3 >>> 8, t + 2;
  };
  a.prototype.writeInt16BE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 2, 32767, -32768), this[t] = r3 >>> 8, this[t + 1] = r3 & 255, t + 2;
  };
  a.prototype.writeInt32LE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 4, 2147483647, -2147483648), this[t] = r3 & 255, this[t + 1] = r3 >>> 8, this[t + 2] = r3 >>> 16, this[t + 3] = r3 >>> 24, t + 4;
  };
  a.prototype.writeInt32BE = function(r3, t, i) {
    return r3 = +r3, t = t >>> 0, i || y2(this, r3, t, 4, 2147483647, -2147483648), r3 < 0 && (r3 = 4294967295 + r3 + 1), this[t] = r3 >>> 24, this[t + 1] = r3 >>> 16, this[t + 2] = r3 >>> 8, this[t + 3] = r3 & 255, t + 4;
  };
  function Fr(e, r3, t, i, n, u3) {
    if (t + i > e.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function gr(e, r3, t, i, n) {
    return r3 = +r3, t = t >>> 0, n || Fr(e, r3, t, 4), _.write(e, r3, t, i, 23, 4), t + 4;
  }
  a.prototype.writeFloatLE = function(r3, t, i) {
    return gr(this, r3, t, true, i);
  };
  a.prototype.writeFloatBE = function(r3, t, i) {
    return gr(this, r3, t, false, i);
  };
  function Br2(e, r3, t, i, n) {
    return r3 = +r3, t = t >>> 0, n || Fr(e, r3, t, 8), _.write(e, r3, t, i, 52, 8), t + 8;
  }
  a.prototype.writeDoubleLE = function(r3, t, i) {
    return Br2(this, r3, t, true, i);
  };
  a.prototype.writeDoubleBE = function(r3, t, i) {
    return Br2(this, r3, t, false, i);
  };
  a.prototype.copy = function(r3, t, i, n) {
    if (!a.isBuffer(r3))
      throw new TypeError("argument should be a Buffer");
    if (i || (i = 0), !n && n !== 0 && (n = this.length), t >= r3.length && (t = r3.length), t || (t = 0), n > 0 && n < i && (n = i), n === i || r3.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (i < 0 || i >= this.length)
      throw new RangeError("Index out of range");
    if (n < 0)
      throw new RangeError("sourceEnd out of bounds");
    n > this.length && (n = this.length), r3.length - t < n - i && (n = r3.length - t + i);
    var u3 = n - i;
    return this === r3 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, i, n) : Uint8Array.prototype.set.call(r3, this.subarray(i, n), t), u3;
  };
  a.prototype.fill = function(r3, t, i, n) {
    if (typeof r3 == "string") {
      if (typeof t == "string" ? (n = t, t = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== void 0 && typeof n != "string")
        throw new TypeError("encoding must be a string");
      if (typeof n == "string" && !a.isEncoding(n))
        throw new TypeError("Unknown encoding: " + n);
      if (r3.length === 1) {
        var u3 = r3.charCodeAt(0);
        (n === "utf8" && u3 < 128 || n === "latin1") && (r3 = u3);
      }
    } else
      typeof r3 == "number" ? r3 = r3 & 255 : typeof r3 == "boolean" && (r3 = Number(r3));
    if (t < 0 || this.length < t || this.length < i)
      throw new RangeError("Out of range index");
    if (i <= t)
      return this;
    t = t >>> 0, i = i === void 0 ? this.length : i >>> 0, r3 || (r3 = 0);
    var o;
    if (typeof r3 == "number")
      for (o = t; o < i; ++o)
        this[o] = r3;
    else {
      var h2 = a.isBuffer(r3) ? r3 : a.from(r3, n), f2 = h2.length;
      if (f2 === 0)
        throw new TypeError('The value "' + r3 + '" is invalid for argument "value"');
      for (o = 0; o < i - t; ++o)
        this[o + t] = h2[o % f2];
    }
    return this;
  };
  var ut = /[^+/0-9A-Za-z-_]/g;
  function ot(e) {
    if (e = e.split("=")[0], e = e.trim().replace(ut, ""), e.length < 2)
      return "";
    for (; e.length % 4 !== 0; )
      e = e + "=";
    return e;
  }
  function Z(e, r3) {
    r3 = r3 || 1 / 0;
    for (var t, i = e.length, n = null, u3 = [], o = 0; o < i; ++o) {
      if (t = e.charCodeAt(o), t > 55295 && t < 57344) {
        if (!n) {
          if (t > 56319) {
            (r3 -= 3) > -1 && u3.push(239, 191, 189);
            continue;
          } else if (o + 1 === i) {
            (r3 -= 3) > -1 && u3.push(239, 191, 189);
            continue;
          }
          n = t;
          continue;
        }
        if (t < 56320) {
          (r3 -= 3) > -1 && u3.push(239, 191, 189), n = t;
          continue;
        }
        t = (n - 55296 << 10 | t - 56320) + 65536;
      } else
        n && (r3 -= 3) > -1 && u3.push(239, 191, 189);
      if (n = null, t < 128) {
        if ((r3 -= 1) < 0)
          break;
        u3.push(t);
      } else if (t < 2048) {
        if ((r3 -= 2) < 0)
          break;
        u3.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((r3 -= 3) < 0)
          break;
        u3.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((r3 -= 4) < 0)
          break;
        u3.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return u3;
  }
  function at(e) {
    for (var r3 = [], t = 0; t < e.length; ++t)
      r3.push(e.charCodeAt(t) & 255);
    return r3;
  }
  function ht(e, r3) {
    for (var t, i, n, u3 = [], o = 0; o < e.length && !((r3 -= 2) < 0); ++o)
      t = e.charCodeAt(o), i = t >> 8, n = t % 256, u3.push(n), u3.push(i);
    return u3;
  }
  function Ar(e) {
    return V.toByteArray(ot(e));
  }
  function H5(e, r3, t, i) {
    for (var n = 0; n < i && !(n + t >= r3.length || n >= e.length); ++n)
      r3[n + t] = e[n];
    return n;
  }
  function A2(e, r3) {
    return e instanceof r3 || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r3.name;
  }
  function j2(e) {
    return e !== e;
  }
  var ft = function() {
    for (var e = "0123456789abcdef", r3 = new Array(256), t = 0; t < 16; ++t)
      for (var i = t * 16, n = 0; n < 16; ++n)
        r3[i + n] = e[t] + e[n];
    return r3;
  }();
});
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Mt = k((Qh, Qg) => {
  U();
  var sd = or(), Bi = sd.Buffer;
  function Xg(t, e) {
    for (var r3 in t)
      e[r3] = t[r3];
  }
  Bi.from && Bi.alloc && Bi.allocUnsafe && Bi.allocUnsafeSlow ? Qg.exports = sd : (Xg(sd, Qh), Qh.Buffer = cs);
  function cs(t, e, r3) {
    return Bi(t, e, r3);
  }
  cs.prototype = Object.create(Bi.prototype);
  Xg(Bi, cs);
  cs.from = function(t, e, r3) {
    if (typeof t == "number")
      throw new TypeError("Argument must not be a number");
    return Bi(t, e, r3);
  };
  cs.alloc = function(t, e, r3) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    var i = Bi(t);
    return e !== void 0 ? typeof r3 == "string" ? i.fill(e, r3) : i.fill(e) : i.fill(0), i;
  };
  cs.allocUnsafe = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return Bi(t);
  };
  cs.allocUnsafeSlow = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return sd.SlowBuffer(t);
  };
});
var us = k((tk, t0) => {
  U();
  var e0 = 65536, c8 = 4294967295;
  function u8() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var d8 = Mt().Buffer, od = N.crypto || N.msCrypto;
  od && od.getRandomValues ? t0.exports = l8 : t0.exports = u8;
  function l8(t, e) {
    if (t > c8)
      throw new RangeError("requested too many random bytes");
    var r3 = d8.allocUnsafe(t);
    if (t > 0)
      if (t > e0)
        for (var i = 0; i < t; i += e0)
          od.getRandomValues(r3.slice(i, i + e0));
      else
        od.getRandomValues(r3);
    return typeof e == "function" ? W.default.nextTick(function() {
      e(null, r3);
    }) : r3;
  }
});
var At = k((rk, r0) => {
  U();
  typeof Object.create == "function" ? r0.exports = function(e, r3) {
    r3 && (e.super_ = r3, e.prototype = Object.create(r3.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : r0.exports = function(e, r3) {
    if (r3) {
      e.super_ = r3;
      var i = function() {
      };
      i.prototype = r3.prototype, e.prototype = new i(), e.prototype.constructor = e;
    }
  };
});
var cd = k((ik, i0) => {
  U();
  var wo = typeof Reflect == "object" ? Reflect : null, em = wo && typeof wo.apply == "function" ? wo.apply : function(e, r3, i) {
    return Function.prototype.apply.call(e, r3, i);
  }, ad;
  wo && typeof wo.ownKeys == "function" ? ad = wo.ownKeys : Object.getOwnPropertySymbols ? ad = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : ad = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  function h8(t) {
    console && console.warn && console.warn(t);
  }
  var rm = Number.isNaN || function(e) {
    return e !== e;
  };
  function Kt() {
    Kt.init.call(this);
  }
  i0.exports = Kt;
  i0.exports.once = y8;
  Kt.EventEmitter = Kt;
  Kt.prototype._events = void 0;
  Kt.prototype._eventsCount = 0;
  Kt.prototype._maxListeners = void 0;
  var tm = 10;
  function fd(t) {
    if (typeof t != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
  }
  Object.defineProperty(Kt, "defaultMaxListeners", { enumerable: true, get: function() {
    return tm;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || rm(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    tm = t;
  } });
  Kt.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  Kt.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || rm(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  function im(t) {
    return t._maxListeners === void 0 ? Kt.defaultMaxListeners : t._maxListeners;
  }
  Kt.prototype.getMaxListeners = function() {
    return im(this);
  };
  Kt.prototype.emit = function(e) {
    for (var r3 = [], i = 1; i < arguments.length; i++)
      r3.push(arguments[i]);
    var n = e === "error", s = this._events;
    if (s !== void 0)
      n = n && s.error === void 0;
    else if (!n)
      return false;
    if (n) {
      var o;
      if (r3.length > 0 && (o = r3[0]), o instanceof Error)
        throw o;
      var f2 = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
      throw f2.context = o, f2;
    }
    var l = s[e];
    if (l === void 0)
      return false;
    if (typeof l == "function")
      em(l, this, r3);
    else
      for (var g5 = l.length, _ = fm(l, g5), i = 0; i < g5; ++i)
        em(_[i], this, r3);
    return true;
  };
  function nm(t, e, r3, i) {
    var n, s, o;
    if (fd(r3), s = t._events, s === void 0 ? (s = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit("newListener", e, r3.listener ? r3.listener : r3), s = t._events), o = s[e]), o === void 0)
      o = s[e] = r3, ++t._eventsCount;
    else if (typeof o == "function" ? o = s[e] = i ? [r3, o] : [o, r3] : i ? o.unshift(r3) : o.push(r3), n = im(t), n > 0 && o.length > n && !o.warned) {
      o.warned = true;
      var f2 = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      f2.name = "MaxListenersExceededWarning", f2.emitter = t, f2.type = e, f2.count = o.length, h8(f2);
    }
    return t;
  }
  Kt.prototype.addListener = function(e, r3) {
    return nm(this, e, r3, false);
  };
  Kt.prototype.on = Kt.prototype.addListener;
  Kt.prototype.prependListener = function(e, r3) {
    return nm(this, e, r3, true);
  };
  function p8() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function sm(t, e, r3) {
    var i = { fired: false, wrapFn: void 0, target: t, type: e, listener: r3 }, n = p8.bind(i);
    return n.listener = r3, i.wrapFn = n, n;
  }
  Kt.prototype.once = function(e, r3) {
    return fd(r3), this.on(e, sm(this, e, r3)), this;
  };
  Kt.prototype.prependOnceListener = function(e, r3) {
    return fd(r3), this.prependListener(e, sm(this, e, r3)), this;
  };
  Kt.prototype.removeListener = function(e, r3) {
    var i, n, s, o, f2;
    if (fd(r3), n = this._events, n === void 0)
      return this;
    if (i = n[e], i === void 0)
      return this;
    if (i === r3 || i.listener === r3)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, i.listener || r3));
    else if (typeof i != "function") {
      for (s = -1, o = i.length - 1; o >= 0; o--)
        if (i[o] === r3 || i[o].listener === r3) {
          f2 = i[o].listener, s = o;
          break;
        }
      if (s < 0)
        return this;
      s === 0 ? i.shift() : g8(i, s), i.length === 1 && (n[e] = i[0]), n.removeListener !== void 0 && this.emit("removeListener", e, f2 || r3);
    }
    return this;
  };
  Kt.prototype.off = Kt.prototype.removeListener;
  Kt.prototype.removeAllListeners = function(e) {
    var r3, i, n;
    if (i = this._events, i === void 0)
      return this;
    if (i.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[e]), this;
    if (arguments.length === 0) {
      var s = Object.keys(i), o;
      for (n = 0; n < s.length; ++n)
        o = s[n], o !== "removeListener" && this.removeAllListeners(o);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (r3 = i[e], typeof r3 == "function")
      this.removeListener(e, r3);
    else if (r3 !== void 0)
      for (n = r3.length - 1; n >= 0; n--)
        this.removeListener(e, r3[n]);
    return this;
  };
  function om(t, e, r3) {
    var i = t._events;
    if (i === void 0)
      return [];
    var n = i[e];
    return n === void 0 ? [] : typeof n == "function" ? r3 ? [n.listener || n] : [n] : r3 ? m8(n) : fm(n, n.length);
  }
  Kt.prototype.listeners = function(e) {
    return om(this, e, true);
  };
  Kt.prototype.rawListeners = function(e) {
    return om(this, e, false);
  };
  Kt.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : am.call(t, e);
  };
  Kt.prototype.listenerCount = am;
  function am(t) {
    var e = this._events;
    if (e !== void 0) {
      var r3 = e[t];
      if (typeof r3 == "function")
        return 1;
      if (r3 !== void 0)
        return r3.length;
    }
    return 0;
  }
  Kt.prototype.eventNames = function() {
    return this._eventsCount > 0 ? ad(this._events) : [];
  };
  function fm(t, e) {
    for (var r3 = new Array(e), i = 0; i < e; ++i)
      r3[i] = t[i];
    return r3;
  }
  function g8(t, e) {
    for (; e + 1 < t.length; e++)
      t[e] = t[e + 1];
    t.pop();
  }
  function m8(t) {
    for (var e = new Array(t.length), r3 = 0; r3 < e.length; ++r3)
      e[r3] = t[r3].listener || t[r3];
    return e;
  }
  function y8(t, e) {
    return new Promise(function(r3, i) {
      function n(o) {
        t.removeListener(e, s), i(o);
      }
      function s() {
        typeof t.removeListener == "function" && t.removeListener("error", n), r3([].slice.call(arguments));
      }
      cm(t, e, s, { once: true }), e !== "error" && b8(t, n, { once: true });
    });
  }
  function b8(t, e, r3) {
    typeof t.on == "function" && cm(t, "error", e, r3);
  }
  function cm(t, e, r3, i) {
    if (typeof t.on == "function")
      i.once ? t.once(e, r3) : t.on(e, r3);
    else if (typeof t.addEventListener == "function")
      t.addEventListener(e, function n(s) {
        i.once && t.removeEventListener(e, n), r3(s);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
  }
});
var n0 = k((nk, um) => {
  U();
  um.exports = cd().EventEmitter;
});
var s0 = k((sk, dm) => {
  U();
  dm.exports = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return false;
    if (typeof Symbol.iterator == "symbol")
      return true;
    var e = {}, r3 = Symbol("test"), i = Object(r3);
    if (typeof r3 == "string" || Object.prototype.toString.call(r3) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
      return false;
    var n = 42;
    e[r3] = n;
    for (r3 in e)
      return false;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return false;
    var s = Object.getOwnPropertySymbols(e);
    if (s.length !== 1 || s[0] !== r3 || !Object.prototype.propertyIsEnumerable.call(e, r3))
      return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = Object.getOwnPropertyDescriptor(e, r3);
      if (o.value !== n || o.enumerable !== true)
        return false;
    }
    return true;
  };
});
var bf = k((ok, lm) => {
  U();
  var v8 = s0();
  lm.exports = function() {
    return v8() && !!Symbol.toStringTag;
  };
});
var gm = k((ak, pm) => {
  U();
  var hm = typeof Symbol < "u" && Symbol, x8 = s0();
  pm.exports = function() {
    return typeof hm != "function" || typeof Symbol != "function" || typeof hm("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : x8();
  };
});
var ym = k((fk, mm) => {
  U();
  var w8 = "Function.prototype.bind called on incompatible ", o0 = Array.prototype.slice, _8 = Object.prototype.toString, A8 = "[object Function]";
  mm.exports = function(e) {
    var r3 = this;
    if (typeof r3 != "function" || _8.call(r3) !== A8)
      throw new TypeError(w8 + r3);
    for (var i = o0.call(arguments, 1), n, s = function() {
      if (this instanceof n) {
        var _ = r3.apply(this, i.concat(o0.call(arguments)));
        return Object(_) === _ ? _ : this;
      } else
        return r3.apply(e, i.concat(o0.call(arguments)));
    }, o = Math.max(0, r3.length - i.length), f2 = [], l = 0; l < o; l++)
      f2.push("$" + l);
    if (n = Function("binder", "return function (" + f2.join(",") + "){ return binder.apply(this,arguments); }")(s), r3.prototype) {
      var g5 = function() {
      };
      g5.prototype = r3.prototype, n.prototype = new g5(), g5.prototype = null;
    }
    return n;
  };
});
var ud = k((ck, bm) => {
  U();
  var E8 = ym();
  bm.exports = Function.prototype.bind || E8;
});
var xm = k((uk, vm) => {
  U();
  var M8 = ud();
  vm.exports = M8.call(Function.call, Object.prototype.hasOwnProperty);
});
var hd = k((dk, Mm) => {
  U();
  var Dt, Mo = SyntaxError, Em = Function, Eo = TypeError, a0 = function(t) {
    try {
      return Em('"use strict"; return (' + t + ").constructor;")();
    } catch {
    }
  }, ds = Object.getOwnPropertyDescriptor;
  if (ds)
    try {
      ds({}, "");
    } catch {
      ds = null;
    }
  var f0 = function() {
    throw new Eo();
  }, S8 = ds ? function() {
    try {
      return arguments.callee, f0;
    } catch {
      try {
        return ds(arguments, "callee").get;
      } catch {
        return f0;
      }
    }
  }() : f0, _o = gm()(), Ci = Object.getPrototypeOf || function(t) {
    return t.__proto__;
  }, Ao = {}, I8 = typeof Uint8Array > "u" ? Dt : Ci(Uint8Array), ls = { "%AggregateError%": typeof AggregateError > "u" ? Dt : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Dt : ArrayBuffer, "%ArrayIteratorPrototype%": _o ? Ci([][Symbol.iterator]()) : Dt, "%AsyncFromSyncIteratorPrototype%": Dt, "%AsyncFunction%": Ao, "%AsyncGenerator%": Ao, "%AsyncGeneratorFunction%": Ao, "%AsyncIteratorPrototype%": Ao, "%Atomics%": typeof Atomics > "u" ? Dt : Atomics, "%BigInt%": typeof BigInt > "u" ? Dt : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? Dt : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? Dt : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? Dt : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? Dt : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? Dt : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Dt : FinalizationRegistry, "%Function%": Em, "%GeneratorFunction%": Ao, "%Int8Array%": typeof Int8Array > "u" ? Dt : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? Dt : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? Dt : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": _o ? Ci(Ci([][Symbol.iterator]())) : Dt, "%JSON%": typeof JSON == "object" ? JSON : Dt, "%Map%": typeof Map > "u" ? Dt : Map, "%MapIteratorPrototype%": typeof Map > "u" || !_o ? Dt : Ci((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? Dt : Promise, "%Proxy%": typeof Proxy > "u" ? Dt : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? Dt : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? Dt : Set, "%SetIteratorPrototype%": typeof Set > "u" || !_o ? Dt : Ci((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Dt : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": _o ? Ci(""[Symbol.iterator]()) : Dt, "%Symbol%": _o ? Symbol : Dt, "%SyntaxError%": Mo, "%ThrowTypeError%": S8, "%TypedArray%": I8, "%TypeError%": Eo, "%Uint8Array%": typeof Uint8Array > "u" ? Dt : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Dt : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? Dt : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? Dt : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? Dt : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? Dt : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? Dt : WeakSet };
  try {
    null.error;
  } catch (t) {
    wm = Ci(Ci(t)), ls["%Error.prototype%"] = wm;
  }
  var wm, T8 = function t(e) {
    var r3;
    if (e === "%AsyncFunction%")
      r3 = a0("async function () {}");
    else if (e === "%GeneratorFunction%")
      r3 = a0("function* () {}");
    else if (e === "%AsyncGeneratorFunction%")
      r3 = a0("async function* () {}");
    else if (e === "%AsyncGenerator%") {
      var i = t("%AsyncGeneratorFunction%");
      i && (r3 = i.prototype);
    } else if (e === "%AsyncIteratorPrototype%") {
      var n = t("%AsyncGenerator%");
      n && (r3 = Ci(n.prototype));
    }
    return ls[e] = r3, r3;
  }, _m = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, vf = ud(), dd = xm(), F8 = vf.call(Function.call, Array.prototype.concat), R8 = vf.call(Function.apply, Array.prototype.splice), Am = vf.call(Function.call, String.prototype.replace), ld = vf.call(Function.call, String.prototype.slice), k8 = vf.call(Function.call, RegExp.prototype.exec), D8 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, N8 = /\\(\\)?/g, B8 = function(e) {
    var r3 = ld(e, 0, 1), i = ld(e, -1);
    if (r3 === "%" && i !== "%")
      throw new Mo("invalid intrinsic syntax, expected closing `%`");
    if (i === "%" && r3 !== "%")
      throw new Mo("invalid intrinsic syntax, expected opening `%`");
    var n = [];
    return Am(e, D8, function(s, o, f2, l) {
      n[n.length] = f2 ? Am(l, N8, "$1") : o || s;
    }), n;
  }, C8 = function(e, r3) {
    var i = e, n;
    if (dd(_m, i) && (n = _m[i], i = "%" + n[0] + "%"), dd(ls, i)) {
      var s = ls[i];
      if (s === Ao && (s = T8(i)), typeof s > "u" && !r3)
        throw new Eo("intrinsic " + e + " exists, but is not available. Please file an issue!");
      return { alias: n, name: i, value: s };
    }
    throw new Mo("intrinsic " + e + " does not exist!");
  };
  Mm.exports = function(e, r3) {
    if (typeof e != "string" || e.length === 0)
      throw new Eo("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof r3 != "boolean")
      throw new Eo('"allowMissing" argument must be a boolean');
    if (k8(/^%?[^%]*%?$/, e) === null)
      throw new Mo("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var i = B8(e), n = i.length > 0 ? i[0] : "", s = C8("%" + n + "%", r3), o = s.name, f2 = s.value, l = false, g5 = s.alias;
    g5 && (n = g5[0], R8(i, F8([0, 1], g5)));
    for (var _ = 1, N2 = true; _ < i.length; _ += 1) {
      var U2 = i[_], V = ld(U2, 0, 1), G = ld(U2, -1);
      if ((V === '"' || V === "'" || V === "`" || G === '"' || G === "'" || G === "`") && V !== G)
        throw new Mo("property names with quotes must have matching quotes");
      if ((U2 === "constructor" || !N2) && (l = true), n += "." + U2, o = "%" + n + "%", dd(ls, o))
        f2 = ls[o];
      else if (f2 != null) {
        if (!(U2 in f2)) {
          if (!r3)
            throw new Eo("base intrinsic for " + e + " exists, but the property is not available.");
          return;
        }
        if (ds && _ + 1 >= i.length) {
          var ee2 = ds(f2, U2);
          N2 = !!ee2, N2 && "get" in ee2 && !("originalValue" in ee2.get) ? f2 = ee2.get : f2 = f2[U2];
        } else
          N2 = dd(f2, U2), f2 = f2[U2];
        N2 && !l && (ls[o] = f2);
      }
    }
    return f2;
  };
});
var km = k((lk, pd) => {
  U();
  var c0 = ud(), So = hd(), Tm = So("%Function.prototype.apply%"), Fm = So("%Function.prototype.call%"), Rm = So("%Reflect.apply%", true) || c0.call(Fm, Tm), Sm = So("%Object.getOwnPropertyDescriptor%", true), hs = So("%Object.defineProperty%", true), O8 = So("%Math.max%");
  if (hs)
    try {
      hs({}, "a", { value: 1 });
    } catch {
      hs = null;
    }
  pd.exports = function(e) {
    var r3 = Rm(c0, Fm, arguments);
    if (Sm && hs) {
      var i = Sm(r3, "length");
      i.configurable && hs(r3, "length", { value: 1 + O8(0, e.length - (arguments.length - 1)) });
    }
    return r3;
  };
  var Im = function() {
    return Rm(c0, Tm, arguments);
  };
  hs ? hs(pd.exports, "apply", { value: Im }) : pd.exports.apply = Im;
});
var gd = k((hk, Bm) => {
  U();
  var Dm = hd(), Nm = km(), j8 = Nm(Dm("String.prototype.indexOf"));
  Bm.exports = function(e, r3) {
    var i = Dm(e, !!r3);
    return typeof i == "function" && j8(e, ".prototype.") > -1 ? Nm(i) : i;
  };
});
var jm = k((pk, Om) => {
  U();
  var L8 = bf()(), q8 = gd(), u0 = q8("Object.prototype.toString"), md = function(e) {
    return L8 && e && typeof e == "object" && Symbol.toStringTag in e ? false : u0(e) === "[object Arguments]";
  }, Cm = function(e) {
    return md(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && u0(e) !== "[object Array]" && u0(e.callee) === "[object Function]";
  }, P8 = function() {
    return md(arguments);
  }();
  md.isLegacyArguments = Cm;
  Om.exports = P8 ? md : Cm;
});
var Pm = k((gk, qm) => {
  U();
  var U8 = Object.prototype.toString, z8 = Function.prototype.toString, H8 = /^\s*(?:function)?\*/, Lm = bf()(), d0 = Object.getPrototypeOf, K8 = function() {
    if (!Lm)
      return false;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, l0;
  qm.exports = function(e) {
    if (typeof e != "function")
      return false;
    if (H8.test(z8.call(e)))
      return true;
    if (!Lm) {
      var r3 = U8.call(e);
      return r3 === "[object GeneratorFunction]";
    }
    if (!d0)
      return false;
    if (typeof l0 > "u") {
      var i = K8();
      l0 = i ? d0(i) : false;
    }
    return d0(e) === l0;
  };
});
var Km = k((mk, Hm) => {
  U();
  var zm = Function.prototype.toString, Io = typeof Reflect == "object" && Reflect !== null && Reflect.apply, p0, yd;
  if (typeof Io == "function" && typeof Object.defineProperty == "function")
    try {
      p0 = Object.defineProperty({}, "length", { get: function() {
        throw yd;
      } }), yd = {}, Io(function() {
        throw 42;
      }, null, p0);
    } catch (t) {
      t !== yd && (Io = null);
    }
  else
    Io = null;
  var G8 = /^\s*class\b/, g0 = function(e) {
    try {
      var r3 = zm.call(e);
      return G8.test(r3);
    } catch {
      return false;
    }
  }, h0 = function(e) {
    try {
      return g0(e) ? false : (zm.call(e), true);
    } catch {
      return false;
    }
  }, bd = Object.prototype.toString, $8 = "[object Object]", W8 = "[object Function]", V8 = "[object GeneratorFunction]", Y8 = "[object HTMLAllCollection]", Z8 = "[object HTML document.all class]", J8 = "[object HTMLCollection]", X8 = typeof Symbol == "function" && !!Symbol.toStringTag, Q8 = !(0 in [,]), m0 = function() {
    return false;
  };
  typeof document == "object" && (Um = document.all, bd.call(Um) === bd.call(document.all) && (m0 = function(e) {
    if ((Q8 || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var r3 = bd.call(e);
        return (r3 === Y8 || r3 === Z8 || r3 === J8 || r3 === $8) && e("") == null;
      } catch {
      }
    return false;
  }));
  var Um;
  Hm.exports = Io ? function(e) {
    if (m0(e))
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    try {
      Io(e, null, p0);
    } catch (r3) {
      if (r3 !== yd)
        return false;
    }
    return !g0(e) && h0(e);
  } : function(e) {
    if (m0(e))
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    if (X8)
      return h0(e);
    if (g0(e))
      return false;
    var r3 = bd.call(e);
    return r3 !== W8 && r3 !== V8 && !/^\[object HTML/.test(r3) ? false : h0(e);
  };
});
var y0 = k((yk, $m) => {
  U();
  var e5 = Km(), t5 = Object.prototype.toString, Gm = Object.prototype.hasOwnProperty, r5 = function(e, r3, i) {
    for (var n = 0, s = e.length; n < s; n++)
      Gm.call(e, n) && (i == null ? r3(e[n], n, e) : r3.call(i, e[n], n, e));
  }, i5 = function(e, r3, i) {
    for (var n = 0, s = e.length; n < s; n++)
      i == null ? r3(e.charAt(n), n, e) : r3.call(i, e.charAt(n), n, e);
  }, n5 = function(e, r3, i) {
    for (var n in e)
      Gm.call(e, n) && (i == null ? r3(e[n], n, e) : r3.call(i, e[n], n, e));
  }, s5 = function(e, r3, i) {
    if (!e5(r3))
      throw new TypeError("iterator must be a function");
    var n;
    arguments.length >= 3 && (n = i), t5.call(e) === "[object Array]" ? r5(e, r3, n) : typeof e == "string" ? i5(e, r3, n) : n5(e, r3, n);
  };
  $m.exports = s5;
});
var v0 = k((bk, Wm) => {
  U();
  var b0 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], o5 = typeof globalThis > "u" ? N : globalThis;
  Wm.exports = function() {
    for (var e = [], r3 = 0; r3 < b0.length; r3++)
      typeof o5[b0[r3]] == "function" && (e[e.length] = b0[r3]);
    return e;
  };
});
var x0 = k((vk, Vm) => {
  U();
  var a5 = hd(), vd = a5("%Object.getOwnPropertyDescriptor%", true);
  if (vd)
    try {
      vd([], "length");
    } catch {
      vd = null;
    }
  Vm.exports = vd;
});
var A0 = k((xk, Qm) => {
  U();
  var Ym = y0(), f5 = v0(), _0 = gd(), c5 = _0("Object.prototype.toString"), Zm = bf()(), xd = x0(), u5 = typeof globalThis > "u" ? N : globalThis, Jm = f5(), d5 = _0("Array.prototype.indexOf", true) || function(e, r3) {
    for (var i = 0; i < e.length; i += 1)
      if (e[i] === r3)
        return i;
    return -1;
  }, l5 = _0("String.prototype.slice"), Xm = {}, w0 = Object.getPrototypeOf;
  Zm && xd && w0 && Ym(Jm, function(t) {
    var e = new u5[t]();
    if (Symbol.toStringTag in e) {
      var r3 = w0(e), i = xd(r3, Symbol.toStringTag);
      if (!i) {
        var n = w0(r3);
        i = xd(n, Symbol.toStringTag);
      }
      Xm[t] = i.get;
    }
  });
  var h5 = function(e) {
    var r3 = false;
    return Ym(Xm, function(i, n) {
      if (!r3)
        try {
          r3 = i.call(e) === n;
        } catch {
        }
    }), r3;
  };
  Qm.exports = function(e) {
    if (!e || typeof e != "object")
      return false;
    if (!Zm || !(Symbol.toStringTag in e)) {
      var r3 = l5(c5(e), 8, -1);
      return d5(Jm, r3) > -1;
    }
    return xd ? h5(e) : false;
  };
});
var oy = k((wk, sy) => {
  U();
  var ty = y0(), p5 = v0(), ry = gd(), E0 = x0(), g5 = ry("Object.prototype.toString"), iy = bf()(), ey = typeof globalThis > "u" ? N : globalThis, m5 = p5(), y5 = ry("String.prototype.slice"), ny = {}, M0 = Object.getPrototypeOf;
  iy && E0 && M0 && ty(m5, function(t) {
    if (typeof ey[t] == "function") {
      var e = new ey[t]();
      if (Symbol.toStringTag in e) {
        var r3 = M0(e), i = E0(r3, Symbol.toStringTag);
        if (!i) {
          var n = M0(r3);
          i = E0(n, Symbol.toStringTag);
        }
        ny[t] = i.get;
      }
    }
  });
  var b5 = function(e) {
    var r3 = false;
    return ty(ny, function(i, n) {
      if (!r3)
        try {
          var s = i.call(e);
          s === n && (r3 = s);
        } catch {
        }
    }), r3;
  }, v5 = A0();
  sy.exports = function(e) {
    return v5(e) ? !iy || !(Symbol.toStringTag in e) ? y5(g5(e), 8, -1) : b5(e) : false;
  };
});
var xy = k((Rt) => {
  U();
  var x5 = jm(), w5 = Pm(), gi = oy(), ay = A0();
  function To(t) {
    return t.call.bind(t);
  }
  var fy = typeof BigInt < "u", cy = typeof Symbol < "u", Wr = To(Object.prototype.toString), _5 = To(Number.prototype.valueOf), A5 = To(String.prototype.valueOf), E5 = To(Boolean.prototype.valueOf);
  fy && (uy = To(BigInt.prototype.valueOf));
  var uy;
  cy && (dy = To(Symbol.prototype.valueOf));
  var dy;
  function wf(t, e) {
    if (typeof t != "object")
      return false;
    try {
      return e(t), true;
    } catch {
      return false;
    }
  }
  Rt.isArgumentsObject = x5;
  Rt.isGeneratorFunction = w5;
  Rt.isTypedArray = ay;
  function M5(t) {
    return typeof Promise < "u" && t instanceof Promise || t !== null && typeof t == "object" && typeof t.then == "function" && typeof t.catch == "function";
  }
  Rt.isPromise = M5;
  function S5(t) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(t) : ay(t) || hy(t);
  }
  Rt.isArrayBufferView = S5;
  function I5(t) {
    return gi(t) === "Uint8Array";
  }
  Rt.isUint8Array = I5;
  function T5(t) {
    return gi(t) === "Uint8ClampedArray";
  }
  Rt.isUint8ClampedArray = T5;
  function F5(t) {
    return gi(t) === "Uint16Array";
  }
  Rt.isUint16Array = F5;
  function R5(t) {
    return gi(t) === "Uint32Array";
  }
  Rt.isUint32Array = R5;
  function k5(t) {
    return gi(t) === "Int8Array";
  }
  Rt.isInt8Array = k5;
  function D5(t) {
    return gi(t) === "Int16Array";
  }
  Rt.isInt16Array = D5;
  function N5(t) {
    return gi(t) === "Int32Array";
  }
  Rt.isInt32Array = N5;
  function B5(t) {
    return gi(t) === "Float32Array";
  }
  Rt.isFloat32Array = B5;
  function C5(t) {
    return gi(t) === "Float64Array";
  }
  Rt.isFloat64Array = C5;
  function O5(t) {
    return gi(t) === "BigInt64Array";
  }
  Rt.isBigInt64Array = O5;
  function j5(t) {
    return gi(t) === "BigUint64Array";
  }
  Rt.isBigUint64Array = j5;
  function wd(t) {
    return Wr(t) === "[object Map]";
  }
  wd.working = typeof Map < "u" && wd(/* @__PURE__ */ new Map());
  function L5(t) {
    return typeof Map > "u" ? false : wd.working ? wd(t) : t instanceof Map;
  }
  Rt.isMap = L5;
  function _d(t) {
    return Wr(t) === "[object Set]";
  }
  _d.working = typeof Set < "u" && _d(/* @__PURE__ */ new Set());
  function q5(t) {
    return typeof Set > "u" ? false : _d.working ? _d(t) : t instanceof Set;
  }
  Rt.isSet = q5;
  function Ad(t) {
    return Wr(t) === "[object WeakMap]";
  }
  Ad.working = typeof WeakMap < "u" && Ad(/* @__PURE__ */ new WeakMap());
  function P5(t) {
    return typeof WeakMap > "u" ? false : Ad.working ? Ad(t) : t instanceof WeakMap;
  }
  Rt.isWeakMap = P5;
  function I0(t) {
    return Wr(t) === "[object WeakSet]";
  }
  I0.working = typeof WeakSet < "u" && I0(/* @__PURE__ */ new WeakSet());
  function U5(t) {
    return I0(t);
  }
  Rt.isWeakSet = U5;
  function Ed(t) {
    return Wr(t) === "[object ArrayBuffer]";
  }
  Ed.working = typeof ArrayBuffer < "u" && Ed(new ArrayBuffer());
  function ly(t) {
    return typeof ArrayBuffer > "u" ? false : Ed.working ? Ed(t) : t instanceof ArrayBuffer;
  }
  Rt.isArrayBuffer = ly;
  function Md(t) {
    return Wr(t) === "[object DataView]";
  }
  Md.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Md(new DataView(new ArrayBuffer(1), 0, 1));
  function hy(t) {
    return typeof DataView > "u" ? false : Md.working ? Md(t) : t instanceof DataView;
  }
  Rt.isDataView = hy;
  var S0 = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function xf(t) {
    return Wr(t) === "[object SharedArrayBuffer]";
  }
  function py(t) {
    return typeof S0 > "u" ? false : (typeof xf.working > "u" && (xf.working = xf(new S0())), xf.working ? xf(t) : t instanceof S0);
  }
  Rt.isSharedArrayBuffer = py;
  function z5(t) {
    return Wr(t) === "[object AsyncFunction]";
  }
  Rt.isAsyncFunction = z5;
  function H5(t) {
    return Wr(t) === "[object Map Iterator]";
  }
  Rt.isMapIterator = H5;
  function K5(t) {
    return Wr(t) === "[object Set Iterator]";
  }
  Rt.isSetIterator = K5;
  function G5(t) {
    return Wr(t) === "[object Generator]";
  }
  Rt.isGeneratorObject = G5;
  function $5(t) {
    return Wr(t) === "[object WebAssembly.Module]";
  }
  Rt.isWebAssemblyCompiledModule = $5;
  function gy(t) {
    return wf(t, _5);
  }
  Rt.isNumberObject = gy;
  function my(t) {
    return wf(t, A5);
  }
  Rt.isStringObject = my;
  function yy(t) {
    return wf(t, E5);
  }
  Rt.isBooleanObject = yy;
  function by(t) {
    return fy && wf(t, uy);
  }
  Rt.isBigIntObject = by;
  function vy(t) {
    return cy && wf(t, dy);
  }
  Rt.isSymbolObject = vy;
  function W5(t) {
    return gy(t) || my(t) || yy(t) || by(t) || vy(t);
  }
  Rt.isBoxedPrimitive = W5;
  function V5(t) {
    return typeof Uint8Array < "u" && (ly(t) || py(t));
  }
  Rt.isAnyArrayBuffer = V5;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(t) {
    Object.defineProperty(Rt, t, { enumerable: false, value: function() {
      throw new Error(t + " is not supported in userland");
    } });
  });
});
var _y = k((Ak, wy) => {
  U();
  wy.exports = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  };
});
var N0 = k((kt) => {
  U();
  var Ay = Object.getOwnPropertyDescriptors || function(e) {
    for (var r3 = Object.keys(e), i = {}, n = 0; n < r3.length; n++)
      i[r3[n]] = Object.getOwnPropertyDescriptor(e, r3[n]);
    return i;
  }, Y5 = /%[sdj%]/g;
  kt.format = function(t) {
    if (!Dd(t)) {
      for (var e = [], r3 = 0; r3 < arguments.length; r3++)
        e.push(kn(arguments[r3]));
      return e.join(" ");
    }
    for (var r3 = 1, i = arguments, n = i.length, s = String(t).replace(Y5, function(f2) {
      if (f2 === "%%")
        return "%";
      if (r3 >= n)
        return f2;
      switch (f2) {
        case "%s":
          return String(i[r3++]);
        case "%d":
          return Number(i[r3++]);
        case "%j":
          try {
            return JSON.stringify(i[r3++]);
          } catch {
            return "[Circular]";
          }
        default:
          return f2;
      }
    }), o = i[r3]; r3 < n; o = i[++r3])
      kd(o) || !Fo(o) ? s += " " + o : s += " " + kn(o);
    return s;
  };
  kt.deprecate = function(t, e) {
    if (typeof W.default < "u" && W.default.noDeprecation === true)
      return t;
    if (typeof W.default > "u")
      return function() {
        return kt.deprecate(t, e).apply(this, arguments);
      };
    var r3 = false;
    function i() {
      if (!r3) {
        if (W.default.throwDeprecation)
          throw new Error(e);
        W.default.traceDeprecation ? console.trace(e) : console.error(e), r3 = true;
      }
      return t.apply(this, arguments);
    }
    return i;
  };
  var Sd = {}, Ey = /^$/;
  W.default.env.NODE_DEBUG && (Id = W.default.env.NODE_DEBUG, Id = Id.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), Ey = new RegExp("^" + Id + "$", "i"));
  var Id;
  kt.debuglog = function(t) {
    if (t = t.toUpperCase(), !Sd[t])
      if (Ey.test(t)) {
        var e = W.default.pid;
        Sd[t] = function() {
          var r3 = kt.format.apply(kt, arguments);
          console.error("%s %d: %s", t, e, r3);
        };
      } else
        Sd[t] = function() {
        };
    return Sd[t];
  };
  function kn(t, e) {
    var r3 = { seen: [], stylize: J5 };
    return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), k0(e) ? r3.showHidden = e : e && kt._extend(r3, e), gs(r3.showHidden) && (r3.showHidden = false), gs(r3.depth) && (r3.depth = 2), gs(r3.colors) && (r3.colors = false), gs(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = Z5), Fd(r3, t, r3.depth);
  }
  kt.inspect = kn;
  kn.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
  kn.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
  function Z5(t, e) {
    var r3 = kn.styles[e];
    return r3 ? "\x1B[" + kn.colors[r3][0] + "m" + t + "\x1B[" + kn.colors[r3][1] + "m" : t;
  }
  function J5(t, e) {
    return t;
  }
  function X5(t) {
    var e = {};
    return t.forEach(function(r3, i) {
      e[r3] = true;
    }), e;
  }
  function Fd(t, e, r3) {
    if (t.customInspect && e && Td(e.inspect) && e.inspect !== kt.inspect && !(e.constructor && e.constructor.prototype === e)) {
      var i = e.inspect(r3, t);
      return Dd(i) || (i = Fd(t, i, r3)), i;
    }
    var n = Q5(t, e);
    if (n)
      return n;
    var s = Object.keys(e), o = X5(s);
    if (t.showHidden && (s = Object.getOwnPropertyNames(e)), Af(e) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0))
      return T0(e);
    if (s.length === 0) {
      if (Td(e)) {
        var f2 = e.name ? ": " + e.name : "";
        return t.stylize("[Function" + f2 + "]", "special");
      }
      if (_f(e))
        return t.stylize(RegExp.prototype.toString.call(e), "regexp");
      if (Rd(e))
        return t.stylize(Date.prototype.toString.call(e), "date");
      if (Af(e))
        return T0(e);
    }
    var l = "", g5 = false, _ = ["{", "}"];
    if (My(e) && (g5 = true, _ = ["[", "]"]), Td(e)) {
      var N2 = e.name ? ": " + e.name : "";
      l = " [Function" + N2 + "]";
    }
    if (_f(e) && (l = " " + RegExp.prototype.toString.call(e)), Rd(e) && (l = " " + Date.prototype.toUTCString.call(e)), Af(e) && (l = " " + T0(e)), s.length === 0 && (!g5 || e.length == 0))
      return _[0] + l + _[1];
    if (r3 < 0)
      return _f(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
    t.seen.push(e);
    var U2;
    return g5 ? U2 = e_(t, e, r3, o, s) : U2 = s.map(function(V) {
      return R0(t, e, r3, o, V, g5);
    }), t.seen.pop(), t_(U2, l, _);
  }
  function Q5(t, e) {
    if (gs(e))
      return t.stylize("undefined", "undefined");
    if (Dd(e)) {
      var r3 = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return t.stylize(r3, "string");
    }
    if (Sy(e))
      return t.stylize("" + e, "number");
    if (k0(e))
      return t.stylize("" + e, "boolean");
    if (kd(e))
      return t.stylize("null", "null");
  }
  function T0(t) {
    return "[" + Error.prototype.toString.call(t) + "]";
  }
  function e_(t, e, r3, i, n) {
    for (var s = [], o = 0, f2 = e.length; o < f2; ++o)
      Iy(e, String(o)) ? s.push(R0(t, e, r3, i, String(o), true)) : s.push("");
    return n.forEach(function(l) {
      l.match(/^\d+$/) || s.push(R0(t, e, r3, i, l, true));
    }), s;
  }
  function R0(t, e, r3, i, n, s) {
    var o, f2, l;
    if (l = Object.getOwnPropertyDescriptor(e, n) || { value: e[n] }, l.get ? l.set ? f2 = t.stylize("[Getter/Setter]", "special") : f2 = t.stylize("[Getter]", "special") : l.set && (f2 = t.stylize("[Setter]", "special")), Iy(i, n) || (o = "[" + n + "]"), f2 || (t.seen.indexOf(l.value) < 0 ? (kd(r3) ? f2 = Fd(t, l.value, null) : f2 = Fd(t, l.value, r3 - 1), f2.indexOf(`
`) > -1 && (s ? f2 = f2.split(`
`).map(function(g5) {
      return "  " + g5;
    }).join(`
`).slice(2) : f2 = `
` + f2.split(`
`).map(function(g5) {
      return "   " + g5;
    }).join(`
`))) : f2 = t.stylize("[Circular]", "special")), gs(o)) {
      if (s && n.match(/^\d+$/))
        return f2;
      o = JSON.stringify("" + n), o.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.slice(1, -1), o = t.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = t.stylize(o, "string"));
    }
    return o + ": " + f2;
  }
  function t_(t, e, r3) {
    var i = 0, n = t.reduce(function(s, o) {
      return i++, o.indexOf(`
`) >= 0 && i++, s + o.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return n > 60 ? r3[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + r3[1] : r3[0] + e + " " + t.join(", ") + " " + r3[1];
  }
  kt.types = xy();
  function My(t) {
    return Array.isArray(t);
  }
  kt.isArray = My;
  function k0(t) {
    return typeof t == "boolean";
  }
  kt.isBoolean = k0;
  function kd(t) {
    return t === null;
  }
  kt.isNull = kd;
  function r_(t) {
    return t == null;
  }
  kt.isNullOrUndefined = r_;
  function Sy(t) {
    return typeof t == "number";
  }
  kt.isNumber = Sy;
  function Dd(t) {
    return typeof t == "string";
  }
  kt.isString = Dd;
  function i_(t) {
    return typeof t == "symbol";
  }
  kt.isSymbol = i_;
  function gs(t) {
    return t === void 0;
  }
  kt.isUndefined = gs;
  function _f(t) {
    return Fo(t) && D0(t) === "[object RegExp]";
  }
  kt.isRegExp = _f;
  kt.types.isRegExp = _f;
  function Fo(t) {
    return typeof t == "object" && t !== null;
  }
  kt.isObject = Fo;
  function Rd(t) {
    return Fo(t) && D0(t) === "[object Date]";
  }
  kt.isDate = Rd;
  kt.types.isDate = Rd;
  function Af(t) {
    return Fo(t) && (D0(t) === "[object Error]" || t instanceof Error);
  }
  kt.isError = Af;
  kt.types.isNativeError = Af;
  function Td(t) {
    return typeof t == "function";
  }
  kt.isFunction = Td;
  function n_(t) {
    return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || typeof t > "u";
  }
  kt.isPrimitive = n_;
  kt.isBuffer = _y();
  function D0(t) {
    return Object.prototype.toString.call(t);
  }
  function F0(t) {
    return t < 10 ? "0" + t.toString(10) : t.toString(10);
  }
  var s_ = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function o_() {
    var t = new Date(), e = [F0(t.getHours()), F0(t.getMinutes()), F0(t.getSeconds())].join(":");
    return [t.getDate(), s_[t.getMonth()], e].join(" ");
  }
  kt.log = function() {
    console.log("%s - %s", o_(), kt.format.apply(kt, arguments));
  };
  kt.inherits = At();
  kt._extend = function(t, e) {
    if (!e || !Fo(e))
      return t;
    for (var r3 = Object.keys(e), i = r3.length; i--; )
      t[r3[i]] = e[r3[i]];
    return t;
  };
  function Iy(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  var ps = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  kt.promisify = function(e) {
    if (typeof e != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (ps && e[ps]) {
      var r3 = e[ps];
      if (typeof r3 != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(r3, ps, { value: r3, enumerable: false, writable: false, configurable: true }), r3;
    }
    function r3() {
      for (var i, n, s = new Promise(function(l, g5) {
        i = l, n = g5;
      }), o = [], f2 = 0; f2 < arguments.length; f2++)
        o.push(arguments[f2]);
      o.push(function(l, g5) {
        l ? n(l) : i(g5);
      });
      try {
        e.apply(this, o);
      } catch (l) {
        n(l);
      }
      return s;
    }
    return Object.setPrototypeOf(r3, Object.getPrototypeOf(e)), ps && Object.defineProperty(r3, ps, { value: r3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(r3, Ay(e));
  };
  kt.promisify.custom = ps;
  function a_(t, e) {
    if (!t) {
      var r3 = new Error("Promise was rejected with a falsy value");
      r3.reason = t, t = r3;
    }
    return e(t);
  }
  function f_(t) {
    if (typeof t != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function e() {
      for (var r3 = [], i = 0; i < arguments.length; i++)
        r3.push(arguments[i]);
      var n = r3.pop();
      if (typeof n != "function")
        throw new TypeError("The last argument must be of type Function");
      var s = this, o = function() {
        return n.apply(s, arguments);
      };
      t.apply(this, r3).then(function(f2) {
        W.default.nextTick(o.bind(null, null, f2));
      }, function(f2) {
        W.default.nextTick(a_.bind(null, f2, o));
      });
    }
    return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Object.defineProperties(e, Ay(t)), e;
  }
  kt.callbackify = f_;
});
var ky = k((Sk, Ry) => {
  U();
  function Ty(t, e) {
    var r3 = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(t);
      e && (i = i.filter(function(n) {
        return Object.getOwnPropertyDescriptor(t, n).enumerable;
      })), r3.push.apply(r3, i);
    }
    return r3;
  }
  function Fy(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r3 = arguments[e] != null ? arguments[e] : {};
      e % 2 ? Ty(Object(r3), true).forEach(function(i) {
        c_(t, i, r3[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r3)) : Ty(Object(r3)).forEach(function(i) {
        Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r3, i));
      });
    }
    return t;
  }
  function c_(t, e, r3) {
    return e = u_(e), e in t ? Object.defineProperty(t, e, { value: r3, enumerable: true, configurable: true, writable: true }) : t[e] = r3, t;
  }
  function u_(t) {
    var e = d_(t, "string");
    return typeof e == "symbol" ? e : String(e);
  }
  function d_(t, e) {
    if (typeof t != "object" || t === null)
      return t;
    var r3 = t[Symbol.toPrimitive];
    if (r3 !== void 0) {
      var i = r3.call(t, e || "default");
      if (typeof i != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e === "string" ? String : Number)(t);
  }
  var l_ = or(), Nd = l_.Buffer, h_ = N0(), B0 = h_.inspect, p_ = B0 && B0.custom || "inspect";
  function g_(t, e, r3) {
    Nd.prototype.copy.call(t, e, r3);
  }
  Ry.exports = class {
    constructor() {
      this.head = null, this.tail = null, this.length = 0;
    }
    push(e) {
      let r3 = { data: e, next: null };
      this.length > 0 ? this.tail.next = r3 : this.head = r3, this.tail = r3, ++this.length;
    }
    unshift(e) {
      let r3 = { data: e, next: this.head };
      this.length === 0 && (this.tail = r3), this.head = r3, ++this.length;
    }
    shift() {
      if (this.length === 0)
        return;
      let e = this.head.data;
      return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
    }
    clear() {
      this.head = this.tail = null, this.length = 0;
    }
    join(e) {
      if (this.length === 0)
        return "";
      for (var r3 = this.head, i = "" + r3.data; r3 = r3.next; )
        i += e + r3.data;
      return i;
    }
    concat(e) {
      if (this.length === 0)
        return Nd.alloc(0);
      let r3 = Nd.allocUnsafe(e >>> 0);
      for (var i = this.head, n = 0; i; )
        g_(i.data, r3, n), n += i.data.length, i = i.next;
      return r3;
    }
    consume(e, r3) {
      var i;
      return e < this.head.data.length ? (i = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : e === this.head.data.length ? i = this.shift() : i = r3 ? this._getString(e) : this._getBuffer(e), i;
    }
    first() {
      return this.head.data;
    }
    _getString(e) {
      var r3 = this.head, i = 1, n = r3.data;
      for (e -= n.length; r3 = r3.next; ) {
        let s = r3.data, o = e > s.length ? s.length : e;
        if (o === s.length ? n += s : n += s.slice(0, e), e -= o, e === 0) {
          o === s.length ? (++i, r3.next ? this.head = r3.next : this.head = this.tail = null) : (this.head = r3, r3.data = s.slice(o));
          break;
        }
        ++i;
      }
      return this.length -= i, n;
    }
    _getBuffer(e) {
      let r3 = Nd.allocUnsafe(e);
      var i = this.head, n = 1;
      for (i.data.copy(r3), e -= i.data.length; i = i.next; ) {
        let s = i.data, o = e > s.length ? s.length : e;
        if (s.copy(r3, r3.length - e, 0, o), e -= o, e === 0) {
          o === s.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = s.slice(o));
          break;
        }
        ++n;
      }
      return this.length -= n, r3;
    }
    [p_](e, r3) {
      return B0(this, Fy(Fy({}, r3), {}, { depth: 0, customInspect: false }));
    }
  };
});
var O0 = k((Ik, Ny) => {
  U();
  function m_(t, e) {
    let r3 = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
    return r3 || i ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, W.default.nextTick(C0, this, t)) : W.default.nextTick(C0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, (n) => {
      !e && n ? this._writableState ? this._writableState.errorEmitted ? W.default.nextTick(Bd, this) : (this._writableState.errorEmitted = true, W.default.nextTick(Dy, this, n)) : W.default.nextTick(Dy, this, n) : e ? (W.default.nextTick(Bd, this), e(n)) : W.default.nextTick(Bd, this);
    }), this);
  }
  function Dy(t, e) {
    C0(t, e), Bd(t);
  }
  function Bd(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
  }
  function y_() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function C0(t, e) {
    t.emit("error", e);
  }
  function b_(t, e) {
    let r3 = t._readableState, i = t._writableState;
    r3 && r3.autoDestroy || i && i.autoDestroy ? t.destroy(e) : t.emit("error", e);
  }
  Ny.exports = { destroy: m_, undestroy: y_, errorOrDestroy: b_ };
});
var ms = k((Tk, Oy) => {
  U();
  function v_(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var Cy = {};
  function Vr(t, e, r3) {
    r3 || (r3 = Error);
    function i(s, o, f2) {
      return typeof e == "string" ? e : e(s, o, f2);
    }
    var n = function(s) {
      v_(o, s);
      function o(f2, l, g5) {
        return s.call(this, i(f2, l, g5)) || this;
      }
      return o;
    }(r3);
    n.prototype.name = r3.name, n.prototype.code = t, Cy[t] = n;
  }
  function By(t, e) {
    if (Array.isArray(t)) {
      var r3 = t.length;
      return t = t.map(function(i) {
        return String(i);
      }), r3 > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r3 - 1).join(", "), ", or ") + t[r3 - 1] : r3 === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
    } else
      return "of ".concat(e, " ").concat(String(t));
  }
  function x_(t, e, r3) {
    return t.substr(!r3 || r3 < 0 ? 0 : +r3, e.length) === e;
  }
  function w_(t, e, r3) {
    return (r3 === void 0 || r3 > t.length) && (r3 = t.length), t.substring(r3 - e.length, r3) === e;
  }
  function __(t, e, r3) {
    return typeof r3 != "number" && (r3 = 0), r3 + e.length > t.length ? false : t.indexOf(e, r3) !== -1;
  }
  Vr("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  }, TypeError);
  Vr("ERR_INVALID_ARG_TYPE", function(t, e, r3) {
    var i;
    typeof e == "string" && x_(e, "not ") ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be";
    var n;
    if (w_(t, " argument"))
      n = "The ".concat(t, " ").concat(i, " ").concat(By(e, "type"));
    else {
      var s = __(t, ".") ? "property" : "argument";
      n = 'The "'.concat(t, '" ').concat(s, " ").concat(i, " ").concat(By(e, "type"));
    }
    return n += ". Received type ".concat(typeof r3), n;
  }, TypeError);
  Vr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  Vr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented";
  });
  Vr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  Vr("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed";
  });
  Vr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  Vr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  Vr("ERR_STREAM_WRITE_AFTER_END", "write after end");
  Vr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  Vr("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t;
  }, TypeError);
  Vr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  Oy.exports.codes = Cy;
});
var j0 = k((Fk, jy) => {
  U();
  var A_ = ms().codes.ERR_INVALID_OPT_VALUE;
  function E_(t, e, r3) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r3] : null;
  }
  function M_(t, e, r3, i) {
    let n = E_(e, i, r3);
    if (n != null) {
      if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
        let s = i ? r3 : "highWaterMark";
        throw new A_(s, n);
      }
      return Math.floor(n);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  jy.exports = { getHighWaterMark: M_ };
});
var qy = k((Rk, Ly) => {
  U();
  Ly.exports = S_;
  function S_(t, e) {
    if (L0("noDeprecation"))
      return t;
    var r3 = false;
    function i() {
      if (!r3) {
        if (L0("throwDeprecation"))
          throw new Error(e);
        L0("traceDeprecation") ? console.trace(e) : console.warn(e), r3 = true;
      }
      return t.apply(this, arguments);
    }
    return i;
  }
  function L0(t) {
    try {
      if (!N.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = N.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var jd = k((kk, Gy) => {
  U();
  Gy.exports = rr2;
  function Uy(t) {
    this.next = null, this.entry = null, this.finish = () => {
      Q_(this, t);
    };
  }
  var Ro;
  rr2.WritableState = Mf;
  var I_ = { deprecate: qy() }, zy = n0(), Od = or().Buffer, T_ = (typeof N < "u" ? N : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function F_(t) {
    return Od.from(t);
  }
  function R_(t) {
    return Od.isBuffer(t) || t instanceof T_;
  }
  var P0 = O0(), k_ = j0(), D_ = k_.getHighWaterMark, Dn = ms().codes, N_ = Dn.ERR_INVALID_ARG_TYPE, B_ = Dn.ERR_METHOD_NOT_IMPLEMENTED, C_ = Dn.ERR_MULTIPLE_CALLBACK, O_ = Dn.ERR_STREAM_CANNOT_PIPE, j_ = Dn.ERR_STREAM_DESTROYED, L_ = Dn.ERR_STREAM_NULL_VALUES, q_ = Dn.ERR_STREAM_WRITE_AFTER_END, P_ = Dn.ERR_UNKNOWN_ENCODING, ko = P0.errorOrDestroy;
  At()(rr2, zy);
  function U_() {
  }
  function Mf(t, e, r3) {
    Ro = Ro || Nn(), t = t || {}, typeof r3 != "boolean" && (r3 = e instanceof Ro), this.objectMode = !!t.objectMode, r3 && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = D_(this, t, "writableHighWaterMark", r3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var i = t.decodeStrings === false;
    this.decodeStrings = !i, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(n) {
      V_(e, n);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Uy(this);
  }
  Mf.prototype.getBuffer = function() {
    for (var e = this.bufferedRequest, r3 = []; e; )
      r3.push(e), e = e.next;
    return r3;
  };
  (function() {
    try {
      Object.defineProperty(Mf.prototype, "buffer", { get: I_.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var Cd;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Cd = Function.prototype[Symbol.hasInstance], Object.defineProperty(rr2, Symbol.hasInstance, { value: function(e) {
    return Cd.call(this, e) ? true : this !== rr2 ? false : e && e._writableState instanceof Mf;
  } })) : Cd = function(e) {
    return e instanceof this;
  };
  function rr2(t) {
    Ro = Ro || Nn();
    let e = this instanceof Ro;
    if (!e && !Cd.call(rr2, this))
      return new rr2(t);
    this._writableState = new Mf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), zy.call(this);
  }
  rr2.prototype.pipe = function() {
    ko(this, new O_());
  };
  function z_(t, e) {
    var r3 = new q_();
    ko(t, r3), W.default.nextTick(e, r3);
  }
  function H_(t, e, r3, i) {
    var n;
    return r3 === null ? n = new L_() : typeof r3 != "string" && !e.objectMode && (n = new N_("chunk", ["string", "Buffer"], r3)), n ? (ko(t, n), W.default.nextTick(i, n), false) : true;
  }
  rr2.prototype.write = function(t, e, r3) {
    var i = this._writableState, n = false, s = !i.objectMode && R_(t);
    return s && !Od.isBuffer(t) && (t = F_(t)), typeof e == "function" && (r3 = e, e = null), s ? e = "buffer" : e || (e = i.defaultEncoding), typeof r3 != "function" && (r3 = U_), i.ending ? z_(this, r3) : (s || H_(this, i, t, r3)) && (i.pendingcb++, n = G_(this, i, s, t, e, r3)), n;
  };
  rr2.prototype.cork = function() {
    this._writableState.corked++;
  };
  rr2.prototype.uncork = function() {
    var t = this._writableState;
    t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Hy(this, t));
  };
  rr2.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
      throw new P_(e);
    return this._writableState.defaultEncoding = e, this;
  };
  Object.defineProperty(rr2.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function K_(t, e, r3) {
    return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = Od.from(e, r3)), e;
  }
  Object.defineProperty(rr2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function G_(t, e, r3, i, n, s) {
    if (!r3) {
      var o = K_(e, i, n);
      i !== o && (r3 = true, n = "buffer", i = o);
    }
    var f2 = e.objectMode ? 1 : i.length;
    e.length += f2;
    var l = e.length < e.highWaterMark;
    if (l || (e.needDrain = true), e.writing || e.corked) {
      var g5 = e.lastBufferedRequest;
      e.lastBufferedRequest = { chunk: i, encoding: n, isBuf: r3, callback: s, next: null }, g5 ? g5.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
    } else
      q0(t, e, false, f2, i, n, s);
    return l;
  }
  function q0(t, e, r3, i, n, s, o) {
    e.writelen = i, e.writecb = o, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new j_("write")) : r3 ? t._writev(n, e.onwrite) : t._write(n, s, e.onwrite), e.sync = false;
  }
  function $_(t, e, r3, i, n) {
    --e.pendingcb, r3 ? (W.default.nextTick(n, i), W.default.nextTick(Ef, t, e), t._writableState.errorEmitted = true, ko(t, i)) : (n(i), t._writableState.errorEmitted = true, ko(t, i), Ef(t, e));
  }
  function W_(t) {
    t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
  }
  function V_(t, e) {
    var r3 = t._writableState, i = r3.sync, n = r3.writecb;
    if (typeof n != "function")
      throw new C_();
    if (W_(r3), e)
      $_(t, r3, i, e, n);
    else {
      var s = Ky(r3) || t.destroyed;
      !s && !r3.corked && !r3.bufferProcessing && r3.bufferedRequest && Hy(t, r3), i ? W.default.nextTick(Py, t, r3, s, n) : Py(t, r3, s, n);
    }
  }
  function Py(t, e, r3, i) {
    r3 || Y_(t, e), e.pendingcb--, i(), Ef(t, e);
  }
  function Y_(t, e) {
    e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
  }
  function Hy(t, e) {
    e.bufferProcessing = true;
    var r3 = e.bufferedRequest;
    if (t._writev && r3 && r3.next) {
      var i = e.bufferedRequestCount, n = new Array(i), s = e.corkedRequestsFree;
      s.entry = r3;
      for (var o = 0, f2 = true; r3; )
        n[o] = r3, r3.isBuf || (f2 = false), r3 = r3.next, o += 1;
      n.allBuffers = f2, q0(t, e, true, e.length, n, "", s.finish), e.pendingcb++, e.lastBufferedRequest = null, s.next ? (e.corkedRequestsFree = s.next, s.next = null) : e.corkedRequestsFree = new Uy(e), e.bufferedRequestCount = 0;
    } else {
      for (; r3; ) {
        var l = r3.chunk, g5 = r3.encoding, _ = r3.callback, N2 = e.objectMode ? 1 : l.length;
        if (q0(t, e, false, N2, l, g5, _), r3 = r3.next, e.bufferedRequestCount--, e.writing)
          break;
      }
      r3 === null && (e.lastBufferedRequest = null);
    }
    e.bufferedRequest = r3, e.bufferProcessing = false;
  }
  rr2.prototype._write = function(t, e, r3) {
    r3(new B_("_write()"));
  };
  rr2.prototype._writev = null;
  rr2.prototype.end = function(t, e, r3) {
    var i = this._writableState;
    return typeof t == "function" ? (r3 = t, t = null, e = null) : typeof e == "function" && (r3 = e, e = null), t != null && this.write(t, e), i.corked && (i.corked = 1, this.uncork()), i.ending || X_(this, i, r3), this;
  };
  Object.defineProperty(rr2.prototype, "writableLength", { enumerable: false, get() {
    return this._writableState.length;
  } });
  function Ky(t) {
    return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
  }
  function Z_(t, e) {
    t._final((r3) => {
      e.pendingcb--, r3 && ko(t, r3), e.prefinished = true, t.emit("prefinish"), Ef(t, e);
    });
  }
  function J_(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, W.default.nextTick(Z_, t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function Ef(t, e) {
    var r3 = Ky(e);
    if (r3 && (J_(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
      let i = t._readableState;
      (!i || i.autoDestroy && i.endEmitted) && t.destroy();
    }
    return r3;
  }
  function X_(t, e, r3) {
    e.ending = true, Ef(t, e), r3 && (e.finished ? W.default.nextTick(r3) : t.once("finish", r3)), e.ended = true, t.writable = false;
  }
  function Q_(t, e, r3) {
    var i = t.entry;
    for (t.entry = null; i; ) {
      var n = i.callback;
      e.pendingcb--, n(r3), i = i.next;
    }
    e.corkedRequestsFree.next = t;
  }
  Object.defineProperty(rr2.prototype, "destroyed", { enumerable: false, get() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set(t) {
    !this._writableState || (this._writableState.destroyed = t);
  } });
  rr2.prototype.destroy = P0.destroy;
  rr2.prototype._undestroy = P0.undestroy;
  rr2.prototype._destroy = function(t, e) {
    e(t);
  };
});
var Nn = k((Dk, Wy) => {
  U();
  var e9 = Object.keys || function(t) {
    var e = [];
    for (var r3 in t)
      e.push(r3);
    return e;
  };
  Wy.exports = Oi;
  var $y = qd(), U0 = jd();
  At()(Oi, $y);
  {
    let t = e9(U0.prototype);
    for (Ld = 0; Ld < t.length; Ld++) {
      let e = t[Ld];
      Oi.prototype[e] || (Oi.prototype[e] = U0.prototype[e]);
    }
  }
  var Ld;
  function Oi(t) {
    if (!(this instanceof Oi))
      return new Oi(t);
    $y.call(this, t), U0.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", t9)));
  }
  Object.defineProperty(Oi.prototype, "writableHighWaterMark", { enumerable: false, get() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty(Oi.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty(Oi.prototype, "writableLength", { enumerable: false, get() {
    return this._writableState.length;
  } });
  function t9() {
    this._writableState.ended || W.default.nextTick(r9, this);
  }
  function r9(t) {
    t.end();
  }
  Object.defineProperty(Oi.prototype, "destroyed", { enumerable: false, get() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set(t) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
  } });
});
var Pd = k((Yy) => {
  U();
  var H0 = Mt().Buffer, Vy = H0.isEncoding || function(t) {
    switch (t = "" + t, t && t.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function i9(t) {
    if (!t)
      return "utf8";
    for (var e; ; )
      switch (t) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t;
        default:
          if (e)
            return;
          t = ("" + t).toLowerCase(), e = true;
      }
  }
  function n9(t) {
    var e = i9(t);
    if (typeof e != "string" && (H0.isEncoding === Vy || !Vy(t)))
      throw new Error("Unknown encoding: " + t);
    return e || t;
  }
  Yy.StringDecoder = Sf;
  function Sf(t) {
    this.encoding = n9(t);
    var e;
    switch (this.encoding) {
      case "utf16le":
        this.text = u9, this.end = d9, e = 4;
        break;
      case "utf8":
        this.fillLast = a9, e = 4;
        break;
      case "base64":
        this.text = l9, this.end = h9, e = 3;
        break;
      default:
        this.write = p9, this.end = g9;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = H0.allocUnsafe(e);
  }
  Sf.prototype.write = function(t) {
    if (t.length === 0)
      return "";
    var e, r3;
    if (this.lastNeed) {
      if (e = this.fillLast(t), e === void 0)
        return "";
      r3 = this.lastNeed, this.lastNeed = 0;
    } else
      r3 = 0;
    return r3 < t.length ? e ? e + this.text(t, r3) : this.text(t, r3) : e || "";
  };
  Sf.prototype.end = c9;
  Sf.prototype.text = f9;
  Sf.prototype.fillLast = function(t) {
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
  };
  function z0(t) {
    return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
  }
  function s9(t, e, r3) {
    var i = e.length - 1;
    if (i < r3)
      return 0;
    var n = z0(e[i]);
    return n >= 0 ? (n > 0 && (t.lastNeed = n - 1), n) : --i < r3 || n === -2 ? 0 : (n = z0(e[i]), n >= 0 ? (n > 0 && (t.lastNeed = n - 2), n) : --i < r3 || n === -2 ? 0 : (n = z0(e[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : t.lastNeed = n - 3), n) : 0));
  }
  function o9(t, e, r3) {
    if ((e[0] & 192) !== 128)
      return t.lastNeed = 0, "";
    if (t.lastNeed > 1 && e.length > 1) {
      if ((e[1] & 192) !== 128)
        return t.lastNeed = 1, "";
      if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
        return t.lastNeed = 2, "";
    }
  }
  function a9(t) {
    var e = this.lastTotal - this.lastNeed, r3 = o9(this, t);
    if (r3 !== void 0)
      return r3;
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
  }
  function f9(t, e) {
    var r3 = s9(this, t, e);
    if (!this.lastNeed)
      return t.toString("utf8", e);
    this.lastTotal = r3;
    var i = t.length - (r3 - this.lastNeed);
    return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i);
  }
  function c9(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + "" : e;
  }
  function u9(t, e) {
    if ((t.length - e) % 2 === 0) {
      var r3 = t.toString("utf16le", e);
      if (r3) {
        var i = r3.charCodeAt(r3.length - 1);
        if (i >= 55296 && i <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r3.slice(0, -1);
      }
      return r3;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
  }
  function d9(t) {
    var e = t && t.length ? this.write(t) : "";
    if (this.lastNeed) {
      var r3 = this.lastTotal - this.lastNeed;
      return e + this.lastChar.toString("utf16le", 0, r3);
    }
    return e;
  }
  function l9(t, e) {
    var r3 = (t.length - e) % 3;
    return r3 === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r3, this.lastTotal = 3, r3 === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r3));
  }
  function h9(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
  }
  function p9(t) {
    return t.toString(this.encoding);
  }
  function g9(t) {
    return t && t.length ? this.write(t) : "";
  }
});
var If = k((Bk, Xy) => {
  U();
  var Zy = ms().codes.ERR_STREAM_PREMATURE_CLOSE;
  function m9(t) {
    let e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r3 = arguments.length, i = new Array(r3), n = 0; n < r3; n++)
          i[n] = arguments[n];
        t.apply(this, i);
      }
    };
  }
  function y9() {
  }
  function b9(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function Jy(t, e, r3) {
    if (typeof e == "function")
      return Jy(t, null, e);
    e || (e = {}), r3 = m9(r3 || y9);
    let i = e.readable || e.readable !== false && t.readable, n = e.writable || e.writable !== false && t.writable, s = () => {
      t.writable || f2();
    };
    var o = t._writableState && t._writableState.finished;
    let f2 = () => {
      n = false, o = true, i || r3.call(t);
    };
    var l = t._readableState && t._readableState.endEmitted;
    let g5 = () => {
      i = false, l = true, n || r3.call(t);
    }, _ = (V) => {
      r3.call(t, V);
    }, N2 = () => {
      let V;
      if (i && !l)
        return (!t._readableState || !t._readableState.ended) && (V = new Zy()), r3.call(t, V);
      if (n && !o)
        return (!t._writableState || !t._writableState.ended) && (V = new Zy()), r3.call(t, V);
    }, U2 = () => {
      t.req.on("finish", f2);
    };
    return b9(t) ? (t.on("complete", f2), t.on("abort", N2), t.req ? U2() : t.on("request", U2)) : n && !t._writableState && (t.on("end", s), t.on("close", s)), t.on("end", g5), t.on("finish", f2), e.error !== false && t.on("error", _), t.on("close", N2), function() {
      t.removeListener("complete", f2), t.removeListener("abort", N2), t.removeListener("request", U2), t.req && t.req.removeListener("finish", f2), t.removeListener("end", s), t.removeListener("close", s), t.removeListener("finish", f2), t.removeListener("end", g5), t.removeListener("error", _), t.removeListener("close", N2);
    };
  }
  Xy.exports = Jy;
});
var eb = k((Ck, Qy) => {
  U();
  var v9 = If(), Bn = Symbol("lastResolve"), ys = Symbol("lastReject"), Tf = Symbol("error"), Ud = Symbol("ended"), bs = Symbol("lastPromise"), K0 = Symbol("handlePromise"), vs = Symbol("stream");
  function Cn(t, e) {
    return { value: t, done: e };
  }
  function x9(t) {
    let e = t[Bn];
    if (e !== null) {
      let r3 = t[vs].read();
      r3 !== null && (t[bs] = null, t[Bn] = null, t[ys] = null, e(Cn(r3, false)));
    }
  }
  function w9(t) {
    W.default.nextTick(x9, t);
  }
  function _9(t, e) {
    return (r3, i) => {
      t.then(() => {
        if (e[Ud]) {
          r3(Cn(void 0, true));
          return;
        }
        e[K0](r3, i);
      }, i);
    };
  }
  var A9 = Object.getPrototypeOf(function() {
  }), E9 = Object.setPrototypeOf({ get stream() {
    return this[vs];
  }, next() {
    let t = this[Tf];
    if (t !== null)
      return Promise.reject(t);
    if (this[Ud])
      return Promise.resolve(Cn(void 0, true));
    if (this[vs].destroyed)
      return new Promise((i, n) => {
        W.default.nextTick(() => {
          this[Tf] ? n(this[Tf]) : i(Cn(void 0, true));
        });
      });
    let e = this[bs], r3;
    if (e)
      r3 = new Promise(_9(e, this));
    else {
      let i = this[vs].read();
      if (i !== null)
        return Promise.resolve(Cn(i, false));
      r3 = new Promise(this[K0]);
    }
    return this[bs] = r3, r3;
  }, [Symbol.asyncIterator]() {
    return this;
  }, return() {
    return new Promise((t, e) => {
      this[vs].destroy(null, (r3) => {
        if (r3) {
          e(r3);
          return;
        }
        t(Cn(void 0, true));
      });
    });
  } }, A9), M9 = (t) => {
    let e = Object.create(E9, { [vs]: { value: t, writable: true }, [Bn]: { value: null, writable: true }, [ys]: { value: null, writable: true }, [Tf]: { value: null, writable: true }, [Ud]: { value: t._readableState.endEmitted, writable: true }, [K0]: { value: (r3, i) => {
      let n = e[vs].read();
      n ? (e[bs] = null, e[Bn] = null, e[ys] = null, r3(Cn(n, false))) : (e[Bn] = r3, e[ys] = i);
    }, writable: true } });
    return e[bs] = null, v9(t, (r3) => {
      if (r3 && r3.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        let n = e[ys];
        n !== null && (e[bs] = null, e[Bn] = null, e[ys] = null, n(r3)), e[Tf] = r3;
        return;
      }
      let i = e[Bn];
      i !== null && (e[bs] = null, e[Bn] = null, e[ys] = null, i(Cn(void 0, true))), e[Ud] = true;
    }), t.on("readable", w9.bind(null, e)), e;
  };
  Qy.exports = M9;
});
var rb = k((Ok, tb) => {
  U();
  tb.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var qd = k((Lk, lb) => {
  U();
  lb.exports = qt;
  var Do;
  qt.ReadableState = ob;
  cd().EventEmitter;
  var sb = function(e, r3) {
    return e.listeners(r3).length;
  }, Rf = n0(), zd = or().Buffer, S9 = (typeof N < "u" ? N : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function I9(t) {
    return zd.from(t);
  }
  function T9(t) {
    return zd.isBuffer(t) || t instanceof S9;
  }
  var G0 = N0(), Ft;
  G0 && G0.debuglog ? Ft = G0.debuglog("stream") : Ft = function() {
  };
  var F9 = ky(), X0 = O0(), R9 = j0(), k9 = R9.getHighWaterMark, Hd = ms().codes, D9 = Hd.ERR_INVALID_ARG_TYPE, N9 = Hd.ERR_STREAM_PUSH_AFTER_EOF, B9 = Hd.ERR_METHOD_NOT_IMPLEMENTED, C9 = Hd.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, No, $0, W0;
  At()(qt, Rf);
  var Ff = X0.errorOrDestroy, V0 = ["error", "close", "destroy", "pause", "resume"];
  function O9(t, e, r3) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r3);
    !t._events || !t._events[e] ? t.on(e, r3) : Array.isArray(t._events[e]) ? t._events[e].unshift(r3) : t._events[e] = [r3, t._events[e]];
  }
  function ob(t, e, r3) {
    Do = Do || Nn(), t = t || {}, typeof r3 != "boolean" && (r3 = e instanceof Do), this.objectMode = !!t.objectMode, r3 && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = k9(this, t, "readableHighWaterMark", r3), this.buffer = new F9(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (No || (No = Pd().StringDecoder), this.decoder = new No(t.encoding), this.encoding = t.encoding);
  }
  function qt(t) {
    if (Do = Do || Nn(), !(this instanceof qt))
      return new qt(t);
    let e = this instanceof Do;
    this._readableState = new ob(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Rf.call(this);
  }
  Object.defineProperty(qt.prototype, "destroyed", { enumerable: false, get() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set(t) {
    !this._readableState || (this._readableState.destroyed = t);
  } });
  qt.prototype.destroy = X0.destroy;
  qt.prototype._undestroy = X0.undestroy;
  qt.prototype._destroy = function(t, e) {
    e(t);
  };
  qt.prototype.push = function(t, e) {
    var r3 = this._readableState, i;
    return r3.objectMode ? i = true : typeof t == "string" && (e = e || r3.defaultEncoding, e !== r3.encoding && (t = zd.from(t, e), e = ""), i = true), ab(this, t, e, false, i);
  };
  qt.prototype.unshift = function(t) {
    return ab(this, t, null, true, false);
  };
  function ab(t, e, r3, i, n) {
    Ft("readableAddChunk", e);
    var s = t._readableState;
    if (e === null)
      s.reading = false, q9(t, s);
    else {
      var o;
      if (n || (o = j9(s, e)), o)
        Ff(t, o);
      else if (s.objectMode || e && e.length > 0)
        if (typeof e != "string" && !s.objectMode && Object.getPrototypeOf(e) !== zd.prototype && (e = I9(e)), i)
          s.endEmitted ? Ff(t, new C9()) : Y0(t, s, e, true);
        else if (s.ended)
          Ff(t, new N9());
        else {
          if (s.destroyed)
            return false;
          s.reading = false, s.decoder && !r3 ? (e = s.decoder.write(e), s.objectMode || e.length !== 0 ? Y0(t, s, e, false) : J0(t, s)) : Y0(t, s, e, false);
        }
      else
        i || (s.reading = false, J0(t, s));
    }
    return !s.ended && (s.length < s.highWaterMark || s.length === 0);
  }
  function Y0(t, e, r3, i) {
    e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r3)) : (e.length += e.objectMode ? 1 : r3.length, i ? e.buffer.unshift(r3) : e.buffer.push(r3), e.needReadable && Kd(t)), J0(t, e);
  }
  function j9(t, e) {
    var r3;
    return !T9(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r3 = new D9("chunk", ["string", "Buffer", "Uint8Array"], e)), r3;
  }
  qt.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  qt.prototype.setEncoding = function(t) {
    No || (No = Pd().StringDecoder);
    let e = new No(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    let r3 = this._readableState.buffer.head, i = "";
    for (; r3 !== null; )
      i += e.write(r3.data), r3 = r3.next;
    return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
  };
  var ib = 1073741824;
  function L9(t) {
    return t >= ib ? t = ib : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
  }
  function nb(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = L9(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
  }
  qt.prototype.read = function(t) {
    Ft("read", t), t = parseInt(t, 10);
    var e = this._readableState, r3 = t;
    if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return Ft("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Z0(this) : Kd(this), null;
    if (t = nb(t, e), t === 0 && e.ended)
      return e.length === 0 && Z0(this), null;
    var i = e.needReadable;
    Ft("need readable", i), (e.length === 0 || e.length - t < e.highWaterMark) && (i = true, Ft("length less than watermark", i)), e.ended || e.reading ? (i = false, Ft("reading or ended", i)) : i && (Ft("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = nb(r3, e)));
    var n;
    return t > 0 ? n = ub(t, e) : n = null, n === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r3 !== t && e.ended && Z0(this)), n !== null && this.emit("data", n), n;
  };
  function q9(t, e) {
    if (Ft("onEofChunk"), !e.ended) {
      if (e.decoder) {
        var r3 = e.decoder.end();
        r3 && r3.length && (e.buffer.push(r3), e.length += e.objectMode ? 1 : r3.length);
      }
      e.ended = true, e.sync ? Kd(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, fb(t)));
    }
  }
  function Kd(t) {
    var e = t._readableState;
    Ft("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ft("emitReadable", e.flowing), e.emittedReadable = true, W.default.nextTick(fb, t));
  }
  function fb(t) {
    var e = t._readableState;
    Ft("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, Q0(t);
  }
  function J0(t, e) {
    e.readingMore || (e.readingMore = true, W.default.nextTick(P9, t, e));
  }
  function P9(t, e) {
    for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      let r3 = e.length;
      if (Ft("maybeReadMore read 0"), t.read(0), r3 === e.length)
        break;
    }
    e.readingMore = false;
  }
  qt.prototype._read = function(t) {
    Ff(this, new B9("_read()"));
  };
  qt.prototype.pipe = function(t, e) {
    var r3 = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = t;
        break;
      case 1:
        i.pipes = [i.pipes, t];
        break;
      default:
        i.pipes.push(t);
        break;
    }
    i.pipesCount += 1, Ft("pipe count=%d opts=%j", i.pipesCount, e);
    var n = (!e || e.end !== false) && t !== W.default.stdout && t !== W.default.stderr, s = n ? f2 : ee2;
    i.endEmitted ? W.default.nextTick(s) : r3.once("end", s), t.on("unpipe", o);
    function o(W5, Z) {
      Ft("onunpipe"), W5 === r3 && Z && Z.hasUnpiped === false && (Z.hasUnpiped = true, _());
    }
    function f2() {
      Ft("onend"), t.end();
    }
    var l = U9(r3);
    t.on("drain", l);
    var g5 = false;
    function _() {
      Ft("cleanup"), t.removeListener("close", V), t.removeListener("finish", G), t.removeListener("drain", l), t.removeListener("error", U2), t.removeListener("unpipe", o), r3.removeListener("end", f2), r3.removeListener("end", ee2), r3.removeListener("data", N2), g5 = true, i.awaitDrain && (!t._writableState || t._writableState.needDrain) && l();
    }
    r3.on("data", N2);
    function N2(W5) {
      Ft("ondata");
      var Z = t.write(W5);
      Ft("dest.write", Z), Z === false && ((i.pipesCount === 1 && i.pipes === t || i.pipesCount > 1 && db(i.pipes, t) !== -1) && !g5 && (Ft("false write response, pause", i.awaitDrain), i.awaitDrain++), r3.pause());
    }
    function U2(W5) {
      Ft("onerror", W5), ee2(), t.removeListener("error", U2), sb(t, "error") === 0 && Ff(t, W5);
    }
    O9(t, "error", U2);
    function V() {
      t.removeListener("finish", G), ee2();
    }
    t.once("close", V);
    function G() {
      Ft("onfinish"), t.removeListener("close", V), ee2();
    }
    t.once("finish", G);
    function ee2() {
      Ft("unpipe"), r3.unpipe(t);
    }
    return t.emit("pipe", r3), i.flowing || (Ft("pipe resume"), r3.resume()), t;
  };
  function U9(t) {
    return function() {
      var r3 = t._readableState;
      Ft("pipeOnDrain", r3.awaitDrain), r3.awaitDrain && r3.awaitDrain--, r3.awaitDrain === 0 && sb(t, "data") && (r3.flowing = true, Q0(t));
    };
  }
  qt.prototype.unpipe = function(t) {
    var e = this._readableState, r3 = { hasUnpiped: false };
    if (e.pipesCount === 0)
      return this;
    if (e.pipesCount === 1)
      return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r3), this);
    if (!t) {
      var i = e.pipes, n = e.pipesCount;
      e.pipes = null, e.pipesCount = 0, e.flowing = false;
      for (var s = 0; s < n; s++)
        i[s].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var o = db(e.pipes, t);
    return o === -1 ? this : (e.pipes.splice(o, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r3), this);
  };
  qt.prototype.on = function(t, e) {
    let r3 = Rf.prototype.on.call(this, t, e), i = this._readableState;
    return t === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== false && this.resume()) : t === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = true, i.flowing = false, i.emittedReadable = false, Ft("on readable", i.length, i.reading), i.length ? Kd(this) : i.reading || W.default.nextTick(z9, this)), r3;
  };
  qt.prototype.addListener = qt.prototype.on;
  qt.prototype.removeListener = function(t, e) {
    let r3 = Rf.prototype.removeListener.call(this, t, e);
    return t === "readable" && W.default.nextTick(cb, this), r3;
  };
  qt.prototype.removeAllListeners = function(t) {
    let e = Rf.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === void 0) && W.default.nextTick(cb, this), e;
  };
  function cb(t) {
    let e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
  }
  function z9(t) {
    Ft("readable nexttick read 0"), t.read(0);
  }
  qt.prototype.resume = function() {
    var t = this._readableState;
    return t.flowing || (Ft("resume"), t.flowing = !t.readableListening, H9(this, t)), t.paused = false, this;
  };
  function H9(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, W.default.nextTick(K9, t, e));
  }
  function K9(t, e) {
    Ft("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), Q0(t), e.flowing && !e.reading && t.read(0);
  }
  qt.prototype.pause = function() {
    return Ft("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ft("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function Q0(t) {
    let e = t._readableState;
    for (Ft("flow", e.flowing); e.flowing && t.read() !== null; )
      ;
  }
  qt.prototype.wrap = function(t) {
    var e = this._readableState, r3 = false;
    t.on("end", () => {
      if (Ft("wrapped end"), e.decoder && !e.ended) {
        var s = e.decoder.end();
        s && s.length && this.push(s);
      }
      this.push(null);
    }), t.on("data", (s) => {
      if (Ft("wrapped data"), e.decoder && (s = e.decoder.write(s)), !(e.objectMode && s == null) && !(!e.objectMode && (!s || !s.length))) {
        var o = this.push(s);
        o || (r3 = true, t.pause());
      }
    });
    for (var i in t)
      this[i] === void 0 && typeof t[i] == "function" && (this[i] = function(o) {
        return function() {
          return t[o].apply(t, arguments);
        };
      }(i));
    for (var n = 0; n < V0.length; n++)
      t.on(V0[n], this.emit.bind(this, V0[n]));
    return this._read = (s) => {
      Ft("wrapped _read", s), r3 && (r3 = false, t.resume());
    }, this;
  };
  typeof Symbol == "function" && (qt.prototype[Symbol.asyncIterator] = function() {
    return $0 === void 0 && ($0 = eb()), $0(this);
  });
  Object.defineProperty(qt.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(qt.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(qt.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e) {
    this._readableState && (this._readableState.flowing = e);
  } });
  qt._fromList = ub;
  Object.defineProperty(qt.prototype, "readableLength", { enumerable: false, get() {
    return this._readableState.length;
  } });
  function ub(t, e) {
    if (e.length === 0)
      return null;
    var r3;
    return e.objectMode ? r3 = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r3 = e.buffer.join("") : e.buffer.length === 1 ? r3 = e.buffer.first() : r3 = e.buffer.concat(e.length), e.buffer.clear()) : r3 = e.buffer.consume(t, e.decoder), r3;
  }
  function Z0(t) {
    var e = t._readableState;
    Ft("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, W.default.nextTick(G9, e, t));
  }
  function G9(t, e) {
    if (Ft("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
      let r3 = e._writableState;
      (!r3 || r3.autoDestroy && r3.finished) && e.destroy();
    }
  }
  typeof Symbol == "function" && (qt.from = function(t, e) {
    return W0 === void 0 && (W0 = rb()), W0(qt, t, e);
  });
  function db(t, e) {
    for (var r3 = 0, i = t.length; r3 < i; r3++)
      if (t[r3] === e)
        return r3;
    return -1;
  }
});
var Wd = k((qk, pb) => {
  U();
  pb.exports = rn;
  var Gd = ms().codes, $9 = Gd.ERR_METHOD_NOT_IMPLEMENTED, W9 = Gd.ERR_MULTIPLE_CALLBACK, V9 = Gd.ERR_TRANSFORM_ALREADY_TRANSFORMING, Y9 = Gd.ERR_TRANSFORM_WITH_LENGTH_0, $d = Nn();
  At()(rn, $d);
  function Z9(t, e) {
    var r3 = this._transformState;
    r3.transforming = false;
    var i = r3.writecb;
    if (i === null)
      return this.emit("error", new W9());
    r3.writechunk = null, r3.writecb = null, e != null && this.push(e), i(t);
    var n = this._readableState;
    n.reading = false, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
  }
  function rn(t) {
    if (!(this instanceof rn))
      return new rn(t);
    $d.call(this, t), this._transformState = { afterTransform: Z9.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", J9);
  }
  function J9() {
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush((t, e) => {
      hb(this, t, e);
    }) : hb(this, null, null);
  }
  rn.prototype.push = function(t, e) {
    return this._transformState.needTransform = false, $d.prototype.push.call(this, t, e);
  };
  rn.prototype._transform = function(t, e, r3) {
    r3(new $9("_transform()"));
  };
  rn.prototype._write = function(t, e, r3) {
    var i = this._transformState;
    if (i.writecb = r3, i.writechunk = t, i.writeencoding = e, !i.transforming) {
      var n = this._readableState;
      (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
  };
  rn.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  rn.prototype._destroy = function(t, e) {
    $d.prototype._destroy.call(this, t, (r3) => {
      e(r3);
    });
  };
  function hb(t, e, r3) {
    if (e)
      return t.emit("error", e);
    if (r3 != null && t.push(r3), t._writableState.length)
      throw new Y9();
    if (t._transformState.transforming)
      throw new V9();
    return t.push(null);
  }
});
var ep = k((Pk, mb) => {
  U();
  mb.exports = kf;
  var gb = Wd();
  At()(kf, gb);
  function kf(t) {
    if (!(this instanceof kf))
      return new kf(t);
    gb.call(this, t);
  }
  kf.prototype._transform = function(t, e, r3) {
    r3(null, t);
  };
});
var rp = k((Uk, xb) => {
  U();
  var tp;
  function X9(t) {
    let e = false;
    return function() {
      e || (e = true, t(...arguments));
    };
  }
  var vb = ms().codes, Q9 = vb.ERR_MISSING_ARGS, eA = vb.ERR_STREAM_DESTROYED;
  function yb(t) {
    if (t)
      throw t;
  }
  function tA(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function rA(t, e, r3, i) {
    i = X9(i);
    let n = false;
    t.on("close", () => {
      n = true;
    }), tp === void 0 && (tp = If()), tp(t, { readable: e, writable: r3 }, (o) => {
      if (o)
        return i(o);
      n = true, i();
    });
    let s = false;
    return (o) => {
      if (!n && !s) {
        if (s = true, tA(t))
          return t.abort();
        if (typeof t.destroy == "function")
          return t.destroy();
        i(o || new eA("pipe"));
      }
    };
  }
  function bb(t) {
    t();
  }
  function iA(t, e) {
    return t.pipe(e);
  }
  function nA(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? yb : t.pop();
  }
  function sA() {
    for (var t = arguments.length, e = new Array(t), r3 = 0; r3 < t; r3++)
      e[r3] = arguments[r3];
    let i = nA(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new Q9("streams");
    let n, s = e.map(function(o, f2) {
      let l = f2 < e.length - 1, g5 = f2 > 0;
      return rA(o, l, g5, function(_) {
        n || (n = _), _ && s.forEach(bb), !l && (s.forEach(bb), i(n));
      });
    });
    return e.reduce(iA);
  }
  xb.exports = sA;
});
var ip = k((Yr, wb) => {
  U();
  Yr = wb.exports = qd();
  Yr.Stream = Yr;
  Yr.Readable = Yr;
  Yr.Writable = jd();
  Yr.Duplex = Nn();
  Yr.Transform = Wd();
  Yr.PassThrough = ep();
  Yr.finished = If();
  Yr.pipeline = rp();
});
var np = k((zk, Ab) => {
  U();
  var Vd = Mt().Buffer, _b = ip().Transform, oA = At();
  function aA(t, e) {
    if (!Vd.isBuffer(t) && typeof t != "string")
      throw new TypeError(e + " must be a string or a buffer");
  }
  function On(t) {
    _b.call(this), this._block = Vd.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
  }
  oA(On, _b);
  On.prototype._transform = function(t, e, r3) {
    var i = null;
    try {
      this.update(t, e);
    } catch (n) {
      i = n;
    }
    r3(i);
  };
  On.prototype._flush = function(t) {
    var e = null;
    try {
      this.push(this.digest());
    } catch (r3) {
      e = r3;
    }
    t(e);
  };
  On.prototype.update = function(t, e) {
    if (aA(t, "Data"), this._finalized)
      throw new Error("Digest already called");
    Vd.isBuffer(t) || (t = Vd.from(t, e));
    for (var r3 = this._block, i = 0; this._blockOffset + t.length - i >= this._blockSize; ) {
      for (var n = this._blockOffset; n < this._blockSize; )
        r3[n++] = t[i++];
      this._update(), this._blockOffset = 0;
    }
    for (; i < t.length; )
      r3[this._blockOffset++] = t[i++];
    for (var s = 0, o = t.length * 8; o > 0; ++s)
      this._length[s] += o, o = this._length[s] / 4294967296 | 0, o > 0 && (this._length[s] -= 4294967296 * o);
    return this;
  };
  On.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  On.prototype.digest = function(t) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var e = this._digest();
    t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
    for (var r3 = 0; r3 < 4; ++r3)
      this._length[r3] = 0;
    return e;
  };
  On.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  Ab.exports = On;
});
var Jd = k((Hk, Mb) => {
  U();
  var fA = At(), Eb = np(), cA = Mt().Buffer, uA = new Array(16);
  function Yd() {
    Eb.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  fA(Yd, Eb);
  Yd.prototype._update = function() {
    for (var t = uA, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    var r3 = this._a, i = this._b, n = this._c, s = this._d;
    r3 = Er(r3, i, n, s, t[0], 3614090360, 7), s = Er(s, r3, i, n, t[1], 3905402710, 12), n = Er(n, s, r3, i, t[2], 606105819, 17), i = Er(i, n, s, r3, t[3], 3250441966, 22), r3 = Er(r3, i, n, s, t[4], 4118548399, 7), s = Er(s, r3, i, n, t[5], 1200080426, 12), n = Er(n, s, r3, i, t[6], 2821735955, 17), i = Er(i, n, s, r3, t[7], 4249261313, 22), r3 = Er(r3, i, n, s, t[8], 1770035416, 7), s = Er(s, r3, i, n, t[9], 2336552879, 12), n = Er(n, s, r3, i, t[10], 4294925233, 17), i = Er(i, n, s, r3, t[11], 2304563134, 22), r3 = Er(r3, i, n, s, t[12], 1804603682, 7), s = Er(s, r3, i, n, t[13], 4254626195, 12), n = Er(n, s, r3, i, t[14], 2792965006, 17), i = Er(i, n, s, r3, t[15], 1236535329, 22), r3 = Mr2(r3, i, n, s, t[1], 4129170786, 5), s = Mr2(s, r3, i, n, t[6], 3225465664, 9), n = Mr2(n, s, r3, i, t[11], 643717713, 14), i = Mr2(i, n, s, r3, t[0], 3921069994, 20), r3 = Mr2(r3, i, n, s, t[5], 3593408605, 5), s = Mr2(s, r3, i, n, t[10], 38016083, 9), n = Mr2(n, s, r3, i, t[15], 3634488961, 14), i = Mr2(i, n, s, r3, t[4], 3889429448, 20), r3 = Mr2(r3, i, n, s, t[9], 568446438, 5), s = Mr2(s, r3, i, n, t[14], 3275163606, 9), n = Mr2(n, s, r3, i, t[3], 4107603335, 14), i = Mr2(i, n, s, r3, t[8], 1163531501, 20), r3 = Mr2(r3, i, n, s, t[13], 2850285829, 5), s = Mr2(s, r3, i, n, t[2], 4243563512, 9), n = Mr2(n, s, r3, i, t[7], 1735328473, 14), i = Mr2(i, n, s, r3, t[12], 2368359562, 20), r3 = Sr2(r3, i, n, s, t[5], 4294588738, 4), s = Sr2(s, r3, i, n, t[8], 2272392833, 11), n = Sr2(n, s, r3, i, t[11], 1839030562, 16), i = Sr2(i, n, s, r3, t[14], 4259657740, 23), r3 = Sr2(r3, i, n, s, t[1], 2763975236, 4), s = Sr2(s, r3, i, n, t[4], 1272893353, 11), n = Sr2(n, s, r3, i, t[7], 4139469664, 16), i = Sr2(i, n, s, r3, t[10], 3200236656, 23), r3 = Sr2(r3, i, n, s, t[13], 681279174, 4), s = Sr2(s, r3, i, n, t[0], 3936430074, 11), n = Sr2(n, s, r3, i, t[3], 3572445317, 16), i = Sr2(i, n, s, r3, t[6], 76029189, 23), r3 = Sr2(r3, i, n, s, t[9], 3654602809, 4), s = Sr2(s, r3, i, n, t[12], 3873151461, 11), n = Sr2(n, s, r3, i, t[15], 530742520, 16), i = Sr2(i, n, s, r3, t[2], 3299628645, 23), r3 = Ir2(r3, i, n, s, t[0], 4096336452, 6), s = Ir2(s, r3, i, n, t[7], 1126891415, 10), n = Ir2(n, s, r3, i, t[14], 2878612391, 15), i = Ir2(i, n, s, r3, t[5], 4237533241, 21), r3 = Ir2(r3, i, n, s, t[12], 1700485571, 6), s = Ir2(s, r3, i, n, t[3], 2399980690, 10), n = Ir2(n, s, r3, i, t[10], 4293915773, 15), i = Ir2(i, n, s, r3, t[1], 2240044497, 21), r3 = Ir2(r3, i, n, s, t[8], 1873313359, 6), s = Ir2(s, r3, i, n, t[15], 4264355552, 10), n = Ir2(n, s, r3, i, t[6], 2734768916, 15), i = Ir2(i, n, s, r3, t[13], 1309151649, 21), r3 = Ir2(r3, i, n, s, t[4], 4149444226, 6), s = Ir2(s, r3, i, n, t[11], 3174756917, 10), n = Ir2(n, s, r3, i, t[2], 718787259, 15), i = Ir2(i, n, s, r3, t[9], 3951481745, 21), this._a = this._a + r3 | 0, this._b = this._b + i | 0, this._c = this._c + n | 0, this._d = this._d + s | 0;
  };
  Yd.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = cA.allocUnsafe(16);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
  };
  function Zd(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Er(t, e, r3, i, n, s, o) {
    return Zd(t + (e & r3 | ~e & i) + n + s | 0, o) + e | 0;
  }
  function Mr2(t, e, r3, i, n, s, o) {
    return Zd(t + (e & i | r3 & ~i) + n + s | 0, o) + e | 0;
  }
  function Sr2(t, e, r3, i, n, s, o) {
    return Zd(t + (e ^ r3 ^ i) + n + s | 0, o) + e | 0;
  }
  function Ir2(t, e, r3, i, n, s, o) {
    return Zd(t + (r3 ^ (e | ~i)) + n + s | 0, o) + e | 0;
  }
  Mb.exports = Yd;
});
var Qd = k((Kk, Db) => {
  U();
  var sp = or().Buffer, dA = At(), kb = np(), lA = new Array(16), Df = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Nf = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], Bf = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], Cf = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], Of = [0, 1518500249, 1859775393, 2400959708, 2840853838], jf = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function Xd() {
    kb.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  dA(Xd, kb);
  Xd.prototype._update = function() {
    for (var t = lA, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    for (var r3 = this._a | 0, i = this._b | 0, n = this._c | 0, s = this._d | 0, o = this._e | 0, f2 = this._a | 0, l = this._b | 0, g5 = this._c | 0, _ = this._d | 0, N2 = this._e | 0, U2 = 0; U2 < 80; U2 += 1) {
      var V, G;
      U2 < 16 ? (V = Sb(r3, i, n, s, o, t[Df[U2]], Of[0], Bf[U2]), G = Rb(f2, l, g5, _, N2, t[Nf[U2]], jf[0], Cf[U2])) : U2 < 32 ? (V = Ib(r3, i, n, s, o, t[Df[U2]], Of[1], Bf[U2]), G = Fb(f2, l, g5, _, N2, t[Nf[U2]], jf[1], Cf[U2])) : U2 < 48 ? (V = Tb(r3, i, n, s, o, t[Df[U2]], Of[2], Bf[U2]), G = Tb(f2, l, g5, _, N2, t[Nf[U2]], jf[2], Cf[U2])) : U2 < 64 ? (V = Fb(r3, i, n, s, o, t[Df[U2]], Of[3], Bf[U2]), G = Ib(f2, l, g5, _, N2, t[Nf[U2]], jf[3], Cf[U2])) : (V = Rb(r3, i, n, s, o, t[Df[U2]], Of[4], Bf[U2]), G = Sb(f2, l, g5, _, N2, t[Nf[U2]], jf[4], Cf[U2])), r3 = o, o = s, s = xs(n, 10), n = i, i = V, f2 = N2, N2 = _, _ = xs(g5, 10), g5 = l, l = G;
    }
    var ee2 = this._b + n + _ | 0;
    this._b = this._c + s + N2 | 0, this._c = this._d + o + f2 | 0, this._d = this._e + r3 + l | 0, this._e = this._a + i + g5 | 0, this._a = ee2;
  };
  Xd.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = sp.alloc ? sp.alloc(20) : new sp(20);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
  };
  function xs(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Sb(t, e, r3, i, n, s, o, f2) {
    return xs(t + (e ^ r3 ^ i) + s + o | 0, f2) + n | 0;
  }
  function Ib(t, e, r3, i, n, s, o, f2) {
    return xs(t + (e & r3 | ~e & i) + s + o | 0, f2) + n | 0;
  }
  function Tb(t, e, r3, i, n, s, o, f2) {
    return xs(t + ((e | ~r3) ^ i) + s + o | 0, f2) + n | 0;
  }
  function Fb(t, e, r3, i, n, s, o, f2) {
    return xs(t + (e & i | r3 & ~i) + s + o | 0, f2) + n | 0;
  }
  function Rb(t, e, r3, i, n, s, o, f2) {
    return xs(t + (e ^ (r3 | ~i)) + s + o | 0, f2) + n | 0;
  }
  Db.exports = Xd;
});
var ws = k((Gk, Bb) => {
  U();
  var Nb = Mt().Buffer;
  function el(t, e) {
    this._block = Nb.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
  }
  el.prototype.update = function(t, e) {
    typeof t == "string" && (e = e || "utf8", t = Nb.from(t, e));
    for (var r3 = this._block, i = this._blockSize, n = t.length, s = this._len, o = 0; o < n; ) {
      for (var f2 = s % i, l = Math.min(n - o, i - f2), g5 = 0; g5 < l; g5++)
        r3[f2 + g5] = t[o + g5];
      s += l, o += l, s % i === 0 && this._update(r3);
    }
    return this._len += n, this;
  };
  el.prototype.digest = function(t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r3 = this._len * 8;
    if (r3 <= 4294967295)
      this._block.writeUInt32BE(r3, this._blockSize - 4);
    else {
      var i = (r3 & 4294967295) >>> 0, n = (r3 - i) / 4294967296;
      this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
    }
    this._update(this._block);
    var s = this._hash();
    return t ? s.toString(t) : s;
  };
  el.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  Bb.exports = el;
});
var jb = k(($k, Ob) => {
  U();
  var hA = At(), Cb = ws(), pA = Mt().Buffer, gA = [1518500249, 1859775393, -1894007588, -899497514], mA = new Array(80);
  function Lf() {
    this.init(), this._w = mA, Cb.call(this, 64, 56);
  }
  hA(Lf, Cb);
  Lf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function yA(t) {
    return t << 5 | t >>> 27;
  }
  function bA(t) {
    return t << 30 | t >>> 2;
  }
  function vA(t, e, r3, i) {
    return t === 0 ? e & r3 | ~e & i : t === 2 ? e & r3 | e & i | r3 & i : e ^ r3 ^ i;
  }
  Lf.prototype._update = function(t) {
    for (var e = this._w, r3 = this._a | 0, i = this._b | 0, n = this._c | 0, s = this._d | 0, o = this._e | 0, f2 = 0; f2 < 16; ++f2)
      e[f2] = t.readInt32BE(f2 * 4);
    for (; f2 < 80; ++f2)
      e[f2] = e[f2 - 3] ^ e[f2 - 8] ^ e[f2 - 14] ^ e[f2 - 16];
    for (var l = 0; l < 80; ++l) {
      var g5 = ~~(l / 20), _ = yA(r3) + vA(g5, i, n, s) + o + e[l] + gA[g5] | 0;
      o = s, s = n, n = bA(i), i = r3, r3 = _;
    }
    this._a = r3 + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0;
  };
  Lf.prototype._hash = function() {
    var t = pA.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  Ob.exports = Lf;
});
var Pb = k((Wk, qb) => {
  U();
  var xA = At(), Lb = ws(), wA = Mt().Buffer, _A = [1518500249, 1859775393, -1894007588, -899497514], AA = new Array(80);
  function qf() {
    this.init(), this._w = AA, Lb.call(this, 64, 56);
  }
  xA(qf, Lb);
  qf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function EA(t) {
    return t << 1 | t >>> 31;
  }
  function MA(t) {
    return t << 5 | t >>> 27;
  }
  function SA(t) {
    return t << 30 | t >>> 2;
  }
  function IA(t, e, r3, i) {
    return t === 0 ? e & r3 | ~e & i : t === 2 ? e & r3 | e & i | r3 & i : e ^ r3 ^ i;
  }
  qf.prototype._update = function(t) {
    for (var e = this._w, r3 = this._a | 0, i = this._b | 0, n = this._c | 0, s = this._d | 0, o = this._e | 0, f2 = 0; f2 < 16; ++f2)
      e[f2] = t.readInt32BE(f2 * 4);
    for (; f2 < 80; ++f2)
      e[f2] = EA(e[f2 - 3] ^ e[f2 - 8] ^ e[f2 - 14] ^ e[f2 - 16]);
    for (var l = 0; l < 80; ++l) {
      var g5 = ~~(l / 20), _ = MA(r3) + IA(g5, i, n, s) + o + e[l] + _A[g5] | 0;
      o = s, s = n, n = SA(i), i = r3, r3 = _;
    }
    this._a = r3 + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0;
  };
  qf.prototype._hash = function() {
    var t = wA.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  qb.exports = qf;
});
var op = k((Vk, zb) => {
  U();
  var TA = At(), Ub = ws(), FA = Mt().Buffer, RA = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], kA = new Array(64);
  function Pf() {
    this.init(), this._w = kA, Ub.call(this, 64, 56);
  }
  TA(Pf, Ub);
  Pf.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function DA(t, e, r3) {
    return r3 ^ t & (e ^ r3);
  }
  function NA(t, e, r3) {
    return t & e | r3 & (t | e);
  }
  function BA(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
  }
  function CA(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
  }
  function OA(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
  }
  function jA(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
  }
  Pf.prototype._update = function(t) {
    for (var e = this._w, r3 = this._a | 0, i = this._b | 0, n = this._c | 0, s = this._d | 0, o = this._e | 0, f2 = this._f | 0, l = this._g | 0, g5 = this._h | 0, _ = 0; _ < 16; ++_)
      e[_] = t.readInt32BE(_ * 4);
    for (; _ < 64; ++_)
      e[_] = jA(e[_ - 2]) + e[_ - 7] + OA(e[_ - 15]) + e[_ - 16] | 0;
    for (var N2 = 0; N2 < 64; ++N2) {
      var U2 = g5 + CA(o) + DA(o, f2, l) + RA[N2] + e[N2] | 0, V = BA(r3) + NA(r3, i, n) | 0;
      g5 = l, l = f2, f2 = o, o = s + U2 | 0, s = n, n = i, i = r3, r3 = U2 + V | 0;
    }
    this._a = r3 + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0, this._f = f2 + this._f | 0, this._g = l + this._g | 0, this._h = g5 + this._h | 0;
  };
  Pf.prototype._hash = function() {
    var t = FA.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
  };
  zb.exports = Pf;
});
var Kb = k((Yk, Hb) => {
  U();
  var LA = At(), qA = op(), PA = ws(), UA = Mt().Buffer, zA = new Array(64);
  function tl() {
    this.init(), this._w = zA, PA.call(this, 64, 56);
  }
  LA(tl, qA);
  tl.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  tl.prototype._hash = function() {
    var t = UA.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
  };
  Hb.exports = tl;
});
var ap = k((Zk, Jb) => {
  U();
  var HA = At(), Zb = ws(), KA = Mt().Buffer, Gb = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], GA = new Array(160);
  function Uf() {
    this.init(), this._w = GA, Zb.call(this, 128, 112);
  }
  HA(Uf, Zb);
  Uf.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function $b(t, e, r3) {
    return r3 ^ t & (e ^ r3);
  }
  function Wb(t, e, r3) {
    return t & e | r3 & (t | e);
  }
  function Vb(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
  }
  function Yb(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
  }
  function $A(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
  }
  function WA(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
  }
  function VA(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
  }
  function YA(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
  }
  function pr2(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0;
  }
  Uf.prototype._update = function(t) {
    for (var e = this._w, r3 = this._ah | 0, i = this._bh | 0, n = this._ch | 0, s = this._dh | 0, o = this._eh | 0, f2 = this._fh | 0, l = this._gh | 0, g5 = this._hh | 0, _ = this._al | 0, N2 = this._bl | 0, U2 = this._cl | 0, V = this._dl | 0, G = this._el | 0, ee2 = this._fl | 0, W5 = this._gl | 0, Z = this._hl | 0, le = 0; le < 32; le += 2)
      e[le] = t.readInt32BE(le * 4), e[le + 1] = t.readInt32BE(le * 4 + 4);
    for (; le < 160; le += 2) {
      var be2 = e[le - 30], Ae = e[le - 15 * 2 + 1], me = $A(be2, Ae), H5 = WA(Ae, be2);
      be2 = e[le - 2 * 2], Ae = e[le - 2 * 2 + 1];
      var ue = VA(be2, Ae), se2 = YA(Ae, be2), ne2 = e[le - 7 * 2], E2 = e[le - 7 * 2 + 1], c = e[le - 16 * 2], m2 = e[le - 16 * 2 + 1], h2 = H5 + E2 | 0, a = me + ne2 + pr2(h2, H5) | 0;
      h2 = h2 + se2 | 0, a = a + ue + pr2(h2, se2) | 0, h2 = h2 + m2 | 0, a = a + c + pr2(h2, m2) | 0, e[le] = a, e[le + 1] = h2;
    }
    for (var u3 = 0; u3 < 160; u3 += 2) {
      a = e[u3], h2 = e[u3 + 1];
      var b2 = Wb(r3, i, n), A2 = Wb(_, N2, U2), v2 = Vb(r3, _), d2 = Vb(_, r3), M = Yb(o, G), B2 = Yb(G, o), y2 = Gb[u3], I = Gb[u3 + 1], de = $b(o, f2, l), Me2 = $b(G, ee2, W5), Se = Z + B2 | 0, Oe = g5 + M + pr2(Se, Z) | 0;
      Se = Se + Me2 | 0, Oe = Oe + de + pr2(Se, Me2) | 0, Se = Se + I | 0, Oe = Oe + y2 + pr2(Se, I) | 0, Se = Se + h2 | 0, Oe = Oe + a + pr2(Se, h2) | 0;
      var ye = d2 + A2 | 0, T = v2 + b2 + pr2(ye, d2) | 0;
      g5 = l, Z = W5, l = f2, W5 = ee2, f2 = o, ee2 = G, G = V + Se | 0, o = s + Oe + pr2(G, V) | 0, s = n, V = U2, n = i, U2 = N2, i = r3, N2 = _, _ = Se + ye | 0, r3 = Oe + T + pr2(_, Se) | 0;
    }
    this._al = this._al + _ | 0, this._bl = this._bl + N2 | 0, this._cl = this._cl + U2 | 0, this._dl = this._dl + V | 0, this._el = this._el + G | 0, this._fl = this._fl + ee2 | 0, this._gl = this._gl + W5 | 0, this._hl = this._hl + Z | 0, this._ah = this._ah + r3 + pr2(this._al, _) | 0, this._bh = this._bh + i + pr2(this._bl, N2) | 0, this._ch = this._ch + n + pr2(this._cl, U2) | 0, this._dh = this._dh + s + pr2(this._dl, V) | 0, this._eh = this._eh + o + pr2(this._el, G) | 0, this._fh = this._fh + f2 + pr2(this._fl, ee2) | 0, this._gh = this._gh + l + pr2(this._gl, W5) | 0, this._hh = this._hh + g5 + pr2(this._hl, Z) | 0;
  };
  Uf.prototype._hash = function() {
    var t = KA.allocUnsafe(64);
    function e(r3, i, n) {
      t.writeInt32BE(r3, n), t.writeInt32BE(i, n + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
  };
  Jb.exports = Uf;
});
var Qb = k((Jk, Xb) => {
  U();
  var ZA = At(), JA = ap(), XA = ws(), QA = Mt().Buffer, e7 = new Array(160);
  function rl() {
    this.init(), this._w = e7, XA.call(this, 128, 112);
  }
  ZA(rl, JA);
  rl.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  rl.prototype._hash = function() {
    var t = QA.allocUnsafe(48);
    function e(r3, i, n) {
      t.writeInt32BE(r3, n), t.writeInt32BE(i, n + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
  };
  Xb.exports = rl;
});
var il = k((nn, e2) => {
  U();
  var nn = e2.exports = function(e) {
    e = e.toLowerCase();
    var r3 = nn[e];
    if (!r3)
      throw new Error(e + " is not supported (we accept pull requests)");
    return new r3();
  };
  nn.sha = jb();
  nn.sha1 = Pb();
  nn.sha224 = Kb();
  nn.sha256 = op();
  nn.sha384 = Qb();
  nn.sha512 = ap();
});
var r2 = k((Xk, t2) => {
  U();
  t2.exports = Zr;
  var fp = cd().EventEmitter, t7 = At();
  t7(Zr, fp);
  Zr.Readable = qd();
  Zr.Writable = jd();
  Zr.Duplex = Nn();
  Zr.Transform = Wd();
  Zr.PassThrough = ep();
  Zr.finished = If();
  Zr.pipeline = rp();
  Zr.Stream = Zr;
  function Zr() {
    fp.call(this);
  }
  Zr.prototype.pipe = function(t, e) {
    var r3 = this;
    function i(_) {
      t.writable && t.write(_) === false && r3.pause && r3.pause();
    }
    r3.on("data", i);
    function n() {
      r3.readable && r3.resume && r3.resume();
    }
    t.on("drain", n), !t._isStdio && (!e || e.end !== false) && (r3.on("end", o), r3.on("close", f2));
    var s = false;
    function o() {
      s || (s = true, t.end());
    }
    function f2() {
      s || (s = true, typeof t.destroy == "function" && t.destroy());
    }
    function l(_) {
      if (g5(), fp.listenerCount(this, "error") === 0)
        throw _;
    }
    r3.on("error", l), t.on("error", l);
    function g5() {
      r3.removeListener("data", i), t.removeListener("drain", n), r3.removeListener("end", o), r3.removeListener("close", f2), r3.removeListener("error", l), t.removeListener("error", l), r3.removeListener("end", g5), r3.removeListener("close", g5), t.removeListener("close", g5);
    }
    return r3.on("end", g5), r3.on("close", g5), t.on("close", g5), t.emit("pipe", r3), t;
  };
});
var sn = k((Qk, s2) => {
  U();
  var i2 = Mt().Buffer, n2 = r2().Transform, r7 = Pd().StringDecoder, i7 = At();
  function mi(t) {
    n2.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  i7(mi, n2);
  mi.prototype.update = function(t, e, r3) {
    typeof t == "string" && (t = i2.from(t, e));
    var i = this._update(t);
    return this.hashMode ? this : (r3 && (i = this._toString(i, r3)), i);
  };
  mi.prototype.setAutoPadding = function() {
  };
  mi.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  mi.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  mi.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  mi.prototype._transform = function(t, e, r3) {
    var i;
    try {
      this.hashMode ? this._update(t) : this.push(this._update(t));
    } catch (n) {
      i = n;
    } finally {
      r3(i);
    }
  };
  mi.prototype._flush = function(t) {
    var e;
    try {
      this.push(this.__final());
    } catch (r3) {
      e = r3;
    }
    t(e);
  };
  mi.prototype._finalOrDigest = function(t) {
    var e = this.__final() || i2.alloc(0);
    return t && (e = this._toString(e, t, true)), e;
  };
  mi.prototype._toString = function(t, e, r3) {
    if (this._decoder || (this._decoder = new r7(e), this._encoding = e), this._encoding !== e)
      throw new Error("can't switch encodings");
    var i = this._decoder.write(t);
    return r3 && (i += this._decoder.end()), i;
  };
  s2.exports = mi;
});
var Bo = k((eD, a2) => {
  U();
  var n7 = At(), s7 = Jd(), o7 = Qd(), a7 = il(), o2 = sn();
  function nl(t) {
    o2.call(this, "digest"), this._hash = t;
  }
  n7(nl, o2);
  nl.prototype._update = function(t) {
    this._hash.update(t);
  };
  nl.prototype._final = function() {
    return this._hash.digest();
  };
  a2.exports = function(e) {
    return e = e.toLowerCase(), e === "md5" ? new s7() : e === "rmd160" || e === "ripemd160" ? new o7() : new nl(a7(e));
  };
});
var u2 = k((tD, c2) => {
  U();
  var f7 = At(), _s = Mt().Buffer, f2 = sn(), c7 = _s.alloc(128), Co = 64;
  function sl(t, e) {
    f2.call(this, "digest"), typeof e == "string" && (e = _s.from(e)), this._alg = t, this._key = e, e.length > Co ? e = t(e) : e.length < Co && (e = _s.concat([e, c7], Co));
    for (var r3 = this._ipad = _s.allocUnsafe(Co), i = this._opad = _s.allocUnsafe(Co), n = 0; n < Co; n++)
      r3[n] = e[n] ^ 54, i[n] = e[n] ^ 92;
    this._hash = [r3];
  }
  f7(sl, f2);
  sl.prototype._update = function(t) {
    this._hash.push(t);
  };
  sl.prototype._final = function() {
    var t = this._alg(_s.concat(this._hash));
    return this._alg(_s.concat([this._opad, t]));
  };
  c2.exports = sl;
});
var cp = k((rD, d2) => {
  U();
  var u7 = Jd();
  d2.exports = function(t) {
    return new u7().update(t).digest();
  };
});
var lp = k((iD, h2) => {
  U();
  var d7 = At(), l7 = u2(), l2 = sn(), zf = Mt().Buffer, h7 = cp(), up = Qd(), dp = il(), p7 = zf.alloc(128);
  function Hf(t, e) {
    l2.call(this, "digest"), typeof e == "string" && (e = zf.from(e));
    var r3 = t === "sha512" || t === "sha384" ? 128 : 64;
    if (this._alg = t, this._key = e, e.length > r3) {
      var i = t === "rmd160" ? new up() : dp(t);
      e = i.update(e).digest();
    } else
      e.length < r3 && (e = zf.concat([e, p7], r3));
    for (var n = this._ipad = zf.allocUnsafe(r3), s = this._opad = zf.allocUnsafe(r3), o = 0; o < r3; o++)
      n[o] = e[o] ^ 54, s[o] = e[o] ^ 92;
    this._hash = t === "rmd160" ? new up() : dp(t), this._hash.update(n);
  }
  d7(Hf, l2);
  Hf.prototype._update = function(t) {
    this._hash.update(t);
  };
  Hf.prototype._final = function() {
    var t = this._hash.digest(), e = this._alg === "rmd160" ? new up() : dp(this._alg);
    return e.update(this._opad).update(t).digest();
  };
  h2.exports = function(e, r3) {
    return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new Hf("rmd160", r3) : e === "md5" ? new l7(h7, r3) : new Hf(e, r3);
  };
});
var hp = k((nD, g7) => {
  g7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
});
var g2 = k((sD, p2) => {
  U();
  p2.exports = hp();
});
var pp = k((oD, m2) => {
  U();
  var m7 = Math.pow(2, 30) - 1;
  m2.exports = function(t, e) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof e != "number")
      throw new TypeError("Key length not a number");
    if (e < 0 || e > m7 || e !== e)
      throw new TypeError("Bad key length");
  };
});
var gp = k((aD, b2) => {
  U();
  var ol;
  N.process && N.process.browser ? ol = "utf-8" : N.process && N.process.version ? (y2 = parseInt(W.default.version.split(".")[0].slice(1), 10), ol = y2 >= 6 ? "utf-8" : "binary") : ol = "utf-8";
  var y2;
  b2.exports = ol;
});
var yp = k((fD, v2) => {
  U();
  var mp = Mt().Buffer;
  v2.exports = function(t, e, r3) {
    if (mp.isBuffer(t))
      return t;
    if (typeof t == "string")
      return mp.from(t, e);
    if (ArrayBuffer.isView(t))
      return mp.from(t.buffer);
    throw new TypeError(r3 + " must be a string, a Buffer, a typed array or a DataView");
  };
});
var bp = k((cD, A2) => {
  U();
  var y7 = cp(), b7 = Qd(), v7 = il(), As = Mt().Buffer, x7 = pp(), x2 = gp(), w2 = yp(), w7 = As.alloc(128), al = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
  function _2(t, e, r3) {
    var i = _7(t), n = t === "sha512" || t === "sha384" ? 128 : 64;
    e.length > n ? e = i(e) : e.length < n && (e = As.concat([e, w7], n));
    for (var s = As.allocUnsafe(n + al[t]), o = As.allocUnsafe(n + al[t]), f2 = 0; f2 < n; f2++)
      s[f2] = e[f2] ^ 54, o[f2] = e[f2] ^ 92;
    var l = As.allocUnsafe(n + r3 + 4);
    s.copy(l, 0, 0, n), this.ipad1 = l, this.ipad2 = s, this.opad = o, this.alg = t, this.blocksize = n, this.hash = i, this.size = al[t];
  }
  _2.prototype.run = function(t, e) {
    t.copy(e, this.blocksize);
    var r3 = this.hash(e);
    return r3.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function _7(t) {
    function e(i) {
      return v7(t).update(i).digest();
    }
    function r3(i) {
      return new b7().update(i).digest();
    }
    return t === "rmd160" || t === "ripemd160" ? r3 : t === "md5" ? y7 : e;
  }
  function A7(t, e, r3, i, n) {
    x7(r3, i), t = w2(t, x2, "Password"), e = w2(e, x2, "Salt"), n = n || "sha1";
    var s = new _2(n, t, e.length), o = As.allocUnsafe(i), f2 = As.allocUnsafe(e.length + 4);
    e.copy(f2, 0, 0, e.length);
    for (var l = 0, g5 = al[n], _ = Math.ceil(i / g5), N2 = 1; N2 <= _; N2++) {
      f2.writeUInt32BE(N2, e.length);
      for (var U2 = s.run(f2, s.ipad1), V = U2, G = 1; G < r3; G++) {
        V = s.run(V, s.ipad2);
        for (var ee2 = 0; ee2 < g5; ee2++)
          U2[ee2] ^= V[ee2];
      }
      U2.copy(o, l), l += g5;
    }
    return o;
  }
  A2.exports = A7;
});
var R2 = k((uD, F2) => {
  U();
  var I2 = Mt().Buffer, E7 = pp(), E2 = gp(), M2 = bp(), S2 = yp(), fl, Kf = N.crypto && N.crypto.subtle, M7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, vp = [];
  function S7(t) {
    if (N.process && !N.process.browser || !Kf || !Kf.importKey || !Kf.deriveBits)
      return Promise.resolve(false);
    if (vp[t] !== void 0)
      return vp[t];
    fl = fl || I2.alloc(8);
    var e = T2(fl, fl, 10, 128, t).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    return vp[t] = e, e;
  }
  var Es;
  function xp() {
    return Es || (N.process && N.process.nextTick ? Es = N.process.nextTick : N.queueMicrotask ? Es = N.queueMicrotask : N.setImmediate ? Es = N.setImmediate : Es = N.setTimeout, Es);
  }
  function T2(t, e, r3, i, n) {
    return Kf.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(s) {
      return Kf.deriveBits({ name: "PBKDF2", salt: e, iterations: r3, hash: { name: n } }, s, i << 3);
    }).then(function(s) {
      return I2.from(s);
    });
  }
  function I7(t, e) {
    t.then(function(r3) {
      xp()(function() {
        e(null, r3);
      });
    }, function(r3) {
      xp()(function() {
        e(r3);
      });
    });
  }
  F2.exports = function(t, e, r3, i, n, s) {
    typeof n == "function" && (s = n, n = void 0), n = n || "sha1";
    var o = M7[n.toLowerCase()];
    if (!o || typeof N.Promise != "function") {
      xp()(function() {
        var f2;
        try {
          f2 = M2(t, e, r3, i, n);
        } catch (l) {
          return s(l);
        }
        s(null, f2);
      });
      return;
    }
    if (E7(r3, i), t = S2(t, E2, "Password"), e = S2(e, E2, "Salt"), typeof s != "function")
      throw new Error("No callback provided to pbkdf2");
    I7(S7(o).then(function(f2) {
      return f2 ? T2(t, e, r3, i, o) : M2(t, e, r3, i, n);
    }), s);
  };
});
var _p = k((wp) => {
  U();
  wp.pbkdf2 = R2();
  wp.pbkdf2Sync = bp();
});
var Ap = k((Jr) => {
  U();
  Jr.readUInt32BE = function(e, r3) {
    var i = e[0 + r3] << 24 | e[1 + r3] << 16 | e[2 + r3] << 8 | e[3 + r3];
    return i >>> 0;
  };
  Jr.writeUInt32BE = function(e, r3, i) {
    e[0 + i] = r3 >>> 24, e[1 + i] = r3 >>> 16 & 255, e[2 + i] = r3 >>> 8 & 255, e[3 + i] = r3 & 255;
  };
  Jr.ip = function(e, r3, i, n) {
    for (var s = 0, o = 0, f2 = 6; f2 >= 0; f2 -= 2) {
      for (var l = 0; l <= 24; l += 8)
        s <<= 1, s |= r3 >>> l + f2 & 1;
      for (var l = 0; l <= 24; l += 8)
        s <<= 1, s |= e >>> l + f2 & 1;
    }
    for (var f2 = 6; f2 >= 0; f2 -= 2) {
      for (var l = 1; l <= 25; l += 8)
        o <<= 1, o |= r3 >>> l + f2 & 1;
      for (var l = 1; l <= 25; l += 8)
        o <<= 1, o |= e >>> l + f2 & 1;
    }
    i[n + 0] = s >>> 0, i[n + 1] = o >>> 0;
  };
  Jr.rip = function(e, r3, i, n) {
    for (var s = 0, o = 0, f2 = 0; f2 < 4; f2++)
      for (var l = 24; l >= 0; l -= 8)
        s <<= 1, s |= r3 >>> l + f2 & 1, s <<= 1, s |= e >>> l + f2 & 1;
    for (var f2 = 4; f2 < 8; f2++)
      for (var l = 24; l >= 0; l -= 8)
        o <<= 1, o |= r3 >>> l + f2 & 1, o <<= 1, o |= e >>> l + f2 & 1;
    i[n + 0] = s >>> 0, i[n + 1] = o >>> 0;
  };
  Jr.pc1 = function(e, r3, i, n) {
    for (var s = 0, o = 0, f2 = 7; f2 >= 5; f2--) {
      for (var l = 0; l <= 24; l += 8)
        s <<= 1, s |= r3 >> l + f2 & 1;
      for (var l = 0; l <= 24; l += 8)
        s <<= 1, s |= e >> l + f2 & 1;
    }
    for (var l = 0; l <= 24; l += 8)
      s <<= 1, s |= r3 >> l + f2 & 1;
    for (var f2 = 1; f2 <= 3; f2++) {
      for (var l = 0; l <= 24; l += 8)
        o <<= 1, o |= r3 >> l + f2 & 1;
      for (var l = 0; l <= 24; l += 8)
        o <<= 1, o |= e >> l + f2 & 1;
    }
    for (var l = 0; l <= 24; l += 8)
      o <<= 1, o |= e >> l + f2 & 1;
    i[n + 0] = s >>> 0, i[n + 1] = o >>> 0;
  };
  Jr.r28shl = function(e, r3) {
    return e << r3 & 268435455 | e >>> 28 - r3;
  };
  var cl = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  Jr.pc2 = function(e, r3, i, n) {
    for (var s = 0, o = 0, f2 = cl.length >>> 1, l = 0; l < f2; l++)
      s <<= 1, s |= e >>> cl[l] & 1;
    for (var l = f2; l < cl.length; l++)
      o <<= 1, o |= r3 >>> cl[l] & 1;
    i[n + 0] = s >>> 0, i[n + 1] = o >>> 0;
  };
  Jr.expand = function(e, r3, i) {
    var n = 0, s = 0;
    n = (e & 1) << 5 | e >>> 27;
    for (var o = 23; o >= 15; o -= 4)
      n <<= 6, n |= e >>> o & 63;
    for (var o = 11; o >= 3; o -= 4)
      s |= e >>> o & 63, s <<= 6;
    s |= (e & 31) << 1 | e >>> 31, r3[i + 0] = n >>> 0, r3[i + 1] = s >>> 0;
  };
  var k2 = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  Jr.substitute = function(e, r3) {
    for (var i = 0, n = 0; n < 4; n++) {
      var s = e >>> 18 - n * 6 & 63, o = k2[n * 64 + s];
      i <<= 4, i |= o;
    }
    for (var n = 0; n < 4; n++) {
      var s = r3 >>> 18 - n * 6 & 63, o = k2[4 * 64 + n * 64 + s];
      i <<= 4, i |= o;
    }
    return i >>> 0;
  };
  var D2 = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  Jr.permute = function(e) {
    for (var r3 = 0, i = 0; i < D2.length; i++)
      r3 <<= 1, r3 |= e >>> D2[i] & 1;
    return r3 >>> 0;
  };
  Jr.padSplit = function(e, r3, i) {
    for (var n = e.toString(2); n.length < r3; )
      n = "0" + n;
    for (var s = [], o = 0; o < r3; o += i)
      s.push(n.slice(o, o + i));
    return s.join(" ");
  };
});
var zr = k((hD, B2) => {
  U();
  B2.exports = N2;
  function N2(t, e) {
    if (!t)
      throw new Error(e || "Assertion failed");
  }
  N2.equal = function(e, r3, i) {
    if (e != r3)
      throw new Error(i || "Assertion failed: " + e + " != " + r3);
  };
});
var ul = k((pD, C2) => {
  U();
  var T7 = zr();
  function Xr(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  C2.exports = Xr;
  Xr.prototype._init = function() {
  };
  Xr.prototype.update = function(e) {
    return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
  };
  Xr.prototype._buffer = function(e, r3) {
    for (var i = Math.min(this.buffer.length - this.bufferOff, e.length - r3), n = 0; n < i; n++)
      this.buffer[this.bufferOff + n] = e[r3 + n];
    return this.bufferOff += i, i;
  };
  Xr.prototype._flushBuffer = function(e, r3) {
    return this._update(this.buffer, 0, e, r3), this.bufferOff = 0, this.blockSize;
  };
  Xr.prototype._updateEncrypt = function(e) {
    var r3 = 0, i = 0, n = (this.bufferOff + e.length) / this.blockSize | 0, s = new Array(n * this.blockSize);
    this.bufferOff !== 0 && (r3 += this._buffer(e, r3), this.bufferOff === this.buffer.length && (i += this._flushBuffer(s, i)));
    for (var o = e.length - (e.length - r3) % this.blockSize; r3 < o; r3 += this.blockSize)
      this._update(e, r3, s, i), i += this.blockSize;
    for (; r3 < e.length; r3++, this.bufferOff++)
      this.buffer[this.bufferOff] = e[r3];
    return s;
  };
  Xr.prototype._updateDecrypt = function(e) {
    for (var r3 = 0, i = 0, n = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, s = new Array(n * this.blockSize); n > 0; n--)
      r3 += this._buffer(e, r3), i += this._flushBuffer(s, i);
    return r3 += this._buffer(e, r3), s;
  };
  Xr.prototype.final = function(e) {
    var r3;
    e && (r3 = this.update(e));
    var i;
    return this.type === "encrypt" ? i = this._finalEncrypt() : i = this._finalDecrypt(), r3 ? r3.concat(i) : i;
  };
  Xr.prototype._pad = function(e, r3) {
    if (r3 === 0)
      return false;
    for (; r3 < e.length; )
      e[r3++] = 0;
    return true;
  };
  Xr.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var e = new Array(this.blockSize);
    return this._update(this.buffer, 0, e, 0), e;
  };
  Xr.prototype._unpad = function(e) {
    return e;
  };
  Xr.prototype._finalDecrypt = function() {
    T7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var e = new Array(this.blockSize);
    return this._flushBuffer(e, 0), this._unpad(e);
  };
});
var Ep = k((gD, L2) => {
  U();
  var O2 = zr(), F7 = At(), ur2 = Ap(), j2 = ul();
  function R7() {
    this.tmp = new Array(2), this.keys = null;
  }
  function ji(t) {
    j2.call(this, t);
    var e = new R7();
    this._desState = e, this.deriveKeys(e, t.key);
  }
  F7(ji, j2);
  L2.exports = ji;
  ji.create = function(e) {
    return new ji(e);
  };
  var k7 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  ji.prototype.deriveKeys = function(e, r3) {
    e.keys = new Array(16 * 2), O2.equal(r3.length, this.blockSize, "Invalid key length");
    var i = ur2.readUInt32BE(r3, 0), n = ur2.readUInt32BE(r3, 4);
    ur2.pc1(i, n, e.tmp, 0), i = e.tmp[0], n = e.tmp[1];
    for (var s = 0; s < e.keys.length; s += 2) {
      var o = k7[s >>> 1];
      i = ur2.r28shl(i, o), n = ur2.r28shl(n, o), ur2.pc2(i, n, e.keys, s);
    }
  };
  ji.prototype._update = function(e, r3, i, n) {
    var s = this._desState, o = ur2.readUInt32BE(e, r3), f2 = ur2.readUInt32BE(e, r3 + 4);
    ur2.ip(o, f2, s.tmp, 0), o = s.tmp[0], f2 = s.tmp[1], this.type === "encrypt" ? this._encrypt(s, o, f2, s.tmp, 0) : this._decrypt(s, o, f2, s.tmp, 0), o = s.tmp[0], f2 = s.tmp[1], ur2.writeUInt32BE(i, o, n), ur2.writeUInt32BE(i, f2, n + 4);
  };
  ji.prototype._pad = function(e, r3) {
    for (var i = e.length - r3, n = r3; n < e.length; n++)
      e[n] = i;
    return true;
  };
  ji.prototype._unpad = function(e) {
    for (var r3 = e[e.length - 1], i = e.length - r3; i < e.length; i++)
      O2.equal(e[i], r3);
    return e.slice(0, e.length - r3);
  };
  ji.prototype._encrypt = function(e, r3, i, n, s) {
    for (var o = r3, f2 = i, l = 0; l < e.keys.length; l += 2) {
      var g5 = e.keys[l], _ = e.keys[l + 1];
      ur2.expand(f2, e.tmp, 0), g5 ^= e.tmp[0], _ ^= e.tmp[1];
      var N2 = ur2.substitute(g5, _), U2 = ur2.permute(N2), V = f2;
      f2 = (o ^ U2) >>> 0, o = V;
    }
    ur2.rip(f2, o, n, s);
  };
  ji.prototype._decrypt = function(e, r3, i, n, s) {
    for (var o = i, f2 = r3, l = e.keys.length - 2; l >= 0; l -= 2) {
      var g5 = e.keys[l], _ = e.keys[l + 1];
      ur2.expand(o, e.tmp, 0), g5 ^= e.tmp[0], _ ^= e.tmp[1];
      var N2 = ur2.substitute(g5, _), U2 = ur2.permute(N2), V = o;
      o = (f2 ^ U2) >>> 0, f2 = V;
    }
    ur2.rip(o, f2, n, s);
  };
});
var P2 = k((q2) => {
  U();
  var D7 = zr(), N7 = At(), dl = {};
  function B7(t) {
    D7.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e = 0; e < this.iv.length; e++)
      this.iv[e] = t[e];
  }
  function C7(t) {
    function e(s) {
      t.call(this, s), this._cbcInit();
    }
    N7(e, t);
    for (var r3 = Object.keys(dl), i = 0; i < r3.length; i++) {
      var n = r3[i];
      e.prototype[n] = dl[n];
    }
    return e.create = function(o) {
      return new e(o);
    }, e;
  }
  q2.instantiate = C7;
  dl._cbcInit = function() {
    var e = new B7(this.options.iv);
    this._cbcState = e;
  };
  dl._update = function(e, r3, i, n) {
    var s = this._cbcState, o = this.constructor.super_.prototype, f2 = s.iv;
    if (this.type === "encrypt") {
      for (var l = 0; l < this.blockSize; l++)
        f2[l] ^= e[r3 + l];
      o._update.call(this, f2, 0, i, n);
      for (var l = 0; l < this.blockSize; l++)
        f2[l] = i[n + l];
    } else {
      o._update.call(this, e, r3, i, n);
      for (var l = 0; l < this.blockSize; l++)
        i[n + l] ^= f2[l];
      for (var l = 0; l < this.blockSize; l++)
        f2[l] = e[r3 + l];
    }
  };
});
var H2 = k((yD, z2) => {
  U();
  var O7 = zr(), j7 = At(), U2 = ul(), jn = Ep();
  function L7(t, e) {
    O7.equal(e.length, 24, "Invalid key length");
    var r3 = e.slice(0, 8), i = e.slice(8, 16), n = e.slice(16, 24);
    t === "encrypt" ? this.ciphers = [jn.create({ type: "encrypt", key: r3 }), jn.create({ type: "decrypt", key: i }), jn.create({ type: "encrypt", key: n })] : this.ciphers = [jn.create({ type: "decrypt", key: n }), jn.create({ type: "encrypt", key: i }), jn.create({ type: "decrypt", key: r3 })];
  }
  function Ms(t) {
    U2.call(this, t);
    var e = new L7(this.type, this.options.key);
    this._edeState = e;
  }
  j7(Ms, U2);
  z2.exports = Ms;
  Ms.create = function(e) {
    return new Ms(e);
  };
  Ms.prototype._update = function(e, r3, i, n) {
    var s = this._edeState;
    s.ciphers[0]._update(e, r3, i, n), s.ciphers[1]._update(i, n, i, n), s.ciphers[2]._update(i, n, i, n);
  };
  Ms.prototype._pad = jn.prototype._pad;
  Ms.prototype._unpad = jn.prototype._unpad;
});
var K2 = k((Oo) => {
  U();
  Oo.utils = Ap();
  Oo.Cipher = ul();
  Oo.DES = Ep();
  Oo.CBC = P2();
  Oo.EDE = H2();
});
var W2 = k((vD, $2) => {
  U();
  var G2 = sn(), on = K2(), q7 = At(), Ss = Mt().Buffer, Gf = { "des-ede3-cbc": on.CBC.instantiate(on.EDE), "des-ede3": on.EDE, "des-ede-cbc": on.CBC.instantiate(on.EDE), "des-ede": on.EDE, "des-cbc": on.CBC.instantiate(on.DES), "des-ecb": on.DES };
  Gf.des = Gf["des-cbc"];
  Gf.des3 = Gf["des-ede3-cbc"];
  $2.exports = ll;
  q7(ll, G2);
  function ll(t) {
    G2.call(this);
    var e = t.mode.toLowerCase(), r3 = Gf[e], i;
    t.decrypt ? i = "decrypt" : i = "encrypt";
    var n = t.key;
    Ss.isBuffer(n) || (n = Ss.from(n)), (e === "des-ede" || e === "des-ede-cbc") && (n = Ss.concat([n, n.slice(0, 8)]));
    var s = t.iv;
    Ss.isBuffer(s) || (s = Ss.from(s)), this._des = r3.create({ key: n, iv: s, type: i });
  }
  ll.prototype._update = function(t) {
    return Ss.from(this._des.update(t));
  };
  ll.prototype._final = function() {
    return Ss.from(this._des.final());
  };
});
var V2 = k((Mp) => {
  U();
  Mp.encrypt = function(t, e) {
    return t._cipher.encryptBlock(e);
  };
  Mp.decrypt = function(t, e) {
    return t._cipher.decryptBlock(e);
  };
});
var jo = k((wD, Y2) => {
  U();
  Y2.exports = function(e, r3) {
    for (var i = Math.min(e.length, r3.length), n = new b.Buffer(i), s = 0; s < i; ++s)
      n[s] = e[s] ^ r3[s];
    return n;
  };
});
var J2 = k((Sp) => {
  U();
  var Z2 = jo();
  Sp.encrypt = function(t, e) {
    var r3 = Z2(e, t._prev);
    return t._prev = t._cipher.encryptBlock(r3), t._prev;
  };
  Sp.decrypt = function(t, e) {
    var r3 = t._prev;
    t._prev = e;
    var i = t._cipher.decryptBlock(e);
    return Z2(i, r3);
  };
});
var ev = k((Q2) => {
  U();
  var $f = Mt().Buffer, P7 = jo();
  function X2(t, e, r3) {
    var i = e.length, n = P7(e, t._cache);
    return t._cache = t._cache.slice(i), t._prev = $f.concat([t._prev, r3 ? e : n]), n;
  }
  Q2.encrypt = function(t, e, r3) {
    for (var i = $f.allocUnsafe(0), n; e.length; )
      if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = $f.allocUnsafe(0)), t._cache.length <= e.length)
        n = t._cache.length, i = $f.concat([i, X2(t, e.slice(0, n), r3)]), e = e.slice(n);
      else {
        i = $f.concat([i, X2(t, e, r3)]);
        break;
      }
    return i;
  };
});
var rv = k((tv) => {
  U();
  var Ip = Mt().Buffer;
  function U7(t, e, r3) {
    var i = t._cipher.encryptBlock(t._prev), n = i[0] ^ e;
    return t._prev = Ip.concat([t._prev.slice(1), Ip.from([r3 ? e : n])]), n;
  }
  tv.encrypt = function(t, e, r3) {
    for (var i = e.length, n = Ip.allocUnsafe(i), s = -1; ++s < i; )
      n[s] = U7(t, e[s], r3);
    return n;
  };
});
var nv = k((iv) => {
  U();
  var hl = Mt().Buffer;
  function z7(t, e, r3) {
    for (var i, n = -1, s = 8, o = 0, f2, l; ++n < s; )
      i = t._cipher.encryptBlock(t._prev), f2 = e & 1 << 7 - n ? 128 : 0, l = i[0] ^ f2, o += (l & 128) >> n % 8, t._prev = H7(t._prev, r3 ? f2 : l);
    return o;
  }
  function H7(t, e) {
    var r3 = t.length, i = -1, n = hl.allocUnsafe(t.length);
    for (t = hl.concat([t, hl.from([e])]); ++i < r3; )
      n[i] = t[i] << 1 | t[i + 1] >> 7;
    return n;
  }
  iv.encrypt = function(t, e, r3) {
    for (var i = e.length, n = hl.allocUnsafe(i), s = -1; ++s < i; )
      n[s] = z7(t, e[s], r3);
    return n;
  };
});
var ov = k((sv) => {
  U();
  var K7 = jo();
  function G7(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
  }
  sv.encrypt = function(t, e) {
    for (; t._cache.length < e.length; )
      t._cache = b.Buffer.concat([t._cache, G7(t)]);
    var r3 = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), K7(e, r3);
  };
});
var Tp = k((ID, av) => {
  U();
  function $7(t) {
    for (var e = t.length, r3; e--; )
      if (r3 = t.readUInt8(e), r3 === 255)
        t.writeUInt8(0, e);
      else {
        r3++, t.writeUInt8(r3, e);
        break;
      }
  }
  av.exports = $7;
});
var Rp = k((cv) => {
  U();
  var W7 = jo(), fv = Mt().Buffer, V7 = Tp();
  function Y7(t) {
    var e = t._cipher.encryptBlockRaw(t._prev);
    return V7(t._prev), e;
  }
  var Fp = 16;
  cv.encrypt = function(t, e) {
    var r3 = Math.ceil(e.length / Fp), i = t._cache.length;
    t._cache = fv.concat([t._cache, fv.allocUnsafe(r3 * Fp)]);
    for (var n = 0; n < r3; n++) {
      var s = Y7(t), o = i + n * Fp;
      t._cache.writeUInt32BE(s[0], o + 0), t._cache.writeUInt32BE(s[1], o + 4), t._cache.writeUInt32BE(s[2], o + 8), t._cache.writeUInt32BE(s[3], o + 12);
    }
    var f2 = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), W7(e, f2);
  };
});
var kp = k((FD, Z7) => {
  Z7.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
});
var gl = k((RD, uv) => {
  U();
  var J7 = { ECB: V2(), CBC: J2(), CFB: ev(), CFB8: rv(), CFB1: nv(), OFB: ov(), CTR: Rp(), GCM: Rp() }, pl = kp();
  for (Dp in pl)
    pl[Dp].module = J7[pl[Dp].mode];
  var Dp;
  uv.exports = pl;
});
var Wf = k((kD, lv) => {
  U();
  var ml = Mt().Buffer;
  function Bp(t) {
    ml.isBuffer(t) || (t = ml.from(t));
    for (var e = t.length / 4 | 0, r3 = new Array(e), i = 0; i < e; i++)
      r3[i] = t.readUInt32BE(i * 4);
    return r3;
  }
  function Np(t) {
    for (var e = 0; e < t.length; t++)
      t[e] = 0;
  }
  function dv(t, e, r3, i, n) {
    for (var s = r3[0], o = r3[1], f2 = r3[2], l = r3[3], g5 = t[0] ^ e[0], _ = t[1] ^ e[1], N2 = t[2] ^ e[2], U2 = t[3] ^ e[3], V, G, ee2, W5, Z = 4, le = 1; le < n; le++)
      V = s[g5 >>> 24] ^ o[_ >>> 16 & 255] ^ f2[N2 >>> 8 & 255] ^ l[U2 & 255] ^ e[Z++], G = s[_ >>> 24] ^ o[N2 >>> 16 & 255] ^ f2[U2 >>> 8 & 255] ^ l[g5 & 255] ^ e[Z++], ee2 = s[N2 >>> 24] ^ o[U2 >>> 16 & 255] ^ f2[g5 >>> 8 & 255] ^ l[_ & 255] ^ e[Z++], W5 = s[U2 >>> 24] ^ o[g5 >>> 16 & 255] ^ f2[_ >>> 8 & 255] ^ l[N2 & 255] ^ e[Z++], g5 = V, _ = G, N2 = ee2, U2 = W5;
    return V = (i[g5 >>> 24] << 24 | i[_ >>> 16 & 255] << 16 | i[N2 >>> 8 & 255] << 8 | i[U2 & 255]) ^ e[Z++], G = (i[_ >>> 24] << 24 | i[N2 >>> 16 & 255] << 16 | i[U2 >>> 8 & 255] << 8 | i[g5 & 255]) ^ e[Z++], ee2 = (i[N2 >>> 24] << 24 | i[U2 >>> 16 & 255] << 16 | i[g5 >>> 8 & 255] << 8 | i[_ & 255]) ^ e[Z++], W5 = (i[U2 >>> 24] << 24 | i[g5 >>> 16 & 255] << 16 | i[_ >>> 8 & 255] << 8 | i[N2 & 255]) ^ e[Z++], V = V >>> 0, G = G >>> 0, ee2 = ee2 >>> 0, W5 = W5 >>> 0, [V, G, ee2, W5];
  }
  var X7 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], fr2 = function() {
    for (var t = new Array(256), e = 0; e < 256; e++)
      e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
    for (var r3 = [], i = [], n = [[], [], [], []], s = [[], [], [], []], o = 0, f2 = 0, l = 0; l < 256; ++l) {
      var g5 = f2 ^ f2 << 1 ^ f2 << 2 ^ f2 << 3 ^ f2 << 4;
      g5 = g5 >>> 8 ^ g5 & 255 ^ 99, r3[o] = g5, i[g5] = o;
      var _ = t[o], N2 = t[_], U2 = t[N2], V = t[g5] * 257 ^ g5 * 16843008;
      n[0][o] = V << 24 | V >>> 8, n[1][o] = V << 16 | V >>> 16, n[2][o] = V << 8 | V >>> 24, n[3][o] = V, V = U2 * 16843009 ^ N2 * 65537 ^ _ * 257 ^ o * 16843008, s[0][g5] = V << 24 | V >>> 8, s[1][g5] = V << 16 | V >>> 16, s[2][g5] = V << 8 | V >>> 24, s[3][g5] = V, o === 0 ? o = f2 = 1 : (o = _ ^ t[t[t[U2 ^ _]]], f2 ^= t[t[f2]]);
    }
    return { SBOX: r3, INV_SBOX: i, SUB_MIX: n, INV_SUB_MIX: s };
  }();
  function Qr(t) {
    this._key = Bp(t), this._reset();
  }
  Qr.blockSize = 4 * 4;
  Qr.keySize = 256 / 8;
  Qr.prototype.blockSize = Qr.blockSize;
  Qr.prototype.keySize = Qr.keySize;
  Qr.prototype._reset = function() {
    for (var t = this._key, e = t.length, r3 = e + 6, i = (r3 + 1) * 4, n = [], s = 0; s < e; s++)
      n[s] = t[s];
    for (s = e; s < i; s++) {
      var o = n[s - 1];
      s % e === 0 ? (o = o << 8 | o >>> 24, o = fr2.SBOX[o >>> 24] << 24 | fr2.SBOX[o >>> 16 & 255] << 16 | fr2.SBOX[o >>> 8 & 255] << 8 | fr2.SBOX[o & 255], o ^= X7[s / e | 0] << 24) : e > 6 && s % e === 4 && (o = fr2.SBOX[o >>> 24] << 24 | fr2.SBOX[o >>> 16 & 255] << 16 | fr2.SBOX[o >>> 8 & 255] << 8 | fr2.SBOX[o & 255]), n[s] = n[s - e] ^ o;
    }
    for (var f2 = [], l = 0; l < i; l++) {
      var g5 = i - l, _ = n[g5 - (l % 4 ? 0 : 4)];
      l < 4 || g5 <= 4 ? f2[l] = _ : f2[l] = fr2.INV_SUB_MIX[0][fr2.SBOX[_ >>> 24]] ^ fr2.INV_SUB_MIX[1][fr2.SBOX[_ >>> 16 & 255]] ^ fr2.INV_SUB_MIX[2][fr2.SBOX[_ >>> 8 & 255]] ^ fr2.INV_SUB_MIX[3][fr2.SBOX[_ & 255]];
    }
    this._nRounds = r3, this._keySchedule = n, this._invKeySchedule = f2;
  };
  Qr.prototype.encryptBlockRaw = function(t) {
    return t = Bp(t), dv(t, this._keySchedule, fr2.SUB_MIX, fr2.SBOX, this._nRounds);
  };
  Qr.prototype.encryptBlock = function(t) {
    var e = this.encryptBlockRaw(t), r3 = ml.allocUnsafe(16);
    return r3.writeUInt32BE(e[0], 0), r3.writeUInt32BE(e[1], 4), r3.writeUInt32BE(e[2], 8), r3.writeUInt32BE(e[3], 12), r3;
  };
  Qr.prototype.decryptBlock = function(t) {
    t = Bp(t);
    var e = t[1];
    t[1] = t[3], t[3] = e;
    var r3 = dv(t, this._invKeySchedule, fr2.INV_SUB_MIX, fr2.INV_SBOX, this._nRounds), i = ml.allocUnsafe(16);
    return i.writeUInt32BE(r3[0], 0), i.writeUInt32BE(r3[3], 4), i.writeUInt32BE(r3[2], 8), i.writeUInt32BE(r3[1], 12), i;
  };
  Qr.prototype.scrub = function() {
    Np(this._keySchedule), Np(this._invKeySchedule), Np(this._key);
  };
  lv.exports.AES = Qr;
});
var gv = k((DD, pv) => {
  U();
  var Lo = Mt().Buffer, Q7 = Lo.alloc(16, 0);
  function eE(t) {
    return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
  }
  function hv(t) {
    var e = Lo.allocUnsafe(16);
    return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
  }
  function Vf(t) {
    this.h = t, this.state = Lo.alloc(16, 0), this.cache = Lo.allocUnsafe(0);
  }
  Vf.prototype.ghash = function(t) {
    for (var e = -1; ++e < t.length; )
      this.state[e] ^= t[e];
    this._multiply();
  };
  Vf.prototype._multiply = function() {
    for (var t = eE(this.h), e = [0, 0, 0, 0], r3, i, n, s = -1; ++s < 128; ) {
      for (i = (this.state[~~(s / 8)] & 1 << 7 - s % 8) !== 0, i && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), n = (t[3] & 1) !== 0, r3 = 3; r3 > 0; r3--)
        t[r3] = t[r3] >>> 1 | (t[r3 - 1] & 1) << 31;
      t[0] = t[0] >>> 1, n && (t[0] = t[0] ^ 225 << 24);
    }
    this.state = hv(e);
  };
  Vf.prototype.update = function(t) {
    this.cache = Lo.concat([this.cache, t]);
    for (var e; this.cache.length >= 16; )
      e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
  };
  Vf.prototype.final = function(t, e) {
    return this.cache.length && this.ghash(Lo.concat([this.cache, Q7], 16)), this.ghash(hv([0, t, 0, e])), this.state;
  };
  pv.exports = Vf;
});
var Cp = k((ND, bv) => {
  U();
  var tE = Wf(), jr = Mt().Buffer, mv = sn(), rE = At(), yv = gv(), iE = jo(), nE = Tp();
  function sE(t, e) {
    var r3 = 0;
    t.length !== e.length && r3++;
    for (var i = Math.min(t.length, e.length), n = 0; n < i; ++n)
      r3 += t[n] ^ e[n];
    return r3;
  }
  function oE(t, e, r3) {
    if (e.length === 12)
      return t._finID = jr.concat([e, jr.from([0, 0, 0, 1])]), jr.concat([e, jr.from([0, 0, 0, 2])]);
    var i = new yv(r3), n = e.length, s = n % 16;
    i.update(e), s && (s = 16 - s, i.update(jr.alloc(s, 0))), i.update(jr.alloc(8, 0));
    var o = n * 8, f2 = jr.alloc(8);
    f2.writeUIntBE(o, 0, 8), i.update(f2), t._finID = i.state;
    var l = jr.from(t._finID);
    return nE(l), l;
  }
  function Is(t, e, r3, i) {
    mv.call(this);
    var n = jr.alloc(4, 0);
    this._cipher = new tE.AES(e);
    var s = this._cipher.encryptBlock(n);
    this._ghash = new yv(s), r3 = oE(this, r3, s), this._prev = jr.from(r3), this._cache = jr.allocUnsafe(0), this._secCache = jr.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
  }
  rE(Is, mv);
  Is.prototype._update = function(t) {
    if (!this._called && this._alen) {
      var e = 16 - this._alen % 16;
      e < 16 && (e = jr.alloc(e, 0), this._ghash.update(e));
    }
    this._called = true;
    var r3 = this._mode.encrypt(this, t);
    return this._decrypt ? this._ghash.update(t) : this._ghash.update(r3), this._len += t.length, r3;
  };
  Is.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var t = iE(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && sE(t, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = t, this._cipher.scrub();
  };
  Is.prototype.getAuthTag = function() {
    if (this._decrypt || !jr.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  Is.prototype.setAuthTag = function(e) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = e;
  };
  Is.prototype.setAAD = function(e) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(e), this._alen += e.length;
  };
  bv.exports = Is;
});
var jp = k((BD, xv) => {
  U();
  var aE = Wf(), Op = Mt().Buffer, vv = sn(), fE = At();
  function yl(t, e, r3, i) {
    vv.call(this), this._cipher = new aE.AES(e), this._prev = Op.from(r3), this._cache = Op.allocUnsafe(0), this._secCache = Op.allocUnsafe(0), this._decrypt = i, this._mode = t;
  }
  fE(yl, vv);
  yl.prototype._update = function(t) {
    return this._mode.encrypt(this, t, this._decrypt);
  };
  yl.prototype._final = function() {
    this._cipher.scrub();
  };
  xv.exports = yl;
});
var Yf = k((CD, wv) => {
  U();
  var Ts = Mt().Buffer, cE = Jd();
  function uE(t, e, r3, i) {
    if (Ts.isBuffer(t) || (t = Ts.from(t, "binary")), e && (Ts.isBuffer(e) || (e = Ts.from(e, "binary")), e.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var n = r3 / 8, s = Ts.alloc(n), o = Ts.alloc(i || 0), f2 = Ts.alloc(0); n > 0 || i > 0; ) {
      var l = new cE();
      l.update(f2), l.update(t), e && l.update(e), f2 = l.digest();
      var g5 = 0;
      if (n > 0) {
        var _ = s.length - n;
        g5 = Math.min(n, f2.length), f2.copy(s, _, 0, g5), n -= g5;
      }
      if (g5 < f2.length && i > 0) {
        var N2 = o.length - i, U2 = Math.min(i, f2.length - g5);
        f2.copy(o, N2, g5, g5 + U2), i -= U2;
      }
    }
    return f2.fill(0), { key: s, iv: o };
  }
  wv.exports = uE;
});
var Mv = k((Lp) => {
  U();
  var _v = gl(), dE = Cp(), an = Mt().Buffer, lE = jp(), Av = sn(), hE = Wf(), pE = Yf(), gE = At();
  function Zf(t, e, r3) {
    Av.call(this), this._cache = new bl(), this._cipher = new hE.AES(e), this._prev = an.from(r3), this._mode = t, this._autopadding = true;
  }
  gE(Zf, Av);
  Zf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r3, i = []; e = this._cache.get(); )
      r3 = this._mode.encrypt(this, e), i.push(r3);
    return an.concat(i);
  };
  var mE = an.alloc(16, 16);
  Zf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
    if (!t.equals(mE))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  Zf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function bl() {
    this.cache = an.allocUnsafe(0);
  }
  bl.prototype.add = function(t) {
    this.cache = an.concat([this.cache, t]);
  };
  bl.prototype.get = function() {
    if (this.cache.length > 15) {
      var t = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), t;
    }
    return null;
  };
  bl.prototype.flush = function() {
    for (var t = 16 - this.cache.length, e = an.allocUnsafe(t), r3 = -1; ++r3 < t; )
      e.writeUInt8(t, r3);
    return an.concat([this.cache, e]);
  };
  function Ev(t, e, r3) {
    var i = _v[t.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof e == "string" && (e = an.from(e)), e.length !== i.key / 8)
      throw new TypeError("invalid key length " + e.length);
    if (typeof r3 == "string" && (r3 = an.from(r3)), i.mode !== "GCM" && r3.length !== i.iv)
      throw new TypeError("invalid iv length " + r3.length);
    return i.type === "stream" ? new lE(i.module, e, r3) : i.type === "auth" ? new dE(i.module, e, r3) : new Zf(i.module, e, r3);
  }
  function yE(t, e) {
    var r3 = _v[t.toLowerCase()];
    if (!r3)
      throw new TypeError("invalid suite type");
    var i = pE(e, false, r3.key, r3.iv);
    return Ev(t, i.key, i.iv);
  }
  Lp.createCipheriv = Ev;
  Lp.createCipher = yE;
});
var Fv = k((qp) => {
  U();
  var bE = Cp(), qo = Mt().Buffer, Sv = gl(), vE = jp(), Iv = sn(), xE = Wf(), wE = Yf(), _E = At();
  function Jf(t, e, r3) {
    Iv.call(this), this._cache = new vl(), this._last = void 0, this._cipher = new xE.AES(e), this._prev = qo.from(r3), this._mode = t, this._autopadding = true;
  }
  _E(Jf, Iv);
  Jf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r3, i = []; e = this._cache.get(this._autopadding); )
      r3 = this._mode.decrypt(this, e), i.push(r3);
    return qo.concat(i);
  };
  Jf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return AE(this._mode.decrypt(this, t));
    if (t)
      throw new Error("data not multiple of block length");
  };
  Jf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function vl() {
    this.cache = qo.allocUnsafe(0);
  }
  vl.prototype.add = function(t) {
    this.cache = qo.concat([this.cache, t]);
  };
  vl.prototype.get = function(t) {
    var e;
    if (t) {
      if (this.cache.length > 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    } else if (this.cache.length >= 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    return null;
  };
  vl.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function AE(t) {
    var e = t[15];
    if (e < 1 || e > 16)
      throw new Error("unable to decrypt data");
    for (var r3 = -1; ++r3 < e; )
      if (t[r3 + (16 - e)] !== e)
        throw new Error("unable to decrypt data");
    if (e !== 16)
      return t.slice(0, 16 - e);
  }
  function Tv(t, e, r3) {
    var i = Sv[t.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof r3 == "string" && (r3 = qo.from(r3)), i.mode !== "GCM" && r3.length !== i.iv)
      throw new TypeError("invalid iv length " + r3.length);
    if (typeof e == "string" && (e = qo.from(e)), e.length !== i.key / 8)
      throw new TypeError("invalid key length " + e.length);
    return i.type === "stream" ? new vE(i.module, e, r3, true) : i.type === "auth" ? new bE(i.module, e, r3, true) : new Jf(i.module, e, r3);
  }
  function EE(t, e) {
    var r3 = Sv[t.toLowerCase()];
    if (!r3)
      throw new TypeError("invalid suite type");
    var i = wE(e, false, r3.key, r3.iv);
    return Tv(t, i.key, i.iv);
  }
  qp.createDecipher = EE;
  qp.createDecipheriv = Tv;
});
var xl = k((yi) => {
  U();
  var Rv = Mv(), kv = Fv(), ME = kp();
  function SE() {
    return Object.keys(ME);
  }
  yi.createCipher = yi.Cipher = Rv.createCipher;
  yi.createCipheriv = yi.Cipheriv = Rv.createCipheriv;
  yi.createDecipher = yi.Decipher = kv.createDecipher;
  yi.createDecipheriv = yi.Decipheriv = kv.createDecipheriv;
  yi.listCiphers = yi.getCiphers = SE;
});
var Dv = k((fn) => {
  U();
  fn["des-ecb"] = { key: 8, iv: 0 };
  fn["des-cbc"] = fn.des = { key: 8, iv: 8 };
  fn["des-ede3-cbc"] = fn.des3 = { key: 24, iv: 8 };
  fn["des-ede3"] = { key: 24, iv: 0 };
  fn["des-ede-cbc"] = { key: 16, iv: 8 };
  fn["des-ede"] = { key: 16, iv: 0 };
});
var jv = k((bi) => {
  U();
  var Nv = W2(), Pp = xl(), Ln = gl(), cn = Dv(), Bv = Yf();
  function IE(t, e) {
    t = t.toLowerCase();
    var r3, i;
    if (Ln[t])
      r3 = Ln[t].key, i = Ln[t].iv;
    else if (cn[t])
      r3 = cn[t].key * 8, i = cn[t].iv;
    else
      throw new TypeError("invalid suite type");
    var n = Bv(e, false, r3, i);
    return Cv(t, n.key, n.iv);
  }
  function TE(t, e) {
    t = t.toLowerCase();
    var r3, i;
    if (Ln[t])
      r3 = Ln[t].key, i = Ln[t].iv;
    else if (cn[t])
      r3 = cn[t].key * 8, i = cn[t].iv;
    else
      throw new TypeError("invalid suite type");
    var n = Bv(e, false, r3, i);
    return Ov(t, n.key, n.iv);
  }
  function Cv(t, e, r3) {
    if (t = t.toLowerCase(), Ln[t])
      return Pp.createCipheriv(t, e, r3);
    if (cn[t])
      return new Nv({ key: e, iv: r3, mode: t });
    throw new TypeError("invalid suite type");
  }
  function Ov(t, e, r3) {
    if (t = t.toLowerCase(), Ln[t])
      return Pp.createDecipheriv(t, e, r3);
    if (cn[t])
      return new Nv({ key: e, iv: r3, mode: t, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function FE() {
    return Object.keys(cn).concat(Pp.getCiphers());
  }
  bi.createCipher = bi.Cipher = IE;
  bi.createCipheriv = bi.Cipheriv = Cv;
  bi.createDecipher = bi.Decipher = TE;
  bi.createDecipheriv = bi.Decipheriv = Ov;
  bi.listCiphers = bi.getCiphers = FE;
});
var dr = k((Lv, Up) => {
  U();
  (function(t, e) {
    function r3(E2, c) {
      if (!E2)
        throw new Error(c || "Assertion failed");
    }
    function i(E2, c) {
      E2.super_ = c;
      var m2 = function() {
      };
      m2.prototype = c.prototype, E2.prototype = new m2(), E2.prototype.constructor = E2;
    }
    function n(E2, c, m2) {
      if (n.isBN(E2))
        return E2;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E2 !== null && ((c === "le" || c === "be") && (m2 = c, c = 10), this._init(E2 || 0, c || 10, m2 || "be"));
    }
    typeof t == "object" ? t.exports = n : e.BN = n, n.BN = n, n.wordSize = 26;
    var s;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s = window.Buffer : s = or().Buffer;
    } catch {
    }
    n.isBN = function(c) {
      return c instanceof n ? true : c !== null && typeof c == "object" && c.constructor.wordSize === n.wordSize && Array.isArray(c.words);
    }, n.max = function(c, m2) {
      return c.cmp(m2) > 0 ? c : m2;
    }, n.min = function(c, m2) {
      return c.cmp(m2) < 0 ? c : m2;
    }, n.prototype._init = function(c, m2, h2) {
      if (typeof c == "number")
        return this._initNumber(c, m2, h2);
      if (typeof c == "object")
        return this._initArray(c, m2, h2);
      m2 === "hex" && (m2 = 16), r3(m2 === (m2 | 0) && m2 >= 2 && m2 <= 36), c = c.toString().replace(/\s+/g, "");
      var a = 0;
      c[0] === "-" && (a++, this.negative = 1), a < c.length && (m2 === 16 ? this._parseHex(c, a, h2) : (this._parseBase(c, m2, a), h2 === "le" && this._initArray(this.toArray(), m2, h2)));
    }, n.prototype._initNumber = function(c, m2, h2) {
      c < 0 && (this.negative = 1, c = -c), c < 67108864 ? (this.words = [c & 67108863], this.length = 1) : c < 4503599627370496 ? (this.words = [c & 67108863, c / 67108864 & 67108863], this.length = 2) : (r3(c < 9007199254740992), this.words = [c & 67108863, c / 67108864 & 67108863, 1], this.length = 3), h2 === "le" && this._initArray(this.toArray(), m2, h2);
    }, n.prototype._initArray = function(c, m2, h2) {
      if (r3(typeof c.length == "number"), c.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c.length / 3), this.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        this.words[a] = 0;
      var u3, b2, A2 = 0;
      if (h2 === "be")
        for (a = c.length - 1, u3 = 0; a >= 0; a -= 3)
          b2 = c[a] | c[a - 1] << 8 | c[a - 2] << 16, this.words[u3] |= b2 << A2 & 67108863, this.words[u3 + 1] = b2 >>> 26 - A2 & 67108863, A2 += 24, A2 >= 26 && (A2 -= 26, u3++);
      else if (h2 === "le")
        for (a = 0, u3 = 0; a < c.length; a += 3)
          b2 = c[a] | c[a + 1] << 8 | c[a + 2] << 16, this.words[u3] |= b2 << A2 & 67108863, this.words[u3 + 1] = b2 >>> 26 - A2 & 67108863, A2 += 24, A2 >= 26 && (A2 -= 26, u3++);
      return this.strip();
    };
    function o(E2, c) {
      var m2 = E2.charCodeAt(c);
      return m2 >= 65 && m2 <= 70 ? m2 - 55 : m2 >= 97 && m2 <= 102 ? m2 - 87 : m2 - 48 & 15;
    }
    function f2(E2, c, m2) {
      var h2 = o(E2, m2);
      return m2 - 1 >= c && (h2 |= o(E2, m2 - 1) << 4), h2;
    }
    n.prototype._parseHex = function(c, m2, h2) {
      this.length = Math.ceil((c.length - m2) / 6), this.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        this.words[a] = 0;
      var u3 = 0, b2 = 0, A2;
      if (h2 === "be")
        for (a = c.length - 1; a >= m2; a -= 2)
          A2 = f2(c, m2, a) << u3, this.words[b2] |= A2 & 67108863, u3 >= 18 ? (u3 -= 18, b2 += 1, this.words[b2] |= A2 >>> 26) : u3 += 8;
      else {
        var v2 = c.length - m2;
        for (a = v2 % 2 === 0 ? m2 + 1 : m2; a < c.length; a += 2)
          A2 = f2(c, m2, a) << u3, this.words[b2] |= A2 & 67108863, u3 >= 18 ? (u3 -= 18, b2 += 1, this.words[b2] |= A2 >>> 26) : u3 += 8;
      }
      this.strip();
    };
    function l(E2, c, m2, h2) {
      for (var a = 0, u3 = Math.min(E2.length, m2), b2 = c; b2 < u3; b2++) {
        var A2 = E2.charCodeAt(b2) - 48;
        a *= h2, A2 >= 49 ? a += A2 - 49 + 10 : A2 >= 17 ? a += A2 - 17 + 10 : a += A2;
      }
      return a;
    }
    n.prototype._parseBase = function(c, m2, h2) {
      this.words = [0], this.length = 1;
      for (var a = 0, u3 = 1; u3 <= 67108863; u3 *= m2)
        a++;
      a--, u3 = u3 / m2 | 0;
      for (var b2 = c.length - h2, A2 = b2 % a, v2 = Math.min(b2, b2 - A2) + h2, d2 = 0, M = h2; M < v2; M += a)
        d2 = l(c, M, M + a, m2), this.imuln(u3), this.words[0] + d2 < 67108864 ? this.words[0] += d2 : this._iaddn(d2);
      if (A2 !== 0) {
        var B2 = 1;
        for (d2 = l(c, M, c.length, m2), M = 0; M < A2; M++)
          B2 *= m2;
        this.imuln(B2), this.words[0] + d2 < 67108864 ? this.words[0] += d2 : this._iaddn(d2);
      }
      this.strip();
    }, n.prototype.copy = function(c) {
      c.words = new Array(this.length);
      for (var m2 = 0; m2 < this.length; m2++)
        c.words[m2] = this.words[m2];
      c.length = this.length, c.negative = this.negative, c.red = this.red;
    }, n.prototype.clone = function() {
      var c = new n(null);
      return this.copy(c), c;
    }, n.prototype._expand = function(c) {
      for (; this.length < c; )
        this.words[this.length++] = 0;
      return this;
    }, n.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, n.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, n.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var g5 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], _ = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], N2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    n.prototype.toString = function(c, m2) {
      c = c || 10, m2 = m2 | 0 || 1;
      var h2;
      if (c === 16 || c === "hex") {
        h2 = "";
        for (var a = 0, u3 = 0, b2 = 0; b2 < this.length; b2++) {
          var A2 = this.words[b2], v2 = ((A2 << a | u3) & 16777215).toString(16);
          u3 = A2 >>> 24 - a & 16777215, u3 !== 0 || b2 !== this.length - 1 ? h2 = g5[6 - v2.length] + v2 + h2 : h2 = v2 + h2, a += 2, a >= 26 && (a -= 26, b2--);
        }
        for (u3 !== 0 && (h2 = u3.toString(16) + h2); h2.length % m2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var d2 = _[c], M = N2[c];
        h2 = "";
        var B2 = this.clone();
        for (B2.negative = 0; !B2.isZero(); ) {
          var y2 = B2.modn(M).toString(c);
          B2 = B2.idivn(M), B2.isZero() ? h2 = y2 + h2 : h2 = g5[d2 - y2.length] + y2 + h2;
        }
        for (this.isZero() && (h2 = "0" + h2); h2.length % m2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      r3(false, "Base should be between 2 and 36");
    }, n.prototype.toNumber = function() {
      var c = this.words[0];
      return this.length === 2 ? c += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r3(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c : c;
    }, n.prototype.toJSON = function() {
      return this.toString(16);
    }, n.prototype.toBuffer = function(c, m2) {
      return r3(typeof s < "u"), this.toArrayLike(s, c, m2);
    }, n.prototype.toArray = function(c, m2) {
      return this.toArrayLike(Array, c, m2);
    }, n.prototype.toArrayLike = function(c, m2, h2) {
      var a = this.byteLength(), u3 = h2 || Math.max(1, a);
      r3(a <= u3, "byte array longer than desired length"), r3(u3 > 0, "Requested array length <= 0"), this.strip();
      var b2 = m2 === "le", A2 = new c(u3), v2, d2, M = this.clone();
      if (b2) {
        for (d2 = 0; !M.isZero(); d2++)
          v2 = M.andln(255), M.iushrn(8), A2[d2] = v2;
        for (; d2 < u3; d2++)
          A2[d2] = 0;
      } else {
        for (d2 = 0; d2 < u3 - a; d2++)
          A2[d2] = 0;
        for (d2 = 0; !M.isZero(); d2++)
          v2 = M.andln(255), M.iushrn(8), A2[u3 - d2 - 1] = v2;
      }
      return A2;
    }, Math.clz32 ? n.prototype._countBits = function(c) {
      return 32 - Math.clz32(c);
    } : n.prototype._countBits = function(c) {
      var m2 = c, h2 = 0;
      return m2 >= 4096 && (h2 += 13, m2 >>>= 13), m2 >= 64 && (h2 += 7, m2 >>>= 7), m2 >= 8 && (h2 += 4, m2 >>>= 4), m2 >= 2 && (h2 += 2, m2 >>>= 2), h2 + m2;
    }, n.prototype._zeroBits = function(c) {
      if (c === 0)
        return 26;
      var m2 = c, h2 = 0;
      return (m2 & 8191) === 0 && (h2 += 13, m2 >>>= 13), (m2 & 127) === 0 && (h2 += 7, m2 >>>= 7), (m2 & 15) === 0 && (h2 += 4, m2 >>>= 4), (m2 & 3) === 0 && (h2 += 2, m2 >>>= 2), (m2 & 1) === 0 && h2++, h2;
    }, n.prototype.bitLength = function() {
      var c = this.words[this.length - 1], m2 = this._countBits(c);
      return (this.length - 1) * 26 + m2;
    };
    function U2(E2) {
      for (var c = new Array(E2.bitLength()), m2 = 0; m2 < c.length; m2++) {
        var h2 = m2 / 26 | 0, a = m2 % 26;
        c[m2] = (E2.words[h2] & 1 << a) >>> a;
      }
      return c;
    }
    n.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c = 0, m2 = 0; m2 < this.length; m2++) {
        var h2 = this._zeroBits(this.words[m2]);
        if (c += h2, h2 !== 26)
          break;
      }
      return c;
    }, n.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, n.prototype.toTwos = function(c) {
      return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
    }, n.prototype.fromTwos = function(c) {
      return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
    }, n.prototype.isNeg = function() {
      return this.negative !== 0;
    }, n.prototype.neg = function() {
      return this.clone().ineg();
    }, n.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, n.prototype.iuor = function(c) {
      for (; this.length < c.length; )
        this.words[this.length++] = 0;
      for (var m2 = 0; m2 < c.length; m2++)
        this.words[m2] = this.words[m2] | c.words[m2];
      return this.strip();
    }, n.prototype.ior = function(c) {
      return r3((this.negative | c.negative) === 0), this.iuor(c);
    }, n.prototype.or = function(c) {
      return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
    }, n.prototype.uor = function(c) {
      return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
    }, n.prototype.iuand = function(c) {
      var m2;
      this.length > c.length ? m2 = c : m2 = this;
      for (var h2 = 0; h2 < m2.length; h2++)
        this.words[h2] = this.words[h2] & c.words[h2];
      return this.length = m2.length, this.strip();
    }, n.prototype.iand = function(c) {
      return r3((this.negative | c.negative) === 0), this.iuand(c);
    }, n.prototype.and = function(c) {
      return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
    }, n.prototype.uand = function(c) {
      return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
    }, n.prototype.iuxor = function(c) {
      var m2, h2;
      this.length > c.length ? (m2 = this, h2 = c) : (m2 = c, h2 = this);
      for (var a = 0; a < h2.length; a++)
        this.words[a] = m2.words[a] ^ h2.words[a];
      if (this !== m2)
        for (; a < m2.length; a++)
          this.words[a] = m2.words[a];
      return this.length = m2.length, this.strip();
    }, n.prototype.ixor = function(c) {
      return r3((this.negative | c.negative) === 0), this.iuxor(c);
    }, n.prototype.xor = function(c) {
      return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
    }, n.prototype.uxor = function(c) {
      return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
    }, n.prototype.inotn = function(c) {
      r3(typeof c == "number" && c >= 0);
      var m2 = Math.ceil(c / 26) | 0, h2 = c % 26;
      this._expand(m2), h2 > 0 && m2--;
      for (var a = 0; a < m2; a++)
        this.words[a] = ~this.words[a] & 67108863;
      return h2 > 0 && (this.words[a] = ~this.words[a] & 67108863 >> 26 - h2), this.strip();
    }, n.prototype.notn = function(c) {
      return this.clone().inotn(c);
    }, n.prototype.setn = function(c, m2) {
      r3(typeof c == "number" && c >= 0);
      var h2 = c / 26 | 0, a = c % 26;
      return this._expand(h2 + 1), m2 ? this.words[h2] = this.words[h2] | 1 << a : this.words[h2] = this.words[h2] & ~(1 << a), this.strip();
    }, n.prototype.iadd = function(c) {
      var m2;
      if (this.negative !== 0 && c.negative === 0)
        return this.negative = 0, m2 = this.isub(c), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c.negative !== 0)
        return c.negative = 0, m2 = this.isub(c), c.negative = 1, m2._normSign();
      var h2, a;
      this.length > c.length ? (h2 = this, a = c) : (h2 = c, a = this);
      for (var u3 = 0, b2 = 0; b2 < a.length; b2++)
        m2 = (h2.words[b2] | 0) + (a.words[b2] | 0) + u3, this.words[b2] = m2 & 67108863, u3 = m2 >>> 26;
      for (; u3 !== 0 && b2 < h2.length; b2++)
        m2 = (h2.words[b2] | 0) + u3, this.words[b2] = m2 & 67108863, u3 = m2 >>> 26;
      if (this.length = h2.length, u3 !== 0)
        this.words[this.length] = u3, this.length++;
      else if (h2 !== this)
        for (; b2 < h2.length; b2++)
          this.words[b2] = h2.words[b2];
      return this;
    }, n.prototype.add = function(c) {
      var m2;
      return c.negative !== 0 && this.negative === 0 ? (c.negative = 0, m2 = this.sub(c), c.negative ^= 1, m2) : c.negative === 0 && this.negative !== 0 ? (this.negative = 0, m2 = c.sub(this), this.negative = 1, m2) : this.length > c.length ? this.clone().iadd(c) : c.clone().iadd(this);
    }, n.prototype.isub = function(c) {
      if (c.negative !== 0) {
        c.negative = 0;
        var m2 = this.iadd(c);
        return c.negative = 1, m2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c), this.negative = 1, this._normSign();
      var h2 = this.cmp(c);
      if (h2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var a, u3;
      h2 > 0 ? (a = this, u3 = c) : (a = c, u3 = this);
      for (var b2 = 0, A2 = 0; A2 < u3.length; A2++)
        m2 = (a.words[A2] | 0) - (u3.words[A2] | 0) + b2, b2 = m2 >> 26, this.words[A2] = m2 & 67108863;
      for (; b2 !== 0 && A2 < a.length; A2++)
        m2 = (a.words[A2] | 0) + b2, b2 = m2 >> 26, this.words[A2] = m2 & 67108863;
      if (b2 === 0 && A2 < a.length && a !== this)
        for (; A2 < a.length; A2++)
          this.words[A2] = a.words[A2];
      return this.length = Math.max(this.length, A2), a !== this && (this.negative = 1), this.strip();
    }, n.prototype.sub = function(c) {
      return this.clone().isub(c);
    };
    function V(E2, c, m2) {
      m2.negative = c.negative ^ E2.negative;
      var h2 = E2.length + c.length | 0;
      m2.length = h2, h2 = h2 - 1 | 0;
      var a = E2.words[0] | 0, u3 = c.words[0] | 0, b2 = a * u3, A2 = b2 & 67108863, v2 = b2 / 67108864 | 0;
      m2.words[0] = A2;
      for (var d2 = 1; d2 < h2; d2++) {
        for (var M = v2 >>> 26, B2 = v2 & 67108863, y2 = Math.min(d2, c.length - 1), I = Math.max(0, d2 - E2.length + 1); I <= y2; I++) {
          var de = d2 - I | 0;
          a = E2.words[de] | 0, u3 = c.words[I] | 0, b2 = a * u3 + B2, M += b2 / 67108864 | 0, B2 = b2 & 67108863;
        }
        m2.words[d2] = B2 | 0, v2 = M | 0;
      }
      return v2 !== 0 ? m2.words[d2] = v2 | 0 : m2.length--, m2.strip();
    }
    var G = function(c, m2, h2) {
      var a = c.words, u3 = m2.words, b2 = h2.words, A2 = 0, v2, d2, M, B2 = a[0] | 0, y2 = B2 & 8191, I = B2 >>> 13, de = a[1] | 0, Me2 = de & 8191, Se = de >>> 13, Oe = a[2] | 0, ye = Oe & 8191, T = Oe >>> 13, j2 = a[3] | 0, P5 = j2 & 8191, te2 = j2 >>> 13, oe2 = a[4] | 0, re = oe2 & 8191, ae = oe2 >>> 13, ie = a[5] | 0, X2 = ie & 8191, R5 = ie >>> 13, x2 = a[6] | 0, F2 = x2 & 8191, q2 = x2 >>> 13, L2 = a[7] | 0, K5 = L2 & 8191, $ = L2 >>> 13, we2 = a[8] | 0, pe = we2 & 8191, _e = we2 >>> 13, fe2 = a[9] | 0, Fe = fe2 & 8191, De = fe2 >>> 13, pt2 = u3[0] | 0, je = pt2 & 8191, Ke = pt2 >>> 13, wt = u3[1] | 0, Pe = wt & 8191, Le2 = wt >>> 13, Vt = u3[2] | 0, Je = Vt & 8191, Xe2 = Vt >>> 13, Jt = u3[3] | 0, Qe = Jt & 8191, et = Jt >>> 13, Ut = u3[4] | 0, lt = Ut & 8191, ht = Ut >>> 13, tn = u3[5] | 0, gt = tn & 8191, yt = tn >>> 13, fs = u3[6] | 0, rt = fs & 8191, bt = fs >>> 13, S2 = u3[7] | 0, D2 = S2 & 8191, k2 = S2 >>> 13, p2 = u3[8] | 0, C2 = p2 & 8191, Q2 = p2 >>> 13, he = u3[9] | 0, ge2 = he & 8191, Ee = he >>> 13;
      h2.negative = c.negative ^ m2.negative, h2.length = 19, v2 = Math.imul(y2, je), d2 = Math.imul(y2, Ke), d2 = d2 + Math.imul(I, je) | 0, M = Math.imul(I, Ke);
      var Ve2 = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (Ve2 >>> 26) | 0, Ve2 &= 67108863, v2 = Math.imul(Me2, je), d2 = Math.imul(Me2, Ke), d2 = d2 + Math.imul(Se, je) | 0, M = Math.imul(Se, Ke), v2 = v2 + Math.imul(y2, Pe) | 0, d2 = d2 + Math.imul(y2, Le2) | 0, d2 = d2 + Math.imul(I, Pe) | 0, M = M + Math.imul(I, Le2) | 0;
      var Ne = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, v2 = Math.imul(ye, je), d2 = Math.imul(ye, Ke), d2 = d2 + Math.imul(T, je) | 0, M = Math.imul(T, Ke), v2 = v2 + Math.imul(Me2, Pe) | 0, d2 = d2 + Math.imul(Me2, Le2) | 0, d2 = d2 + Math.imul(Se, Pe) | 0, M = M + Math.imul(Se, Le2) | 0, v2 = v2 + Math.imul(y2, Je) | 0, d2 = d2 + Math.imul(y2, Xe2) | 0, d2 = d2 + Math.imul(I, Je) | 0, M = M + Math.imul(I, Xe2) | 0;
      var tt = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, v2 = Math.imul(P5, je), d2 = Math.imul(P5, Ke), d2 = d2 + Math.imul(te2, je) | 0, M = Math.imul(te2, Ke), v2 = v2 + Math.imul(ye, Pe) | 0, d2 = d2 + Math.imul(ye, Le2) | 0, d2 = d2 + Math.imul(T, Pe) | 0, M = M + Math.imul(T, Le2) | 0, v2 = v2 + Math.imul(Me2, Je) | 0, d2 = d2 + Math.imul(Me2, Xe2) | 0, d2 = d2 + Math.imul(Se, Je) | 0, M = M + Math.imul(Se, Xe2) | 0, v2 = v2 + Math.imul(y2, Qe) | 0, d2 = d2 + Math.imul(y2, et) | 0, d2 = d2 + Math.imul(I, Qe) | 0, M = M + Math.imul(I, et) | 0;
      var He = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, v2 = Math.imul(re, je), d2 = Math.imul(re, Ke), d2 = d2 + Math.imul(ae, je) | 0, M = Math.imul(ae, Ke), v2 = v2 + Math.imul(P5, Pe) | 0, d2 = d2 + Math.imul(P5, Le2) | 0, d2 = d2 + Math.imul(te2, Pe) | 0, M = M + Math.imul(te2, Le2) | 0, v2 = v2 + Math.imul(ye, Je) | 0, d2 = d2 + Math.imul(ye, Xe2) | 0, d2 = d2 + Math.imul(T, Je) | 0, M = M + Math.imul(T, Xe2) | 0, v2 = v2 + Math.imul(Me2, Qe) | 0, d2 = d2 + Math.imul(Me2, et) | 0, d2 = d2 + Math.imul(Se, Qe) | 0, M = M + Math.imul(Se, et) | 0, v2 = v2 + Math.imul(y2, lt) | 0, d2 = d2 + Math.imul(y2, ht) | 0, d2 = d2 + Math.imul(I, lt) | 0, M = M + Math.imul(I, ht) | 0;
      var it = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, v2 = Math.imul(X2, je), d2 = Math.imul(X2, Ke), d2 = d2 + Math.imul(R5, je) | 0, M = Math.imul(R5, Ke), v2 = v2 + Math.imul(re, Pe) | 0, d2 = d2 + Math.imul(re, Le2) | 0, d2 = d2 + Math.imul(ae, Pe) | 0, M = M + Math.imul(ae, Le2) | 0, v2 = v2 + Math.imul(P5, Je) | 0, d2 = d2 + Math.imul(P5, Xe2) | 0, d2 = d2 + Math.imul(te2, Je) | 0, M = M + Math.imul(te2, Xe2) | 0, v2 = v2 + Math.imul(ye, Qe) | 0, d2 = d2 + Math.imul(ye, et) | 0, d2 = d2 + Math.imul(T, Qe) | 0, M = M + Math.imul(T, et) | 0, v2 = v2 + Math.imul(Me2, lt) | 0, d2 = d2 + Math.imul(Me2, ht) | 0, d2 = d2 + Math.imul(Se, lt) | 0, M = M + Math.imul(Se, ht) | 0, v2 = v2 + Math.imul(y2, gt) | 0, d2 = d2 + Math.imul(y2, yt) | 0, d2 = d2 + Math.imul(I, gt) | 0, M = M + Math.imul(I, yt) | 0;
      var nt = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, v2 = Math.imul(F2, je), d2 = Math.imul(F2, Ke), d2 = d2 + Math.imul(q2, je) | 0, M = Math.imul(q2, Ke), v2 = v2 + Math.imul(X2, Pe) | 0, d2 = d2 + Math.imul(X2, Le2) | 0, d2 = d2 + Math.imul(R5, Pe) | 0, M = M + Math.imul(R5, Le2) | 0, v2 = v2 + Math.imul(re, Je) | 0, d2 = d2 + Math.imul(re, Xe2) | 0, d2 = d2 + Math.imul(ae, Je) | 0, M = M + Math.imul(ae, Xe2) | 0, v2 = v2 + Math.imul(P5, Qe) | 0, d2 = d2 + Math.imul(P5, et) | 0, d2 = d2 + Math.imul(te2, Qe) | 0, M = M + Math.imul(te2, et) | 0, v2 = v2 + Math.imul(ye, lt) | 0, d2 = d2 + Math.imul(ye, ht) | 0, d2 = d2 + Math.imul(T, lt) | 0, M = M + Math.imul(T, ht) | 0, v2 = v2 + Math.imul(Me2, gt) | 0, d2 = d2 + Math.imul(Me2, yt) | 0, d2 = d2 + Math.imul(Se, gt) | 0, M = M + Math.imul(Se, yt) | 0, v2 = v2 + Math.imul(y2, rt) | 0, d2 = d2 + Math.imul(y2, bt) | 0, d2 = d2 + Math.imul(I, rt) | 0, M = M + Math.imul(I, bt) | 0;
      var dt = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, v2 = Math.imul(K5, je), d2 = Math.imul(K5, Ke), d2 = d2 + Math.imul($, je) | 0, M = Math.imul($, Ke), v2 = v2 + Math.imul(F2, Pe) | 0, d2 = d2 + Math.imul(F2, Le2) | 0, d2 = d2 + Math.imul(q2, Pe) | 0, M = M + Math.imul(q2, Le2) | 0, v2 = v2 + Math.imul(X2, Je) | 0, d2 = d2 + Math.imul(X2, Xe2) | 0, d2 = d2 + Math.imul(R5, Je) | 0, M = M + Math.imul(R5, Xe2) | 0, v2 = v2 + Math.imul(re, Qe) | 0, d2 = d2 + Math.imul(re, et) | 0, d2 = d2 + Math.imul(ae, Qe) | 0, M = M + Math.imul(ae, et) | 0, v2 = v2 + Math.imul(P5, lt) | 0, d2 = d2 + Math.imul(P5, ht) | 0, d2 = d2 + Math.imul(te2, lt) | 0, M = M + Math.imul(te2, ht) | 0, v2 = v2 + Math.imul(ye, gt) | 0, d2 = d2 + Math.imul(ye, yt) | 0, d2 = d2 + Math.imul(T, gt) | 0, M = M + Math.imul(T, yt) | 0, v2 = v2 + Math.imul(Me2, rt) | 0, d2 = d2 + Math.imul(Me2, bt) | 0, d2 = d2 + Math.imul(Se, rt) | 0, M = M + Math.imul(Se, bt) | 0, v2 = v2 + Math.imul(y2, D2) | 0, d2 = d2 + Math.imul(y2, k2) | 0, d2 = d2 + Math.imul(I, D2) | 0, M = M + Math.imul(I, k2) | 0;
      var ut = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, v2 = Math.imul(pe, je), d2 = Math.imul(pe, Ke), d2 = d2 + Math.imul(_e, je) | 0, M = Math.imul(_e, Ke), v2 = v2 + Math.imul(K5, Pe) | 0, d2 = d2 + Math.imul(K5, Le2) | 0, d2 = d2 + Math.imul($, Pe) | 0, M = M + Math.imul($, Le2) | 0, v2 = v2 + Math.imul(F2, Je) | 0, d2 = d2 + Math.imul(F2, Xe2) | 0, d2 = d2 + Math.imul(q2, Je) | 0, M = M + Math.imul(q2, Xe2) | 0, v2 = v2 + Math.imul(X2, Qe) | 0, d2 = d2 + Math.imul(X2, et) | 0, d2 = d2 + Math.imul(R5, Qe) | 0, M = M + Math.imul(R5, et) | 0, v2 = v2 + Math.imul(re, lt) | 0, d2 = d2 + Math.imul(re, ht) | 0, d2 = d2 + Math.imul(ae, lt) | 0, M = M + Math.imul(ae, ht) | 0, v2 = v2 + Math.imul(P5, gt) | 0, d2 = d2 + Math.imul(P5, yt) | 0, d2 = d2 + Math.imul(te2, gt) | 0, M = M + Math.imul(te2, yt) | 0, v2 = v2 + Math.imul(ye, rt) | 0, d2 = d2 + Math.imul(ye, bt) | 0, d2 = d2 + Math.imul(T, rt) | 0, M = M + Math.imul(T, bt) | 0, v2 = v2 + Math.imul(Me2, D2) | 0, d2 = d2 + Math.imul(Me2, k2) | 0, d2 = d2 + Math.imul(Se, D2) | 0, M = M + Math.imul(Se, k2) | 0, v2 = v2 + Math.imul(y2, C2) | 0, d2 = d2 + Math.imul(y2, Q2) | 0, d2 = d2 + Math.imul(I, C2) | 0, M = M + Math.imul(I, Q2) | 0;
      var st = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, v2 = Math.imul(Fe, je), d2 = Math.imul(Fe, Ke), d2 = d2 + Math.imul(De, je) | 0, M = Math.imul(De, Ke), v2 = v2 + Math.imul(pe, Pe) | 0, d2 = d2 + Math.imul(pe, Le2) | 0, d2 = d2 + Math.imul(_e, Pe) | 0, M = M + Math.imul(_e, Le2) | 0, v2 = v2 + Math.imul(K5, Je) | 0, d2 = d2 + Math.imul(K5, Xe2) | 0, d2 = d2 + Math.imul($, Je) | 0, M = M + Math.imul($, Xe2) | 0, v2 = v2 + Math.imul(F2, Qe) | 0, d2 = d2 + Math.imul(F2, et) | 0, d2 = d2 + Math.imul(q2, Qe) | 0, M = M + Math.imul(q2, et) | 0, v2 = v2 + Math.imul(X2, lt) | 0, d2 = d2 + Math.imul(X2, ht) | 0, d2 = d2 + Math.imul(R5, lt) | 0, M = M + Math.imul(R5, ht) | 0, v2 = v2 + Math.imul(re, gt) | 0, d2 = d2 + Math.imul(re, yt) | 0, d2 = d2 + Math.imul(ae, gt) | 0, M = M + Math.imul(ae, yt) | 0, v2 = v2 + Math.imul(P5, rt) | 0, d2 = d2 + Math.imul(P5, bt) | 0, d2 = d2 + Math.imul(te2, rt) | 0, M = M + Math.imul(te2, bt) | 0, v2 = v2 + Math.imul(ye, D2) | 0, d2 = d2 + Math.imul(ye, k2) | 0, d2 = d2 + Math.imul(T, D2) | 0, M = M + Math.imul(T, k2) | 0, v2 = v2 + Math.imul(Me2, C2) | 0, d2 = d2 + Math.imul(Me2, Q2) | 0, d2 = d2 + Math.imul(Se, C2) | 0, M = M + Math.imul(Se, Q2) | 0, v2 = v2 + Math.imul(y2, ge2) | 0, d2 = d2 + Math.imul(y2, Ee) | 0, d2 = d2 + Math.imul(I, ge2) | 0, M = M + Math.imul(I, Ee) | 0;
      var at = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, v2 = Math.imul(Fe, Pe), d2 = Math.imul(Fe, Le2), d2 = d2 + Math.imul(De, Pe) | 0, M = Math.imul(De, Le2), v2 = v2 + Math.imul(pe, Je) | 0, d2 = d2 + Math.imul(pe, Xe2) | 0, d2 = d2 + Math.imul(_e, Je) | 0, M = M + Math.imul(_e, Xe2) | 0, v2 = v2 + Math.imul(K5, Qe) | 0, d2 = d2 + Math.imul(K5, et) | 0, d2 = d2 + Math.imul($, Qe) | 0, M = M + Math.imul($, et) | 0, v2 = v2 + Math.imul(F2, lt) | 0, d2 = d2 + Math.imul(F2, ht) | 0, d2 = d2 + Math.imul(q2, lt) | 0, M = M + Math.imul(q2, ht) | 0, v2 = v2 + Math.imul(X2, gt) | 0, d2 = d2 + Math.imul(X2, yt) | 0, d2 = d2 + Math.imul(R5, gt) | 0, M = M + Math.imul(R5, yt) | 0, v2 = v2 + Math.imul(re, rt) | 0, d2 = d2 + Math.imul(re, bt) | 0, d2 = d2 + Math.imul(ae, rt) | 0, M = M + Math.imul(ae, bt) | 0, v2 = v2 + Math.imul(P5, D2) | 0, d2 = d2 + Math.imul(P5, k2) | 0, d2 = d2 + Math.imul(te2, D2) | 0, M = M + Math.imul(te2, k2) | 0, v2 = v2 + Math.imul(ye, C2) | 0, d2 = d2 + Math.imul(ye, Q2) | 0, d2 = d2 + Math.imul(T, C2) | 0, M = M + Math.imul(T, Q2) | 0, v2 = v2 + Math.imul(Me2, ge2) | 0, d2 = d2 + Math.imul(Me2, Ee) | 0, d2 = d2 + Math.imul(Se, ge2) | 0, M = M + Math.imul(Se, Ee) | 0;
      var ot = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, v2 = Math.imul(Fe, Je), d2 = Math.imul(Fe, Xe2), d2 = d2 + Math.imul(De, Je) | 0, M = Math.imul(De, Xe2), v2 = v2 + Math.imul(pe, Qe) | 0, d2 = d2 + Math.imul(pe, et) | 0, d2 = d2 + Math.imul(_e, Qe) | 0, M = M + Math.imul(_e, et) | 0, v2 = v2 + Math.imul(K5, lt) | 0, d2 = d2 + Math.imul(K5, ht) | 0, d2 = d2 + Math.imul($, lt) | 0, M = M + Math.imul($, ht) | 0, v2 = v2 + Math.imul(F2, gt) | 0, d2 = d2 + Math.imul(F2, yt) | 0, d2 = d2 + Math.imul(q2, gt) | 0, M = M + Math.imul(q2, yt) | 0, v2 = v2 + Math.imul(X2, rt) | 0, d2 = d2 + Math.imul(X2, bt) | 0, d2 = d2 + Math.imul(R5, rt) | 0, M = M + Math.imul(R5, bt) | 0, v2 = v2 + Math.imul(re, D2) | 0, d2 = d2 + Math.imul(re, k2) | 0, d2 = d2 + Math.imul(ae, D2) | 0, M = M + Math.imul(ae, k2) | 0, v2 = v2 + Math.imul(P5, C2) | 0, d2 = d2 + Math.imul(P5, Q2) | 0, d2 = d2 + Math.imul(te2, C2) | 0, M = M + Math.imul(te2, Q2) | 0, v2 = v2 + Math.imul(ye, ge2) | 0, d2 = d2 + Math.imul(ye, Ee) | 0, d2 = d2 + Math.imul(T, ge2) | 0, M = M + Math.imul(T, Ee) | 0;
      var Ge2 = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (Ge2 >>> 26) | 0, Ge2 &= 67108863, v2 = Math.imul(Fe, Qe), d2 = Math.imul(Fe, et), d2 = d2 + Math.imul(De, Qe) | 0, M = Math.imul(De, et), v2 = v2 + Math.imul(pe, lt) | 0, d2 = d2 + Math.imul(pe, ht) | 0, d2 = d2 + Math.imul(_e, lt) | 0, M = M + Math.imul(_e, ht) | 0, v2 = v2 + Math.imul(K5, gt) | 0, d2 = d2 + Math.imul(K5, yt) | 0, d2 = d2 + Math.imul($, gt) | 0, M = M + Math.imul($, yt) | 0, v2 = v2 + Math.imul(F2, rt) | 0, d2 = d2 + Math.imul(F2, bt) | 0, d2 = d2 + Math.imul(q2, rt) | 0, M = M + Math.imul(q2, bt) | 0, v2 = v2 + Math.imul(X2, D2) | 0, d2 = d2 + Math.imul(X2, k2) | 0, d2 = d2 + Math.imul(R5, D2) | 0, M = M + Math.imul(R5, k2) | 0, v2 = v2 + Math.imul(re, C2) | 0, d2 = d2 + Math.imul(re, Q2) | 0, d2 = d2 + Math.imul(ae, C2) | 0, M = M + Math.imul(ae, Q2) | 0, v2 = v2 + Math.imul(P5, ge2) | 0, d2 = d2 + Math.imul(P5, Ee) | 0, d2 = d2 + Math.imul(te2, ge2) | 0, M = M + Math.imul(te2, Ee) | 0;
      var Ye2 = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (Ye2 >>> 26) | 0, Ye2 &= 67108863, v2 = Math.imul(Fe, lt), d2 = Math.imul(Fe, ht), d2 = d2 + Math.imul(De, lt) | 0, M = Math.imul(De, ht), v2 = v2 + Math.imul(pe, gt) | 0, d2 = d2 + Math.imul(pe, yt) | 0, d2 = d2 + Math.imul(_e, gt) | 0, M = M + Math.imul(_e, yt) | 0, v2 = v2 + Math.imul(K5, rt) | 0, d2 = d2 + Math.imul(K5, bt) | 0, d2 = d2 + Math.imul($, rt) | 0, M = M + Math.imul($, bt) | 0, v2 = v2 + Math.imul(F2, D2) | 0, d2 = d2 + Math.imul(F2, k2) | 0, d2 = d2 + Math.imul(q2, D2) | 0, M = M + Math.imul(q2, k2) | 0, v2 = v2 + Math.imul(X2, C2) | 0, d2 = d2 + Math.imul(X2, Q2) | 0, d2 = d2 + Math.imul(R5, C2) | 0, M = M + Math.imul(R5, Q2) | 0, v2 = v2 + Math.imul(re, ge2) | 0, d2 = d2 + Math.imul(re, Ee) | 0, d2 = d2 + Math.imul(ae, ge2) | 0, M = M + Math.imul(ae, Ee) | 0;
      var ze = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, v2 = Math.imul(Fe, gt), d2 = Math.imul(Fe, yt), d2 = d2 + Math.imul(De, gt) | 0, M = Math.imul(De, yt), v2 = v2 + Math.imul(pe, rt) | 0, d2 = d2 + Math.imul(pe, bt) | 0, d2 = d2 + Math.imul(_e, rt) | 0, M = M + Math.imul(_e, bt) | 0, v2 = v2 + Math.imul(K5, D2) | 0, d2 = d2 + Math.imul(K5, k2) | 0, d2 = d2 + Math.imul($, D2) | 0, M = M + Math.imul($, k2) | 0, v2 = v2 + Math.imul(F2, C2) | 0, d2 = d2 + Math.imul(F2, Q2) | 0, d2 = d2 + Math.imul(q2, C2) | 0, M = M + Math.imul(q2, Q2) | 0, v2 = v2 + Math.imul(X2, ge2) | 0, d2 = d2 + Math.imul(X2, Ee) | 0, d2 = d2 + Math.imul(R5, ge2) | 0, M = M + Math.imul(R5, Ee) | 0;
      var $e = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, v2 = Math.imul(Fe, rt), d2 = Math.imul(Fe, bt), d2 = d2 + Math.imul(De, rt) | 0, M = Math.imul(De, bt), v2 = v2 + Math.imul(pe, D2) | 0, d2 = d2 + Math.imul(pe, k2) | 0, d2 = d2 + Math.imul(_e, D2) | 0, M = M + Math.imul(_e, k2) | 0, v2 = v2 + Math.imul(K5, C2) | 0, d2 = d2 + Math.imul(K5, Q2) | 0, d2 = d2 + Math.imul($, C2) | 0, M = M + Math.imul($, Q2) | 0, v2 = v2 + Math.imul(F2, ge2) | 0, d2 = d2 + Math.imul(F2, Ee) | 0, d2 = d2 + Math.imul(q2, ge2) | 0, M = M + Math.imul(q2, Ee) | 0;
      var We = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, v2 = Math.imul(Fe, D2), d2 = Math.imul(Fe, k2), d2 = d2 + Math.imul(De, D2) | 0, M = Math.imul(De, k2), v2 = v2 + Math.imul(pe, C2) | 0, d2 = d2 + Math.imul(pe, Q2) | 0, d2 = d2 + Math.imul(_e, C2) | 0, M = M + Math.imul(_e, Q2) | 0, v2 = v2 + Math.imul(K5, ge2) | 0, d2 = d2 + Math.imul(K5, Ee) | 0, d2 = d2 + Math.imul($, ge2) | 0, M = M + Math.imul($, Ee) | 0;
      var qe = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, v2 = Math.imul(Fe, C2), d2 = Math.imul(Fe, Q2), d2 = d2 + Math.imul(De, C2) | 0, M = Math.imul(De, Q2), v2 = v2 + Math.imul(pe, ge2) | 0, d2 = d2 + Math.imul(pe, Ee) | 0, d2 = d2 + Math.imul(_e, ge2) | 0, M = M + Math.imul(_e, Ee) | 0;
      var ve = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      A2 = (M + (d2 >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, v2 = Math.imul(Fe, ge2), d2 = Math.imul(Fe, Ee), d2 = d2 + Math.imul(De, ge2) | 0, M = Math.imul(De, Ee);
      var xe2 = (A2 + v2 | 0) + ((d2 & 8191) << 13) | 0;
      return A2 = (M + (d2 >>> 13) | 0) + (xe2 >>> 26) | 0, xe2 &= 67108863, b2[0] = Ve2, b2[1] = Ne, b2[2] = tt, b2[3] = He, b2[4] = it, b2[5] = nt, b2[6] = dt, b2[7] = ut, b2[8] = st, b2[9] = at, b2[10] = ot, b2[11] = Ge2, b2[12] = Ye2, b2[13] = ze, b2[14] = $e, b2[15] = We, b2[16] = qe, b2[17] = ve, b2[18] = xe2, A2 !== 0 && (b2[19] = A2, h2.length++), h2;
    };
    Math.imul || (G = V);
    function ee2(E2, c, m2) {
      m2.negative = c.negative ^ E2.negative, m2.length = E2.length + c.length;
      for (var h2 = 0, a = 0, u3 = 0; u3 < m2.length - 1; u3++) {
        var b2 = a;
        a = 0;
        for (var A2 = h2 & 67108863, v2 = Math.min(u3, c.length - 1), d2 = Math.max(0, u3 - E2.length + 1); d2 <= v2; d2++) {
          var M = u3 - d2, B2 = E2.words[M] | 0, y2 = c.words[d2] | 0, I = B2 * y2, de = I & 67108863;
          b2 = b2 + (I / 67108864 | 0) | 0, de = de + A2 | 0, A2 = de & 67108863, b2 = b2 + (de >>> 26) | 0, a += b2 >>> 26, b2 &= 67108863;
        }
        m2.words[u3] = A2, h2 = b2, b2 = a;
      }
      return h2 !== 0 ? m2.words[u3] = h2 : m2.length--, m2.strip();
    }
    function W5(E2, c, m2) {
      var h2 = new Z();
      return h2.mulp(E2, c, m2);
    }
    n.prototype.mulTo = function(c, m2) {
      var h2, a = this.length + c.length;
      return this.length === 10 && c.length === 10 ? h2 = G(this, c, m2) : a < 63 ? h2 = V(this, c, m2) : a < 1024 ? h2 = ee2(this, c, m2) : h2 = W5(this, c, m2), h2;
    };
    function Z(E2, c) {
      this.x = E2, this.y = c;
    }
    Z.prototype.makeRBT = function(c) {
      for (var m2 = new Array(c), h2 = n.prototype._countBits(c) - 1, a = 0; a < c; a++)
        m2[a] = this.revBin(a, h2, c);
      return m2;
    }, Z.prototype.revBin = function(c, m2, h2) {
      if (c === 0 || c === h2 - 1)
        return c;
      for (var a = 0, u3 = 0; u3 < m2; u3++)
        a |= (c & 1) << m2 - u3 - 1, c >>= 1;
      return a;
    }, Z.prototype.permute = function(c, m2, h2, a, u3, b2) {
      for (var A2 = 0; A2 < b2; A2++)
        a[A2] = m2[c[A2]], u3[A2] = h2[c[A2]];
    }, Z.prototype.transform = function(c, m2, h2, a, u3, b2) {
      this.permute(b2, c, m2, h2, a, u3);
      for (var A2 = 1; A2 < u3; A2 <<= 1)
        for (var v2 = A2 << 1, d2 = Math.cos(2 * Math.PI / v2), M = Math.sin(2 * Math.PI / v2), B2 = 0; B2 < u3; B2 += v2)
          for (var y2 = d2, I = M, de = 0; de < A2; de++) {
            var Me2 = h2[B2 + de], Se = a[B2 + de], Oe = h2[B2 + de + A2], ye = a[B2 + de + A2], T = y2 * Oe - I * ye;
            ye = y2 * ye + I * Oe, Oe = T, h2[B2 + de] = Me2 + Oe, a[B2 + de] = Se + ye, h2[B2 + de + A2] = Me2 - Oe, a[B2 + de + A2] = Se - ye, de !== v2 && (T = d2 * y2 - M * I, I = d2 * I + M * y2, y2 = T);
          }
    }, Z.prototype.guessLen13b = function(c, m2) {
      var h2 = Math.max(m2, c) | 1, a = h2 & 1, u3 = 0;
      for (h2 = h2 / 2 | 0; h2; h2 = h2 >>> 1)
        u3++;
      return 1 << u3 + 1 + a;
    }, Z.prototype.conjugate = function(c, m2, h2) {
      if (!(h2 <= 1))
        for (var a = 0; a < h2 / 2; a++) {
          var u3 = c[a];
          c[a] = c[h2 - a - 1], c[h2 - a - 1] = u3, u3 = m2[a], m2[a] = -m2[h2 - a - 1], m2[h2 - a - 1] = -u3;
        }
    }, Z.prototype.normalize13b = function(c, m2) {
      for (var h2 = 0, a = 0; a < m2 / 2; a++) {
        var u3 = Math.round(c[2 * a + 1] / m2) * 8192 + Math.round(c[2 * a] / m2) + h2;
        c[a] = u3 & 67108863, u3 < 67108864 ? h2 = 0 : h2 = u3 / 67108864 | 0;
      }
      return c;
    }, Z.prototype.convert13b = function(c, m2, h2, a) {
      for (var u3 = 0, b2 = 0; b2 < m2; b2++)
        u3 = u3 + (c[b2] | 0), h2[2 * b2] = u3 & 8191, u3 = u3 >>> 13, h2[2 * b2 + 1] = u3 & 8191, u3 = u3 >>> 13;
      for (b2 = 2 * m2; b2 < a; ++b2)
        h2[b2] = 0;
      r3(u3 === 0), r3((u3 & -8192) === 0);
    }, Z.prototype.stub = function(c) {
      for (var m2 = new Array(c), h2 = 0; h2 < c; h2++)
        m2[h2] = 0;
      return m2;
    }, Z.prototype.mulp = function(c, m2, h2) {
      var a = 2 * this.guessLen13b(c.length, m2.length), u3 = this.makeRBT(a), b2 = this.stub(a), A2 = new Array(a), v2 = new Array(a), d2 = new Array(a), M = new Array(a), B2 = new Array(a), y2 = new Array(a), I = h2.words;
      I.length = a, this.convert13b(c.words, c.length, A2, a), this.convert13b(m2.words, m2.length, M, a), this.transform(A2, b2, v2, d2, a, u3), this.transform(M, b2, B2, y2, a, u3);
      for (var de = 0; de < a; de++) {
        var Me2 = v2[de] * B2[de] - d2[de] * y2[de];
        d2[de] = v2[de] * y2[de] + d2[de] * B2[de], v2[de] = Me2;
      }
      return this.conjugate(v2, d2, a), this.transform(v2, d2, I, b2, a, u3), this.conjugate(I, b2, a), this.normalize13b(I, a), h2.negative = c.negative ^ m2.negative, h2.length = c.length + m2.length, h2.strip();
    }, n.prototype.mul = function(c) {
      var m2 = new n(null);
      return m2.words = new Array(this.length + c.length), this.mulTo(c, m2);
    }, n.prototype.mulf = function(c) {
      var m2 = new n(null);
      return m2.words = new Array(this.length + c.length), W5(this, c, m2);
    }, n.prototype.imul = function(c) {
      return this.clone().mulTo(c, this);
    }, n.prototype.imuln = function(c) {
      r3(typeof c == "number"), r3(c < 67108864);
      for (var m2 = 0, h2 = 0; h2 < this.length; h2++) {
        var a = (this.words[h2] | 0) * c, u3 = (a & 67108863) + (m2 & 67108863);
        m2 >>= 26, m2 += a / 67108864 | 0, m2 += u3 >>> 26, this.words[h2] = u3 & 67108863;
      }
      return m2 !== 0 && (this.words[h2] = m2, this.length++), this;
    }, n.prototype.muln = function(c) {
      return this.clone().imuln(c);
    }, n.prototype.sqr = function() {
      return this.mul(this);
    }, n.prototype.isqr = function() {
      return this.imul(this.clone());
    }, n.prototype.pow = function(c) {
      var m2 = U2(c);
      if (m2.length === 0)
        return new n(1);
      for (var h2 = this, a = 0; a < m2.length && m2[a] === 0; a++, h2 = h2.sqr())
        ;
      if (++a < m2.length)
        for (var u3 = h2.sqr(); a < m2.length; a++, u3 = u3.sqr())
          m2[a] !== 0 && (h2 = h2.mul(u3));
      return h2;
    }, n.prototype.iushln = function(c) {
      r3(typeof c == "number" && c >= 0);
      var m2 = c % 26, h2 = (c - m2) / 26, a = 67108863 >>> 26 - m2 << 26 - m2, u3;
      if (m2 !== 0) {
        var b2 = 0;
        for (u3 = 0; u3 < this.length; u3++) {
          var A2 = this.words[u3] & a, v2 = (this.words[u3] | 0) - A2 << m2;
          this.words[u3] = v2 | b2, b2 = A2 >>> 26 - m2;
        }
        b2 && (this.words[u3] = b2, this.length++);
      }
      if (h2 !== 0) {
        for (u3 = this.length - 1; u3 >= 0; u3--)
          this.words[u3 + h2] = this.words[u3];
        for (u3 = 0; u3 < h2; u3++)
          this.words[u3] = 0;
        this.length += h2;
      }
      return this.strip();
    }, n.prototype.ishln = function(c) {
      return r3(this.negative === 0), this.iushln(c);
    }, n.prototype.iushrn = function(c, m2, h2) {
      r3(typeof c == "number" && c >= 0);
      var a;
      m2 ? a = (m2 - m2 % 26) / 26 : a = 0;
      var u3 = c % 26, b2 = Math.min((c - u3) / 26, this.length), A2 = 67108863 ^ 67108863 >>> u3 << u3, v2 = h2;
      if (a -= b2, a = Math.max(0, a), v2) {
        for (var d2 = 0; d2 < b2; d2++)
          v2.words[d2] = this.words[d2];
        v2.length = b2;
      }
      if (b2 !== 0)
        if (this.length > b2)
          for (this.length -= b2, d2 = 0; d2 < this.length; d2++)
            this.words[d2] = this.words[d2 + b2];
        else
          this.words[0] = 0, this.length = 1;
      var M = 0;
      for (d2 = this.length - 1; d2 >= 0 && (M !== 0 || d2 >= a); d2--) {
        var B2 = this.words[d2] | 0;
        this.words[d2] = M << 26 - u3 | B2 >>> u3, M = B2 & A2;
      }
      return v2 && M !== 0 && (v2.words[v2.length++] = M), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, n.prototype.ishrn = function(c, m2, h2) {
      return r3(this.negative === 0), this.iushrn(c, m2, h2);
    }, n.prototype.shln = function(c) {
      return this.clone().ishln(c);
    }, n.prototype.ushln = function(c) {
      return this.clone().iushln(c);
    }, n.prototype.shrn = function(c) {
      return this.clone().ishrn(c);
    }, n.prototype.ushrn = function(c) {
      return this.clone().iushrn(c);
    }, n.prototype.testn = function(c) {
      r3(typeof c == "number" && c >= 0);
      var m2 = c % 26, h2 = (c - m2) / 26, a = 1 << m2;
      if (this.length <= h2)
        return false;
      var u3 = this.words[h2];
      return !!(u3 & a);
    }, n.prototype.imaskn = function(c) {
      r3(typeof c == "number" && c >= 0);
      var m2 = c % 26, h2 = (c - m2) / 26;
      if (r3(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h2)
        return this;
      if (m2 !== 0 && h2++, this.length = Math.min(h2, this.length), m2 !== 0) {
        var a = 67108863 ^ 67108863 >>> m2 << m2;
        this.words[this.length - 1] &= a;
      }
      return this.strip();
    }, n.prototype.maskn = function(c) {
      return this.clone().imaskn(c);
    }, n.prototype.iaddn = function(c) {
      return r3(typeof c == "number"), r3(c < 67108864), c < 0 ? this.isubn(-c) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < c ? (this.words[0] = c - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c), this.negative = 1, this) : this._iaddn(c);
    }, n.prototype._iaddn = function(c) {
      this.words[0] += c;
      for (var m2 = 0; m2 < this.length && this.words[m2] >= 67108864; m2++)
        this.words[m2] -= 67108864, m2 === this.length - 1 ? this.words[m2 + 1] = 1 : this.words[m2 + 1]++;
      return this.length = Math.max(this.length, m2 + 1), this;
    }, n.prototype.isubn = function(c) {
      if (r3(typeof c == "number"), r3(c < 67108864), c < 0)
        return this.iaddn(-c);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c), this.negative = 1, this;
      if (this.words[0] -= c, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m2 = 0; m2 < this.length && this.words[m2] < 0; m2++)
          this.words[m2] += 67108864, this.words[m2 + 1] -= 1;
      return this.strip();
    }, n.prototype.addn = function(c) {
      return this.clone().iaddn(c);
    }, n.prototype.subn = function(c) {
      return this.clone().isubn(c);
    }, n.prototype.iabs = function() {
      return this.negative = 0, this;
    }, n.prototype.abs = function() {
      return this.clone().iabs();
    }, n.prototype._ishlnsubmul = function(c, m2, h2) {
      var a = c.length + h2, u3;
      this._expand(a);
      var b2, A2 = 0;
      for (u3 = 0; u3 < c.length; u3++) {
        b2 = (this.words[u3 + h2] | 0) + A2;
        var v2 = (c.words[u3] | 0) * m2;
        b2 -= v2 & 67108863, A2 = (b2 >> 26) - (v2 / 67108864 | 0), this.words[u3 + h2] = b2 & 67108863;
      }
      for (; u3 < this.length - h2; u3++)
        b2 = (this.words[u3 + h2] | 0) + A2, A2 = b2 >> 26, this.words[u3 + h2] = b2 & 67108863;
      if (A2 === 0)
        return this.strip();
      for (r3(A2 === -1), A2 = 0, u3 = 0; u3 < this.length; u3++)
        b2 = -(this.words[u3] | 0) + A2, A2 = b2 >> 26, this.words[u3] = b2 & 67108863;
      return this.negative = 1, this.strip();
    }, n.prototype._wordDiv = function(c, m2) {
      var h2 = this.length - c.length, a = this.clone(), u3 = c, b2 = u3.words[u3.length - 1] | 0, A2 = this._countBits(b2);
      h2 = 26 - A2, h2 !== 0 && (u3 = u3.ushln(h2), a.iushln(h2), b2 = u3.words[u3.length - 1] | 0);
      var v2 = a.length - u3.length, d2;
      if (m2 !== "mod") {
        d2 = new n(null), d2.length = v2 + 1, d2.words = new Array(d2.length);
        for (var M = 0; M < d2.length; M++)
          d2.words[M] = 0;
      }
      var B2 = a.clone()._ishlnsubmul(u3, 1, v2);
      B2.negative === 0 && (a = B2, d2 && (d2.words[v2] = 1));
      for (var y2 = v2 - 1; y2 >= 0; y2--) {
        var I = (a.words[u3.length + y2] | 0) * 67108864 + (a.words[u3.length + y2 - 1] | 0);
        for (I = Math.min(I / b2 | 0, 67108863), a._ishlnsubmul(u3, I, y2); a.negative !== 0; )
          I--, a.negative = 0, a._ishlnsubmul(u3, 1, y2), a.isZero() || (a.negative ^= 1);
        d2 && (d2.words[y2] = I);
      }
      return d2 && d2.strip(), a.strip(), m2 !== "div" && h2 !== 0 && a.iushrn(h2), { div: d2 || null, mod: a };
    }, n.prototype.divmod = function(c, m2, h2) {
      if (r3(!c.isZero()), this.isZero())
        return { div: new n(0), mod: new n(0) };
      var a, u3, b2;
      return this.negative !== 0 && c.negative === 0 ? (b2 = this.neg().divmod(c, m2), m2 !== "mod" && (a = b2.div.neg()), m2 !== "div" && (u3 = b2.mod.neg(), h2 && u3.negative !== 0 && u3.iadd(c)), { div: a, mod: u3 }) : this.negative === 0 && c.negative !== 0 ? (b2 = this.divmod(c.neg(), m2), m2 !== "mod" && (a = b2.div.neg()), { div: a, mod: b2.mod }) : (this.negative & c.negative) !== 0 ? (b2 = this.neg().divmod(c.neg(), m2), m2 !== "div" && (u3 = b2.mod.neg(), h2 && u3.negative !== 0 && u3.isub(c)), { div: b2.div, mod: u3 }) : c.length > this.length || this.cmp(c) < 0 ? { div: new n(0), mod: this } : c.length === 1 ? m2 === "div" ? { div: this.divn(c.words[0]), mod: null } : m2 === "mod" ? { div: null, mod: new n(this.modn(c.words[0])) } : { div: this.divn(c.words[0]), mod: new n(this.modn(c.words[0])) } : this._wordDiv(c, m2);
    }, n.prototype.div = function(c) {
      return this.divmod(c, "div", false).div;
    }, n.prototype.mod = function(c) {
      return this.divmod(c, "mod", false).mod;
    }, n.prototype.umod = function(c) {
      return this.divmod(c, "mod", true).mod;
    }, n.prototype.divRound = function(c) {
      var m2 = this.divmod(c);
      if (m2.mod.isZero())
        return m2.div;
      var h2 = m2.div.negative !== 0 ? m2.mod.isub(c) : m2.mod, a = c.ushrn(1), u3 = c.andln(1), b2 = h2.cmp(a);
      return b2 < 0 || u3 === 1 && b2 === 0 ? m2.div : m2.div.negative !== 0 ? m2.div.isubn(1) : m2.div.iaddn(1);
    }, n.prototype.modn = function(c) {
      r3(c <= 67108863);
      for (var m2 = (1 << 26) % c, h2 = 0, a = this.length - 1; a >= 0; a--)
        h2 = (m2 * h2 + (this.words[a] | 0)) % c;
      return h2;
    }, n.prototype.idivn = function(c) {
      r3(c <= 67108863);
      for (var m2 = 0, h2 = this.length - 1; h2 >= 0; h2--) {
        var a = (this.words[h2] | 0) + m2 * 67108864;
        this.words[h2] = a / c | 0, m2 = a % c;
      }
      return this.strip();
    }, n.prototype.divn = function(c) {
      return this.clone().idivn(c);
    }, n.prototype.egcd = function(c) {
      r3(c.negative === 0), r3(!c.isZero());
      var m2 = this, h2 = c.clone();
      m2.negative !== 0 ? m2 = m2.umod(c) : m2 = m2.clone();
      for (var a = new n(1), u3 = new n(0), b2 = new n(0), A2 = new n(1), v2 = 0; m2.isEven() && h2.isEven(); )
        m2.iushrn(1), h2.iushrn(1), ++v2;
      for (var d2 = h2.clone(), M = m2.clone(); !m2.isZero(); ) {
        for (var B2 = 0, y2 = 1; (m2.words[0] & y2) === 0 && B2 < 26; ++B2, y2 <<= 1)
          ;
        if (B2 > 0)
          for (m2.iushrn(B2); B2-- > 0; )
            (a.isOdd() || u3.isOdd()) && (a.iadd(d2), u3.isub(M)), a.iushrn(1), u3.iushrn(1);
        for (var I = 0, de = 1; (h2.words[0] & de) === 0 && I < 26; ++I, de <<= 1)
          ;
        if (I > 0)
          for (h2.iushrn(I); I-- > 0; )
            (b2.isOdd() || A2.isOdd()) && (b2.iadd(d2), A2.isub(M)), b2.iushrn(1), A2.iushrn(1);
        m2.cmp(h2) >= 0 ? (m2.isub(h2), a.isub(b2), u3.isub(A2)) : (h2.isub(m2), b2.isub(a), A2.isub(u3));
      }
      return { a: b2, b: A2, gcd: h2.iushln(v2) };
    }, n.prototype._invmp = function(c) {
      r3(c.negative === 0), r3(!c.isZero());
      var m2 = this, h2 = c.clone();
      m2.negative !== 0 ? m2 = m2.umod(c) : m2 = m2.clone();
      for (var a = new n(1), u3 = new n(0), b2 = h2.clone(); m2.cmpn(1) > 0 && h2.cmpn(1) > 0; ) {
        for (var A2 = 0, v2 = 1; (m2.words[0] & v2) === 0 && A2 < 26; ++A2, v2 <<= 1)
          ;
        if (A2 > 0)
          for (m2.iushrn(A2); A2-- > 0; )
            a.isOdd() && a.iadd(b2), a.iushrn(1);
        for (var d2 = 0, M = 1; (h2.words[0] & M) === 0 && d2 < 26; ++d2, M <<= 1)
          ;
        if (d2 > 0)
          for (h2.iushrn(d2); d2-- > 0; )
            u3.isOdd() && u3.iadd(b2), u3.iushrn(1);
        m2.cmp(h2) >= 0 ? (m2.isub(h2), a.isub(u3)) : (h2.isub(m2), u3.isub(a));
      }
      var B2;
      return m2.cmpn(1) === 0 ? B2 = a : B2 = u3, B2.cmpn(0) < 0 && B2.iadd(c), B2;
    }, n.prototype.gcd = function(c) {
      if (this.isZero())
        return c.abs();
      if (c.isZero())
        return this.abs();
      var m2 = this.clone(), h2 = c.clone();
      m2.negative = 0, h2.negative = 0;
      for (var a = 0; m2.isEven() && h2.isEven(); a++)
        m2.iushrn(1), h2.iushrn(1);
      do {
        for (; m2.isEven(); )
          m2.iushrn(1);
        for (; h2.isEven(); )
          h2.iushrn(1);
        var u3 = m2.cmp(h2);
        if (u3 < 0) {
          var b2 = m2;
          m2 = h2, h2 = b2;
        } else if (u3 === 0 || h2.cmpn(1) === 0)
          break;
        m2.isub(h2);
      } while (true);
      return h2.iushln(a);
    }, n.prototype.invm = function(c) {
      return this.egcd(c).a.umod(c);
    }, n.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, n.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, n.prototype.andln = function(c) {
      return this.words[0] & c;
    }, n.prototype.bincn = function(c) {
      r3(typeof c == "number");
      var m2 = c % 26, h2 = (c - m2) / 26, a = 1 << m2;
      if (this.length <= h2)
        return this._expand(h2 + 1), this.words[h2] |= a, this;
      for (var u3 = a, b2 = h2; u3 !== 0 && b2 < this.length; b2++) {
        var A2 = this.words[b2] | 0;
        A2 += u3, u3 = A2 >>> 26, A2 &= 67108863, this.words[b2] = A2;
      }
      return u3 !== 0 && (this.words[b2] = u3, this.length++), this;
    }, n.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, n.prototype.cmpn = function(c) {
      var m2 = c < 0;
      if (this.negative !== 0 && !m2)
        return -1;
      if (this.negative === 0 && m2)
        return 1;
      this.strip();
      var h2;
      if (this.length > 1)
        h2 = 1;
      else {
        m2 && (c = -c), r3(c <= 67108863, "Number is too big");
        var a = this.words[0] | 0;
        h2 = a === c ? 0 : a < c ? -1 : 1;
      }
      return this.negative !== 0 ? -h2 | 0 : h2;
    }, n.prototype.cmp = function(c) {
      if (this.negative !== 0 && c.negative === 0)
        return -1;
      if (this.negative === 0 && c.negative !== 0)
        return 1;
      var m2 = this.ucmp(c);
      return this.negative !== 0 ? -m2 | 0 : m2;
    }, n.prototype.ucmp = function(c) {
      if (this.length > c.length)
        return 1;
      if (this.length < c.length)
        return -1;
      for (var m2 = 0, h2 = this.length - 1; h2 >= 0; h2--) {
        var a = this.words[h2] | 0, u3 = c.words[h2] | 0;
        if (a !== u3) {
          a < u3 ? m2 = -1 : a > u3 && (m2 = 1);
          break;
        }
      }
      return m2;
    }, n.prototype.gtn = function(c) {
      return this.cmpn(c) === 1;
    }, n.prototype.gt = function(c) {
      return this.cmp(c) === 1;
    }, n.prototype.gten = function(c) {
      return this.cmpn(c) >= 0;
    }, n.prototype.gte = function(c) {
      return this.cmp(c) >= 0;
    }, n.prototype.ltn = function(c) {
      return this.cmpn(c) === -1;
    }, n.prototype.lt = function(c) {
      return this.cmp(c) === -1;
    }, n.prototype.lten = function(c) {
      return this.cmpn(c) <= 0;
    }, n.prototype.lte = function(c) {
      return this.cmp(c) <= 0;
    }, n.prototype.eqn = function(c) {
      return this.cmpn(c) === 0;
    }, n.prototype.eq = function(c) {
      return this.cmp(c) === 0;
    }, n.red = function(c) {
      return new se2(c);
    }, n.prototype.toRed = function(c) {
      return r3(!this.red, "Already a number in reduction context"), r3(this.negative === 0, "red works only with positives"), c.convertTo(this)._forceRed(c);
    }, n.prototype.fromRed = function() {
      return r3(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, n.prototype._forceRed = function(c) {
      return this.red = c, this;
    }, n.prototype.forceRed = function(c) {
      return r3(!this.red, "Already a number in reduction context"), this._forceRed(c);
    }, n.prototype.redAdd = function(c) {
      return r3(this.red, "redAdd works only with red numbers"), this.red.add(this, c);
    }, n.prototype.redIAdd = function(c) {
      return r3(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c);
    }, n.prototype.redSub = function(c) {
      return r3(this.red, "redSub works only with red numbers"), this.red.sub(this, c);
    }, n.prototype.redISub = function(c) {
      return r3(this.red, "redISub works only with red numbers"), this.red.isub(this, c);
    }, n.prototype.redShl = function(c) {
      return r3(this.red, "redShl works only with red numbers"), this.red.shl(this, c);
    }, n.prototype.redMul = function(c) {
      return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.mul(this, c);
    }, n.prototype.redIMul = function(c) {
      return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.imul(this, c);
    }, n.prototype.redSqr = function() {
      return r3(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, n.prototype.redISqr = function() {
      return r3(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, n.prototype.redSqrt = function() {
      return r3(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, n.prototype.redInvm = function() {
      return r3(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, n.prototype.redNeg = function() {
      return r3(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, n.prototype.redPow = function(c) {
      return r3(this.red && !c.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c);
    };
    var le = { k256: null, p224: null, p192: null, p25519: null };
    function be2(E2, c) {
      this.name = E2, this.p = new n(c, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be2.prototype._tmp = function() {
      var c = new n(null);
      return c.words = new Array(Math.ceil(this.n / 13)), c;
    }, be2.prototype.ireduce = function(c) {
      var m2 = c, h2;
      do
        this.split(m2, this.tmp), m2 = this.imulK(m2), m2 = m2.iadd(this.tmp), h2 = m2.bitLength();
      while (h2 > this.n);
      var a = h2 < this.n ? -1 : m2.ucmp(this.p);
      return a === 0 ? (m2.words[0] = 0, m2.length = 1) : a > 0 ? m2.isub(this.p) : m2.strip !== void 0 ? m2.strip() : m2._strip(), m2;
    }, be2.prototype.split = function(c, m2) {
      c.iushrn(this.n, 0, m2);
    }, be2.prototype.imulK = function(c) {
      return c.imul(this.k);
    };
    function Ae() {
      be2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    i(Ae, be2), Ae.prototype.split = function(c, m2) {
      for (var h2 = 4194303, a = Math.min(c.length, 9), u3 = 0; u3 < a; u3++)
        m2.words[u3] = c.words[u3];
      if (m2.length = a, c.length <= 9) {
        c.words[0] = 0, c.length = 1;
        return;
      }
      var b2 = c.words[9];
      for (m2.words[m2.length++] = b2 & h2, u3 = 10; u3 < c.length; u3++) {
        var A2 = c.words[u3] | 0;
        c.words[u3 - 10] = (A2 & h2) << 4 | b2 >>> 22, b2 = A2;
      }
      b2 >>>= 22, c.words[u3 - 10] = b2, b2 === 0 && c.length > 10 ? c.length -= 10 : c.length -= 9;
    }, Ae.prototype.imulK = function(c) {
      c.words[c.length] = 0, c.words[c.length + 1] = 0, c.length += 2;
      for (var m2 = 0, h2 = 0; h2 < c.length; h2++) {
        var a = c.words[h2] | 0;
        m2 += a * 977, c.words[h2] = m2 & 67108863, m2 = a * 64 + (m2 / 67108864 | 0);
      }
      return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
    };
    function me() {
      be2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    i(me, be2);
    function H5() {
      be2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    i(H5, be2);
    function ue() {
      be2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    i(ue, be2), ue.prototype.imulK = function(c) {
      for (var m2 = 0, h2 = 0; h2 < c.length; h2++) {
        var a = (c.words[h2] | 0) * 19 + m2, u3 = a & 67108863;
        a >>>= 26, c.words[h2] = u3, m2 = a;
      }
      return m2 !== 0 && (c.words[c.length++] = m2), c;
    }, n._prime = function(c) {
      if (le[c])
        return le[c];
      var m2;
      if (c === "k256")
        m2 = new Ae();
      else if (c === "p224")
        m2 = new me();
      else if (c === "p192")
        m2 = new H5();
      else if (c === "p25519")
        m2 = new ue();
      else
        throw new Error("Unknown prime " + c);
      return le[c] = m2, m2;
    };
    function se2(E2) {
      if (typeof E2 == "string") {
        var c = n._prime(E2);
        this.m = c.p, this.prime = c;
      } else
        r3(E2.gtn(1), "modulus must be greater than 1"), this.m = E2, this.prime = null;
    }
    se2.prototype._verify1 = function(c) {
      r3(c.negative === 0, "red works only with positives"), r3(c.red, "red works only with red numbers");
    }, se2.prototype._verify2 = function(c, m2) {
      r3((c.negative | m2.negative) === 0, "red works only with positives"), r3(c.red && c.red === m2.red, "red works only with red numbers");
    }, se2.prototype.imod = function(c) {
      return this.prime ? this.prime.ireduce(c)._forceRed(this) : c.umod(this.m)._forceRed(this);
    }, se2.prototype.neg = function(c) {
      return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
    }, se2.prototype.add = function(c, m2) {
      this._verify2(c, m2);
      var h2 = c.add(m2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2._forceRed(this);
    }, se2.prototype.iadd = function(c, m2) {
      this._verify2(c, m2);
      var h2 = c.iadd(m2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2;
    }, se2.prototype.sub = function(c, m2) {
      this._verify2(c, m2);
      var h2 = c.sub(m2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2._forceRed(this);
    }, se2.prototype.isub = function(c, m2) {
      this._verify2(c, m2);
      var h2 = c.isub(m2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2;
    }, se2.prototype.shl = function(c, m2) {
      return this._verify1(c), this.imod(c.ushln(m2));
    }, se2.prototype.imul = function(c, m2) {
      return this._verify2(c, m2), this.imod(c.imul(m2));
    }, se2.prototype.mul = function(c, m2) {
      return this._verify2(c, m2), this.imod(c.mul(m2));
    }, se2.prototype.isqr = function(c) {
      return this.imul(c, c.clone());
    }, se2.prototype.sqr = function(c) {
      return this.mul(c, c);
    }, se2.prototype.sqrt = function(c) {
      if (c.isZero())
        return c.clone();
      var m2 = this.m.andln(3);
      if (r3(m2 % 2 === 1), m2 === 3) {
        var h2 = this.m.add(new n(1)).iushrn(2);
        return this.pow(c, h2);
      }
      for (var a = this.m.subn(1), u3 = 0; !a.isZero() && a.andln(1) === 0; )
        u3++, a.iushrn(1);
      r3(!a.isZero());
      var b2 = new n(1).toRed(this), A2 = b2.redNeg(), v2 = this.m.subn(1).iushrn(1), d2 = this.m.bitLength();
      for (d2 = new n(2 * d2 * d2).toRed(this); this.pow(d2, v2).cmp(A2) !== 0; )
        d2.redIAdd(A2);
      for (var M = this.pow(d2, a), B2 = this.pow(c, a.addn(1).iushrn(1)), y2 = this.pow(c, a), I = u3; y2.cmp(b2) !== 0; ) {
        for (var de = y2, Me2 = 0; de.cmp(b2) !== 0; Me2++)
          de = de.redSqr();
        r3(Me2 < I);
        var Se = this.pow(M, new n(1).iushln(I - Me2 - 1));
        B2 = B2.redMul(Se), M = Se.redSqr(), y2 = y2.redMul(M), I = Me2;
      }
      return B2;
    }, se2.prototype.invm = function(c) {
      var m2 = c._invmp(this.m);
      return m2.negative !== 0 ? (m2.negative = 0, this.imod(m2).redNeg()) : this.imod(m2);
    }, se2.prototype.pow = function(c, m2) {
      if (m2.isZero())
        return new n(1).toRed(this);
      if (m2.cmpn(1) === 0)
        return c.clone();
      var h2 = 4, a = new Array(1 << h2);
      a[0] = new n(1).toRed(this), a[1] = c;
      for (var u3 = 2; u3 < a.length; u3++)
        a[u3] = this.mul(a[u3 - 1], c);
      var b2 = a[0], A2 = 0, v2 = 0, d2 = m2.bitLength() % 26;
      for (d2 === 0 && (d2 = 26), u3 = m2.length - 1; u3 >= 0; u3--) {
        for (var M = m2.words[u3], B2 = d2 - 1; B2 >= 0; B2--) {
          var y2 = M >> B2 & 1;
          if (b2 !== a[0] && (b2 = this.sqr(b2)), y2 === 0 && A2 === 0) {
            v2 = 0;
            continue;
          }
          A2 <<= 1, A2 |= y2, v2++, !(v2 !== h2 && (u3 !== 0 || B2 !== 0)) && (b2 = this.mul(b2, a[A2]), v2 = 0, A2 = 0);
        }
        d2 = 26;
      }
      return b2;
    }, se2.prototype.convertTo = function(c) {
      var m2 = c.umod(this.m);
      return m2 === c ? m2.clone() : m2;
    }, se2.prototype.convertFrom = function(c) {
      var m2 = c.clone();
      return m2.red = null, m2;
    }, n.mont = function(c) {
      return new ne2(c);
    };
    function ne2(E2) {
      se2.call(this, E2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(ne2, se2), ne2.prototype.convertTo = function(c) {
      return this.imod(c.ushln(this.shift));
    }, ne2.prototype.convertFrom = function(c) {
      var m2 = this.imod(c.mul(this.rinv));
      return m2.red = null, m2;
    }, ne2.prototype.imul = function(c, m2) {
      if (c.isZero() || m2.isZero())
        return c.words[0] = 0, c.length = 1, c;
      var h2 = c.imul(m2), a = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h2.isub(a).iushrn(this.shift), b2 = u3;
      return u3.cmp(this.m) >= 0 ? b2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (b2 = u3.iadd(this.m)), b2._forceRed(this);
    }, ne2.prototype.mul = function(c, m2) {
      if (c.isZero() || m2.isZero())
        return new n(0)._forceRed(this);
      var h2 = c.mul(m2), a = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h2.isub(a).iushrn(this.shift), b2 = u3;
      return u3.cmp(this.m) >= 0 ? b2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (b2 = u3.iadd(this.m)), b2._forceRed(this);
    }, ne2.prototype.invm = function(c) {
      var m2 = this.imod(c._invmp(this.m).mul(this.r2));
      return m2._forceRed(this);
    };
  })(typeof Up > "u" || Up, Lv);
});
var wl = k((UD, Kp) => {
  U();
  var zp;
  Kp.exports = function(e) {
    return zp || (zp = new qn(null)), zp.generate(e);
  };
  function qn(t) {
    this.rand = t;
  }
  Kp.exports.Rand = qn;
  qn.prototype.generate = function(e) {
    return this._rand(e);
  };
  qn.prototype._rand = function(e) {
    if (this.rand.getBytes)
      return this.rand.getBytes(e);
    for (var r3 = new Uint8Array(e), i = 0; i < r3.length; i++)
      r3[i] = this.rand.getByte();
    return r3;
  };
  if (typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? qn.prototype._rand = function(e) {
      var r3 = new Uint8Array(e);
      return self.crypto.getRandomValues(r3), r3;
    } : self.msCrypto && self.msCrypto.getRandomValues ? qn.prototype._rand = function(e) {
      var r3 = new Uint8Array(e);
      return self.msCrypto.getRandomValues(r3), r3;
    } : typeof window == "object" && (qn.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      if (Hp = Gp(), typeof Hp.randomBytes != "function")
        throw new Error("Not supported");
      qn.prototype._rand = function(e) {
        return Hp.randomBytes(e);
      };
    } catch {
    }
  var Hp;
});
var $p = k((zD, qv) => {
  U();
  var Fs = dr(), RE = wl();
  function Rs(t) {
    this.rand = t || new RE.Rand();
  }
  qv.exports = Rs;
  Rs.create = function(e) {
    return new Rs(e);
  };
  Rs.prototype._randbelow = function(e) {
    var r3 = e.bitLength(), i = Math.ceil(r3 / 8);
    do
      var n = new Fs(this.rand.generate(i));
    while (n.cmp(e) >= 0);
    return n;
  };
  Rs.prototype._randrange = function(e, r3) {
    var i = r3.sub(e);
    return e.add(this._randbelow(i));
  };
  Rs.prototype.test = function(e, r3, i) {
    var n = e.bitLength(), s = Fs.mont(e), o = new Fs(1).toRed(s);
    r3 || (r3 = Math.max(1, n / 48 | 0));
    for (var f2 = e.subn(1), l = 0; !f2.testn(l); l++)
      ;
    for (var g5 = e.shrn(l), _ = f2.toRed(s), N2 = true; r3 > 0; r3--) {
      var U2 = this._randrange(new Fs(2), f2);
      i && i(U2);
      var V = U2.toRed(s).redPow(g5);
      if (!(V.cmp(o) === 0 || V.cmp(_) === 0)) {
        for (var G = 1; G < l; G++) {
          if (V = V.redSqr(), V.cmp(o) === 0)
            return false;
          if (V.cmp(_) === 0)
            break;
        }
        if (G === l)
          return false;
      }
    }
    return N2;
  };
  Rs.prototype.getDivisor = function(e, r3) {
    var i = e.bitLength(), n = Fs.mont(e), s = new Fs(1).toRed(n);
    r3 || (r3 = Math.max(1, i / 48 | 0));
    for (var o = e.subn(1), f2 = 0; !o.testn(f2); f2++)
      ;
    for (var l = e.shrn(f2), g5 = o.toRed(n); r3 > 0; r3--) {
      var _ = this._randrange(new Fs(2), o), N2 = e.gcd(_);
      if (N2.cmpn(1) !== 0)
        return N2;
      var U2 = _.toRed(n).redPow(l);
      if (!(U2.cmp(s) === 0 || U2.cmp(g5) === 0)) {
        for (var V = 1; V < f2; V++) {
          if (U2 = U2.redSqr(), U2.cmp(s) === 0)
            return U2.fromRed().subn(1).gcd(e);
          if (U2.cmp(g5) === 0)
            break;
        }
        if (V === f2)
          return U2 = U2.redSqr(), U2.fromRed().subn(1).gcd(e);
      }
    }
    return false;
  };
});
var Xp = k((WD, zv) => {
  U();
  var kE = us();
  zv.exports = Jp;
  Jp.simpleSieve = Yp;
  Jp.fermatTest = Zp;
  var br = dr(), DE = new br(24), NE = $p(), Pv = new NE(), BE = new br(1), Vp = new br(2), CE = new br(5);
  new br(16);
  new br(8);
  var OE = new br(10), jE = new br(3);
  new br(7);
  var LE = new br(11), Uv = new br(4);
  new br(12);
  var Wp = null;
  function qE() {
    if (Wp !== null)
      return Wp;
    var t = 1048576, e = [];
    e[0] = 2;
    for (var r3 = 1, i = 3; i < t; i += 2) {
      for (var n = Math.ceil(Math.sqrt(i)), s = 0; s < r3 && e[s] <= n && i % e[s] !== 0; s++)
        ;
      r3 !== s && e[s] <= n || (e[r3++] = i);
    }
    return Wp = e, e;
  }
  function Yp(t) {
    for (var e = qE(), r3 = 0; r3 < e.length; r3++)
      if (t.modn(e[r3]) === 0)
        return t.cmpn(e[r3]) === 0;
    return true;
  }
  function Zp(t) {
    var e = br.mont(t);
    return Vp.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Jp(t, e) {
    if (t < 16)
      return e === 2 || e === 5 ? new br([140, 123]) : new br([140, 39]);
    e = new br(e);
    for (var r3, i; ; ) {
      for (r3 = new br(kE(Math.ceil(t / 8))); r3.bitLength() > t; )
        r3.ishrn(1);
      if (r3.isEven() && r3.iadd(BE), r3.testn(1) || r3.iadd(Vp), e.cmp(Vp)) {
        if (!e.cmp(CE))
          for (; r3.mod(OE).cmp(jE); )
            r3.iadd(Uv);
      } else
        for (; r3.mod(DE).cmp(LE); )
          r3.iadd(Uv);
      if (i = r3.shrn(1), Yp(i) && Yp(r3) && Zp(i) && Zp(r3) && Pv.test(i) && Pv.test(r3))
        return r3;
    }
  }
});
var Hv = k((VD, PE) => {
  PE.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
});
var Wv = k((YD, $v) => {
  U();
  var ei = dr(), UE = $p(), Kv = new UE(), zE = new ei(24), HE = new ei(11), KE = new ei(10), GE = new ei(3), $E = new ei(7), Gv = Xp(), WE = us();
  $v.exports = un;
  function VE(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this._pub = new ei(t), this;
  }
  function YE(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this._priv = new ei(t), this;
  }
  var _l = {};
  function ZE(t, e) {
    var r3 = e.toString("hex"), i = [r3, t.toString(16)].join("_");
    if (i in _l)
      return _l[i];
    var n = 0;
    if (t.isEven() || !Gv.simpleSieve || !Gv.fermatTest(t) || !Kv.test(t))
      return n += 1, r3 === "02" || r3 === "05" ? n += 8 : n += 4, _l[i] = n, n;
    Kv.test(t.shrn(1)) || (n += 2);
    var s;
    switch (r3) {
      case "02":
        t.mod(zE).cmp(HE) && (n += 8);
        break;
      case "05":
        s = t.mod(KE), s.cmp(GE) && s.cmp($E) && (n += 8);
        break;
      default:
        n += 4;
    }
    return _l[i] = n, n;
  }
  function un(t, e, r3) {
    this.setGenerator(e), this.__prime = new ei(t), this._prime = ei.mont(this.__prime), this._primeLen = t.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r3 ? (this.setPublicKey = VE, this.setPrivateKey = YE) : this._primeCode = 8;
  }
  Object.defineProperty(un.prototype, "verifyError", { enumerable: true, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = ZE(this.__prime, this.__gen)), this._primeCode;
  } });
  un.prototype.generateKeys = function() {
    return this._priv || (this._priv = new ei(WE(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  };
  un.prototype.computeSecret = function(t) {
    t = new ei(t), t = t.toRed(this._prime);
    var e = t.redPow(this._priv).fromRed(), r3 = new b.Buffer(e.toArray()), i = this.getPrime();
    if (r3.length < i.length) {
      var n = new b.Buffer(i.length - r3.length);
      n.fill(0), r3 = b.Buffer.concat([n, r3]);
    }
    return r3;
  };
  un.prototype.getPublicKey = function(e) {
    return Al(this._pub, e);
  };
  un.prototype.getPrivateKey = function(e) {
    return Al(this._priv, e);
  };
  un.prototype.getPrime = function(t) {
    return Al(this.__prime, t);
  };
  un.prototype.getGenerator = function(t) {
    return Al(this._gen, t);
  };
  un.prototype.setGenerator = function(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this.__gen = t, this._gen = new ei(t), this;
  };
  function Al(t, e) {
    var r3 = new b.Buffer(t.toArray());
    return e ? r3.toString(e) : r3;
  }
});
var Zv = k((Po) => {
  U();
  var JE = Xp(), Vv = Hv(), Qp = Wv();
  function XE(t) {
    var e = new b.Buffer(Vv[t].prime, "hex"), r3 = new b.Buffer(Vv[t].gen, "hex");
    return new Qp(e, r3);
  }
  var QE = { binary: true, hex: true, base64: true };
  function Yv(t, e, r3, i) {
    return b.Buffer.isBuffer(e) || QE[e] === void 0 ? Yv(t, "binary", e, r3) : (e = e || "binary", i = i || "binary", r3 = r3 || new b.Buffer([2]), b.Buffer.isBuffer(r3) || (r3 = new b.Buffer(r3, i)), typeof t == "number" ? new Qp(JE(t, r3), r3, true) : (b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), new Qp(t, r3, true)));
  }
  Po.DiffieHellmanGroup = Po.createDiffieHellmanGroup = Po.getDiffieHellman = XE;
  Po.createDiffieHellman = Po.DiffieHellman = Yv;
});
var El = k((Jv, e1) => {
  U();
  (function(t, e) {
    function r3(h2, a) {
      if (!h2)
        throw new Error(a || "Assertion failed");
    }
    function i(h2, a) {
      h2.super_ = a;
      var u3 = function() {
      };
      u3.prototype = a.prototype, h2.prototype = new u3(), h2.prototype.constructor = h2;
    }
    function n(h2, a, u3) {
      if (n.isBN(h2))
        return h2;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, h2 !== null && ((a === "le" || a === "be") && (u3 = a, a = 10), this._init(h2 || 0, a || 10, u3 || "be"));
    }
    typeof t == "object" ? t.exports = n : e.BN = n, n.BN = n, n.wordSize = 26;
    var s;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s = window.Buffer : s = or().Buffer;
    } catch {
    }
    n.isBN = function(a) {
      return a instanceof n ? true : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words);
    }, n.max = function(a, u3) {
      return a.cmp(u3) > 0 ? a : u3;
    }, n.min = function(a, u3) {
      return a.cmp(u3) < 0 ? a : u3;
    }, n.prototype._init = function(a, u3, b2) {
      if (typeof a == "number")
        return this._initNumber(a, u3, b2);
      if (typeof a == "object")
        return this._initArray(a, u3, b2);
      u3 === "hex" && (u3 = 16), r3(u3 === (u3 | 0) && u3 >= 2 && u3 <= 36), a = a.toString().replace(/\s+/g, "");
      var A2 = 0;
      a[0] === "-" && (A2++, this.negative = 1), A2 < a.length && (u3 === 16 ? this._parseHex(a, A2, b2) : (this._parseBase(a, u3, A2), b2 === "le" && this._initArray(this.toArray(), u3, b2)));
    }, n.prototype._initNumber = function(a, u3, b2) {
      a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [a & 67108863, a / 67108864 & 67108863], this.length = 2) : (r3(a < 9007199254740992), this.words = [a & 67108863, a / 67108864 & 67108863, 1], this.length = 3), b2 === "le" && this._initArray(this.toArray(), u3, b2);
    }, n.prototype._initArray = function(a, u3, b2) {
      if (r3(typeof a.length == "number"), a.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
      for (var A2 = 0; A2 < this.length; A2++)
        this.words[A2] = 0;
      var v2, d2, M = 0;
      if (b2 === "be")
        for (A2 = a.length - 1, v2 = 0; A2 >= 0; A2 -= 3)
          d2 = a[A2] | a[A2 - 1] << 8 | a[A2 - 2] << 16, this.words[v2] |= d2 << M & 67108863, this.words[v2 + 1] = d2 >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, v2++);
      else if (b2 === "le")
        for (A2 = 0, v2 = 0; A2 < a.length; A2 += 3)
          d2 = a[A2] | a[A2 + 1] << 8 | a[A2 + 2] << 16, this.words[v2] |= d2 << M & 67108863, this.words[v2 + 1] = d2 >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, v2++);
      return this._strip();
    };
    function o(h2, a) {
      var u3 = h2.charCodeAt(a);
      if (u3 >= 48 && u3 <= 57)
        return u3 - 48;
      if (u3 >= 65 && u3 <= 70)
        return u3 - 55;
      if (u3 >= 97 && u3 <= 102)
        return u3 - 87;
      r3(false, "Invalid character in " + h2);
    }
    function f2(h2, a, u3) {
      var b2 = o(h2, u3);
      return u3 - 1 >= a && (b2 |= o(h2, u3 - 1) << 4), b2;
    }
    n.prototype._parseHex = function(a, u3, b2) {
      this.length = Math.ceil((a.length - u3) / 6), this.words = new Array(this.length);
      for (var A2 = 0; A2 < this.length; A2++)
        this.words[A2] = 0;
      var v2 = 0, d2 = 0, M;
      if (b2 === "be")
        for (A2 = a.length - 1; A2 >= u3; A2 -= 2)
          M = f2(a, u3, A2) << v2, this.words[d2] |= M & 67108863, v2 >= 18 ? (v2 -= 18, d2 += 1, this.words[d2] |= M >>> 26) : v2 += 8;
      else {
        var B2 = a.length - u3;
        for (A2 = B2 % 2 === 0 ? u3 + 1 : u3; A2 < a.length; A2 += 2)
          M = f2(a, u3, A2) << v2, this.words[d2] |= M & 67108863, v2 >= 18 ? (v2 -= 18, d2 += 1, this.words[d2] |= M >>> 26) : v2 += 8;
      }
      this._strip();
    };
    function l(h2, a, u3, b2) {
      for (var A2 = 0, v2 = 0, d2 = Math.min(h2.length, u3), M = a; M < d2; M++) {
        var B2 = h2.charCodeAt(M) - 48;
        A2 *= b2, B2 >= 49 ? v2 = B2 - 49 + 10 : B2 >= 17 ? v2 = B2 - 17 + 10 : v2 = B2, r3(B2 >= 0 && v2 < b2, "Invalid character"), A2 += v2;
      }
      return A2;
    }
    n.prototype._parseBase = function(a, u3, b2) {
      this.words = [0], this.length = 1;
      for (var A2 = 0, v2 = 1; v2 <= 67108863; v2 *= u3)
        A2++;
      A2--, v2 = v2 / u3 | 0;
      for (var d2 = a.length - b2, M = d2 % A2, B2 = Math.min(d2, d2 - M) + b2, y2 = 0, I = b2; I < B2; I += A2)
        y2 = l(a, I, I + A2, u3), this.imuln(v2), this.words[0] + y2 < 67108864 ? this.words[0] += y2 : this._iaddn(y2);
      if (M !== 0) {
        var de = 1;
        for (y2 = l(a, I, a.length, u3), I = 0; I < M; I++)
          de *= u3;
        this.imuln(de), this.words[0] + y2 < 67108864 ? this.words[0] += y2 : this._iaddn(y2);
      }
      this._strip();
    }, n.prototype.copy = function(a) {
      a.words = new Array(this.length);
      for (var u3 = 0; u3 < this.length; u3++)
        a.words[u3] = this.words[u3];
      a.length = this.length, a.negative = this.negative, a.red = this.red;
    };
    function g5(h2, a) {
      h2.words = a.words, h2.length = a.length, h2.negative = a.negative, h2.red = a.red;
    }
    if (n.prototype._move = function(a) {
      g5(a, this);
    }, n.prototype.clone = function() {
      var a = new n(null);
      return this.copy(a), a;
    }, n.prototype._expand = function(a) {
      for (; this.length < a; )
        this.words[this.length++] = 0;
      return this;
    }, n.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, n.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        n.prototype[Symbol.for("nodejs.util.inspect.custom")] = _;
      } catch {
        n.prototype.inspect = _;
      }
    else
      n.prototype.inspect = _;
    function _() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var N2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], U2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], V = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    n.prototype.toString = function(a, u3) {
      a = a || 10, u3 = u3 | 0 || 1;
      var b2;
      if (a === 16 || a === "hex") {
        b2 = "";
        for (var A2 = 0, v2 = 0, d2 = 0; d2 < this.length; d2++) {
          var M = this.words[d2], B2 = ((M << A2 | v2) & 16777215).toString(16);
          v2 = M >>> 24 - A2 & 16777215, A2 += 2, A2 >= 26 && (A2 -= 26, d2--), v2 !== 0 || d2 !== this.length - 1 ? b2 = N2[6 - B2.length] + B2 + b2 : b2 = B2 + b2;
        }
        for (v2 !== 0 && (b2 = v2.toString(16) + b2); b2.length % u3 !== 0; )
          b2 = "0" + b2;
        return this.negative !== 0 && (b2 = "-" + b2), b2;
      }
      if (a === (a | 0) && a >= 2 && a <= 36) {
        var y2 = U2[a], I = V[a];
        b2 = "";
        var de = this.clone();
        for (de.negative = 0; !de.isZero(); ) {
          var Me2 = de.modrn(I).toString(a);
          de = de.idivn(I), de.isZero() ? b2 = Me2 + b2 : b2 = N2[y2 - Me2.length] + Me2 + b2;
        }
        for (this.isZero() && (b2 = "0" + b2); b2.length % u3 !== 0; )
          b2 = "0" + b2;
        return this.negative !== 0 && (b2 = "-" + b2), b2;
      }
      r3(false, "Base should be between 2 and 36");
    }, n.prototype.toNumber = function() {
      var a = this.words[0];
      return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r3(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
    }, n.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, s && (n.prototype.toBuffer = function(a, u3) {
      return this.toArrayLike(s, a, u3);
    }), n.prototype.toArray = function(a, u3) {
      return this.toArrayLike(Array, a, u3);
    };
    var G = function(a, u3) {
      return a.allocUnsafe ? a.allocUnsafe(u3) : new a(u3);
    };
    n.prototype.toArrayLike = function(a, u3, b2) {
      this._strip();
      var A2 = this.byteLength(), v2 = b2 || Math.max(1, A2);
      r3(A2 <= v2, "byte array longer than desired length"), r3(v2 > 0, "Requested array length <= 0");
      var d2 = G(a, v2), M = u3 === "le" ? "LE" : "BE";
      return this["_toArrayLike" + M](d2, A2), d2;
    }, n.prototype._toArrayLikeLE = function(a, u3) {
      for (var b2 = 0, A2 = 0, v2 = 0, d2 = 0; v2 < this.length; v2++) {
        var M = this.words[v2] << d2 | A2;
        a[b2++] = M & 255, b2 < a.length && (a[b2++] = M >> 8 & 255), b2 < a.length && (a[b2++] = M >> 16 & 255), d2 === 6 ? (b2 < a.length && (a[b2++] = M >> 24 & 255), A2 = 0, d2 = 0) : (A2 = M >>> 24, d2 += 2);
      }
      if (b2 < a.length)
        for (a[b2++] = A2; b2 < a.length; )
          a[b2++] = 0;
    }, n.prototype._toArrayLikeBE = function(a, u3) {
      for (var b2 = a.length - 1, A2 = 0, v2 = 0, d2 = 0; v2 < this.length; v2++) {
        var M = this.words[v2] << d2 | A2;
        a[b2--] = M & 255, b2 >= 0 && (a[b2--] = M >> 8 & 255), b2 >= 0 && (a[b2--] = M >> 16 & 255), d2 === 6 ? (b2 >= 0 && (a[b2--] = M >> 24 & 255), A2 = 0, d2 = 0) : (A2 = M >>> 24, d2 += 2);
      }
      if (b2 >= 0)
        for (a[b2--] = A2; b2 >= 0; )
          a[b2--] = 0;
    }, Math.clz32 ? n.prototype._countBits = function(a) {
      return 32 - Math.clz32(a);
    } : n.prototype._countBits = function(a) {
      var u3 = a, b2 = 0;
      return u3 >= 4096 && (b2 += 13, u3 >>>= 13), u3 >= 64 && (b2 += 7, u3 >>>= 7), u3 >= 8 && (b2 += 4, u3 >>>= 4), u3 >= 2 && (b2 += 2, u3 >>>= 2), b2 + u3;
    }, n.prototype._zeroBits = function(a) {
      if (a === 0)
        return 26;
      var u3 = a, b2 = 0;
      return (u3 & 8191) === 0 && (b2 += 13, u3 >>>= 13), (u3 & 127) === 0 && (b2 += 7, u3 >>>= 7), (u3 & 15) === 0 && (b2 += 4, u3 >>>= 4), (u3 & 3) === 0 && (b2 += 2, u3 >>>= 2), (u3 & 1) === 0 && b2++, b2;
    }, n.prototype.bitLength = function() {
      var a = this.words[this.length - 1], u3 = this._countBits(a);
      return (this.length - 1) * 26 + u3;
    };
    function ee2(h2) {
      for (var a = new Array(h2.bitLength()), u3 = 0; u3 < a.length; u3++) {
        var b2 = u3 / 26 | 0, A2 = u3 % 26;
        a[u3] = h2.words[b2] >>> A2 & 1;
      }
      return a;
    }
    n.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var a = 0, u3 = 0; u3 < this.length; u3++) {
        var b2 = this._zeroBits(this.words[u3]);
        if (a += b2, b2 !== 26)
          break;
      }
      return a;
    }, n.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, n.prototype.toTwos = function(a) {
      return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
    }, n.prototype.fromTwos = function(a) {
      return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
    }, n.prototype.isNeg = function() {
      return this.negative !== 0;
    }, n.prototype.neg = function() {
      return this.clone().ineg();
    }, n.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, n.prototype.iuor = function(a) {
      for (; this.length < a.length; )
        this.words[this.length++] = 0;
      for (var u3 = 0; u3 < a.length; u3++)
        this.words[u3] = this.words[u3] | a.words[u3];
      return this._strip();
    }, n.prototype.ior = function(a) {
      return r3((this.negative | a.negative) === 0), this.iuor(a);
    }, n.prototype.or = function(a) {
      return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
    }, n.prototype.uor = function(a) {
      return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
    }, n.prototype.iuand = function(a) {
      var u3;
      this.length > a.length ? u3 = a : u3 = this;
      for (var b2 = 0; b2 < u3.length; b2++)
        this.words[b2] = this.words[b2] & a.words[b2];
      return this.length = u3.length, this._strip();
    }, n.prototype.iand = function(a) {
      return r3((this.negative | a.negative) === 0), this.iuand(a);
    }, n.prototype.and = function(a) {
      return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
    }, n.prototype.uand = function(a) {
      return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
    }, n.prototype.iuxor = function(a) {
      var u3, b2;
      this.length > a.length ? (u3 = this, b2 = a) : (u3 = a, b2 = this);
      for (var A2 = 0; A2 < b2.length; A2++)
        this.words[A2] = u3.words[A2] ^ b2.words[A2];
      if (this !== u3)
        for (; A2 < u3.length; A2++)
          this.words[A2] = u3.words[A2];
      return this.length = u3.length, this._strip();
    }, n.prototype.ixor = function(a) {
      return r3((this.negative | a.negative) === 0), this.iuxor(a);
    }, n.prototype.xor = function(a) {
      return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
    }, n.prototype.uxor = function(a) {
      return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
    }, n.prototype.inotn = function(a) {
      r3(typeof a == "number" && a >= 0);
      var u3 = Math.ceil(a / 26) | 0, b2 = a % 26;
      this._expand(u3), b2 > 0 && u3--;
      for (var A2 = 0; A2 < u3; A2++)
        this.words[A2] = ~this.words[A2] & 67108863;
      return b2 > 0 && (this.words[A2] = ~this.words[A2] & 67108863 >> 26 - b2), this._strip();
    }, n.prototype.notn = function(a) {
      return this.clone().inotn(a);
    }, n.prototype.setn = function(a, u3) {
      r3(typeof a == "number" && a >= 0);
      var b2 = a / 26 | 0, A2 = a % 26;
      return this._expand(b2 + 1), u3 ? this.words[b2] = this.words[b2] | 1 << A2 : this.words[b2] = this.words[b2] & ~(1 << A2), this._strip();
    }, n.prototype.iadd = function(a) {
      var u3;
      if (this.negative !== 0 && a.negative === 0)
        return this.negative = 0, u3 = this.isub(a), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && a.negative !== 0)
        return a.negative = 0, u3 = this.isub(a), a.negative = 1, u3._normSign();
      var b2, A2;
      this.length > a.length ? (b2 = this, A2 = a) : (b2 = a, A2 = this);
      for (var v2 = 0, d2 = 0; d2 < A2.length; d2++)
        u3 = (b2.words[d2] | 0) + (A2.words[d2] | 0) + v2, this.words[d2] = u3 & 67108863, v2 = u3 >>> 26;
      for (; v2 !== 0 && d2 < b2.length; d2++)
        u3 = (b2.words[d2] | 0) + v2, this.words[d2] = u3 & 67108863, v2 = u3 >>> 26;
      if (this.length = b2.length, v2 !== 0)
        this.words[this.length] = v2, this.length++;
      else if (b2 !== this)
        for (; d2 < b2.length; d2++)
          this.words[d2] = b2.words[d2];
      return this;
    }, n.prototype.add = function(a) {
      var u3;
      return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, u3 = this.sub(a), a.negative ^= 1, u3) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, u3 = a.sub(this), this.negative = 1, u3) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
    }, n.prototype.isub = function(a) {
      if (a.negative !== 0) {
        a.negative = 0;
        var u3 = this.iadd(a);
        return a.negative = 1, u3._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
      var b2 = this.cmp(a);
      if (b2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var A2, v2;
      b2 > 0 ? (A2 = this, v2 = a) : (A2 = a, v2 = this);
      for (var d2 = 0, M = 0; M < v2.length; M++)
        u3 = (A2.words[M] | 0) - (v2.words[M] | 0) + d2, d2 = u3 >> 26, this.words[M] = u3 & 67108863;
      for (; d2 !== 0 && M < A2.length; M++)
        u3 = (A2.words[M] | 0) + d2, d2 = u3 >> 26, this.words[M] = u3 & 67108863;
      if (d2 === 0 && M < A2.length && A2 !== this)
        for (; M < A2.length; M++)
          this.words[M] = A2.words[M];
      return this.length = Math.max(this.length, M), A2 !== this && (this.negative = 1), this._strip();
    }, n.prototype.sub = function(a) {
      return this.clone().isub(a);
    };
    function W5(h2, a, u3) {
      u3.negative = a.negative ^ h2.negative;
      var b2 = h2.length + a.length | 0;
      u3.length = b2, b2 = b2 - 1 | 0;
      var A2 = h2.words[0] | 0, v2 = a.words[0] | 0, d2 = A2 * v2, M = d2 & 67108863, B2 = d2 / 67108864 | 0;
      u3.words[0] = M;
      for (var y2 = 1; y2 < b2; y2++) {
        for (var I = B2 >>> 26, de = B2 & 67108863, Me2 = Math.min(y2, a.length - 1), Se = Math.max(0, y2 - h2.length + 1); Se <= Me2; Se++) {
          var Oe = y2 - Se | 0;
          A2 = h2.words[Oe] | 0, v2 = a.words[Se] | 0, d2 = A2 * v2 + de, I += d2 / 67108864 | 0, de = d2 & 67108863;
        }
        u3.words[y2] = de | 0, B2 = I | 0;
      }
      return B2 !== 0 ? u3.words[y2] = B2 | 0 : u3.length--, u3._strip();
    }
    var Z = function(a, u3, b2) {
      var A2 = a.words, v2 = u3.words, d2 = b2.words, M = 0, B2, y2, I, de = A2[0] | 0, Me2 = de & 8191, Se = de >>> 13, Oe = A2[1] | 0, ye = Oe & 8191, T = Oe >>> 13, j2 = A2[2] | 0, P5 = j2 & 8191, te2 = j2 >>> 13, oe2 = A2[3] | 0, re = oe2 & 8191, ae = oe2 >>> 13, ie = A2[4] | 0, X2 = ie & 8191, R5 = ie >>> 13, x2 = A2[5] | 0, F2 = x2 & 8191, q2 = x2 >>> 13, L2 = A2[6] | 0, K5 = L2 & 8191, $ = L2 >>> 13, we2 = A2[7] | 0, pe = we2 & 8191, _e = we2 >>> 13, fe2 = A2[8] | 0, Fe = fe2 & 8191, De = fe2 >>> 13, pt2 = A2[9] | 0, je = pt2 & 8191, Ke = pt2 >>> 13, wt = v2[0] | 0, Pe = wt & 8191, Le2 = wt >>> 13, Vt = v2[1] | 0, Je = Vt & 8191, Xe2 = Vt >>> 13, Jt = v2[2] | 0, Qe = Jt & 8191, et = Jt >>> 13, Ut = v2[3] | 0, lt = Ut & 8191, ht = Ut >>> 13, tn = v2[4] | 0, gt = tn & 8191, yt = tn >>> 13, fs = v2[5] | 0, rt = fs & 8191, bt = fs >>> 13, S2 = v2[6] | 0, D2 = S2 & 8191, k2 = S2 >>> 13, p2 = v2[7] | 0, C2 = p2 & 8191, Q2 = p2 >>> 13, he = v2[8] | 0, ge2 = he & 8191, Ee = he >>> 13, Ve2 = v2[9] | 0, Ne = Ve2 & 8191, tt = Ve2 >>> 13;
      b2.negative = a.negative ^ u3.negative, b2.length = 19, B2 = Math.imul(Me2, Pe), y2 = Math.imul(Me2, Le2), y2 = y2 + Math.imul(Se, Pe) | 0, I = Math.imul(Se, Le2);
      var He = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, B2 = Math.imul(ye, Pe), y2 = Math.imul(ye, Le2), y2 = y2 + Math.imul(T, Pe) | 0, I = Math.imul(T, Le2), B2 = B2 + Math.imul(Me2, Je) | 0, y2 = y2 + Math.imul(Me2, Xe2) | 0, y2 = y2 + Math.imul(Se, Je) | 0, I = I + Math.imul(Se, Xe2) | 0;
      var it = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, B2 = Math.imul(P5, Pe), y2 = Math.imul(P5, Le2), y2 = y2 + Math.imul(te2, Pe) | 0, I = Math.imul(te2, Le2), B2 = B2 + Math.imul(ye, Je) | 0, y2 = y2 + Math.imul(ye, Xe2) | 0, y2 = y2 + Math.imul(T, Je) | 0, I = I + Math.imul(T, Xe2) | 0, B2 = B2 + Math.imul(Me2, Qe) | 0, y2 = y2 + Math.imul(Me2, et) | 0, y2 = y2 + Math.imul(Se, Qe) | 0, I = I + Math.imul(Se, et) | 0;
      var nt = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, B2 = Math.imul(re, Pe), y2 = Math.imul(re, Le2), y2 = y2 + Math.imul(ae, Pe) | 0, I = Math.imul(ae, Le2), B2 = B2 + Math.imul(P5, Je) | 0, y2 = y2 + Math.imul(P5, Xe2) | 0, y2 = y2 + Math.imul(te2, Je) | 0, I = I + Math.imul(te2, Xe2) | 0, B2 = B2 + Math.imul(ye, Qe) | 0, y2 = y2 + Math.imul(ye, et) | 0, y2 = y2 + Math.imul(T, Qe) | 0, I = I + Math.imul(T, et) | 0, B2 = B2 + Math.imul(Me2, lt) | 0, y2 = y2 + Math.imul(Me2, ht) | 0, y2 = y2 + Math.imul(Se, lt) | 0, I = I + Math.imul(Se, ht) | 0;
      var dt = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, B2 = Math.imul(X2, Pe), y2 = Math.imul(X2, Le2), y2 = y2 + Math.imul(R5, Pe) | 0, I = Math.imul(R5, Le2), B2 = B2 + Math.imul(re, Je) | 0, y2 = y2 + Math.imul(re, Xe2) | 0, y2 = y2 + Math.imul(ae, Je) | 0, I = I + Math.imul(ae, Xe2) | 0, B2 = B2 + Math.imul(P5, Qe) | 0, y2 = y2 + Math.imul(P5, et) | 0, y2 = y2 + Math.imul(te2, Qe) | 0, I = I + Math.imul(te2, et) | 0, B2 = B2 + Math.imul(ye, lt) | 0, y2 = y2 + Math.imul(ye, ht) | 0, y2 = y2 + Math.imul(T, lt) | 0, I = I + Math.imul(T, ht) | 0, B2 = B2 + Math.imul(Me2, gt) | 0, y2 = y2 + Math.imul(Me2, yt) | 0, y2 = y2 + Math.imul(Se, gt) | 0, I = I + Math.imul(Se, yt) | 0;
      var ut = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, B2 = Math.imul(F2, Pe), y2 = Math.imul(F2, Le2), y2 = y2 + Math.imul(q2, Pe) | 0, I = Math.imul(q2, Le2), B2 = B2 + Math.imul(X2, Je) | 0, y2 = y2 + Math.imul(X2, Xe2) | 0, y2 = y2 + Math.imul(R5, Je) | 0, I = I + Math.imul(R5, Xe2) | 0, B2 = B2 + Math.imul(re, Qe) | 0, y2 = y2 + Math.imul(re, et) | 0, y2 = y2 + Math.imul(ae, Qe) | 0, I = I + Math.imul(ae, et) | 0, B2 = B2 + Math.imul(P5, lt) | 0, y2 = y2 + Math.imul(P5, ht) | 0, y2 = y2 + Math.imul(te2, lt) | 0, I = I + Math.imul(te2, ht) | 0, B2 = B2 + Math.imul(ye, gt) | 0, y2 = y2 + Math.imul(ye, yt) | 0, y2 = y2 + Math.imul(T, gt) | 0, I = I + Math.imul(T, yt) | 0, B2 = B2 + Math.imul(Me2, rt) | 0, y2 = y2 + Math.imul(Me2, bt) | 0, y2 = y2 + Math.imul(Se, rt) | 0, I = I + Math.imul(Se, bt) | 0;
      var st = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, B2 = Math.imul(K5, Pe), y2 = Math.imul(K5, Le2), y2 = y2 + Math.imul($, Pe) | 0, I = Math.imul($, Le2), B2 = B2 + Math.imul(F2, Je) | 0, y2 = y2 + Math.imul(F2, Xe2) | 0, y2 = y2 + Math.imul(q2, Je) | 0, I = I + Math.imul(q2, Xe2) | 0, B2 = B2 + Math.imul(X2, Qe) | 0, y2 = y2 + Math.imul(X2, et) | 0, y2 = y2 + Math.imul(R5, Qe) | 0, I = I + Math.imul(R5, et) | 0, B2 = B2 + Math.imul(re, lt) | 0, y2 = y2 + Math.imul(re, ht) | 0, y2 = y2 + Math.imul(ae, lt) | 0, I = I + Math.imul(ae, ht) | 0, B2 = B2 + Math.imul(P5, gt) | 0, y2 = y2 + Math.imul(P5, yt) | 0, y2 = y2 + Math.imul(te2, gt) | 0, I = I + Math.imul(te2, yt) | 0, B2 = B2 + Math.imul(ye, rt) | 0, y2 = y2 + Math.imul(ye, bt) | 0, y2 = y2 + Math.imul(T, rt) | 0, I = I + Math.imul(T, bt) | 0, B2 = B2 + Math.imul(Me2, D2) | 0, y2 = y2 + Math.imul(Me2, k2) | 0, y2 = y2 + Math.imul(Se, D2) | 0, I = I + Math.imul(Se, k2) | 0;
      var at = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, B2 = Math.imul(pe, Pe), y2 = Math.imul(pe, Le2), y2 = y2 + Math.imul(_e, Pe) | 0, I = Math.imul(_e, Le2), B2 = B2 + Math.imul(K5, Je) | 0, y2 = y2 + Math.imul(K5, Xe2) | 0, y2 = y2 + Math.imul($, Je) | 0, I = I + Math.imul($, Xe2) | 0, B2 = B2 + Math.imul(F2, Qe) | 0, y2 = y2 + Math.imul(F2, et) | 0, y2 = y2 + Math.imul(q2, Qe) | 0, I = I + Math.imul(q2, et) | 0, B2 = B2 + Math.imul(X2, lt) | 0, y2 = y2 + Math.imul(X2, ht) | 0, y2 = y2 + Math.imul(R5, lt) | 0, I = I + Math.imul(R5, ht) | 0, B2 = B2 + Math.imul(re, gt) | 0, y2 = y2 + Math.imul(re, yt) | 0, y2 = y2 + Math.imul(ae, gt) | 0, I = I + Math.imul(ae, yt) | 0, B2 = B2 + Math.imul(P5, rt) | 0, y2 = y2 + Math.imul(P5, bt) | 0, y2 = y2 + Math.imul(te2, rt) | 0, I = I + Math.imul(te2, bt) | 0, B2 = B2 + Math.imul(ye, D2) | 0, y2 = y2 + Math.imul(ye, k2) | 0, y2 = y2 + Math.imul(T, D2) | 0, I = I + Math.imul(T, k2) | 0, B2 = B2 + Math.imul(Me2, C2) | 0, y2 = y2 + Math.imul(Me2, Q2) | 0, y2 = y2 + Math.imul(Se, C2) | 0, I = I + Math.imul(Se, Q2) | 0;
      var ot = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, B2 = Math.imul(Fe, Pe), y2 = Math.imul(Fe, Le2), y2 = y2 + Math.imul(De, Pe) | 0, I = Math.imul(De, Le2), B2 = B2 + Math.imul(pe, Je) | 0, y2 = y2 + Math.imul(pe, Xe2) | 0, y2 = y2 + Math.imul(_e, Je) | 0, I = I + Math.imul(_e, Xe2) | 0, B2 = B2 + Math.imul(K5, Qe) | 0, y2 = y2 + Math.imul(K5, et) | 0, y2 = y2 + Math.imul($, Qe) | 0, I = I + Math.imul($, et) | 0, B2 = B2 + Math.imul(F2, lt) | 0, y2 = y2 + Math.imul(F2, ht) | 0, y2 = y2 + Math.imul(q2, lt) | 0, I = I + Math.imul(q2, ht) | 0, B2 = B2 + Math.imul(X2, gt) | 0, y2 = y2 + Math.imul(X2, yt) | 0, y2 = y2 + Math.imul(R5, gt) | 0, I = I + Math.imul(R5, yt) | 0, B2 = B2 + Math.imul(re, rt) | 0, y2 = y2 + Math.imul(re, bt) | 0, y2 = y2 + Math.imul(ae, rt) | 0, I = I + Math.imul(ae, bt) | 0, B2 = B2 + Math.imul(P5, D2) | 0, y2 = y2 + Math.imul(P5, k2) | 0, y2 = y2 + Math.imul(te2, D2) | 0, I = I + Math.imul(te2, k2) | 0, B2 = B2 + Math.imul(ye, C2) | 0, y2 = y2 + Math.imul(ye, Q2) | 0, y2 = y2 + Math.imul(T, C2) | 0, I = I + Math.imul(T, Q2) | 0, B2 = B2 + Math.imul(Me2, ge2) | 0, y2 = y2 + Math.imul(Me2, Ee) | 0, y2 = y2 + Math.imul(Se, ge2) | 0, I = I + Math.imul(Se, Ee) | 0;
      var Ge2 = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (Ge2 >>> 26) | 0, Ge2 &= 67108863, B2 = Math.imul(je, Pe), y2 = Math.imul(je, Le2), y2 = y2 + Math.imul(Ke, Pe) | 0, I = Math.imul(Ke, Le2), B2 = B2 + Math.imul(Fe, Je) | 0, y2 = y2 + Math.imul(Fe, Xe2) | 0, y2 = y2 + Math.imul(De, Je) | 0, I = I + Math.imul(De, Xe2) | 0, B2 = B2 + Math.imul(pe, Qe) | 0, y2 = y2 + Math.imul(pe, et) | 0, y2 = y2 + Math.imul(_e, Qe) | 0, I = I + Math.imul(_e, et) | 0, B2 = B2 + Math.imul(K5, lt) | 0, y2 = y2 + Math.imul(K5, ht) | 0, y2 = y2 + Math.imul($, lt) | 0, I = I + Math.imul($, ht) | 0, B2 = B2 + Math.imul(F2, gt) | 0, y2 = y2 + Math.imul(F2, yt) | 0, y2 = y2 + Math.imul(q2, gt) | 0, I = I + Math.imul(q2, yt) | 0, B2 = B2 + Math.imul(X2, rt) | 0, y2 = y2 + Math.imul(X2, bt) | 0, y2 = y2 + Math.imul(R5, rt) | 0, I = I + Math.imul(R5, bt) | 0, B2 = B2 + Math.imul(re, D2) | 0, y2 = y2 + Math.imul(re, k2) | 0, y2 = y2 + Math.imul(ae, D2) | 0, I = I + Math.imul(ae, k2) | 0, B2 = B2 + Math.imul(P5, C2) | 0, y2 = y2 + Math.imul(P5, Q2) | 0, y2 = y2 + Math.imul(te2, C2) | 0, I = I + Math.imul(te2, Q2) | 0, B2 = B2 + Math.imul(ye, ge2) | 0, y2 = y2 + Math.imul(ye, Ee) | 0, y2 = y2 + Math.imul(T, ge2) | 0, I = I + Math.imul(T, Ee) | 0, B2 = B2 + Math.imul(Me2, Ne) | 0, y2 = y2 + Math.imul(Me2, tt) | 0, y2 = y2 + Math.imul(Se, Ne) | 0, I = I + Math.imul(Se, tt) | 0;
      var Ye2 = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (Ye2 >>> 26) | 0, Ye2 &= 67108863, B2 = Math.imul(je, Je), y2 = Math.imul(je, Xe2), y2 = y2 + Math.imul(Ke, Je) | 0, I = Math.imul(Ke, Xe2), B2 = B2 + Math.imul(Fe, Qe) | 0, y2 = y2 + Math.imul(Fe, et) | 0, y2 = y2 + Math.imul(De, Qe) | 0, I = I + Math.imul(De, et) | 0, B2 = B2 + Math.imul(pe, lt) | 0, y2 = y2 + Math.imul(pe, ht) | 0, y2 = y2 + Math.imul(_e, lt) | 0, I = I + Math.imul(_e, ht) | 0, B2 = B2 + Math.imul(K5, gt) | 0, y2 = y2 + Math.imul(K5, yt) | 0, y2 = y2 + Math.imul($, gt) | 0, I = I + Math.imul($, yt) | 0, B2 = B2 + Math.imul(F2, rt) | 0, y2 = y2 + Math.imul(F2, bt) | 0, y2 = y2 + Math.imul(q2, rt) | 0, I = I + Math.imul(q2, bt) | 0, B2 = B2 + Math.imul(X2, D2) | 0, y2 = y2 + Math.imul(X2, k2) | 0, y2 = y2 + Math.imul(R5, D2) | 0, I = I + Math.imul(R5, k2) | 0, B2 = B2 + Math.imul(re, C2) | 0, y2 = y2 + Math.imul(re, Q2) | 0, y2 = y2 + Math.imul(ae, C2) | 0, I = I + Math.imul(ae, Q2) | 0, B2 = B2 + Math.imul(P5, ge2) | 0, y2 = y2 + Math.imul(P5, Ee) | 0, y2 = y2 + Math.imul(te2, ge2) | 0, I = I + Math.imul(te2, Ee) | 0, B2 = B2 + Math.imul(ye, Ne) | 0, y2 = y2 + Math.imul(ye, tt) | 0, y2 = y2 + Math.imul(T, Ne) | 0, I = I + Math.imul(T, tt) | 0;
      var ze = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B2 = Math.imul(je, Qe), y2 = Math.imul(je, et), y2 = y2 + Math.imul(Ke, Qe) | 0, I = Math.imul(Ke, et), B2 = B2 + Math.imul(Fe, lt) | 0, y2 = y2 + Math.imul(Fe, ht) | 0, y2 = y2 + Math.imul(De, lt) | 0, I = I + Math.imul(De, ht) | 0, B2 = B2 + Math.imul(pe, gt) | 0, y2 = y2 + Math.imul(pe, yt) | 0, y2 = y2 + Math.imul(_e, gt) | 0, I = I + Math.imul(_e, yt) | 0, B2 = B2 + Math.imul(K5, rt) | 0, y2 = y2 + Math.imul(K5, bt) | 0, y2 = y2 + Math.imul($, rt) | 0, I = I + Math.imul($, bt) | 0, B2 = B2 + Math.imul(F2, D2) | 0, y2 = y2 + Math.imul(F2, k2) | 0, y2 = y2 + Math.imul(q2, D2) | 0, I = I + Math.imul(q2, k2) | 0, B2 = B2 + Math.imul(X2, C2) | 0, y2 = y2 + Math.imul(X2, Q2) | 0, y2 = y2 + Math.imul(R5, C2) | 0, I = I + Math.imul(R5, Q2) | 0, B2 = B2 + Math.imul(re, ge2) | 0, y2 = y2 + Math.imul(re, Ee) | 0, y2 = y2 + Math.imul(ae, ge2) | 0, I = I + Math.imul(ae, Ee) | 0, B2 = B2 + Math.imul(P5, Ne) | 0, y2 = y2 + Math.imul(P5, tt) | 0, y2 = y2 + Math.imul(te2, Ne) | 0, I = I + Math.imul(te2, tt) | 0;
      var $e = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, B2 = Math.imul(je, lt), y2 = Math.imul(je, ht), y2 = y2 + Math.imul(Ke, lt) | 0, I = Math.imul(Ke, ht), B2 = B2 + Math.imul(Fe, gt) | 0, y2 = y2 + Math.imul(Fe, yt) | 0, y2 = y2 + Math.imul(De, gt) | 0, I = I + Math.imul(De, yt) | 0, B2 = B2 + Math.imul(pe, rt) | 0, y2 = y2 + Math.imul(pe, bt) | 0, y2 = y2 + Math.imul(_e, rt) | 0, I = I + Math.imul(_e, bt) | 0, B2 = B2 + Math.imul(K5, D2) | 0, y2 = y2 + Math.imul(K5, k2) | 0, y2 = y2 + Math.imul($, D2) | 0, I = I + Math.imul($, k2) | 0, B2 = B2 + Math.imul(F2, C2) | 0, y2 = y2 + Math.imul(F2, Q2) | 0, y2 = y2 + Math.imul(q2, C2) | 0, I = I + Math.imul(q2, Q2) | 0, B2 = B2 + Math.imul(X2, ge2) | 0, y2 = y2 + Math.imul(X2, Ee) | 0, y2 = y2 + Math.imul(R5, ge2) | 0, I = I + Math.imul(R5, Ee) | 0, B2 = B2 + Math.imul(re, Ne) | 0, y2 = y2 + Math.imul(re, tt) | 0, y2 = y2 + Math.imul(ae, Ne) | 0, I = I + Math.imul(ae, tt) | 0;
      var We = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, B2 = Math.imul(je, gt), y2 = Math.imul(je, yt), y2 = y2 + Math.imul(Ke, gt) | 0, I = Math.imul(Ke, yt), B2 = B2 + Math.imul(Fe, rt) | 0, y2 = y2 + Math.imul(Fe, bt) | 0, y2 = y2 + Math.imul(De, rt) | 0, I = I + Math.imul(De, bt) | 0, B2 = B2 + Math.imul(pe, D2) | 0, y2 = y2 + Math.imul(pe, k2) | 0, y2 = y2 + Math.imul(_e, D2) | 0, I = I + Math.imul(_e, k2) | 0, B2 = B2 + Math.imul(K5, C2) | 0, y2 = y2 + Math.imul(K5, Q2) | 0, y2 = y2 + Math.imul($, C2) | 0, I = I + Math.imul($, Q2) | 0, B2 = B2 + Math.imul(F2, ge2) | 0, y2 = y2 + Math.imul(F2, Ee) | 0, y2 = y2 + Math.imul(q2, ge2) | 0, I = I + Math.imul(q2, Ee) | 0, B2 = B2 + Math.imul(X2, Ne) | 0, y2 = y2 + Math.imul(X2, tt) | 0, y2 = y2 + Math.imul(R5, Ne) | 0, I = I + Math.imul(R5, tt) | 0;
      var qe = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, B2 = Math.imul(je, rt), y2 = Math.imul(je, bt), y2 = y2 + Math.imul(Ke, rt) | 0, I = Math.imul(Ke, bt), B2 = B2 + Math.imul(Fe, D2) | 0, y2 = y2 + Math.imul(Fe, k2) | 0, y2 = y2 + Math.imul(De, D2) | 0, I = I + Math.imul(De, k2) | 0, B2 = B2 + Math.imul(pe, C2) | 0, y2 = y2 + Math.imul(pe, Q2) | 0, y2 = y2 + Math.imul(_e, C2) | 0, I = I + Math.imul(_e, Q2) | 0, B2 = B2 + Math.imul(K5, ge2) | 0, y2 = y2 + Math.imul(K5, Ee) | 0, y2 = y2 + Math.imul($, ge2) | 0, I = I + Math.imul($, Ee) | 0, B2 = B2 + Math.imul(F2, Ne) | 0, y2 = y2 + Math.imul(F2, tt) | 0, y2 = y2 + Math.imul(q2, Ne) | 0, I = I + Math.imul(q2, tt) | 0;
      var ve = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, B2 = Math.imul(je, D2), y2 = Math.imul(je, k2), y2 = y2 + Math.imul(Ke, D2) | 0, I = Math.imul(Ke, k2), B2 = B2 + Math.imul(Fe, C2) | 0, y2 = y2 + Math.imul(Fe, Q2) | 0, y2 = y2 + Math.imul(De, C2) | 0, I = I + Math.imul(De, Q2) | 0, B2 = B2 + Math.imul(pe, ge2) | 0, y2 = y2 + Math.imul(pe, Ee) | 0, y2 = y2 + Math.imul(_e, ge2) | 0, I = I + Math.imul(_e, Ee) | 0, B2 = B2 + Math.imul(K5, Ne) | 0, y2 = y2 + Math.imul(K5, tt) | 0, y2 = y2 + Math.imul($, Ne) | 0, I = I + Math.imul($, tt) | 0;
      var xe2 = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (xe2 >>> 26) | 0, xe2 &= 67108863, B2 = Math.imul(je, C2), y2 = Math.imul(je, Q2), y2 = y2 + Math.imul(Ke, C2) | 0, I = Math.imul(Ke, Q2), B2 = B2 + Math.imul(Fe, ge2) | 0, y2 = y2 + Math.imul(Fe, Ee) | 0, y2 = y2 + Math.imul(De, ge2) | 0, I = I + Math.imul(De, Ee) | 0, B2 = B2 + Math.imul(pe, Ne) | 0, y2 = y2 + Math.imul(pe, tt) | 0, y2 = y2 + Math.imul(_e, Ne) | 0, I = I + Math.imul(_e, tt) | 0;
      var ke = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, B2 = Math.imul(je, ge2), y2 = Math.imul(je, Ee), y2 = y2 + Math.imul(Ke, ge2) | 0, I = Math.imul(Ke, Ee), B2 = B2 + Math.imul(Fe, Ne) | 0, y2 = y2 + Math.imul(Fe, tt) | 0, y2 = y2 + Math.imul(De, Ne) | 0, I = I + Math.imul(De, tt) | 0;
      var Ie = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      M = (I + (y2 >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, B2 = Math.imul(je, Ne), y2 = Math.imul(je, tt), y2 = y2 + Math.imul(Ke, Ne) | 0, I = Math.imul(Ke, tt);
      var Te = (M + B2 | 0) + ((y2 & 8191) << 13) | 0;
      return M = (I + (y2 >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, d2[0] = He, d2[1] = it, d2[2] = nt, d2[3] = dt, d2[4] = ut, d2[5] = st, d2[6] = at, d2[7] = ot, d2[8] = Ge2, d2[9] = Ye2, d2[10] = ze, d2[11] = $e, d2[12] = We, d2[13] = qe, d2[14] = ve, d2[15] = xe2, d2[16] = ke, d2[17] = Ie, d2[18] = Te, M !== 0 && (d2[19] = M, b2.length++), b2;
    };
    Math.imul || (Z = W5);
    function le(h2, a, u3) {
      u3.negative = a.negative ^ h2.negative, u3.length = h2.length + a.length;
      for (var b2 = 0, A2 = 0, v2 = 0; v2 < u3.length - 1; v2++) {
        var d2 = A2;
        A2 = 0;
        for (var M = b2 & 67108863, B2 = Math.min(v2, a.length - 1), y2 = Math.max(0, v2 - h2.length + 1); y2 <= B2; y2++) {
          var I = v2 - y2, de = h2.words[I] | 0, Me2 = a.words[y2] | 0, Se = de * Me2, Oe = Se & 67108863;
          d2 = d2 + (Se / 67108864 | 0) | 0, Oe = Oe + M | 0, M = Oe & 67108863, d2 = d2 + (Oe >>> 26) | 0, A2 += d2 >>> 26, d2 &= 67108863;
        }
        u3.words[v2] = M, b2 = d2, d2 = A2;
      }
      return b2 !== 0 ? u3.words[v2] = b2 : u3.length--, u3._strip();
    }
    function be2(h2, a, u3) {
      return le(h2, a, u3);
    }
    n.prototype.mulTo = function(a, u3) {
      var b2, A2 = this.length + a.length;
      return this.length === 10 && a.length === 10 ? b2 = Z(this, a, u3) : A2 < 63 ? b2 = W5(this, a, u3) : A2 < 1024 ? b2 = le(this, a, u3) : b2 = be2(this, a, u3), b2;
    };
    n.prototype.mul = function(a) {
      var u3 = new n(null);
      return u3.words = new Array(this.length + a.length), this.mulTo(a, u3);
    }, n.prototype.mulf = function(a) {
      var u3 = new n(null);
      return u3.words = new Array(this.length + a.length), be2(this, a, u3);
    }, n.prototype.imul = function(a) {
      return this.clone().mulTo(a, this);
    }, n.prototype.imuln = function(a) {
      var u3 = a < 0;
      u3 && (a = -a), r3(typeof a == "number"), r3(a < 67108864);
      for (var b2 = 0, A2 = 0; A2 < this.length; A2++) {
        var v2 = (this.words[A2] | 0) * a, d2 = (v2 & 67108863) + (b2 & 67108863);
        b2 >>= 26, b2 += v2 / 67108864 | 0, b2 += d2 >>> 26, this.words[A2] = d2 & 67108863;
      }
      return b2 !== 0 && (this.words[A2] = b2, this.length++), u3 ? this.ineg() : this;
    }, n.prototype.muln = function(a) {
      return this.clone().imuln(a);
    }, n.prototype.sqr = function() {
      return this.mul(this);
    }, n.prototype.isqr = function() {
      return this.imul(this.clone());
    }, n.prototype.pow = function(a) {
      var u3 = ee2(a);
      if (u3.length === 0)
        return new n(1);
      for (var b2 = this, A2 = 0; A2 < u3.length && u3[A2] === 0; A2++, b2 = b2.sqr())
        ;
      if (++A2 < u3.length)
        for (var v2 = b2.sqr(); A2 < u3.length; A2++, v2 = v2.sqr())
          u3[A2] !== 0 && (b2 = b2.mul(v2));
      return b2;
    }, n.prototype.iushln = function(a) {
      r3(typeof a == "number" && a >= 0);
      var u3 = a % 26, b2 = (a - u3) / 26, A2 = 67108863 >>> 26 - u3 << 26 - u3, v2;
      if (u3 !== 0) {
        var d2 = 0;
        for (v2 = 0; v2 < this.length; v2++) {
          var M = this.words[v2] & A2, B2 = (this.words[v2] | 0) - M << u3;
          this.words[v2] = B2 | d2, d2 = M >>> 26 - u3;
        }
        d2 && (this.words[v2] = d2, this.length++);
      }
      if (b2 !== 0) {
        for (v2 = this.length - 1; v2 >= 0; v2--)
          this.words[v2 + b2] = this.words[v2];
        for (v2 = 0; v2 < b2; v2++)
          this.words[v2] = 0;
        this.length += b2;
      }
      return this._strip();
    }, n.prototype.ishln = function(a) {
      return r3(this.negative === 0), this.iushln(a);
    }, n.prototype.iushrn = function(a, u3, b2) {
      r3(typeof a == "number" && a >= 0);
      var A2;
      u3 ? A2 = (u3 - u3 % 26) / 26 : A2 = 0;
      var v2 = a % 26, d2 = Math.min((a - v2) / 26, this.length), M = 67108863 ^ 67108863 >>> v2 << v2, B2 = b2;
      if (A2 -= d2, A2 = Math.max(0, A2), B2) {
        for (var y2 = 0; y2 < d2; y2++)
          B2.words[y2] = this.words[y2];
        B2.length = d2;
      }
      if (d2 !== 0)
        if (this.length > d2)
          for (this.length -= d2, y2 = 0; y2 < this.length; y2++)
            this.words[y2] = this.words[y2 + d2];
        else
          this.words[0] = 0, this.length = 1;
      var I = 0;
      for (y2 = this.length - 1; y2 >= 0 && (I !== 0 || y2 >= A2); y2--) {
        var de = this.words[y2] | 0;
        this.words[y2] = I << 26 - v2 | de >>> v2, I = de & M;
      }
      return B2 && I !== 0 && (B2.words[B2.length++] = I), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, n.prototype.ishrn = function(a, u3, b2) {
      return r3(this.negative === 0), this.iushrn(a, u3, b2);
    }, n.prototype.shln = function(a) {
      return this.clone().ishln(a);
    }, n.prototype.ushln = function(a) {
      return this.clone().iushln(a);
    }, n.prototype.shrn = function(a) {
      return this.clone().ishrn(a);
    }, n.prototype.ushrn = function(a) {
      return this.clone().iushrn(a);
    }, n.prototype.testn = function(a) {
      r3(typeof a == "number" && a >= 0);
      var u3 = a % 26, b2 = (a - u3) / 26, A2 = 1 << u3;
      if (this.length <= b2)
        return false;
      var v2 = this.words[b2];
      return !!(v2 & A2);
    }, n.prototype.imaskn = function(a) {
      r3(typeof a == "number" && a >= 0);
      var u3 = a % 26, b2 = (a - u3) / 26;
      if (r3(this.negative === 0, "imaskn works only with positive numbers"), this.length <= b2)
        return this;
      if (u3 !== 0 && b2++, this.length = Math.min(b2, this.length), u3 !== 0) {
        var A2 = 67108863 ^ 67108863 >>> u3 << u3;
        this.words[this.length - 1] &= A2;
      }
      return this._strip();
    }, n.prototype.maskn = function(a) {
      return this.clone().imaskn(a);
    }, n.prototype.iaddn = function(a) {
      return r3(typeof a == "number"), r3(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
    }, n.prototype._iaddn = function(a) {
      this.words[0] += a;
      for (var u3 = 0; u3 < this.length && this.words[u3] >= 67108864; u3++)
        this.words[u3] -= 67108864, u3 === this.length - 1 ? this.words[u3 + 1] = 1 : this.words[u3 + 1]++;
      return this.length = Math.max(this.length, u3 + 1), this;
    }, n.prototype.isubn = function(a) {
      if (r3(typeof a == "number"), r3(a < 67108864), a < 0)
        return this.iaddn(-a);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(a), this.negative = 1, this;
      if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var u3 = 0; u3 < this.length && this.words[u3] < 0; u3++)
          this.words[u3] += 67108864, this.words[u3 + 1] -= 1;
      return this._strip();
    }, n.prototype.addn = function(a) {
      return this.clone().iaddn(a);
    }, n.prototype.subn = function(a) {
      return this.clone().isubn(a);
    }, n.prototype.iabs = function() {
      return this.negative = 0, this;
    }, n.prototype.abs = function() {
      return this.clone().iabs();
    }, n.prototype._ishlnsubmul = function(a, u3, b2) {
      var A2 = a.length + b2, v2;
      this._expand(A2);
      var d2, M = 0;
      for (v2 = 0; v2 < a.length; v2++) {
        d2 = (this.words[v2 + b2] | 0) + M;
        var B2 = (a.words[v2] | 0) * u3;
        d2 -= B2 & 67108863, M = (d2 >> 26) - (B2 / 67108864 | 0), this.words[v2 + b2] = d2 & 67108863;
      }
      for (; v2 < this.length - b2; v2++)
        d2 = (this.words[v2 + b2] | 0) + M, M = d2 >> 26, this.words[v2 + b2] = d2 & 67108863;
      if (M === 0)
        return this._strip();
      for (r3(M === -1), M = 0, v2 = 0; v2 < this.length; v2++)
        d2 = -(this.words[v2] | 0) + M, M = d2 >> 26, this.words[v2] = d2 & 67108863;
      return this.negative = 1, this._strip();
    }, n.prototype._wordDiv = function(a, u3) {
      var b2 = this.length - a.length, A2 = this.clone(), v2 = a, d2 = v2.words[v2.length - 1] | 0, M = this._countBits(d2);
      b2 = 26 - M, b2 !== 0 && (v2 = v2.ushln(b2), A2.iushln(b2), d2 = v2.words[v2.length - 1] | 0);
      var B2 = A2.length - v2.length, y2;
      if (u3 !== "mod") {
        y2 = new n(null), y2.length = B2 + 1, y2.words = new Array(y2.length);
        for (var I = 0; I < y2.length; I++)
          y2.words[I] = 0;
      }
      var de = A2.clone()._ishlnsubmul(v2, 1, B2);
      de.negative === 0 && (A2 = de, y2 && (y2.words[B2] = 1));
      for (var Me2 = B2 - 1; Me2 >= 0; Me2--) {
        var Se = (A2.words[v2.length + Me2] | 0) * 67108864 + (A2.words[v2.length + Me2 - 1] | 0);
        for (Se = Math.min(Se / d2 | 0, 67108863), A2._ishlnsubmul(v2, Se, Me2); A2.negative !== 0; )
          Se--, A2.negative = 0, A2._ishlnsubmul(v2, 1, Me2), A2.isZero() || (A2.negative ^= 1);
        y2 && (y2.words[Me2] = Se);
      }
      return y2 && y2._strip(), A2._strip(), u3 !== "div" && b2 !== 0 && A2.iushrn(b2), { div: y2 || null, mod: A2 };
    }, n.prototype.divmod = function(a, u3, b2) {
      if (r3(!a.isZero()), this.isZero())
        return { div: new n(0), mod: new n(0) };
      var A2, v2, d2;
      return this.negative !== 0 && a.negative === 0 ? (d2 = this.neg().divmod(a, u3), u3 !== "mod" && (A2 = d2.div.neg()), u3 !== "div" && (v2 = d2.mod.neg(), b2 && v2.negative !== 0 && v2.iadd(a)), { div: A2, mod: v2 }) : this.negative === 0 && a.negative !== 0 ? (d2 = this.divmod(a.neg(), u3), u3 !== "mod" && (A2 = d2.div.neg()), { div: A2, mod: d2.mod }) : (this.negative & a.negative) !== 0 ? (d2 = this.neg().divmod(a.neg(), u3), u3 !== "div" && (v2 = d2.mod.neg(), b2 && v2.negative !== 0 && v2.isub(a)), { div: d2.div, mod: v2 }) : a.length > this.length || this.cmp(a) < 0 ? { div: new n(0), mod: this } : a.length === 1 ? u3 === "div" ? { div: this.divn(a.words[0]), mod: null } : u3 === "mod" ? { div: null, mod: new n(this.modrn(a.words[0])) } : { div: this.divn(a.words[0]), mod: new n(this.modrn(a.words[0])) } : this._wordDiv(a, u3);
    }, n.prototype.div = function(a) {
      return this.divmod(a, "div", false).div;
    }, n.prototype.mod = function(a) {
      return this.divmod(a, "mod", false).mod;
    }, n.prototype.umod = function(a) {
      return this.divmod(a, "mod", true).mod;
    }, n.prototype.divRound = function(a) {
      var u3 = this.divmod(a);
      if (u3.mod.isZero())
        return u3.div;
      var b2 = u3.div.negative !== 0 ? u3.mod.isub(a) : u3.mod, A2 = a.ushrn(1), v2 = a.andln(1), d2 = b2.cmp(A2);
      return d2 < 0 || v2 === 1 && d2 === 0 ? u3.div : u3.div.negative !== 0 ? u3.div.isubn(1) : u3.div.iaddn(1);
    }, n.prototype.modrn = function(a) {
      var u3 = a < 0;
      u3 && (a = -a), r3(a <= 67108863);
      for (var b2 = (1 << 26) % a, A2 = 0, v2 = this.length - 1; v2 >= 0; v2--)
        A2 = (b2 * A2 + (this.words[v2] | 0)) % a;
      return u3 ? -A2 : A2;
    }, n.prototype.modn = function(a) {
      return this.modrn(a);
    }, n.prototype.idivn = function(a) {
      var u3 = a < 0;
      u3 && (a = -a), r3(a <= 67108863);
      for (var b2 = 0, A2 = this.length - 1; A2 >= 0; A2--) {
        var v2 = (this.words[A2] | 0) + b2 * 67108864;
        this.words[A2] = v2 / a | 0, b2 = v2 % a;
      }
      return this._strip(), u3 ? this.ineg() : this;
    }, n.prototype.divn = function(a) {
      return this.clone().idivn(a);
    }, n.prototype.egcd = function(a) {
      r3(a.negative === 0), r3(!a.isZero());
      var u3 = this, b2 = a.clone();
      u3.negative !== 0 ? u3 = u3.umod(a) : u3 = u3.clone();
      for (var A2 = new n(1), v2 = new n(0), d2 = new n(0), M = new n(1), B2 = 0; u3.isEven() && b2.isEven(); )
        u3.iushrn(1), b2.iushrn(1), ++B2;
      for (var y2 = b2.clone(), I = u3.clone(); !u3.isZero(); ) {
        for (var de = 0, Me2 = 1; (u3.words[0] & Me2) === 0 && de < 26; ++de, Me2 <<= 1)
          ;
        if (de > 0)
          for (u3.iushrn(de); de-- > 0; )
            (A2.isOdd() || v2.isOdd()) && (A2.iadd(y2), v2.isub(I)), A2.iushrn(1), v2.iushrn(1);
        for (var Se = 0, Oe = 1; (b2.words[0] & Oe) === 0 && Se < 26; ++Se, Oe <<= 1)
          ;
        if (Se > 0)
          for (b2.iushrn(Se); Se-- > 0; )
            (d2.isOdd() || M.isOdd()) && (d2.iadd(y2), M.isub(I)), d2.iushrn(1), M.iushrn(1);
        u3.cmp(b2) >= 0 ? (u3.isub(b2), A2.isub(d2), v2.isub(M)) : (b2.isub(u3), d2.isub(A2), M.isub(v2));
      }
      return { a: d2, b: M, gcd: b2.iushln(B2) };
    }, n.prototype._invmp = function(a) {
      r3(a.negative === 0), r3(!a.isZero());
      var u3 = this, b2 = a.clone();
      u3.negative !== 0 ? u3 = u3.umod(a) : u3 = u3.clone();
      for (var A2 = new n(1), v2 = new n(0), d2 = b2.clone(); u3.cmpn(1) > 0 && b2.cmpn(1) > 0; ) {
        for (var M = 0, B2 = 1; (u3.words[0] & B2) === 0 && M < 26; ++M, B2 <<= 1)
          ;
        if (M > 0)
          for (u3.iushrn(M); M-- > 0; )
            A2.isOdd() && A2.iadd(d2), A2.iushrn(1);
        for (var y2 = 0, I = 1; (b2.words[0] & I) === 0 && y2 < 26; ++y2, I <<= 1)
          ;
        if (y2 > 0)
          for (b2.iushrn(y2); y2-- > 0; )
            v2.isOdd() && v2.iadd(d2), v2.iushrn(1);
        u3.cmp(b2) >= 0 ? (u3.isub(b2), A2.isub(v2)) : (b2.isub(u3), v2.isub(A2));
      }
      var de;
      return u3.cmpn(1) === 0 ? de = A2 : de = v2, de.cmpn(0) < 0 && de.iadd(a), de;
    }, n.prototype.gcd = function(a) {
      if (this.isZero())
        return a.abs();
      if (a.isZero())
        return this.abs();
      var u3 = this.clone(), b2 = a.clone();
      u3.negative = 0, b2.negative = 0;
      for (var A2 = 0; u3.isEven() && b2.isEven(); A2++)
        u3.iushrn(1), b2.iushrn(1);
      do {
        for (; u3.isEven(); )
          u3.iushrn(1);
        for (; b2.isEven(); )
          b2.iushrn(1);
        var v2 = u3.cmp(b2);
        if (v2 < 0) {
          var d2 = u3;
          u3 = b2, b2 = d2;
        } else if (v2 === 0 || b2.cmpn(1) === 0)
          break;
        u3.isub(b2);
      } while (true);
      return b2.iushln(A2);
    }, n.prototype.invm = function(a) {
      return this.egcd(a).a.umod(a);
    }, n.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, n.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, n.prototype.andln = function(a) {
      return this.words[0] & a;
    }, n.prototype.bincn = function(a) {
      r3(typeof a == "number");
      var u3 = a % 26, b2 = (a - u3) / 26, A2 = 1 << u3;
      if (this.length <= b2)
        return this._expand(b2 + 1), this.words[b2] |= A2, this;
      for (var v2 = A2, d2 = b2; v2 !== 0 && d2 < this.length; d2++) {
        var M = this.words[d2] | 0;
        M += v2, v2 = M >>> 26, M &= 67108863, this.words[d2] = M;
      }
      return v2 !== 0 && (this.words[d2] = v2, this.length++), this;
    }, n.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, n.prototype.cmpn = function(a) {
      var u3 = a < 0;
      if (this.negative !== 0 && !u3)
        return -1;
      if (this.negative === 0 && u3)
        return 1;
      this._strip();
      var b2;
      if (this.length > 1)
        b2 = 1;
      else {
        u3 && (a = -a), r3(a <= 67108863, "Number is too big");
        var A2 = this.words[0] | 0;
        b2 = A2 === a ? 0 : A2 < a ? -1 : 1;
      }
      return this.negative !== 0 ? -b2 | 0 : b2;
    }, n.prototype.cmp = function(a) {
      if (this.negative !== 0 && a.negative === 0)
        return -1;
      if (this.negative === 0 && a.negative !== 0)
        return 1;
      var u3 = this.ucmp(a);
      return this.negative !== 0 ? -u3 | 0 : u3;
    }, n.prototype.ucmp = function(a) {
      if (this.length > a.length)
        return 1;
      if (this.length < a.length)
        return -1;
      for (var u3 = 0, b2 = this.length - 1; b2 >= 0; b2--) {
        var A2 = this.words[b2] | 0, v2 = a.words[b2] | 0;
        if (A2 !== v2) {
          A2 < v2 ? u3 = -1 : A2 > v2 && (u3 = 1);
          break;
        }
      }
      return u3;
    }, n.prototype.gtn = function(a) {
      return this.cmpn(a) === 1;
    }, n.prototype.gt = function(a) {
      return this.cmp(a) === 1;
    }, n.prototype.gten = function(a) {
      return this.cmpn(a) >= 0;
    }, n.prototype.gte = function(a) {
      return this.cmp(a) >= 0;
    }, n.prototype.ltn = function(a) {
      return this.cmpn(a) === -1;
    }, n.prototype.lt = function(a) {
      return this.cmp(a) === -1;
    }, n.prototype.lten = function(a) {
      return this.cmpn(a) <= 0;
    }, n.prototype.lte = function(a) {
      return this.cmp(a) <= 0;
    }, n.prototype.eqn = function(a) {
      return this.cmpn(a) === 0;
    }, n.prototype.eq = function(a) {
      return this.cmp(a) === 0;
    }, n.red = function(a) {
      return new c(a);
    }, n.prototype.toRed = function(a) {
      return r3(!this.red, "Already a number in reduction context"), r3(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
    }, n.prototype.fromRed = function() {
      return r3(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, n.prototype._forceRed = function(a) {
      return this.red = a, this;
    }, n.prototype.forceRed = function(a) {
      return r3(!this.red, "Already a number in reduction context"), this._forceRed(a);
    }, n.prototype.redAdd = function(a) {
      return r3(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
    }, n.prototype.redIAdd = function(a) {
      return r3(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
    }, n.prototype.redSub = function(a) {
      return r3(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
    }, n.prototype.redISub = function(a) {
      return r3(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
    }, n.prototype.redShl = function(a) {
      return r3(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
    }, n.prototype.redMul = function(a) {
      return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
    }, n.prototype.redIMul = function(a) {
      return r3(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
    }, n.prototype.redSqr = function() {
      return r3(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, n.prototype.redISqr = function() {
      return r3(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, n.prototype.redSqrt = function() {
      return r3(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, n.prototype.redInvm = function() {
      return r3(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, n.prototype.redNeg = function() {
      return r3(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, n.prototype.redPow = function(a) {
      return r3(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
    };
    var me = { k256: null, p224: null, p192: null, p25519: null };
    function H5(h2, a) {
      this.name = h2, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    H5.prototype._tmp = function() {
      var a = new n(null);
      return a.words = new Array(Math.ceil(this.n / 13)), a;
    }, H5.prototype.ireduce = function(a) {
      var u3 = a, b2;
      do
        this.split(u3, this.tmp), u3 = this.imulK(u3), u3 = u3.iadd(this.tmp), b2 = u3.bitLength();
      while (b2 > this.n);
      var A2 = b2 < this.n ? -1 : u3.ucmp(this.p);
      return A2 === 0 ? (u3.words[0] = 0, u3.length = 1) : A2 > 0 ? u3.isub(this.p) : u3.strip !== void 0 ? u3.strip() : u3._strip(), u3;
    }, H5.prototype.split = function(a, u3) {
      a.iushrn(this.n, 0, u3);
    }, H5.prototype.imulK = function(a) {
      return a.imul(this.k);
    };
    function ue() {
      H5.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    i(ue, H5), ue.prototype.split = function(a, u3) {
      for (var b2 = 4194303, A2 = Math.min(a.length, 9), v2 = 0; v2 < A2; v2++)
        u3.words[v2] = a.words[v2];
      if (u3.length = A2, a.length <= 9) {
        a.words[0] = 0, a.length = 1;
        return;
      }
      var d2 = a.words[9];
      for (u3.words[u3.length++] = d2 & b2, v2 = 10; v2 < a.length; v2++) {
        var M = a.words[v2] | 0;
        a.words[v2 - 10] = (M & b2) << 4 | d2 >>> 22, d2 = M;
      }
      d2 >>>= 22, a.words[v2 - 10] = d2, d2 === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
    }, ue.prototype.imulK = function(a) {
      a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
      for (var u3 = 0, b2 = 0; b2 < a.length; b2++) {
        var A2 = a.words[b2] | 0;
        u3 += A2 * 977, a.words[b2] = u3 & 67108863, u3 = A2 * 64 + (u3 / 67108864 | 0);
      }
      return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
    };
    function se2() {
      H5.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    i(se2, H5);
    function ne2() {
      H5.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    i(ne2, H5);
    function E2() {
      H5.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    i(E2, H5), E2.prototype.imulK = function(a) {
      for (var u3 = 0, b2 = 0; b2 < a.length; b2++) {
        var A2 = (a.words[b2] | 0) * 19 + u3, v2 = A2 & 67108863;
        A2 >>>= 26, a.words[b2] = v2, u3 = A2;
      }
      return u3 !== 0 && (a.words[a.length++] = u3), a;
    }, n._prime = function(a) {
      if (me[a])
        return me[a];
      var u3;
      if (a === "k256")
        u3 = new ue();
      else if (a === "p224")
        u3 = new se2();
      else if (a === "p192")
        u3 = new ne2();
      else if (a === "p25519")
        u3 = new E2();
      else
        throw new Error("Unknown prime " + a);
      return me[a] = u3, u3;
    };
    function c(h2) {
      if (typeof h2 == "string") {
        var a = n._prime(h2);
        this.m = a.p, this.prime = a;
      } else
        r3(h2.gtn(1), "modulus must be greater than 1"), this.m = h2, this.prime = null;
    }
    c.prototype._verify1 = function(a) {
      r3(a.negative === 0, "red works only with positives"), r3(a.red, "red works only with red numbers");
    }, c.prototype._verify2 = function(a, u3) {
      r3((a.negative | u3.negative) === 0, "red works only with positives"), r3(a.red && a.red === u3.red, "red works only with red numbers");
    }, c.prototype.imod = function(a) {
      return this.prime ? this.prime.ireduce(a)._forceRed(this) : (g5(a, a.umod(this.m)._forceRed(this)), a);
    }, c.prototype.neg = function(a) {
      return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
    }, c.prototype.add = function(a, u3) {
      this._verify2(a, u3);
      var b2 = a.add(u3);
      return b2.cmp(this.m) >= 0 && b2.isub(this.m), b2._forceRed(this);
    }, c.prototype.iadd = function(a, u3) {
      this._verify2(a, u3);
      var b2 = a.iadd(u3);
      return b2.cmp(this.m) >= 0 && b2.isub(this.m), b2;
    }, c.prototype.sub = function(a, u3) {
      this._verify2(a, u3);
      var b2 = a.sub(u3);
      return b2.cmpn(0) < 0 && b2.iadd(this.m), b2._forceRed(this);
    }, c.prototype.isub = function(a, u3) {
      this._verify2(a, u3);
      var b2 = a.isub(u3);
      return b2.cmpn(0) < 0 && b2.iadd(this.m), b2;
    }, c.prototype.shl = function(a, u3) {
      return this._verify1(a), this.imod(a.ushln(u3));
    }, c.prototype.imul = function(a, u3) {
      return this._verify2(a, u3), this.imod(a.imul(u3));
    }, c.prototype.mul = function(a, u3) {
      return this._verify2(a, u3), this.imod(a.mul(u3));
    }, c.prototype.isqr = function(a) {
      return this.imul(a, a.clone());
    }, c.prototype.sqr = function(a) {
      return this.mul(a, a);
    }, c.prototype.sqrt = function(a) {
      if (a.isZero())
        return a.clone();
      var u3 = this.m.andln(3);
      if (r3(u3 % 2 === 1), u3 === 3) {
        var b2 = this.m.add(new n(1)).iushrn(2);
        return this.pow(a, b2);
      }
      for (var A2 = this.m.subn(1), v2 = 0; !A2.isZero() && A2.andln(1) === 0; )
        v2++, A2.iushrn(1);
      r3(!A2.isZero());
      var d2 = new n(1).toRed(this), M = d2.redNeg(), B2 = this.m.subn(1).iushrn(1), y2 = this.m.bitLength();
      for (y2 = new n(2 * y2 * y2).toRed(this); this.pow(y2, B2).cmp(M) !== 0; )
        y2.redIAdd(M);
      for (var I = this.pow(y2, A2), de = this.pow(a, A2.addn(1).iushrn(1)), Me2 = this.pow(a, A2), Se = v2; Me2.cmp(d2) !== 0; ) {
        for (var Oe = Me2, ye = 0; Oe.cmp(d2) !== 0; ye++)
          Oe = Oe.redSqr();
        r3(ye < Se);
        var T = this.pow(I, new n(1).iushln(Se - ye - 1));
        de = de.redMul(T), I = T.redSqr(), Me2 = Me2.redMul(I), Se = ye;
      }
      return de;
    }, c.prototype.invm = function(a) {
      var u3 = a._invmp(this.m);
      return u3.negative !== 0 ? (u3.negative = 0, this.imod(u3).redNeg()) : this.imod(u3);
    }, c.prototype.pow = function(a, u3) {
      if (u3.isZero())
        return new n(1).toRed(this);
      if (u3.cmpn(1) === 0)
        return a.clone();
      var b2 = 4, A2 = new Array(1 << b2);
      A2[0] = new n(1).toRed(this), A2[1] = a;
      for (var v2 = 2; v2 < A2.length; v2++)
        A2[v2] = this.mul(A2[v2 - 1], a);
      var d2 = A2[0], M = 0, B2 = 0, y2 = u3.bitLength() % 26;
      for (y2 === 0 && (y2 = 26), v2 = u3.length - 1; v2 >= 0; v2--) {
        for (var I = u3.words[v2], de = y2 - 1; de >= 0; de--) {
          var Me2 = I >> de & 1;
          if (d2 !== A2[0] && (d2 = this.sqr(d2)), Me2 === 0 && M === 0) {
            B2 = 0;
            continue;
          }
          M <<= 1, M |= Me2, B2++, !(B2 !== b2 && (v2 !== 0 || de !== 0)) && (d2 = this.mul(d2, A2[M]), B2 = 0, M = 0);
        }
        y2 = 26;
      }
      return d2;
    }, c.prototype.convertTo = function(a) {
      var u3 = a.umod(this.m);
      return u3 === a ? u3.clone() : u3;
    }, c.prototype.convertFrom = function(a) {
      var u3 = a.clone();
      return u3.red = null, u3;
    }, n.mont = function(a) {
      return new m2(a);
    };
    function m2(h2) {
      c.call(this, h2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(m2, c), m2.prototype.convertTo = function(a) {
      return this.imod(a.ushln(this.shift));
    }, m2.prototype.convertFrom = function(a) {
      var u3 = this.imod(a.mul(this.rinv));
      return u3.red = null, u3;
    }, m2.prototype.imul = function(a, u3) {
      if (a.isZero() || u3.isZero())
        return a.words[0] = 0, a.length = 1, a;
      var b2 = a.imul(u3), A2 = b2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v2 = b2.isub(A2).iushrn(this.shift), d2 = v2;
      return v2.cmp(this.m) >= 0 ? d2 = v2.isub(this.m) : v2.cmpn(0) < 0 && (d2 = v2.iadd(this.m)), d2._forceRed(this);
    }, m2.prototype.mul = function(a, u3) {
      if (a.isZero() || u3.isZero())
        return new n(0)._forceRed(this);
      var b2 = a.mul(u3), A2 = b2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v2 = b2.isub(A2).iushrn(this.shift), d2 = v2;
      return v2.cmp(this.m) >= 0 ? d2 = v2.isub(this.m) : v2.cmpn(0) < 0 && (d2 = v2.iadd(this.m)), d2._forceRed(this);
    }, m2.prototype.invm = function(a) {
      var u3 = this.imod(a._invmp(this.m).mul(this.r2));
      return u3._forceRed(this);
    };
  })(typeof e1 > "u" || e1, Jv);
});
var Ml = k((JD, ex) => {
  U();
  var Uo = El(), eM = us();
  function tM(t) {
    var e = Xv(t), r3 = e.toRed(Uo.mont(t.modulus)).redPow(new Uo(t.publicExponent)).fromRed();
    return { blinder: r3, unblinder: e.invm(t.modulus) };
  }
  function Xv(t) {
    var e = t.modulus.byteLength(), r3;
    do
      r3 = new Uo(eM(e));
    while (r3.cmp(t.modulus) >= 0 || !r3.umod(t.prime1) || !r3.umod(t.prime2));
    return r3;
  }
  function Qv(t, e) {
    var r3 = tM(e), i = e.modulus.byteLength(), n = new Uo(t).mul(r3.blinder).umod(e.modulus), s = n.toRed(Uo.mont(e.prime1)), o = n.toRed(Uo.mont(e.prime2)), f2 = e.coefficient, l = e.prime1, g5 = e.prime2, _ = s.redPow(e.exponent1).fromRed(), N2 = o.redPow(e.exponent2).fromRed(), U2 = _.isub(N2).imul(f2).umod(l).imul(g5);
    return N2.iadd(U2).imul(r3.unblinder).umod(e.modulus).toArrayLike(b.Buffer, "be", i);
  }
  Qv.getr = Xv;
  ex.exports = Qv;
});
var tx = k((XD, rM) => {
  rM.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
});
var t1 = k((nx) => {
  U();
  var Sl = nx;
  function iM(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r3 = [];
    if (typeof t != "string") {
      for (var i = 0; i < t.length; i++)
        r3[i] = t[i] | 0;
      return r3;
    }
    if (e === "hex") {
      t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
      for (var i = 0; i < t.length; i += 2)
        r3.push(parseInt(t[i] + t[i + 1], 16));
    } else
      for (var i = 0; i < t.length; i++) {
        var n = t.charCodeAt(i), s = n >> 8, o = n & 255;
        s ? r3.push(s, o) : r3.push(o);
      }
    return r3;
  }
  Sl.toArray = iM;
  function rx(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Sl.zero2 = rx;
  function ix(t) {
    for (var e = "", r3 = 0; r3 < t.length; r3++)
      e += rx(t[r3].toString(16));
    return e;
  }
  Sl.toHex = ix;
  Sl.encode = function(e, r3) {
    return r3 === "hex" ? ix(e) : e;
  };
});
var Hr = k((sx) => {
  U();
  var vi = sx, nM = dr(), sM = zr(), Il = t1();
  vi.assert = sM;
  vi.toArray = Il.toArray;
  vi.zero2 = Il.zero2;
  vi.toHex = Il.toHex;
  vi.encode = Il.encode;
  function oM(t, e, r3) {
    var i = new Array(Math.max(t.bitLength(), r3) + 1);
    i.fill(0);
    for (var n = 1 << e + 1, s = t.clone(), o = 0; o < i.length; o++) {
      var f2, l = s.andln(n - 1);
      s.isOdd() ? (l > (n >> 1) - 1 ? f2 = (n >> 1) - l : f2 = l, s.isubn(f2)) : f2 = 0, i[o] = f2, s.iushrn(1);
    }
    return i;
  }
  vi.getNAF = oM;
  function aM(t, e) {
    var r3 = [[], []];
    t = t.clone(), e = e.clone();
    for (var i = 0, n = 0, s; t.cmpn(-i) > 0 || e.cmpn(-n) > 0; ) {
      var o = t.andln(3) + i & 3, f2 = e.andln(3) + n & 3;
      o === 3 && (o = -1), f2 === 3 && (f2 = -1);
      var l;
      (o & 1) === 0 ? l = 0 : (s = t.andln(7) + i & 7, (s === 3 || s === 5) && f2 === 2 ? l = -o : l = o), r3[0].push(l);
      var g5;
      (f2 & 1) === 0 ? g5 = 0 : (s = e.andln(7) + n & 7, (s === 3 || s === 5) && o === 2 ? g5 = -f2 : g5 = f2), r3[1].push(g5), 2 * i === l + 1 && (i = 1 - i), 2 * n === g5 + 1 && (n = 1 - n), t.iushrn(1), e.iushrn(1);
    }
    return r3;
  }
  vi.getJSF = aM;
  function fM(t, e, r3) {
    var i = "_" + e;
    t.prototype[e] = function() {
      return this[i] !== void 0 ? this[i] : this[i] = r3.call(this);
    };
  }
  vi.cachedProperty = fM;
  function cM(t) {
    return typeof t == "string" ? vi.toArray(t, "hex") : t;
  }
  vi.parseBytes = cM;
  function uM(t) {
    return new nM(t, "hex", "le");
  }
  vi.intFromLE = uM;
});
var Qf = k((tN, ox) => {
  U();
  var ks = dr(), Xf = Hr(), Tl = Xf.getNAF, dM = Xf.getJSF, Fl = Xf.assert;
  function Pn(t, e) {
    this.type = t, this.p = new ks(e.p, 16), this.red = e.prime ? ks.red(e.prime) : ks.mont(this.p), this.zero = new ks(0).toRed(this.red), this.one = new ks(1).toRed(this.red), this.two = new ks(2).toRed(this.red), this.n = e.n && new ks(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r3 = this.n && this.p.div(this.n);
    !r3 || r3.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  ox.exports = Pn;
  Pn.prototype.point = function() {
    throw new Error("Not implemented");
  };
  Pn.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  Pn.prototype._fixedNafMul = function(e, r3) {
    Fl(e.precomputed);
    var i = e._getDoubles(), n = Tl(r3, 1, this._bitLength), s = (1 << i.step + 1) - (i.step % 2 === 0 ? 2 : 1);
    s /= 3;
    var o = [], f2, l;
    for (f2 = 0; f2 < n.length; f2 += i.step) {
      l = 0;
      for (var g5 = f2 + i.step - 1; g5 >= f2; g5--)
        l = (l << 1) + n[g5];
      o.push(l);
    }
    for (var _ = this.jpoint(null, null, null), N2 = this.jpoint(null, null, null), U2 = s; U2 > 0; U2--) {
      for (f2 = 0; f2 < o.length; f2++)
        l = o[f2], l === U2 ? N2 = N2.mixedAdd(i.points[f2]) : l === -U2 && (N2 = N2.mixedAdd(i.points[f2].neg()));
      _ = _.add(N2);
    }
    return _.toP();
  };
  Pn.prototype._wnafMul = function(e, r3) {
    var i = 4, n = e._getNAFPoints(i);
    i = n.wnd;
    for (var s = n.points, o = Tl(r3, i, this._bitLength), f2 = this.jpoint(null, null, null), l = o.length - 1; l >= 0; l--) {
      for (var g5 = 0; l >= 0 && o[l] === 0; l--)
        g5++;
      if (l >= 0 && g5++, f2 = f2.dblp(g5), l < 0)
        break;
      var _ = o[l];
      Fl(_ !== 0), e.type === "affine" ? _ > 0 ? f2 = f2.mixedAdd(s[_ - 1 >> 1]) : f2 = f2.mixedAdd(s[-_ - 1 >> 1].neg()) : _ > 0 ? f2 = f2.add(s[_ - 1 >> 1]) : f2 = f2.add(s[-_ - 1 >> 1].neg());
    }
    return e.type === "affine" ? f2.toP() : f2;
  };
  Pn.prototype._wnafMulAdd = function(e, r3, i, n, s) {
    var o = this._wnafT1, f2 = this._wnafT2, l = this._wnafT3, g5 = 0, _, N2, U2;
    for (_ = 0; _ < n; _++) {
      U2 = r3[_];
      var V = U2._getNAFPoints(e);
      o[_] = V.wnd, f2[_] = V.points;
    }
    for (_ = n - 1; _ >= 1; _ -= 2) {
      var G = _ - 1, ee2 = _;
      if (o[G] !== 1 || o[ee2] !== 1) {
        l[G] = Tl(i[G], o[G], this._bitLength), l[ee2] = Tl(i[ee2], o[ee2], this._bitLength), g5 = Math.max(l[G].length, g5), g5 = Math.max(l[ee2].length, g5);
        continue;
      }
      var W5 = [r3[G], null, null, r3[ee2]];
      r3[G].y.cmp(r3[ee2].y) === 0 ? (W5[1] = r3[G].add(r3[ee2]), W5[2] = r3[G].toJ().mixedAdd(r3[ee2].neg())) : r3[G].y.cmp(r3[ee2].y.redNeg()) === 0 ? (W5[1] = r3[G].toJ().mixedAdd(r3[ee2]), W5[2] = r3[G].add(r3[ee2].neg())) : (W5[1] = r3[G].toJ().mixedAdd(r3[ee2]), W5[2] = r3[G].toJ().mixedAdd(r3[ee2].neg()));
      var Z = [-3, -1, -5, -7, 0, 7, 5, 1, 3], le = dM(i[G], i[ee2]);
      for (g5 = Math.max(le[0].length, g5), l[G] = new Array(g5), l[ee2] = new Array(g5), N2 = 0; N2 < g5; N2++) {
        var be2 = le[0][N2] | 0, Ae = le[1][N2] | 0;
        l[G][N2] = Z[(be2 + 1) * 3 + (Ae + 1)], l[ee2][N2] = 0, f2[G] = W5;
      }
    }
    var me = this.jpoint(null, null, null), H5 = this._wnafT4;
    for (_ = g5; _ >= 0; _--) {
      for (var ue = 0; _ >= 0; ) {
        var se2 = true;
        for (N2 = 0; N2 < n; N2++)
          H5[N2] = l[N2][_] | 0, H5[N2] !== 0 && (se2 = false);
        if (!se2)
          break;
        ue++, _--;
      }
      if (_ >= 0 && ue++, me = me.dblp(ue), _ < 0)
        break;
      for (N2 = 0; N2 < n; N2++) {
        var ne2 = H5[N2];
        ne2 !== 0 && (ne2 > 0 ? U2 = f2[N2][ne2 - 1 >> 1] : ne2 < 0 && (U2 = f2[N2][-ne2 - 1 >> 1].neg()), U2.type === "affine" ? me = me.mixedAdd(U2) : me = me.add(U2));
      }
    }
    for (_ = 0; _ < n; _++)
      f2[_] = null;
    return s ? me : me.toP();
  };
  function ti(t, e) {
    this.curve = t, this.type = e, this.precomputed = null;
  }
  Pn.BasePoint = ti;
  ti.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  ti.prototype.validate = function() {
    return this.curve.validate(this);
  };
  Pn.prototype.decodePoint = function(e, r3) {
    e = Xf.toArray(e, r3);
    var i = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * i) {
      e[0] === 6 ? Fl(e[e.length - 1] % 2 === 0) : e[0] === 7 && Fl(e[e.length - 1] % 2 === 1);
      var n = this.point(e.slice(1, 1 + i), e.slice(1 + i, 1 + 2 * i));
      return n;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i)
      return this.pointFromX(e.slice(1, 1 + i), e[0] === 3);
    throw new Error("Unknown point format");
  };
  ti.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  ti.prototype._encode = function(e) {
    var r3 = this.curve.p.byteLength(), i = this.getX().toArray("be", r3);
    return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray("be", r3));
  };
  ti.prototype.encode = function(e, r3) {
    return Xf.encode(this._encode(r3), e);
  };
  ti.prototype.precompute = function(e) {
    if (this.precomputed)
      return this;
    var r3 = { doubles: null, naf: null, beta: null };
    return r3.naf = this._getNAFPoints(8), r3.doubles = this._getDoubles(4, e), r3.beta = this._getBeta(), this.precomputed = r3, this;
  };
  ti.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
      return false;
    var r3 = this.precomputed.doubles;
    return r3 ? r3.points.length >= Math.ceil((e.bitLength() + 1) / r3.step) : false;
  };
  ti.prototype._getDoubles = function(e, r3) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var i = [this], n = this, s = 0; s < r3; s += e) {
      for (var o = 0; o < e; o++)
        n = n.dbl();
      i.push(n);
    }
    return { step: e, points: i };
  };
  ti.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var r3 = [this], i = (1 << e) - 1, n = i === 1 ? null : this.dbl(), s = 1; s < i; s++)
      r3[s] = r3[s - 1].add(n);
    return { wnd: e, points: r3 };
  };
  ti.prototype._getBeta = function() {
    return null;
  };
  ti.prototype.dblp = function(e) {
    for (var r3 = this, i = 0; i < e; i++)
      r3 = r3.dbl();
    return r3;
  };
});
var fx = k((rN, ax) => {
  U();
  var lM = Hr(), ir = dr(), r1 = At(), zo = Qf(), hM = lM.assert;
  function ri(t) {
    zo.call(this, "short", t), this.a = new ir(t.a, 16).toRed(this.red), this.b = new ir(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  r1(ri, zo);
  ax.exports = ri;
  ri.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var r3, i;
      if (e.beta)
        r3 = new ir(e.beta, 16).toRed(this.red);
      else {
        var n = this._getEndoRoots(this.p);
        r3 = n[0].cmp(n[1]) < 0 ? n[0] : n[1], r3 = r3.toRed(this.red);
      }
      if (e.lambda)
        i = new ir(e.lambda, 16);
      else {
        var s = this._getEndoRoots(this.n);
        this.g.mul(s[0]).x.cmp(this.g.x.redMul(r3)) === 0 ? i = s[0] : (i = s[1], hM(this.g.mul(i).x.cmp(this.g.x.redMul(r3)) === 0));
      }
      var o;
      return e.basis ? o = e.basis.map(function(f2) {
        return { a: new ir(f2.a, 16), b: new ir(f2.b, 16) };
      }) : o = this._getEndoBasis(i), { beta: r3, lambda: i, basis: o };
    }
  };
  ri.prototype._getEndoRoots = function(e) {
    var r3 = e === this.p ? this.red : ir.mont(e), i = new ir(2).toRed(r3).redInvm(), n = i.redNeg(), s = new ir(3).toRed(r3).redNeg().redSqrt().redMul(i), o = n.redAdd(s).fromRed(), f2 = n.redSub(s).fromRed();
    return [o, f2];
  };
  ri.prototype._getEndoBasis = function(e) {
    for (var r3 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, n = this.n.clone(), s = new ir(1), o = new ir(0), f2 = new ir(0), l = new ir(1), g5, _, N2, U2, V, G, ee2, W5 = 0, Z, le; i.cmpn(0) !== 0; ) {
      var be2 = n.div(i);
      Z = n.sub(be2.mul(i)), le = f2.sub(be2.mul(s));
      var Ae = l.sub(be2.mul(o));
      if (!N2 && Z.cmp(r3) < 0)
        g5 = ee2.neg(), _ = s, N2 = Z.neg(), U2 = le;
      else if (N2 && ++W5 === 2)
        break;
      ee2 = Z, n = i, i = Z, f2 = s, s = le, l = o, o = Ae;
    }
    V = Z.neg(), G = le;
    var me = N2.sqr().add(U2.sqr()), H5 = V.sqr().add(G.sqr());
    return H5.cmp(me) >= 0 && (V = g5, G = _), N2.negative && (N2 = N2.neg(), U2 = U2.neg()), V.negative && (V = V.neg(), G = G.neg()), [{ a: N2, b: U2 }, { a: V, b: G }];
  };
  ri.prototype._endoSplit = function(e) {
    var r3 = this.endo.basis, i = r3[0], n = r3[1], s = n.b.mul(e).divRound(this.n), o = i.b.neg().mul(e).divRound(this.n), f2 = s.mul(i.a), l = o.mul(n.a), g5 = s.mul(i.b), _ = o.mul(n.b), N2 = e.sub(f2).sub(l), U2 = g5.add(_).neg();
    return { k1: N2, k2: U2 };
  };
  ri.prototype.pointFromX = function(e, r3) {
    e = new ir(e, 16), e.red || (e = e.toRed(this.red));
    var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), n = i.redSqrt();
    if (n.redSqr().redSub(i).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var s = n.fromRed().isOdd();
    return (r3 && !s || !r3 && s) && (n = n.redNeg()), this.point(e, n);
  };
  ri.prototype.validate = function(e) {
    if (e.inf)
      return true;
    var r3 = e.x, i = e.y, n = this.a.redMul(r3), s = r3.redSqr().redMul(r3).redIAdd(n).redIAdd(this.b);
    return i.redSqr().redISub(s).cmpn(0) === 0;
  };
  ri.prototype._endoWnafMulAdd = function(e, r3, i) {
    for (var n = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
      var f2 = this._endoSplit(r3[o]), l = e[o], g5 = l._getBeta();
      f2.k1.negative && (f2.k1.ineg(), l = l.neg(true)), f2.k2.negative && (f2.k2.ineg(), g5 = g5.neg(true)), n[o * 2] = l, n[o * 2 + 1] = g5, s[o * 2] = f2.k1, s[o * 2 + 1] = f2.k2;
    }
    for (var _ = this._wnafMulAdd(1, n, s, o * 2, i), N2 = 0; N2 < o * 2; N2++)
      n[N2] = null, s[N2] = null;
    return _;
  };
  function gr(t, e, r3, i) {
    zo.BasePoint.call(this, t, "affine"), e === null && r3 === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new ir(e, 16), this.y = new ir(r3, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  r1(gr, zo.BasePoint);
  ri.prototype.point = function(e, r3, i) {
    return new gr(this, e, r3, i);
  };
  ri.prototype.pointFromJSON = function(e, r3) {
    return gr.fromJSON(this, e, r3);
  };
  gr.prototype._getBeta = function() {
    if (!!this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta)
        return e.beta;
      var r3 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var i = this.curve, n = function(s) {
          return i.point(s.x.redMul(i.endo.beta), s.y);
        };
        e.beta = r3, r3.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(n) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(n) } };
      }
      return r3;
    }
  };
  gr.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
  };
  gr.fromJSON = function(e, r3, i) {
    typeof r3 == "string" && (r3 = JSON.parse(r3));
    var n = e.point(r3[0], r3[1], i);
    if (!r3[2])
      return n;
    function s(f2) {
      return e.point(f2[0], f2[1], i);
    }
    var o = r3[2];
    return n.precomputed = { beta: null, doubles: o.doubles && { step: o.doubles.step, points: [n].concat(o.doubles.points.map(s)) }, naf: o.naf && { wnd: o.naf.wnd, points: [n].concat(o.naf.points.map(s)) } }, n;
  };
  gr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  gr.prototype.isInfinity = function() {
    return this.inf;
  };
  gr.prototype.add = function(e) {
    if (this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.eq(e))
      return this.dbl();
    if (this.neg().eq(e))
      return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
      return this.curve.point(null, null);
    var r3 = this.y.redSub(e.y);
    r3.cmpn(0) !== 0 && (r3 = r3.redMul(this.x.redSub(e.x).redInvm()));
    var i = r3.redSqr().redISub(this.x).redISub(e.x), n = r3.redMul(this.x.redSub(i)).redISub(this.y);
    return this.curve.point(i, n);
  };
  gr.prototype.dbl = function() {
    if (this.inf)
      return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
      return this.curve.point(null, null);
    var r3 = this.curve.a, i = this.x.redSqr(), n = e.redInvm(), s = i.redAdd(i).redIAdd(i).redIAdd(r3).redMul(n), o = s.redSqr().redISub(this.x.redAdd(this.x)), f2 = s.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, f2);
  };
  gr.prototype.getX = function() {
    return this.x.fromRed();
  };
  gr.prototype.getY = function() {
    return this.y.fromRed();
  };
  gr.prototype.mul = function(e) {
    return e = new ir(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
  };
  gr.prototype.mulAdd = function(e, r3, i) {
    var n = [this, r3], s = [e, i];
    return this.curve.endo ? this.curve._endoWnafMulAdd(n, s) : this.curve._wnafMulAdd(1, n, s, 2);
  };
  gr.prototype.jmulAdd = function(e, r3, i) {
    var n = [this, r3], s = [e, i];
    return this.curve.endo ? this.curve._endoWnafMulAdd(n, s, true) : this.curve._wnafMulAdd(1, n, s, 2, true);
  };
  gr.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  gr.prototype.neg = function(e) {
    if (this.inf)
      return this;
    var r3 = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var i = this.precomputed, n = function(s) {
        return s.neg();
      };
      r3.precomputed = { naf: i.naf && { wnd: i.naf.wnd, points: i.naf.points.map(n) }, doubles: i.doubles && { step: i.doubles.step, points: i.doubles.points.map(n) } };
    }
    return r3;
  };
  gr.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function vr(t, e, r3, i) {
    zo.BasePoint.call(this, t, "jacobian"), e === null && r3 === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new ir(0)) : (this.x = new ir(e, 16), this.y = new ir(r3, 16), this.z = new ir(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  r1(vr, zo.BasePoint);
  ri.prototype.jpoint = function(e, r3, i) {
    return new vr(this, e, r3, i);
  };
  vr.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var e = this.z.redInvm(), r3 = e.redSqr(), i = this.x.redMul(r3), n = this.y.redMul(r3).redMul(e);
    return this.curve.point(i, n);
  };
  vr.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  vr.prototype.add = function(e) {
    if (this.isInfinity())
      return e;
    if (e.isInfinity())
      return this;
    var r3 = e.z.redSqr(), i = this.z.redSqr(), n = this.x.redMul(r3), s = e.x.redMul(i), o = this.y.redMul(r3.redMul(e.z)), f2 = e.y.redMul(i.redMul(this.z)), l = n.redSub(s), g5 = o.redSub(f2);
    if (l.cmpn(0) === 0)
      return g5.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var _ = l.redSqr(), N2 = _.redMul(l), U2 = n.redMul(_), V = g5.redSqr().redIAdd(N2).redISub(U2).redISub(U2), G = g5.redMul(U2.redISub(V)).redISub(o.redMul(N2)), ee2 = this.z.redMul(e.z).redMul(l);
    return this.curve.jpoint(V, G, ee2);
  };
  vr.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
      return e.toJ();
    if (e.isInfinity())
      return this;
    var r3 = this.z.redSqr(), i = this.x, n = e.x.redMul(r3), s = this.y, o = e.y.redMul(r3).redMul(this.z), f2 = i.redSub(n), l = s.redSub(o);
    if (f2.cmpn(0) === 0)
      return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var g5 = f2.redSqr(), _ = g5.redMul(f2), N2 = i.redMul(g5), U2 = l.redSqr().redIAdd(_).redISub(N2).redISub(N2), V = l.redMul(N2.redISub(U2)).redISub(s.redMul(_)), G = this.z.redMul(f2);
    return this.curve.jpoint(U2, V, G);
  };
  vr.prototype.dblp = function(e) {
    if (e === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!e)
      return this.dbl();
    var r3;
    if (this.curve.zeroA || this.curve.threeA) {
      var i = this;
      for (r3 = 0; r3 < e; r3++)
        i = i.dbl();
      return i;
    }
    var n = this.curve.a, s = this.curve.tinv, o = this.x, f2 = this.y, l = this.z, g5 = l.redSqr().redSqr(), _ = f2.redAdd(f2);
    for (r3 = 0; r3 < e; r3++) {
      var N2 = o.redSqr(), U2 = _.redSqr(), V = U2.redSqr(), G = N2.redAdd(N2).redIAdd(N2).redIAdd(n.redMul(g5)), ee2 = o.redMul(U2), W5 = G.redSqr().redISub(ee2.redAdd(ee2)), Z = ee2.redISub(W5), le = G.redMul(Z);
      le = le.redIAdd(le).redISub(V);
      var be2 = _.redMul(l);
      r3 + 1 < e && (g5 = g5.redMul(V)), o = W5, l = be2, _ = le;
    }
    return this.curve.jpoint(o, _.redMul(s), l);
  };
  vr.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  vr.prototype._zeroDbl = function() {
    var e, r3, i;
    if (this.zOne) {
      var n = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), f2 = this.x.redAdd(s).redSqr().redISub(n).redISub(o);
      f2 = f2.redIAdd(f2);
      var l = n.redAdd(n).redIAdd(n), g5 = l.redSqr().redISub(f2).redISub(f2), _ = o.redIAdd(o);
      _ = _.redIAdd(_), _ = _.redIAdd(_), e = g5, r3 = l.redMul(f2.redISub(g5)).redISub(_), i = this.y.redAdd(this.y);
    } else {
      var N2 = this.x.redSqr(), U2 = this.y.redSqr(), V = U2.redSqr(), G = this.x.redAdd(U2).redSqr().redISub(N2).redISub(V);
      G = G.redIAdd(G);
      var ee2 = N2.redAdd(N2).redIAdd(N2), W5 = ee2.redSqr(), Z = V.redIAdd(V);
      Z = Z.redIAdd(Z), Z = Z.redIAdd(Z), e = W5.redISub(G).redISub(G), r3 = ee2.redMul(G.redISub(e)).redISub(Z), i = this.y.redMul(this.z), i = i.redIAdd(i);
    }
    return this.curve.jpoint(e, r3, i);
  };
  vr.prototype._threeDbl = function() {
    var e, r3, i;
    if (this.zOne) {
      var n = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), f2 = this.x.redAdd(s).redSqr().redISub(n).redISub(o);
      f2 = f2.redIAdd(f2);
      var l = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a), g5 = l.redSqr().redISub(f2).redISub(f2);
      e = g5;
      var _ = o.redIAdd(o);
      _ = _.redIAdd(_), _ = _.redIAdd(_), r3 = l.redMul(f2.redISub(g5)).redISub(_), i = this.y.redAdd(this.y);
    } else {
      var N2 = this.z.redSqr(), U2 = this.y.redSqr(), V = this.x.redMul(U2), G = this.x.redSub(N2).redMul(this.x.redAdd(N2));
      G = G.redAdd(G).redIAdd(G);
      var ee2 = V.redIAdd(V);
      ee2 = ee2.redIAdd(ee2);
      var W5 = ee2.redAdd(ee2);
      e = G.redSqr().redISub(W5), i = this.y.redAdd(this.z).redSqr().redISub(U2).redISub(N2);
      var Z = U2.redSqr();
      Z = Z.redIAdd(Z), Z = Z.redIAdd(Z), Z = Z.redIAdd(Z), r3 = G.redMul(ee2.redISub(e)).redISub(Z);
    }
    return this.curve.jpoint(e, r3, i);
  };
  vr.prototype._dbl = function() {
    var e = this.curve.a, r3 = this.x, i = this.y, n = this.z, s = n.redSqr().redSqr(), o = r3.redSqr(), f2 = i.redSqr(), l = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), g5 = r3.redAdd(r3);
    g5 = g5.redIAdd(g5);
    var _ = g5.redMul(f2), N2 = l.redSqr().redISub(_.redAdd(_)), U2 = _.redISub(N2), V = f2.redSqr();
    V = V.redIAdd(V), V = V.redIAdd(V), V = V.redIAdd(V);
    var G = l.redMul(U2).redISub(V), ee2 = i.redAdd(i).redMul(n);
    return this.curve.jpoint(N2, G, ee2);
  };
  vr.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var e = this.x.redSqr(), r3 = this.y.redSqr(), i = this.z.redSqr(), n = r3.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), f2 = this.x.redAdd(r3).redSqr().redISub(e).redISub(n);
    f2 = f2.redIAdd(f2), f2 = f2.redAdd(f2).redIAdd(f2), f2 = f2.redISub(o);
    var l = f2.redSqr(), g5 = n.redIAdd(n);
    g5 = g5.redIAdd(g5), g5 = g5.redIAdd(g5), g5 = g5.redIAdd(g5);
    var _ = s.redIAdd(f2).redSqr().redISub(o).redISub(l).redISub(g5), N2 = r3.redMul(_);
    N2 = N2.redIAdd(N2), N2 = N2.redIAdd(N2);
    var U2 = this.x.redMul(l).redISub(N2);
    U2 = U2.redIAdd(U2), U2 = U2.redIAdd(U2);
    var V = this.y.redMul(_.redMul(g5.redISub(_)).redISub(f2.redMul(l)));
    V = V.redIAdd(V), V = V.redIAdd(V), V = V.redIAdd(V);
    var G = this.z.redAdd(f2).redSqr().redISub(i).redISub(l);
    return this.curve.jpoint(U2, V, G);
  };
  vr.prototype.mul = function(e, r3) {
    return e = new ir(e, r3), this.curve._wnafMul(this, e);
  };
  vr.prototype.eq = function(e) {
    if (e.type === "affine")
      return this.eq(e.toJ());
    if (this === e)
      return true;
    var r3 = this.z.redSqr(), i = e.z.redSqr();
    if (this.x.redMul(i).redISub(e.x.redMul(r3)).cmpn(0) !== 0)
      return false;
    var n = r3.redMul(this.z), s = i.redMul(e.z);
    return this.y.redMul(s).redISub(e.y.redMul(n)).cmpn(0) === 0;
  };
  vr.prototype.eqXToP = function(e) {
    var r3 = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(r3);
    if (this.x.cmp(i) === 0)
      return true;
    for (var n = e.clone(), s = this.curve.redN.redMul(r3); ; ) {
      if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
        return false;
      if (i.redIAdd(s), this.x.cmp(i) === 0)
        return true;
    }
  };
  vr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  vr.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
});
var dx = k((iN, ux) => {
  U();
  var Ho = dr(), cx = At(), Rl = Qf(), pM = Hr();
  function Ko(t) {
    Rl.call(this, "mont", t), this.a = new Ho(t.a, 16).toRed(this.red), this.b = new Ho(t.b, 16).toRed(this.red), this.i4 = new Ho(4).toRed(this.red).redInvm(), this.two = new Ho(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  cx(Ko, Rl);
  ux.exports = Ko;
  Ko.prototype.validate = function(e) {
    var r3 = e.normalize().x, i = r3.redSqr(), n = i.redMul(r3).redAdd(i.redMul(this.a)).redAdd(r3), s = n.redSqrt();
    return s.redSqr().cmp(n) === 0;
  };
  function mr(t, e, r3) {
    Rl.BasePoint.call(this, t, "projective"), e === null && r3 === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Ho(e, 16), this.z = new Ho(r3, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  cx(mr, Rl.BasePoint);
  Ko.prototype.decodePoint = function(e, r3) {
    return this.point(pM.toArray(e, r3), 1);
  };
  Ko.prototype.point = function(e, r3) {
    return new mr(this, e, r3);
  };
  Ko.prototype.pointFromJSON = function(e) {
    return mr.fromJSON(this, e);
  };
  mr.prototype.precompute = function() {
  };
  mr.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  mr.fromJSON = function(e, r3) {
    return new mr(e, r3[0], r3[1] || e.one);
  };
  mr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  mr.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  mr.prototype.dbl = function() {
    var e = this.x.redAdd(this.z), r3 = e.redSqr(), i = this.x.redSub(this.z), n = i.redSqr(), s = r3.redSub(n), o = r3.redMul(n), f2 = s.redMul(n.redAdd(this.curve.a24.redMul(s)));
    return this.curve.point(o, f2);
  };
  mr.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  mr.prototype.diffAdd = function(e, r3) {
    var i = this.x.redAdd(this.z), n = this.x.redSub(this.z), s = e.x.redAdd(e.z), o = e.x.redSub(e.z), f2 = o.redMul(i), l = s.redMul(n), g5 = r3.z.redMul(f2.redAdd(l).redSqr()), _ = r3.x.redMul(f2.redISub(l).redSqr());
    return this.curve.point(g5, _);
  };
  mr.prototype.mul = function(e) {
    for (var r3 = e.clone(), i = this, n = this.curve.point(null, null), s = this, o = []; r3.cmpn(0) !== 0; r3.iushrn(1))
      o.push(r3.andln(1));
    for (var f2 = o.length - 1; f2 >= 0; f2--)
      o[f2] === 0 ? (i = i.diffAdd(n, s), n = n.dbl()) : (n = i.diffAdd(n, s), i = i.dbl());
    return n;
  };
  mr.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  mr.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  mr.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0;
  };
  mr.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  mr.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
});
var px = k((nN, hx) => {
  U();
  var gM = Hr(), dn = dr(), lx = At(), kl = Qf(), mM = gM.assert;
  function Li(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, kl.call(this, "edwards", t), this.a = new dn(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new dn(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new dn(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), mM(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
  }
  lx(Li, kl);
  hx.exports = Li;
  Li.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e);
  };
  Li.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e);
  };
  Li.prototype.jpoint = function(e, r3, i, n) {
    return this.point(e, r3, i, n);
  };
  Li.prototype.pointFromX = function(e, r3) {
    e = new dn(e, 16), e.red || (e = e.toRed(this.red));
    var i = e.redSqr(), n = this.c2.redSub(this.a.redMul(i)), s = this.one.redSub(this.c2.redMul(this.d).redMul(i)), o = n.redMul(s.redInvm()), f2 = o.redSqrt();
    if (f2.redSqr().redSub(o).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var l = f2.fromRed().isOdd();
    return (r3 && !l || !r3 && l) && (f2 = f2.redNeg()), this.point(e, f2);
  };
  Li.prototype.pointFromY = function(e, r3) {
    e = new dn(e, 16), e.red || (e = e.toRed(this.red));
    var i = e.redSqr(), n = i.redSub(this.c2), s = i.redMul(this.d).redMul(this.c2).redSub(this.a), o = n.redMul(s.redInvm());
    if (o.cmp(this.zero) === 0) {
      if (r3)
        throw new Error("invalid point");
      return this.point(this.zero, e);
    }
    var f2 = o.redSqrt();
    if (f2.redSqr().redSub(o).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return f2.fromRed().isOdd() !== r3 && (f2 = f2.redNeg()), this.point(f2, e);
  };
  Li.prototype.validate = function(e) {
    if (e.isInfinity())
      return true;
    e.normalize();
    var r3 = e.x.redSqr(), i = e.y.redSqr(), n = r3.redMul(this.a).redAdd(i), s = this.c2.redMul(this.one.redAdd(this.d.redMul(r3).redMul(i)));
    return n.cmp(s) === 0;
  };
  function Zt(t, e, r3, i, n) {
    kl.BasePoint.call(this, t, "projective"), e === null && r3 === null && i === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new dn(e, 16), this.y = new dn(r3, 16), this.z = i ? new dn(i, 16) : this.curve.one, this.t = n && new dn(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  lx(Zt, kl.BasePoint);
  Li.prototype.pointFromJSON = function(e) {
    return Zt.fromJSON(this, e);
  };
  Li.prototype.point = function(e, r3, i, n) {
    return new Zt(this, e, r3, i, n);
  };
  Zt.fromJSON = function(e, r3) {
    return new Zt(e, r3[0], r3[1], r3[2]);
  };
  Zt.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Zt.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Zt.prototype._extDbl = function() {
    var e = this.x.redSqr(), r3 = this.y.redSqr(), i = this.z.redSqr();
    i = i.redIAdd(i);
    var n = this.curve._mulA(e), s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r3), o = n.redAdd(r3), f2 = o.redSub(i), l = n.redSub(r3), g5 = s.redMul(f2), _ = o.redMul(l), N2 = s.redMul(l), U2 = f2.redMul(o);
    return this.curve.point(g5, _, U2, N2);
  };
  Zt.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(), r3 = this.x.redSqr(), i = this.y.redSqr(), n, s, o, f2, l, g5;
    if (this.curve.twisted) {
      f2 = this.curve._mulA(r3);
      var _ = f2.redAdd(i);
      this.zOne ? (n = e.redSub(r3).redSub(i).redMul(_.redSub(this.curve.two)), s = _.redMul(f2.redSub(i)), o = _.redSqr().redSub(_).redSub(_)) : (l = this.z.redSqr(), g5 = _.redSub(l).redISub(l), n = e.redSub(r3).redISub(i).redMul(g5), s = _.redMul(f2.redSub(i)), o = _.redMul(g5));
    } else
      f2 = r3.redAdd(i), l = this.curve._mulC(this.z).redSqr(), g5 = f2.redSub(l).redSub(l), n = this.curve._mulC(e.redISub(f2)).redMul(g5), s = this.curve._mulC(f2).redMul(r3.redISub(i)), o = f2.redMul(g5);
    return this.curve.point(n, s, o);
  };
  Zt.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  Zt.prototype._extAdd = function(e) {
    var r3 = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), i = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), n = this.t.redMul(this.curve.dd).redMul(e.t), s = this.z.redMul(e.z.redAdd(e.z)), o = i.redSub(r3), f2 = s.redSub(n), l = s.redAdd(n), g5 = i.redAdd(r3), _ = o.redMul(f2), N2 = l.redMul(g5), U2 = o.redMul(g5), V = f2.redMul(l);
    return this.curve.point(_, N2, V, U2);
  };
  Zt.prototype._projAdd = function(e) {
    var r3 = this.z.redMul(e.z), i = r3.redSqr(), n = this.x.redMul(e.x), s = this.y.redMul(e.y), o = this.curve.d.redMul(n).redMul(s), f2 = i.redSub(o), l = i.redAdd(o), g5 = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(n).redISub(s), _ = r3.redMul(f2).redMul(g5), N2, U2;
    return this.curve.twisted ? (N2 = r3.redMul(l).redMul(s.redSub(this.curve._mulA(n))), U2 = f2.redMul(l)) : (N2 = r3.redMul(l).redMul(s.redSub(n)), U2 = this.curve._mulC(f2).redMul(l)), this.curve.point(_, N2, U2);
  };
  Zt.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
  };
  Zt.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
  };
  Zt.prototype.mulAdd = function(e, r3, i) {
    return this.curve._wnafMulAdd(1, [this, r3], [e, i], 2, false);
  };
  Zt.prototype.jmulAdd = function(e, r3, i) {
    return this.curve._wnafMulAdd(1, [this, r3], [e, i], 2, true);
  };
  Zt.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
  };
  Zt.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Zt.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  Zt.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  Zt.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
  };
  Zt.prototype.eqXToP = function(e) {
    var r3 = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r3) === 0)
      return true;
    for (var i = e.clone(), n = this.curve.redN.redMul(this.z); ; ) {
      if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
        return false;
      if (r3.redIAdd(n), this.x.cmp(r3) === 0)
        return true;
    }
  };
  Zt.prototype.toP = Zt.prototype.normalize;
  Zt.prototype.mixedAdd = Zt.prototype.add;
});
var i1 = k((gx) => {
  U();
  var Dl = gx;
  Dl.base = Qf();
  Dl.short = fx();
  Dl.mont = dx();
  Dl.edwards = px();
});
var xi = k((Yt) => {
  U();
  var yM = zr(), bM = At();
  Yt.inherits = bM;
  function vM(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
  }
  function xM(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r3 = [];
    if (typeof t == "string")
      if (e) {
        if (e === "hex")
          for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), n = 0; n < t.length; n += 2)
            r3.push(parseInt(t[n] + t[n + 1], 16));
      } else
        for (var i = 0, n = 0; n < t.length; n++) {
          var s = t.charCodeAt(n);
          s < 128 ? r3[i++] = s : s < 2048 ? (r3[i++] = s >> 6 | 192, r3[i++] = s & 63 | 128) : vM(t, n) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++n) & 1023), r3[i++] = s >> 18 | 240, r3[i++] = s >> 12 & 63 | 128, r3[i++] = s >> 6 & 63 | 128, r3[i++] = s & 63 | 128) : (r3[i++] = s >> 12 | 224, r3[i++] = s >> 6 & 63 | 128, r3[i++] = s & 63 | 128);
        }
    else
      for (n = 0; n < t.length; n++)
        r3[n] = t[n] | 0;
    return r3;
  }
  Yt.toArray = xM;
  function wM(t) {
    for (var e = "", r3 = 0; r3 < t.length; r3++)
      e += yx(t[r3].toString(16));
    return e;
  }
  Yt.toHex = wM;
  function mx(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0;
  }
  Yt.htonl = mx;
  function _M(t, e) {
    for (var r3 = "", i = 0; i < t.length; i++) {
      var n = t[i];
      e === "little" && (n = mx(n)), r3 += bx(n.toString(16));
    }
    return r3;
  }
  Yt.toHex32 = _M;
  function yx(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Yt.zero2 = yx;
  function bx(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
  }
  Yt.zero8 = bx;
  function AM(t, e, r3, i) {
    var n = r3 - e;
    yM(n % 4 === 0);
    for (var s = new Array(n / 4), o = 0, f2 = e; o < s.length; o++, f2 += 4) {
      var l;
      i === "big" ? l = t[f2] << 24 | t[f2 + 1] << 16 | t[f2 + 2] << 8 | t[f2 + 3] : l = t[f2 + 3] << 24 | t[f2 + 2] << 16 | t[f2 + 1] << 8 | t[f2], s[o] = l >>> 0;
    }
    return s;
  }
  Yt.join32 = AM;
  function EM(t, e) {
    for (var r3 = new Array(t.length * 4), i = 0, n = 0; i < t.length; i++, n += 4) {
      var s = t[i];
      e === "big" ? (r3[n] = s >>> 24, r3[n + 1] = s >>> 16 & 255, r3[n + 2] = s >>> 8 & 255, r3[n + 3] = s & 255) : (r3[n + 3] = s >>> 24, r3[n + 2] = s >>> 16 & 255, r3[n + 1] = s >>> 8 & 255, r3[n] = s & 255);
    }
    return r3;
  }
  Yt.split32 = EM;
  function MM(t, e) {
    return t >>> e | t << 32 - e;
  }
  Yt.rotr32 = MM;
  function SM(t, e) {
    return t << e | t >>> 32 - e;
  }
  Yt.rotl32 = SM;
  function IM(t, e) {
    return t + e >>> 0;
  }
  Yt.sum32 = IM;
  function TM(t, e, r3) {
    return t + e + r3 >>> 0;
  }
  Yt.sum32_3 = TM;
  function FM(t, e, r3, i) {
    return t + e + r3 + i >>> 0;
  }
  Yt.sum32_4 = FM;
  function RM(t, e, r3, i, n) {
    return t + e + r3 + i + n >>> 0;
  }
  Yt.sum32_5 = RM;
  function kM(t, e, r3, i) {
    var n = t[e], s = t[e + 1], o = i + s >>> 0, f2 = (o < i ? 1 : 0) + r3 + n;
    t[e] = f2 >>> 0, t[e + 1] = o;
  }
  Yt.sum64 = kM;
  function DM(t, e, r3, i) {
    var n = e + i >>> 0, s = (n < e ? 1 : 0) + t + r3;
    return s >>> 0;
  }
  Yt.sum64_hi = DM;
  function NM(t, e, r3, i) {
    var n = e + i;
    return n >>> 0;
  }
  Yt.sum64_lo = NM;
  function BM(t, e, r3, i, n, s, o, f2) {
    var l = 0, g5 = e;
    g5 = g5 + i >>> 0, l += g5 < e ? 1 : 0, g5 = g5 + s >>> 0, l += g5 < s ? 1 : 0, g5 = g5 + f2 >>> 0, l += g5 < f2 ? 1 : 0;
    var _ = t + r3 + n + o + l;
    return _ >>> 0;
  }
  Yt.sum64_4_hi = BM;
  function CM(t, e, r3, i, n, s, o, f2) {
    var l = e + i + s + f2;
    return l >>> 0;
  }
  Yt.sum64_4_lo = CM;
  function OM(t, e, r3, i, n, s, o, f2, l, g5) {
    var _ = 0, N2 = e;
    N2 = N2 + i >>> 0, _ += N2 < e ? 1 : 0, N2 = N2 + s >>> 0, _ += N2 < s ? 1 : 0, N2 = N2 + f2 >>> 0, _ += N2 < f2 ? 1 : 0, N2 = N2 + g5 >>> 0, _ += N2 < g5 ? 1 : 0;
    var U2 = t + r3 + n + o + l + _;
    return U2 >>> 0;
  }
  Yt.sum64_5_hi = OM;
  function jM(t, e, r3, i, n, s, o, f2, l, g5) {
    var _ = e + i + s + f2 + g5;
    return _ >>> 0;
  }
  Yt.sum64_5_lo = jM;
  function LM(t, e, r3) {
    var i = e << 32 - r3 | t >>> r3;
    return i >>> 0;
  }
  Yt.rotr64_hi = LM;
  function qM(t, e, r3) {
    var i = t << 32 - r3 | e >>> r3;
    return i >>> 0;
  }
  Yt.rotr64_lo = qM;
  function PM(t, e, r3) {
    return t >>> r3;
  }
  Yt.shr64_hi = PM;
  function UM(t, e, r3) {
    var i = t << 32 - r3 | e >>> r3;
    return i >>> 0;
  }
  Yt.shr64_lo = UM;
});
var Go = k((xx) => {
  U();
  var vx = xi(), zM = zr();
  function Nl() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  xx.BlockHash = Nl;
  Nl.prototype.update = function(e, r3) {
    if (e = vx.toArray(e, r3), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var i = e.length % this._delta8;
      this.pending = e.slice(e.length - i, e.length), this.pending.length === 0 && (this.pending = null), e = vx.join32(e, 0, e.length - i, this.endian);
      for (var n = 0; n < e.length; n += this._delta32)
        this._update(e, n, n + this._delta32);
    }
    return this;
  };
  Nl.prototype.digest = function(e) {
    return this.update(this._pad()), zM(this.pending === null), this._digest(e);
  };
  Nl.prototype._pad = function() {
    var e = this.pendingTotal, r3 = this._delta8, i = r3 - (e + this.padLength) % r3, n = new Array(i + this.padLength);
    n[0] = 128;
    for (var s = 1; s < i; s++)
      n[s] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var o = 8; o < this.padLength; o++)
        n[s++] = 0;
      n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = e >>> 24 & 255, n[s++] = e >>> 16 & 255, n[s++] = e >>> 8 & 255, n[s++] = e & 255;
    } else
      for (n[s++] = e & 255, n[s++] = e >>> 8 & 255, n[s++] = e >>> 16 & 255, n[s++] = e >>> 24 & 255, n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = 0, o = 8; o < this.padLength; o++)
        n[s++] = 0;
    return n;
  };
});
var n1 = k((ln) => {
  U();
  var HM = xi(), qi = HM.rotr32;
  function KM(t, e, r3, i) {
    if (t === 0)
      return wx(e, r3, i);
    if (t === 1 || t === 3)
      return Ax(e, r3, i);
    if (t === 2)
      return _x(e, r3, i);
  }
  ln.ft_1 = KM;
  function wx(t, e, r3) {
    return t & e ^ ~t & r3;
  }
  ln.ch32 = wx;
  function _x(t, e, r3) {
    return t & e ^ t & r3 ^ e & r3;
  }
  ln.maj32 = _x;
  function Ax(t, e, r3) {
    return t ^ e ^ r3;
  }
  ln.p32 = Ax;
  function GM(t) {
    return qi(t, 2) ^ qi(t, 13) ^ qi(t, 22);
  }
  ln.s0_256 = GM;
  function $M(t) {
    return qi(t, 6) ^ qi(t, 11) ^ qi(t, 25);
  }
  ln.s1_256 = $M;
  function WM(t) {
    return qi(t, 7) ^ qi(t, 18) ^ t >>> 3;
  }
  ln.g0_256 = WM;
  function VM(t) {
    return qi(t, 17) ^ qi(t, 19) ^ t >>> 10;
  }
  ln.g1_256 = VM;
});
var Sx = k((cN, Mx) => {
  U();
  var $o = xi(), YM = Go(), ZM = n1(), s1 = $o.rotl32, ec = $o.sum32, JM = $o.sum32_5, XM = ZM.ft_1, Ex = YM.BlockHash, QM = [1518500249, 1859775393, 2400959708, 3395469782];
  function Pi() {
    if (!(this instanceof Pi))
      return new Pi();
    Ex.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
  }
  $o.inherits(Pi, Ex);
  Mx.exports = Pi;
  Pi.blockSize = 512;
  Pi.outSize = 160;
  Pi.hmacStrength = 80;
  Pi.padLength = 64;
  Pi.prototype._update = function(e, r3) {
    for (var i = this.W, n = 0; n < 16; n++)
      i[n] = e[r3 + n];
    for (; n < i.length; n++)
      i[n] = s1(i[n - 3] ^ i[n - 8] ^ i[n - 14] ^ i[n - 16], 1);
    var s = this.h[0], o = this.h[1], f2 = this.h[2], l = this.h[3], g5 = this.h[4];
    for (n = 0; n < i.length; n++) {
      var _ = ~~(n / 20), N2 = JM(s1(s, 5), XM(_, o, f2, l), g5, i[n], QM[_]);
      g5 = l, l = f2, f2 = s1(o, 30), o = s, s = N2;
    }
    this.h[0] = ec(this.h[0], s), this.h[1] = ec(this.h[1], o), this.h[2] = ec(this.h[2], f2), this.h[3] = ec(this.h[3], l), this.h[4] = ec(this.h[4], g5);
  };
  Pi.prototype._digest = function(e) {
    return e === "hex" ? $o.toHex32(this.h, "big") : $o.split32(this.h, "big");
  };
});
var o1 = k((uN, Tx) => {
  U();
  var Wo = xi(), eS = Go(), Vo = n1(), tS = zr(), wi = Wo.sum32, rS = Wo.sum32_4, iS = Wo.sum32_5, nS = Vo.ch32, sS = Vo.maj32, oS = Vo.s0_256, aS = Vo.s1_256, fS = Vo.g0_256, cS = Vo.g1_256, Ix = eS.BlockHash, uS = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function Ui() {
    if (!(this instanceof Ui))
      return new Ui();
    Ix.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = uS, this.W = new Array(64);
  }
  Wo.inherits(Ui, Ix);
  Tx.exports = Ui;
  Ui.blockSize = 512;
  Ui.outSize = 256;
  Ui.hmacStrength = 192;
  Ui.padLength = 64;
  Ui.prototype._update = function(e, r3) {
    for (var i = this.W, n = 0; n < 16; n++)
      i[n] = e[r3 + n];
    for (; n < i.length; n++)
      i[n] = rS(cS(i[n - 2]), i[n - 7], fS(i[n - 15]), i[n - 16]);
    var s = this.h[0], o = this.h[1], f2 = this.h[2], l = this.h[3], g5 = this.h[4], _ = this.h[5], N2 = this.h[6], U2 = this.h[7];
    for (tS(this.k.length === i.length), n = 0; n < i.length; n++) {
      var V = iS(U2, aS(g5), nS(g5, _, N2), this.k[n], i[n]), G = wi(oS(s), sS(s, o, f2));
      U2 = N2, N2 = _, _ = g5, g5 = wi(l, V), l = f2, f2 = o, o = s, s = wi(V, G);
    }
    this.h[0] = wi(this.h[0], s), this.h[1] = wi(this.h[1], o), this.h[2] = wi(this.h[2], f2), this.h[3] = wi(this.h[3], l), this.h[4] = wi(this.h[4], g5), this.h[5] = wi(this.h[5], _), this.h[6] = wi(this.h[6], N2), this.h[7] = wi(this.h[7], U2);
  };
  Ui.prototype._digest = function(e) {
    return e === "hex" ? Wo.toHex32(this.h, "big") : Wo.split32(this.h, "big");
  };
});
var kx = k((dN, Rx) => {
  U();
  var a1 = xi(), Fx = o1();
  function hn() {
    if (!(this instanceof hn))
      return new hn();
    Fx.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  a1.inherits(hn, Fx);
  Rx.exports = hn;
  hn.blockSize = 512;
  hn.outSize = 224;
  hn.hmacStrength = 192;
  hn.padLength = 64;
  hn.prototype._digest = function(e) {
    return e === "hex" ? a1.toHex32(this.h.slice(0, 7), "big") : a1.split32(this.h.slice(0, 7), "big");
  };
});
var u1 = k((lN, Cx) => {
  U();
  var Lr2 = xi(), dS = Go(), lS = zr(), zi = Lr2.rotr64_hi, Hi = Lr2.rotr64_lo, Dx = Lr2.shr64_hi, Nx = Lr2.shr64_lo, Un = Lr2.sum64, f1 = Lr2.sum64_hi, c1 = Lr2.sum64_lo, hS = Lr2.sum64_4_hi, pS = Lr2.sum64_4_lo, gS = Lr2.sum64_5_hi, mS = Lr2.sum64_5_lo, Bx = dS.BlockHash, yS = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  function _i() {
    if (!(this instanceof _i))
      return new _i();
    Bx.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = yS, this.W = new Array(160);
  }
  Lr2.inherits(_i, Bx);
  Cx.exports = _i;
  _i.blockSize = 1024;
  _i.outSize = 512;
  _i.hmacStrength = 192;
  _i.padLength = 128;
  _i.prototype._prepareBlock = function(e, r3) {
    for (var i = this.W, n = 0; n < 32; n++)
      i[n] = e[r3 + n];
    for (; n < i.length; n += 2) {
      var s = TS(i[n - 4], i[n - 3]), o = FS(i[n - 4], i[n - 3]), f2 = i[n - 14], l = i[n - 13], g5 = SS(i[n - 30], i[n - 29]), _ = IS(i[n - 30], i[n - 29]), N2 = i[n - 32], U2 = i[n - 31];
      i[n] = hS(s, o, f2, l, g5, _, N2, U2), i[n + 1] = pS(s, o, f2, l, g5, _, N2, U2);
    }
  };
  _i.prototype._update = function(e, r3) {
    this._prepareBlock(e, r3);
    var i = this.W, n = this.h[0], s = this.h[1], o = this.h[2], f2 = this.h[3], l = this.h[4], g5 = this.h[5], _ = this.h[6], N2 = this.h[7], U2 = this.h[8], V = this.h[9], G = this.h[10], ee2 = this.h[11], W5 = this.h[12], Z = this.h[13], le = this.h[14], be2 = this.h[15];
    lS(this.k.length === i.length);
    for (var Ae = 0; Ae < i.length; Ae += 2) {
      var me = le, H5 = be2, ue = ES(U2, V), se2 = MS(U2, V), ne2 = bS(U2, V, G, ee2, W5), E2 = vS(U2, V, G, ee2, W5, Z), c = this.k[Ae], m2 = this.k[Ae + 1], h2 = i[Ae], a = i[Ae + 1], u3 = gS(me, H5, ue, se2, ne2, E2, c, m2, h2, a), b2 = mS(me, H5, ue, se2, ne2, E2, c, m2, h2, a);
      me = _S(n, s), H5 = AS(n, s), ue = xS(n, s, o, f2, l), se2 = wS(n, s, o, f2, l, g5);
      var A2 = f1(me, H5, ue, se2), v2 = c1(me, H5, ue, se2);
      le = W5, be2 = Z, W5 = G, Z = ee2, G = U2, ee2 = V, U2 = f1(_, N2, u3, b2), V = c1(N2, N2, u3, b2), _ = l, N2 = g5, l = o, g5 = f2, o = n, f2 = s, n = f1(u3, b2, A2, v2), s = c1(u3, b2, A2, v2);
    }
    Un(this.h, 0, n, s), Un(this.h, 2, o, f2), Un(this.h, 4, l, g5), Un(this.h, 6, _, N2), Un(this.h, 8, U2, V), Un(this.h, 10, G, ee2), Un(this.h, 12, W5, Z), Un(this.h, 14, le, be2);
  };
  _i.prototype._digest = function(e) {
    return e === "hex" ? Lr2.toHex32(this.h, "big") : Lr2.split32(this.h, "big");
  };
  function bS(t, e, r3, i, n) {
    var s = t & r3 ^ ~t & n;
    return s < 0 && (s += 4294967296), s;
  }
  function vS(t, e, r3, i, n, s) {
    var o = e & i ^ ~e & s;
    return o < 0 && (o += 4294967296), o;
  }
  function xS(t, e, r3, i, n) {
    var s = t & r3 ^ t & n ^ r3 & n;
    return s < 0 && (s += 4294967296), s;
  }
  function wS(t, e, r3, i, n, s) {
    var o = e & i ^ e & s ^ i & s;
    return o < 0 && (o += 4294967296), o;
  }
  function _S(t, e) {
    var r3 = zi(t, e, 28), i = zi(e, t, 2), n = zi(e, t, 7), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
  function AS(t, e) {
    var r3 = Hi(t, e, 28), i = Hi(e, t, 2), n = Hi(e, t, 7), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
  function ES(t, e) {
    var r3 = zi(t, e, 14), i = zi(t, e, 18), n = zi(e, t, 9), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
  function MS(t, e) {
    var r3 = Hi(t, e, 14), i = Hi(t, e, 18), n = Hi(e, t, 9), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
  function SS(t, e) {
    var r3 = zi(t, e, 1), i = zi(t, e, 8), n = Dx(t, e, 7), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
  function IS(t, e) {
    var r3 = Hi(t, e, 1), i = Hi(t, e, 8), n = Nx(t, e, 7), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
  function TS(t, e) {
    var r3 = zi(t, e, 19), i = zi(e, t, 29), n = Dx(t, e, 6), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
  function FS(t, e) {
    var r3 = Hi(t, e, 19), i = Hi(e, t, 29), n = Nx(t, e, 6), s = r3 ^ i ^ n;
    return s < 0 && (s += 4294967296), s;
  }
});
var Lx = k((hN, jx) => {
  U();
  var d1 = xi(), Ox = u1();
  function pn() {
    if (!(this instanceof pn))
      return new pn();
    Ox.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  d1.inherits(pn, Ox);
  jx.exports = pn;
  pn.blockSize = 1024;
  pn.outSize = 384;
  pn.hmacStrength = 192;
  pn.padLength = 128;
  pn.prototype._digest = function(e) {
    return e === "hex" ? d1.toHex32(this.h.slice(0, 12), "big") : d1.split32(this.h.slice(0, 12), "big");
  };
});
var qx = k((Yo) => {
  U();
  Yo.sha1 = Sx();
  Yo.sha224 = kx();
  Yo.sha256 = o1();
  Yo.sha384 = Lx();
  Yo.sha512 = u1();
});
var Gx = k((Kx) => {
  U();
  var Ds = xi(), RS = Go(), Bl = Ds.rotl32, Px = Ds.sum32, tc = Ds.sum32_3, Ux = Ds.sum32_4, Hx = RS.BlockHash;
  function Ki() {
    if (!(this instanceof Ki))
      return new Ki();
    Hx.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  Ds.inherits(Ki, Hx);
  Kx.ripemd160 = Ki;
  Ki.blockSize = 512;
  Ki.outSize = 160;
  Ki.hmacStrength = 192;
  Ki.padLength = 64;
  Ki.prototype._update = function(e, r3) {
    for (var i = this.h[0], n = this.h[1], s = this.h[2], o = this.h[3], f2 = this.h[4], l = i, g5 = n, _ = s, N2 = o, U2 = f2, V = 0; V < 80; V++) {
      var G = Px(Bl(Ux(i, zx(V, n, s, o), e[NS[V] + r3], kS(V)), CS[V]), f2);
      i = f2, f2 = o, o = Bl(s, 10), s = n, n = G, G = Px(Bl(Ux(l, zx(79 - V, g5, _, N2), e[BS[V] + r3], DS(V)), OS[V]), U2), l = U2, U2 = N2, N2 = Bl(_, 10), _ = g5, g5 = G;
    }
    G = tc(this.h[1], s, N2), this.h[1] = tc(this.h[2], o, U2), this.h[2] = tc(this.h[3], f2, l), this.h[3] = tc(this.h[4], i, g5), this.h[4] = tc(this.h[0], n, _), this.h[0] = G;
  };
  Ki.prototype._digest = function(e) {
    return e === "hex" ? Ds.toHex32(this.h, "little") : Ds.split32(this.h, "little");
  };
  function zx(t, e, r3, i) {
    return t <= 15 ? e ^ r3 ^ i : t <= 31 ? e & r3 | ~e & i : t <= 47 ? (e | ~r3) ^ i : t <= 63 ? e & i | r3 & ~i : e ^ (r3 | ~i);
  }
  function kS(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
  }
  function DS(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
  }
  var NS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], BS = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], CS = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], OS = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
});
var Wx = k((mN, $x) => {
  U();
  var jS = xi(), LS = zr();
  function Zo(t, e, r3) {
    if (!(this instanceof Zo))
      return new Zo(t, e, r3);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(jS.toArray(e, r3));
  }
  $x.exports = Zo;
  Zo.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), LS(e.length <= this.blockSize);
    for (var r3 = e.length; r3 < this.blockSize; r3++)
      e.push(0);
    for (r3 = 0; r3 < e.length; r3++)
      e[r3] ^= 54;
    for (this.inner = new this.Hash().update(e), r3 = 0; r3 < e.length; r3++)
      e[r3] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  Zo.prototype.update = function(e, r3) {
    return this.inner.update(e, r3), this;
  };
  Zo.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
});
var Cl = k((Vx) => {
  U();
  var xr = Vx;
  xr.utils = xi();
  xr.common = Go();
  xr.sha = qx();
  xr.ripemd = Gx();
  xr.hmac = Wx();
  xr.sha1 = xr.sha.sha1;
  xr.sha256 = xr.sha.sha256;
  xr.sha224 = xr.sha.sha224;
  xr.sha384 = xr.sha.sha384;
  xr.sha512 = xr.sha.sha512;
  xr.ripemd160 = xr.ripemd.ripemd160;
});
var Zx = k((bN, Yx) => {
  U();
  Yx.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
});
var Ol = k((Qx) => {
  U();
  var h1 = Qx, zn = Cl(), l1 = i1(), qS = Hr(), Jx = qS.assert;
  function Xx(t) {
    t.type === "short" ? this.curve = new l1.short(t) : t.type === "edwards" ? this.curve = new l1.edwards(t) : this.curve = new l1.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, Jx(this.g.validate(), "Invalid curve"), Jx(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  h1.PresetCurve = Xx;
  function Hn(t, e) {
    Object.defineProperty(h1, t, { configurable: true, enumerable: true, get: function() {
      var r3 = new Xx(e);
      return Object.defineProperty(h1, t, { configurable: true, enumerable: true, value: r3 }), r3;
    } });
  }
  Hn("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: zn.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
  Hn("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: zn.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
  Hn("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: zn.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
  Hn("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: zn.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
  Hn("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: zn.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
  Hn("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: zn.sha256, gRed: false, g: ["9"] });
  Hn("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: zn.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var p1;
  try {
    p1 = Zx();
  } catch {
    p1 = void 0;
  }
  Hn("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: zn.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", p1] });
});
var rw = k((xN, tw) => {
  U();
  var PS = Cl(), Ns = t1(), ew = zr();
  function Kn(t) {
    if (!(this instanceof Kn))
      return new Kn(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Ns.toArray(t.entropy, t.entropyEnc || "hex"), r3 = Ns.toArray(t.nonce, t.nonceEnc || "hex"), i = Ns.toArray(t.pers, t.persEnc || "hex");
    ew(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r3, i);
  }
  tw.exports = Kn;
  Kn.prototype._init = function(e, r3, i) {
    var n = e.concat(r3).concat(i);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var s = 0; s < this.V.length; s++)
      this.K[s] = 0, this.V[s] = 1;
    this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  Kn.prototype._hmac = function() {
    return new PS.hmac(this.hash, this.K);
  };
  Kn.prototype._update = function(e) {
    var r3 = this._hmac().update(this.V).update([0]);
    e && (r3 = r3.update(e)), this.K = r3.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  Kn.prototype.reseed = function(e, r3, i, n) {
    typeof r3 != "string" && (n = i, i = r3, r3 = null), e = Ns.toArray(e, r3), i = Ns.toArray(i, n), ew(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(i || [])), this._reseed = 1;
  };
  Kn.prototype.generate = function(e, r3, i, n) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof r3 != "string" && (n = i, i = r3, r3 = null), i && (i = Ns.toArray(i, n || "hex"), this._update(i));
    for (var s = []; s.length < e; )
      this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
    var o = s.slice(0, e);
    return this._update(i), this._reseed++, Ns.encode(o, r3);
  };
});
var nw = k((wN, iw) => {
  U();
  var US = dr(), zS = Hr(), g1 = zS.assert;
  function Tr2(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  iw.exports = Tr2;
  Tr2.fromPublic = function(e, r3, i) {
    return r3 instanceof Tr2 ? r3 : new Tr2(e, { pub: r3, pubEnc: i });
  };
  Tr2.fromPrivate = function(e, r3, i) {
    return r3 instanceof Tr2 ? r3 : new Tr2(e, { priv: r3, privEnc: i });
  };
  Tr2.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
  };
  Tr2.prototype.getPublic = function(e, r3) {
    return typeof e == "string" && (r3 = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r3 ? this.pub.encode(r3, e) : this.pub;
  };
  Tr2.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  Tr2.prototype._importPrivate = function(e, r3) {
    this.priv = new US(e, r3 || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  Tr2.prototype._importPublic = function(e, r3) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? g1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && g1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, r3);
  };
  Tr2.prototype.derive = function(e) {
    return e.validate() || g1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  Tr2.prototype.sign = function(e, r3, i) {
    return this.ec.sign(e, this, r3, i);
  };
  Tr2.prototype.verify = function(e, r3) {
    return this.ec.verify(e, r3, this);
  };
  Tr2.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});
var aw = k((_N, ow) => {
  U();
  var jl = dr(), b1 = Hr(), HS = b1.assert;
  function Ll(t, e) {
    if (t instanceof Ll)
      return t;
    this._importDER(t, e) || (HS(t.r && t.s, "Signature without r or s"), this.r = new jl(t.r, 16), this.s = new jl(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
  }
  ow.exports = Ll;
  function KS() {
    this.place = 0;
  }
  function m1(t, e) {
    var r3 = t[e.place++];
    if (!(r3 & 128))
      return r3;
    var i = r3 & 15;
    if (i === 0 || i > 4)
      return false;
    for (var n = 0, s = 0, o = e.place; s < i; s++, o++)
      n <<= 8, n |= t[o], n >>>= 0;
    return n <= 127 ? false : (e.place = o, n);
  }
  function sw(t) {
    for (var e = 0, r3 = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r3; )
      e++;
    return e === 0 ? t : t.slice(e);
  }
  Ll.prototype._importDER = function(e, r3) {
    e = b1.toArray(e, r3);
    var i = new KS();
    if (e[i.place++] !== 48)
      return false;
    var n = m1(e, i);
    if (n === false || n + i.place !== e.length || e[i.place++] !== 2)
      return false;
    var s = m1(e, i);
    if (s === false)
      return false;
    var o = e.slice(i.place, s + i.place);
    if (i.place += s, e[i.place++] !== 2)
      return false;
    var f2 = m1(e, i);
    if (f2 === false || e.length !== f2 + i.place)
      return false;
    var l = e.slice(i.place, f2 + i.place);
    if (o[0] === 0)
      if (o[1] & 128)
        o = o.slice(1);
      else
        return false;
    if (l[0] === 0)
      if (l[1] & 128)
        l = l.slice(1);
      else
        return false;
    return this.r = new jl(o), this.s = new jl(l), this.recoveryParam = null, true;
  };
  function y1(t, e) {
    if (e < 128) {
      t.push(e);
      return;
    }
    var r3 = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r3 | 128); --r3; )
      t.push(e >>> (r3 << 3) & 255);
    t.push(e);
  }
  Ll.prototype.toDER = function(e) {
    var r3 = this.r.toArray(), i = this.s.toArray();
    for (r3[0] & 128 && (r3 = [0].concat(r3)), i[0] & 128 && (i = [0].concat(i)), r3 = sw(r3), i = sw(i); !i[0] && !(i[1] & 128); )
      i = i.slice(1);
    var n = [2];
    y1(n, r3.length), n = n.concat(r3), n.push(2), y1(n, i.length);
    var s = n.concat(i), o = [48];
    return y1(o, s.length), o = o.concat(s), b1.encode(o, e);
  };
});
var dw = k((AN, uw) => {
  U();
  var Bs = dr(), fw = rw(), GS = Hr(), v1 = Ol(), $S = wl(), cw = GS.assert, x1 = nw(), ql = aw();
  function ii(t) {
    if (!(this instanceof ii))
      return new ii(t);
    typeof t == "string" && (cw(Object.prototype.hasOwnProperty.call(v1, t), "Unknown curve " + t), t = v1[t]), t instanceof v1.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
  }
  uw.exports = ii;
  ii.prototype.keyPair = function(e) {
    return new x1(this, e);
  };
  ii.prototype.keyFromPrivate = function(e, r3) {
    return x1.fromPrivate(this, e, r3);
  };
  ii.prototype.keyFromPublic = function(e, r3) {
    return x1.fromPublic(this, e, r3);
  };
  ii.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r3 = new fw({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || $S(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), i = this.n.byteLength(), n = this.n.sub(new Bs(2)); ; ) {
      var s = new Bs(r3.generate(i));
      if (!(s.cmp(n) > 0))
        return s.iaddn(1), this.keyFromPrivate(s);
    }
  };
  ii.prototype._truncateToN = function(e, r3) {
    var i = e.byteLength() * 8 - this.n.bitLength();
    return i > 0 && (e = e.ushrn(i)), !r3 && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  ii.prototype.sign = function(e, r3, i, n) {
    typeof i == "object" && (n = i, i = null), n || (n = {}), r3 = this.keyFromPrivate(r3, i), e = this._truncateToN(new Bs(e, 16));
    for (var s = this.n.byteLength(), o = r3.getPrivate().toArray("be", s), f2 = e.toArray("be", s), l = new fw({ hash: this.hash, entropy: o, nonce: f2, pers: n.pers, persEnc: n.persEnc || "utf8" }), g5 = this.n.sub(new Bs(1)), _ = 0; ; _++) {
      var N2 = n.k ? n.k(_) : new Bs(l.generate(this.n.byteLength()));
      if (N2 = this._truncateToN(N2, true), !(N2.cmpn(1) <= 0 || N2.cmp(g5) >= 0)) {
        var U2 = this.g.mul(N2);
        if (!U2.isInfinity()) {
          var V = U2.getX(), G = V.umod(this.n);
          if (G.cmpn(0) !== 0) {
            var ee2 = N2.invm(this.n).mul(G.mul(r3.getPrivate()).iadd(e));
            if (ee2 = ee2.umod(this.n), ee2.cmpn(0) !== 0) {
              var W5 = (U2.getY().isOdd() ? 1 : 0) | (V.cmp(G) !== 0 ? 2 : 0);
              return n.canonical && ee2.cmp(this.nh) > 0 && (ee2 = this.n.sub(ee2), W5 ^= 1), new ql({ r: G, s: ee2, recoveryParam: W5 });
            }
          }
        }
      }
    }
  };
  ii.prototype.verify = function(e, r3, i, n) {
    e = this._truncateToN(new Bs(e, 16)), i = this.keyFromPublic(i, n), r3 = new ql(r3, "hex");
    var s = r3.r, o = r3.s;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
      return false;
    var f2 = o.invm(this.n), l = f2.mul(e).umod(this.n), g5 = f2.mul(s).umod(this.n), _;
    return this.curve._maxwellTrick ? (_ = this.g.jmulAdd(l, i.getPublic(), g5), _.isInfinity() ? false : _.eqXToP(s)) : (_ = this.g.mulAdd(l, i.getPublic(), g5), _.isInfinity() ? false : _.getX().umod(this.n).cmp(s) === 0);
  };
  ii.prototype.recoverPubKey = function(t, e, r3, i) {
    cw((3 & r3) === r3, "The recovery param is more than two bits"), e = new ql(e, i);
    var n = this.n, s = new Bs(t), o = e.r, f2 = e.s, l = r3 & 1, g5 = r3 >> 1;
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && g5)
      throw new Error("Unable to find sencond key candinate");
    g5 ? o = this.curve.pointFromX(o.add(this.curve.n), l) : o = this.curve.pointFromX(o, l);
    var _ = e.r.invm(n), N2 = n.sub(s).mul(_).umod(n), U2 = f2.mul(_).umod(n);
    return this.g.mulAdd(N2, o, U2);
  };
  ii.prototype.getKeyRecoveryParam = function(t, e, r3, i) {
    if (e = new ql(e, i), e.recoveryParam !== null)
      return e.recoveryParam;
    for (var n = 0; n < 4; n++) {
      var s;
      try {
        s = this.recoverPubKey(t, e, n);
      } catch {
        continue;
      }
      if (s.eq(r3))
        return n;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});
var gw = k((EN, pw) => {
  U();
  var rc = Hr(), hw = rc.assert, lw = rc.parseBytes, Jo = rc.cachedProperty;
  function yr(t, e) {
    this.eddsa = t, this._secret = lw(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = lw(e.pub);
  }
  yr.fromPublic = function(e, r3) {
    return r3 instanceof yr ? r3 : new yr(e, { pub: r3 });
  };
  yr.fromSecret = function(e, r3) {
    return r3 instanceof yr ? r3 : new yr(e, { secret: r3 });
  };
  yr.prototype.secret = function() {
    return this._secret;
  };
  Jo(yr, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  Jo(yr, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  Jo(yr, "privBytes", function() {
    var e = this.eddsa, r3 = this.hash(), i = e.encodingLength - 1, n = r3.slice(0, e.encodingLength);
    return n[0] &= 248, n[i] &= 127, n[i] |= 64, n;
  });
  Jo(yr, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  Jo(yr, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  Jo(yr, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  yr.prototype.sign = function(e) {
    return hw(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
  };
  yr.prototype.verify = function(e, r3) {
    return this.eddsa.verify(e, r3, this);
  };
  yr.prototype.getSecret = function(e) {
    return hw(this._secret, "KeyPair is public only"), rc.encode(this.secret(), e);
  };
  yr.prototype.getPublic = function(e) {
    return rc.encode(this.pubBytes(), e);
  };
  pw.exports = yr;
});
var yw = k((MN, mw) => {
  U();
  var WS = dr(), Pl = Hr(), VS = Pl.assert, Ul = Pl.cachedProperty, YS = Pl.parseBytes;
  function Cs(t, e) {
    this.eddsa = t, typeof e != "object" && (e = YS(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), VS(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof WS && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
  }
  Ul(Cs, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  Ul(Cs, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  Ul(Cs, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  Ul(Cs, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  Cs.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Cs.prototype.toHex = function() {
    return Pl.encode(this.toBytes(), "hex").toUpperCase();
  };
  mw.exports = Cs;
});
var _w = k((SN, ww) => {
  U();
  var ZS = Cl(), JS = Ol(), Xo = Hr(), XS = Xo.assert, vw = Xo.parseBytes, xw = gw(), bw = yw();
  function qr(t) {
    if (XS(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof qr))
      return new qr(t);
    t = JS[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = ZS.sha512;
  }
  ww.exports = qr;
  qr.prototype.sign = function(e, r3) {
    e = vw(e);
    var i = this.keyFromSecret(r3), n = this.hashInt(i.messagePrefix(), e), s = this.g.mul(n), o = this.encodePoint(s), f2 = this.hashInt(o, i.pubBytes(), e).mul(i.priv()), l = n.add(f2).umod(this.curve.n);
    return this.makeSignature({ R: s, S: l, Rencoded: o });
  };
  qr.prototype.verify = function(e, r3, i) {
    e = vw(e), r3 = this.makeSignature(r3);
    var n = this.keyFromPublic(i), s = this.hashInt(r3.Rencoded(), n.pubBytes(), e), o = this.g.mul(r3.S()), f2 = r3.R().add(n.pub().mul(s));
    return f2.eq(o);
  };
  qr.prototype.hashInt = function() {
    for (var e = this.hash(), r3 = 0; r3 < arguments.length; r3++)
      e.update(arguments[r3]);
    return Xo.intFromLE(e.digest()).umod(this.curve.n);
  };
  qr.prototype.keyFromPublic = function(e) {
    return xw.fromPublic(this, e);
  };
  qr.prototype.keyFromSecret = function(e) {
    return xw.fromSecret(this, e);
  };
  qr.prototype.makeSignature = function(e) {
    return e instanceof bw ? e : new bw(this, e);
  };
  qr.prototype.encodePoint = function(e) {
    var r3 = e.getY().toArray("le", this.encodingLength);
    return r3[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r3;
  };
  qr.prototype.decodePoint = function(e) {
    e = Xo.parseBytes(e);
    var r3 = e.length - 1, i = e.slice(0, r3).concat(e[r3] & -129), n = (e[r3] & 128) !== 0, s = Xo.intFromLE(i);
    return this.curve.pointFromY(s, n);
  };
  qr.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength);
  };
  qr.prototype.decodeInt = function(e) {
    return Xo.intFromLE(e);
  };
  qr.prototype.isPoint = function(e) {
    return e instanceof this.pointClass;
  };
});
var zl = k((Aw) => {
  U();
  var Os = Aw;
  Os.version = tx().version;
  Os.utils = Hr();
  Os.rand = wl();
  Os.curve = i1();
  Os.curves = Ol();
  Os.ec = dw();
  Os.eddsa = _w();
});
var Kl = k((TN, Ew) => {
  U();
  var Hl = or(), Qo = Hl.Buffer, ni = {}, si;
  for (si in Hl)
    !Hl.hasOwnProperty(si) || si === "SlowBuffer" || si === "Buffer" || (ni[si] = Hl[si]);
  var ea = ni.Buffer = {};
  for (si in Qo)
    !Qo.hasOwnProperty(si) || si === "allocUnsafe" || si === "allocUnsafeSlow" || (ea[si] = Qo[si]);
  ni.Buffer.prototype = Qo.prototype;
  (!ea.from || ea.from === Uint8Array.from) && (ea.from = function(t, e, r3) {
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
    if (t && typeof t.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    return Qo(t, e, r3);
  });
  ea.alloc || (ea.alloc = function(t, e, r3) {
    if (typeof t != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
    if (t < 0 || t >= 2 * (1 << 30))
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    var i = Qo(t);
    return !e || e.length === 0 ? i.fill(0) : typeof r3 == "string" ? i.fill(e, r3) : i.fill(e), i;
  });
  if (!ni.kStringMaxLength)
    try {
      ni.kStringMaxLength = W.default.binding("buffer").kStringMaxLength;
    } catch {
    }
  ni.constants || (ni.constants = { MAX_LENGTH: ni.kMaxLength }, ni.kStringMaxLength && (ni.constants.MAX_STRING_LENGTH = ni.kStringMaxLength));
  Ew.exports = ni;
});
var Gl = k((Mw) => {
  U();
  var QS = At();
  function oi(t) {
    this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
  }
  Mw.Reporter = oi;
  oi.prototype.isError = function(e) {
    return e instanceof ta;
  };
  oi.prototype.save = function() {
    let e = this._reporterState;
    return { obj: e.obj, pathLen: e.path.length };
  };
  oi.prototype.restore = function(e) {
    let r3 = this._reporterState;
    r3.obj = e.obj, r3.path = r3.path.slice(0, e.pathLen);
  };
  oi.prototype.enterKey = function(e) {
    return this._reporterState.path.push(e);
  };
  oi.prototype.exitKey = function(e) {
    let r3 = this._reporterState;
    r3.path = r3.path.slice(0, e - 1);
  };
  oi.prototype.leaveKey = function(e, r3, i) {
    let n = this._reporterState;
    this.exitKey(e), n.obj !== null && (n.obj[r3] = i);
  };
  oi.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  oi.prototype.enterObject = function() {
    let e = this._reporterState, r3 = e.obj;
    return e.obj = {}, r3;
  };
  oi.prototype.leaveObject = function(e) {
    let r3 = this._reporterState, i = r3.obj;
    return r3.obj = e, i;
  };
  oi.prototype.error = function(e) {
    let r3, i = this._reporterState, n = e instanceof ta;
    if (n ? r3 = e : r3 = new ta(i.path.map(function(s) {
      return "[" + JSON.stringify(s) + "]";
    }).join(""), e.message || e, e.stack), !i.options.partial)
      throw r3;
    return n || i.errors.push(r3), r3;
  };
  oi.prototype.wrapResult = function(e) {
    let r3 = this._reporterState;
    return r3.options.partial ? { result: this.isError(e) ? null : e, errors: r3.errors } : e;
  };
  function ta(t, e) {
    this.path = t, this.rethrow(e);
  }
  QS(ta, Error);
  ta.prototype.rethrow = function(e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ta), !this.stack)
      try {
        throw new Error(this.message);
      } catch (r3) {
        this.stack = r3.stack;
      }
    return this;
  };
});
var na = k((w1) => {
  U();
  var eI = At(), $l = Gl().Reporter, ra = Kl().Buffer;
  function ai(t, e) {
    if ($l.call(this, e), !ra.isBuffer(t)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = t, this.offset = 0, this.length = t.length;
  }
  eI(ai, $l);
  w1.DecoderBuffer = ai;
  ai.isDecoderBuffer = function(e) {
    return e instanceof ai ? true : typeof e == "object" && ra.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
  };
  ai.prototype.save = function() {
    return { offset: this.offset, reporter: $l.prototype.save.call(this) };
  };
  ai.prototype.restore = function(e) {
    let r3 = new ai(this.base);
    return r3.offset = e.offset, r3.length = this.offset, this.offset = e.offset, $l.prototype.restore.call(this, e.reporter), r3;
  };
  ai.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  ai.prototype.readUInt8 = function(e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
  };
  ai.prototype.skip = function(e, r3) {
    if (!(this.offset + e <= this.length))
      return this.error(r3 || "DecoderBuffer overrun");
    let i = new ai(this.base);
    return i._reporterState = this._reporterState, i.offset = this.offset, i.length = this.offset + e, this.offset += e, i;
  };
  ai.prototype.raw = function(e) {
    return this.base.slice(e ? e.offset : this.offset, this.length);
  };
  function ia(t, e) {
    if (Array.isArray(t))
      this.length = 0, this.value = t.map(function(r3) {
        return ia.isEncoderBuffer(r3) || (r3 = new ia(r3, e)), this.length += r3.length, r3;
      }, this);
    else if (typeof t == "number") {
      if (!(0 <= t && t <= 255))
        return e.error("non-byte EncoderBuffer value");
      this.value = t, this.length = 1;
    } else if (typeof t == "string")
      this.value = t, this.length = ra.byteLength(t);
    else if (ra.isBuffer(t))
      this.value = t, this.length = t.length;
    else
      return e.error("Unsupported type: " + typeof t);
  }
  w1.EncoderBuffer = ia;
  ia.isEncoderBuffer = function(e) {
    return e instanceof ia ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
  };
  ia.prototype.join = function(e, r3) {
    return e || (e = ra.alloc(this.length)), r3 || (r3 = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(i) {
      i.join(e, r3), r3 += i.length;
    }) : (typeof this.value == "number" ? e[r3] = this.value : typeof this.value == "string" ? e.write(this.value, r3) : ra.isBuffer(this.value) && this.value.copy(e, r3), r3 += this.length)), e;
  };
});
var Wl = k((kN, Iw) => {
  U();
  var tI = Gl().Reporter, rI = na().EncoderBuffer, iI = na().DecoderBuffer, Dr = zr(), Sw = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], nI = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Sw), sI = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function Gt(t, e, r3) {
    let i = {};
    this._baseState = i, i.name = r3, i.enc = t, i.parent = e || null, i.children = null, i.tag = null, i.args = null, i.reverseArgs = null, i.choice = null, i.optional = false, i.any = false, i.obj = false, i.use = null, i.useDecoder = null, i.key = null, i.default = null, i.explicit = null, i.implicit = null, i.contains = null, i.parent || (i.children = [], this._wrap());
  }
  Iw.exports = Gt;
  var oI = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  Gt.prototype.clone = function() {
    let e = this._baseState, r3 = {};
    oI.forEach(function(n) {
      r3[n] = e[n];
    });
    let i = new this.constructor(r3.parent);
    return i._baseState = r3, i;
  };
  Gt.prototype._wrap = function() {
    let e = this._baseState;
    nI.forEach(function(r3) {
      this[r3] = function() {
        let n = new this.constructor(this);
        return e.children.push(n), n[r3].apply(n, arguments);
      };
    }, this);
  };
  Gt.prototype._init = function(e) {
    let r3 = this._baseState;
    Dr(r3.parent === null), e.call(this), r3.children = r3.children.filter(function(i) {
      return i._baseState.parent === this;
    }, this), Dr.equal(r3.children.length, 1, "Root node can have only one child");
  };
  Gt.prototype._useArgs = function(e) {
    let r3 = this._baseState, i = e.filter(function(n) {
      return n instanceof this.constructor;
    }, this);
    e = e.filter(function(n) {
      return !(n instanceof this.constructor);
    }, this), i.length !== 0 && (Dr(r3.children === null), r3.children = i, i.forEach(function(n) {
      n._baseState.parent = this;
    }, this)), e.length !== 0 && (Dr(r3.args === null), r3.args = e, r3.reverseArgs = e.map(function(n) {
      if (typeof n != "object" || n.constructor !== Object)
        return n;
      let s = {};
      return Object.keys(n).forEach(function(o) {
        o == (o | 0) && (o |= 0);
        let f2 = n[o];
        s[f2] = o;
      }), s;
    }));
  };
  sI.forEach(function(t) {
    Gt.prototype[t] = function() {
      let r3 = this._baseState;
      throw new Error(t + " not implemented for encoding: " + r3.enc);
    };
  });
  Sw.forEach(function(t) {
    Gt.prototype[t] = function() {
      let r3 = this._baseState, i = Array.prototype.slice.call(arguments);
      return Dr(r3.tag === null), r3.tag = t, this._useArgs(i), this;
    };
  });
  Gt.prototype.use = function(e) {
    Dr(e);
    let r3 = this._baseState;
    return Dr(r3.use === null), r3.use = e, this;
  };
  Gt.prototype.optional = function() {
    let e = this._baseState;
    return e.optional = true, this;
  };
  Gt.prototype.def = function(e) {
    let r3 = this._baseState;
    return Dr(r3.default === null), r3.default = e, r3.optional = true, this;
  };
  Gt.prototype.explicit = function(e) {
    let r3 = this._baseState;
    return Dr(r3.explicit === null && r3.implicit === null), r3.explicit = e, this;
  };
  Gt.prototype.implicit = function(e) {
    let r3 = this._baseState;
    return Dr(r3.explicit === null && r3.implicit === null), r3.implicit = e, this;
  };
  Gt.prototype.obj = function() {
    let e = this._baseState, r3 = Array.prototype.slice.call(arguments);
    return e.obj = true, r3.length !== 0 && this._useArgs(r3), this;
  };
  Gt.prototype.key = function(e) {
    let r3 = this._baseState;
    return Dr(r3.key === null), r3.key = e, this;
  };
  Gt.prototype.any = function() {
    let e = this._baseState;
    return e.any = true, this;
  };
  Gt.prototype.choice = function(e) {
    let r3 = this._baseState;
    return Dr(r3.choice === null), r3.choice = e, this._useArgs(Object.keys(e).map(function(i) {
      return e[i];
    })), this;
  };
  Gt.prototype.contains = function(e) {
    let r3 = this._baseState;
    return Dr(r3.use === null), r3.contains = e, this;
  };
  Gt.prototype._decode = function(e, r3) {
    let i = this._baseState;
    if (i.parent === null)
      return e.wrapResult(i.children[0]._decode(e, r3));
    let n = i.default, s = true, o = null;
    if (i.key !== null && (o = e.enterKey(i.key)), i.optional) {
      let l = null;
      if (i.explicit !== null ? l = i.explicit : i.implicit !== null ? l = i.implicit : i.tag !== null && (l = i.tag), l === null && !i.any) {
        let g5 = e.save();
        try {
          i.choice === null ? this._decodeGeneric(i.tag, e, r3) : this._decodeChoice(e, r3), s = true;
        } catch {
          s = false;
        }
        e.restore(g5);
      } else if (s = this._peekTag(e, l, i.any), e.isError(s))
        return s;
    }
    let f2;
    if (i.obj && s && (f2 = e.enterObject()), s) {
      if (i.explicit !== null) {
        let g5 = this._decodeTag(e, i.explicit);
        if (e.isError(g5))
          return g5;
        e = g5;
      }
      let l = e.offset;
      if (i.use === null && i.choice === null) {
        let g5;
        i.any && (g5 = e.save());
        let _ = this._decodeTag(e, i.implicit !== null ? i.implicit : i.tag, i.any);
        if (e.isError(_))
          return _;
        i.any ? n = e.raw(g5) : e = _;
      }
      if (r3 && r3.track && i.tag !== null && r3.track(e.path(), l, e.length, "tagged"), r3 && r3.track && i.tag !== null && r3.track(e.path(), e.offset, e.length, "content"), i.any || (i.choice === null ? n = this._decodeGeneric(i.tag, e, r3) : n = this._decodeChoice(e, r3)), e.isError(n))
        return n;
      if (!i.any && i.choice === null && i.children !== null && i.children.forEach(function(_) {
        _._decode(e, r3);
      }), i.contains && (i.tag === "octstr" || i.tag === "bitstr")) {
        let g5 = new iI(n);
        n = this._getUse(i.contains, e._reporterState.obj)._decode(g5, r3);
      }
    }
    return i.obj && s && (n = e.leaveObject(f2)), i.key !== null && (n !== null || s === true) ? e.leaveKey(o, i.key, n) : o !== null && e.exitKey(o), n;
  };
  Gt.prototype._decodeGeneric = function(e, r3, i) {
    let n = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r3, e, n.args[0], i) : /str$/.test(e) ? this._decodeStr(r3, e, i) : e === "objid" && n.args ? this._decodeObjid(r3, n.args[0], n.args[1], i) : e === "objid" ? this._decodeObjid(r3, null, null, i) : e === "gentime" || e === "utctime" ? this._decodeTime(r3, e, i) : e === "null_" ? this._decodeNull(r3, i) : e === "bool" ? this._decodeBool(r3, i) : e === "objDesc" ? this._decodeStr(r3, e, i) : e === "int" || e === "enum" ? this._decodeInt(r3, n.args && n.args[0], i) : n.use !== null ? this._getUse(n.use, r3._reporterState.obj)._decode(r3, i) : r3.error("unknown tag: " + e);
  };
  Gt.prototype._getUse = function(e, r3) {
    let i = this._baseState;
    return i.useDecoder = this._use(e, r3), Dr(i.useDecoder._baseState.parent === null), i.useDecoder = i.useDecoder._baseState.children[0], i.implicit !== i.useDecoder._baseState.implicit && (i.useDecoder = i.useDecoder.clone(), i.useDecoder._baseState.implicit = i.implicit), i.useDecoder;
  };
  Gt.prototype._decodeChoice = function(e, r3) {
    let i = this._baseState, n = null, s = false;
    return Object.keys(i.choice).some(function(o) {
      let f2 = e.save(), l = i.choice[o];
      try {
        let g5 = l._decode(e, r3);
        if (e.isError(g5))
          return false;
        n = { type: o, value: g5 }, s = true;
      } catch {
        return e.restore(f2), false;
      }
      return true;
    }, this), s ? n : e.error("Choice not matched");
  };
  Gt.prototype._createEncoderBuffer = function(e) {
    return new rI(e, this.reporter);
  };
  Gt.prototype._encode = function(e, r3, i) {
    let n = this._baseState;
    if (n.default !== null && n.default === e)
      return;
    let s = this._encodeValue(e, r3, i);
    if (s !== void 0 && !this._skipDefault(s, r3, i))
      return s;
  };
  Gt.prototype._encodeValue = function(e, r3, i) {
    let n = this._baseState;
    if (n.parent === null)
      return n.children[0]._encode(e, r3 || new tI());
    let s = null;
    if (this.reporter = r3, n.optional && e === void 0)
      if (n.default !== null)
        e = n.default;
      else
        return;
    let o = null, f2 = false;
    if (n.any)
      s = this._createEncoderBuffer(e);
    else if (n.choice)
      s = this._encodeChoice(e, r3);
    else if (n.contains)
      o = this._getUse(n.contains, i)._encode(e, r3), f2 = true;
    else if (n.children)
      o = n.children.map(function(l) {
        if (l._baseState.tag === "null_")
          return l._encode(null, r3, e);
        if (l._baseState.key === null)
          return r3.error("Child should have a key");
        let g5 = r3.enterKey(l._baseState.key);
        if (typeof e != "object")
          return r3.error("Child expected, but input is not object");
        let _ = l._encode(e[l._baseState.key], r3, e);
        return r3.leaveKey(g5), _;
      }, this).filter(function(l) {
        return l;
      }), o = this._createEncoderBuffer(o);
    else if (n.tag === "seqof" || n.tag === "setof") {
      if (!(n.args && n.args.length === 1))
        return r3.error("Too many args for : " + n.tag);
      if (!Array.isArray(e))
        return r3.error("seqof/setof, but data is not Array");
      let l = this.clone();
      l._baseState.implicit = null, o = this._createEncoderBuffer(e.map(function(g5) {
        let _ = this._baseState;
        return this._getUse(_.args[0], e)._encode(g5, r3);
      }, l));
    } else
      n.use !== null ? s = this._getUse(n.use, i)._encode(e, r3) : (o = this._encodePrimitive(n.tag, e), f2 = true);
    if (!n.any && n.choice === null) {
      let l = n.implicit !== null ? n.implicit : n.tag, g5 = n.implicit === null ? "universal" : "context";
      l === null ? n.use === null && r3.error("Tag could be omitted only for .use()") : n.use === null && (s = this._encodeComposite(l, f2, g5, o));
    }
    return n.explicit !== null && (s = this._encodeComposite(n.explicit, false, "context", s)), s;
  };
  Gt.prototype._encodeChoice = function(e, r3) {
    let i = this._baseState, n = i.choice[e.type];
    return n || Dr(false, e.type + " not found in " + JSON.stringify(Object.keys(i.choice))), n._encode(e.value, r3);
  };
  Gt.prototype._encodePrimitive = function(e, r3) {
    let i = this._baseState;
    if (/str$/.test(e))
      return this._encodeStr(r3, e);
    if (e === "objid" && i.args)
      return this._encodeObjid(r3, i.reverseArgs[0], i.args[1]);
    if (e === "objid")
      return this._encodeObjid(r3, null, null);
    if (e === "gentime" || e === "utctime")
      return this._encodeTime(r3, e);
    if (e === "null_")
      return this._encodeNull();
    if (e === "int" || e === "enum")
      return this._encodeInt(r3, i.args && i.reverseArgs[0]);
    if (e === "bool")
      return this._encodeBool(r3);
    if (e === "objDesc")
      return this._encodeStr(r3, e);
    throw new Error("Unsupported tag: " + e);
  };
  Gt.prototype._isNumstr = function(e) {
    return /^[0-9 ]*$/.test(e);
  };
  Gt.prototype._isPrintstr = function(e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
  };
});
var Vl = k((js) => {
  U();
  function Tw(t) {
    let e = {};
    return Object.keys(t).forEach(function(r3) {
      (r3 | 0) == r3 && (r3 = r3 | 0);
      let i = t[r3];
      e[i] = r3;
    }), e;
  }
  js.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  js.tagClassByName = Tw(js.tagClass);
  js.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  js.tagByName = Tw(js.tag);
});
var A1 = k((NN, kw) => {
  U();
  var aI = At(), gn = Kl().Buffer, Fw = Wl(), _1 = Vl();
  function Rw(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ai(), this.tree._init(t.body);
  }
  kw.exports = Rw;
  Rw.prototype.encode = function(e, r3) {
    return this.tree._encode(e, r3).join();
  };
  function Ai(t) {
    Fw.call(this, "der", t);
  }
  aI(Ai, Fw);
  Ai.prototype._encodeComposite = function(e, r3, i, n) {
    let s = fI(e, r3, i, this.reporter);
    if (n.length < 128) {
      let l = gn.alloc(2);
      return l[0] = s, l[1] = n.length, this._createEncoderBuffer([l, n]);
    }
    let o = 1;
    for (let l = n.length; l >= 256; l >>= 8)
      o++;
    let f2 = gn.alloc(1 + 1 + o);
    f2[0] = s, f2[1] = 128 | o;
    for (let l = 1 + o, g5 = n.length; g5 > 0; l--, g5 >>= 8)
      f2[l] = g5 & 255;
    return this._createEncoderBuffer([f2, n]);
  };
  Ai.prototype._encodeStr = function(e, r3) {
    if (r3 === "bitstr")
      return this._createEncoderBuffer([e.unused | 0, e.data]);
    if (r3 === "bmpstr") {
      let i = gn.alloc(e.length * 2);
      for (let n = 0; n < e.length; n++)
        i.writeUInt16BE(e.charCodeAt(n), n * 2);
      return this._createEncoderBuffer(i);
    } else
      return r3 === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r3 === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r3) ? this._createEncoderBuffer(e) : r3 === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r3 + " unsupported");
  };
  Ai.prototype._encodeObjid = function(e, r3, i) {
    if (typeof e == "string") {
      if (!r3)
        return this.reporter.error("string objid given, but no values map found");
      if (!r3.hasOwnProperty(e))
        return this.reporter.error("objid not found in values map");
      e = r3[e].split(/[\s.]+/g);
      for (let f2 = 0; f2 < e.length; f2++)
        e[f2] |= 0;
    } else if (Array.isArray(e)) {
      e = e.slice();
      for (let f2 = 0; f2 < e.length; f2++)
        e[f2] |= 0;
    }
    if (!Array.isArray(e))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!i) {
      if (e[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      e.splice(0, 2, e[0] * 40 + e[1]);
    }
    let n = 0;
    for (let f2 = 0; f2 < e.length; f2++) {
      let l = e[f2];
      for (n++; l >= 128; l >>= 7)
        n++;
    }
    let s = gn.alloc(n), o = s.length - 1;
    for (let f2 = e.length - 1; f2 >= 0; f2--) {
      let l = e[f2];
      for (s[o--] = l & 127; (l >>= 7) > 0; )
        s[o--] = 128 | l & 127;
    }
    return this._createEncoderBuffer(s);
  };
  function fi(t) {
    return t < 10 ? "0" + t : t;
  }
  Ai.prototype._encodeTime = function(e, r3) {
    let i, n = new Date(e);
    return r3 === "gentime" ? i = [fi(n.getUTCFullYear()), fi(n.getUTCMonth() + 1), fi(n.getUTCDate()), fi(n.getUTCHours()), fi(n.getUTCMinutes()), fi(n.getUTCSeconds()), "Z"].join("") : r3 === "utctime" ? i = [fi(n.getUTCFullYear() % 100), fi(n.getUTCMonth() + 1), fi(n.getUTCDate()), fi(n.getUTCHours()), fi(n.getUTCMinutes()), fi(n.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r3 + " time is not supported yet"), this._encodeStr(i, "octstr");
  };
  Ai.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  Ai.prototype._encodeInt = function(e, r3) {
    if (typeof e == "string") {
      if (!r3)
        return this.reporter.error("String int or enum given, but no values map");
      if (!r3.hasOwnProperty(e))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
      e = r3[e];
    }
    if (typeof e != "number" && !gn.isBuffer(e)) {
      let s = e.toArray();
      !e.sign && s[0] & 128 && s.unshift(0), e = gn.from(s);
    }
    if (gn.isBuffer(e)) {
      let s = e.length;
      e.length === 0 && s++;
      let o = gn.alloc(s);
      return e.copy(o), e.length === 0 && (o[0] = 0), this._createEncoderBuffer(o);
    }
    if (e < 128)
      return this._createEncoderBuffer(e);
    if (e < 256)
      return this._createEncoderBuffer([0, e]);
    let i = 1;
    for (let s = e; s >= 256; s >>= 8)
      i++;
    let n = new Array(i);
    for (let s = n.length - 1; s >= 0; s--)
      n[s] = e & 255, e >>= 8;
    return n[0] & 128 && n.unshift(0), this._createEncoderBuffer(gn.from(n));
  };
  Ai.prototype._encodeBool = function(e) {
    return this._createEncoderBuffer(e ? 255 : 0);
  };
  Ai.prototype._use = function(e, r3) {
    return typeof e == "function" && (e = e(r3)), e._getEncoder("der").tree;
  };
  Ai.prototype._skipDefault = function(e, r3, i) {
    let n = this._baseState, s;
    if (n.default === null)
      return false;
    let o = e.join();
    if (n.defaultBuffer === void 0 && (n.defaultBuffer = this._encodeValue(n.default, r3, i).join()), o.length !== n.defaultBuffer.length)
      return false;
    for (s = 0; s < o.length; s++)
      if (o[s] !== n.defaultBuffer[s])
        return false;
    return true;
  };
  function fI(t, e, r3, i) {
    let n;
    if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), _1.tagByName.hasOwnProperty(t))
      n = _1.tagByName[t];
    else if (typeof t == "number" && (t | 0) === t)
      n = t;
    else
      return i.error("Unknown tag: " + t);
    return n >= 31 ? i.error("Multi-octet tag encoding unsupported") : (e || (n |= 32), n |= _1.tagClassByName[r3 || "universal"] << 6, n);
  }
});
var Nw = k((BN, Dw) => {
  U();
  var cI = At(), E1 = A1();
  function M1(t) {
    E1.call(this, t), this.enc = "pem";
  }
  cI(M1, E1);
  Dw.exports = M1;
  M1.prototype.encode = function(e, r3) {
    let n = E1.prototype.encode.call(this, e).toString("base64"), s = ["-----BEGIN " + r3.label + "-----"];
    for (let o = 0; o < n.length; o += 64)
      s.push(n.slice(o, o + 64));
    return s.push("-----END " + r3.label + "-----"), s.join(`
`);
  };
});
var S1 = k((Cw) => {
  U();
  var Bw = Cw;
  Bw.der = A1();
  Bw.pem = Nw();
});
var T1 = k((ON, Uw) => {
  U();
  var uI = At(), dI = dr(), Ow = na().DecoderBuffer, Lw = Wl(), jw = Vl();
  function qw(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Kr(), this.tree._init(t.body);
  }
  Uw.exports = qw;
  qw.prototype.decode = function(e, r3) {
    return Ow.isDecoderBuffer(e) || (e = new Ow(e, r3)), this.tree._decode(e, r3);
  };
  function Kr(t) {
    Lw.call(this, "der", t);
  }
  uI(Kr, Lw);
  Kr.prototype._peekTag = function(e, r3, i) {
    if (e.isEmpty())
      return false;
    let n = e.save(), s = I1(e, 'Failed to peek tag: "' + r3 + '"');
    return e.isError(s) ? s : (e.restore(n), s.tag === r3 || s.tagStr === r3 || s.tagStr + "of" === r3 || i);
  };
  Kr.prototype._decodeTag = function(e, r3, i) {
    let n = I1(e, 'Failed to decode tag of "' + r3 + '"');
    if (e.isError(n))
      return n;
    let s = Pw(e, n.primitive, 'Failed to get length of "' + r3 + '"');
    if (e.isError(s))
      return s;
    if (!i && n.tag !== r3 && n.tagStr !== r3 && n.tagStr + "of" !== r3)
      return e.error('Failed to match tag: "' + r3 + '"');
    if (n.primitive || s !== null)
      return e.skip(s, 'Failed to match body of: "' + r3 + '"');
    let o = e.save(), f2 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(f2) ? f2 : (s = e.offset - o.offset, e.restore(o), e.skip(s, 'Failed to match body of: "' + r3 + '"'));
  };
  Kr.prototype._skipUntilEnd = function(e, r3) {
    for (; ; ) {
      let i = I1(e, r3);
      if (e.isError(i))
        return i;
      let n = Pw(e, i.primitive, r3);
      if (e.isError(n))
        return n;
      let s;
      if (i.primitive || n !== null ? s = e.skip(n) : s = this._skipUntilEnd(e, r3), e.isError(s))
        return s;
      if (i.tagStr === "end")
        break;
    }
  };
  Kr.prototype._decodeList = function(e, r3, i, n) {
    let s = [];
    for (; !e.isEmpty(); ) {
      let o = this._peekTag(e, "end");
      if (e.isError(o))
        return o;
      let f2 = i.decode(e, "der", n);
      if (e.isError(f2) && o)
        break;
      s.push(f2);
    }
    return s;
  };
  Kr.prototype._decodeStr = function(e, r3) {
    if (r3 === "bitstr") {
      let i = e.readUInt8();
      return e.isError(i) ? i : { unused: i, data: e.raw() };
    } else if (r3 === "bmpstr") {
      let i = e.raw();
      if (i.length % 2 === 1)
        return e.error("Decoding of string type: bmpstr length mismatch");
      let n = "";
      for (let s = 0; s < i.length / 2; s++)
        n += String.fromCharCode(i.readUInt16BE(s * 2));
      return n;
    } else if (r3 === "numstr") {
      let i = e.raw().toString("ascii");
      return this._isNumstr(i) ? i : e.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (r3 === "octstr")
        return e.raw();
      if (r3 === "objDesc")
        return e.raw();
      if (r3 === "printstr") {
        let i = e.raw().toString("ascii");
        return this._isPrintstr(i) ? i : e.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(r3) ? e.raw().toString() : e.error("Decoding of string type: " + r3 + " unsupported");
    }
  };
  Kr.prototype._decodeObjid = function(e, r3, i) {
    let n, s = [], o = 0, f2 = 0;
    for (; !e.isEmpty(); )
      f2 = e.readUInt8(), o <<= 7, o |= f2 & 127, (f2 & 128) === 0 && (s.push(o), o = 0);
    f2 & 128 && s.push(o);
    let l = s[0] / 40 | 0, g5 = s[0] % 40;
    if (i ? n = s : n = [l, g5].concat(s.slice(1)), r3) {
      let _ = r3[n.join(" ")];
      _ === void 0 && (_ = r3[n.join(".")]), _ !== void 0 && (n = _);
    }
    return n;
  };
  Kr.prototype._decodeTime = function(e, r3) {
    let i = e.raw().toString(), n, s, o, f2, l, g5;
    if (r3 === "gentime")
      n = i.slice(0, 4) | 0, s = i.slice(4, 6) | 0, o = i.slice(6, 8) | 0, f2 = i.slice(8, 10) | 0, l = i.slice(10, 12) | 0, g5 = i.slice(12, 14) | 0;
    else if (r3 === "utctime")
      n = i.slice(0, 2) | 0, s = i.slice(2, 4) | 0, o = i.slice(4, 6) | 0, f2 = i.slice(6, 8) | 0, l = i.slice(8, 10) | 0, g5 = i.slice(10, 12) | 0, n < 70 ? n = 2e3 + n : n = 1900 + n;
    else
      return e.error("Decoding " + r3 + " time is not supported yet");
    return Date.UTC(n, s - 1, o, f2, l, g5, 0);
  };
  Kr.prototype._decodeNull = function() {
    return null;
  };
  Kr.prototype._decodeBool = function(e) {
    let r3 = e.readUInt8();
    return e.isError(r3) ? r3 : r3 !== 0;
  };
  Kr.prototype._decodeInt = function(e, r3) {
    let i = e.raw(), n = new dI(i);
    return r3 && (n = r3[n.toString(10)] || n), n;
  };
  Kr.prototype._use = function(e, r3) {
    return typeof e == "function" && (e = e(r3)), e._getDecoder("der").tree;
  };
  function I1(t, e) {
    let r3 = t.readUInt8(e);
    if (t.isError(r3))
      return r3;
    let i = jw.tagClass[r3 >> 6], n = (r3 & 32) === 0;
    if ((r3 & 31) === 31) {
      let o = r3;
      for (r3 = 0; (o & 128) === 128; ) {
        if (o = t.readUInt8(e), t.isError(o))
          return o;
        r3 <<= 7, r3 |= o & 127;
      }
    } else
      r3 &= 31;
    let s = jw.tag[r3];
    return { cls: i, primitive: n, tag: r3, tagStr: s };
  }
  function Pw(t, e, r3) {
    let i = t.readUInt8(r3);
    if (t.isError(i))
      return i;
    if (!e && i === 128)
      return null;
    if ((i & 128) === 0)
      return i;
    let n = i & 127;
    if (n > 4)
      return t.error("length octect is too long");
    i = 0;
    for (let s = 0; s < n; s++) {
      i <<= 8;
      let o = t.readUInt8(r3);
      if (t.isError(o))
        return o;
      i |= o;
    }
    return i;
  }
});
var Hw = k((jN, zw) => {
  U();
  var lI = At(), hI = Kl().Buffer, F1 = T1();
  function R1(t) {
    F1.call(this, t), this.enc = "pem";
  }
  lI(R1, F1);
  zw.exports = R1;
  R1.prototype.decode = function(e, r3) {
    let i = e.toString().split(/[\r\n]+/g), n = r3.label.toUpperCase(), s = /^-----(BEGIN|END) ([^-]+)-----$/, o = -1, f2 = -1;
    for (let _ = 0; _ < i.length; _++) {
      let N2 = i[_].match(s);
      if (N2 !== null && N2[2] === n)
        if (o === -1) {
          if (N2[1] !== "BEGIN")
            break;
          o = _;
        } else {
          if (N2[1] !== "END")
            break;
          f2 = _;
          break;
        }
    }
    if (o === -1 || f2 === -1)
      throw new Error("PEM section not found for: " + n);
    let l = i.slice(o + 1, f2).join("");
    l.replace(/[^a-z0-9+/=]+/gi, "");
    let g5 = hI.from(l, "base64");
    return F1.prototype.decode.call(this, g5, r3);
  };
});
var k1 = k((Gw) => {
  U();
  var Kw = Gw;
  Kw.der = T1();
  Kw.pem = Hw();
});
var Ww = k(($w) => {
  U();
  var pI = S1(), gI = k1(), mI = At(), yI = $w;
  yI.define = function(e, r3) {
    return new sa(e, r3);
  };
  function sa(t, e) {
    this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
  }
  sa.prototype._createNamed = function(e) {
    let r3 = this.name;
    function i(n) {
      this._initNamed(n, r3);
    }
    return mI(i, e), i.prototype._initNamed = function(s, o) {
      e.call(this, s, o);
    }, new i(this);
  };
  sa.prototype._getDecoder = function(e) {
    return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(gI[e])), this.decoders[e];
  };
  sa.prototype.decode = function(e, r3, i) {
    return this._getDecoder(r3).decode(e, i);
  };
  sa.prototype._getEncoder = function(e) {
    return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(pI[e])), this.encoders[e];
  };
  sa.prototype.encode = function(e, r3, i) {
    return this._getEncoder(r3).encode(e, i);
  };
});
var Yw = k((Vw) => {
  U();
  var Yl = Vw;
  Yl.Reporter = Gl().Reporter;
  Yl.DecoderBuffer = na().DecoderBuffer;
  Yl.EncoderBuffer = na().EncoderBuffer;
  Yl.Node = Wl();
});
var Xw = k((Jw) => {
  U();
  var Zw = Jw;
  Zw._reverse = function(e) {
    let r3 = {};
    return Object.keys(e).forEach(function(i) {
      (i | 0) == i && (i = i | 0);
      let n = e[i];
      r3[n] = i;
    }), r3;
  };
  Zw.der = Vl();
});
var D1 = k((Qw) => {
  U();
  var oa = Qw;
  oa.bignum = dr();
  oa.define = Ww().define;
  oa.base = Yw();
  oa.constants = Xw();
  oa.decoders = k1();
  oa.encoders = S1();
});
var i6 = k((HN, r6) => {
  U();
  var Ei = D1(), e6 = Ei.define("Time", function() {
    this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
  }), bI = Ei.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), N1 = Ei.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), vI = Ei.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(N1), this.key("subjectPublicKey").bitstr());
  }), xI = Ei.define("RelativeDistinguishedName", function() {
    this.setof(bI);
  }), wI = Ei.define("RDNSequence", function() {
    this.seqof(xI);
  }), t6 = Ei.define("Name", function() {
    this.choice({ rdnSequence: this.use(wI) });
  }), _I = Ei.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(e6), this.key("notAfter").use(e6));
  }), AI = Ei.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  }), EI = Ei.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(N1), this.key("issuer").use(t6), this.key("validity").use(_I), this.key("subject").use(t6), this.key("subjectPublicKeyInfo").use(vI), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(AI).optional());
  }), MI = Ei.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(EI), this.key("signatureAlgorithm").use(N1), this.key("signatureValue").bitstr());
  });
  r6.exports = MI;
});
var s6 = k((Si) => {
  U();
  var Mi = D1();
  Si.certificate = i6();
  var SI = Mi.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  Si.RSAPrivateKey = SI;
  var II = Mi.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  Si.RSAPublicKey = II;
  var TI = Mi.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(n6), this.key("subjectPublicKey").bitstr());
  });
  Si.PublicKey = TI;
  var n6 = Mi.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), FI = Mi.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(n6), this.key("subjectPrivateKey").octstr());
  });
  Si.PrivateKey = FI;
  var RI = Mi.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  Si.EncryptedPrivateKey = RI;
  var kI = Mi.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  Si.DSAPrivateKey = kI;
  Si.DSAparam = Mi.define("DSAparam", function() {
    this.int();
  });
  var DI = Mi.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(NI), this.key("publicKey").optional().explicit(1).bitstr());
  });
  Si.ECPrivateKey = DI;
  var NI = Mi.define("ECParameters", function() {
    this.choice({ namedCurve: this.objid() });
  });
  Si.signature = Mi.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
});
var o6 = k((GN, BI) => {
  BI.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
});
var f6 = k(($N, a6) => {
  U();
  var CI = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, OI = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, jI = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, LI = Yf(), qI = xl(), Zl = Mt().Buffer;
  a6.exports = function(t, e) {
    var r3 = t.toString(), i = r3.match(CI), n;
    if (i) {
      var o = "aes" + i[1], f2 = Zl.from(i[2], "hex"), l = Zl.from(i[3].replace(/[\r\n]/g, ""), "base64"), g5 = LI(e, f2.slice(0, 8), parseInt(i[1], 10)).key, _ = [], N2 = qI.createDecipheriv(o, g5, f2);
      _.push(N2.update(l)), _.push(N2.final()), n = Zl.concat(_);
    } else {
      var s = r3.match(jI);
      n = Zl.from(s[2].replace(/[\r\n]/g, ""), "base64");
    }
    var U2 = r3.match(OI)[1];
    return { tag: U2, data: n };
  };
});
var ic = k((WN, u6) => {
  U();
  var Pr = s6(), PI = o6(), UI = f6(), zI = xl(), HI = _p(), B1 = Mt().Buffer;
  u6.exports = c6;
  function c6(t) {
    var e;
    typeof t == "object" && !B1.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = B1.from(t));
    var r3 = UI(t, e), i = r3.tag, n = r3.data, s, o;
    switch (i) {
      case "CERTIFICATE":
        o = Pr.certificate.decode(n, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (o || (o = Pr.PublicKey.decode(n, "der")), s = o.algorithm.algorithm.join("."), s) {
          case "1.2.840.113549.1.1.1":
            return Pr.RSAPublicKey.decode(o.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return o.subjectPrivateKey = o.subjectPublicKey, { type: "ec", data: o };
          case "1.2.840.10040.4.1":
            return o.algorithm.params.pub_key = Pr.DSAparam.decode(o.subjectPublicKey.data, "der"), { type: "dsa", data: o.algorithm.params };
          default:
            throw new Error("unknown key id " + s);
        }
      case "ENCRYPTED PRIVATE KEY":
        n = Pr.EncryptedPrivateKey.decode(n, "der"), n = KI(n, e);
      case "PRIVATE KEY":
        switch (o = Pr.PrivateKey.decode(n, "der"), s = o.algorithm.algorithm.join("."), s) {
          case "1.2.840.113549.1.1.1":
            return Pr.RSAPrivateKey.decode(o.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return { curve: o.algorithm.curve, privateKey: Pr.ECPrivateKey.decode(o.subjectPrivateKey, "der").privateKey };
          case "1.2.840.10040.4.1":
            return o.algorithm.params.priv_key = Pr.DSAparam.decode(o.subjectPrivateKey, "der"), { type: "dsa", params: o.algorithm.params };
          default:
            throw new Error("unknown key id " + s);
        }
      case "RSA PUBLIC KEY":
        return Pr.RSAPublicKey.decode(n, "der");
      case "RSA PRIVATE KEY":
        return Pr.RSAPrivateKey.decode(n, "der");
      case "DSA PRIVATE KEY":
        return { type: "dsa", params: Pr.DSAPrivateKey.decode(n, "der") };
      case "EC PRIVATE KEY":
        return n = Pr.ECPrivateKey.decode(n, "der"), { curve: n.parameters.value, privateKey: n.privateKey };
      default:
        throw new Error("unknown key type " + i);
    }
  }
  c6.signature = Pr.signature;
  function KI(t, e) {
    var r3 = t.algorithm.decrypt.kde.kdeparams.salt, i = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), n = PI[t.algorithm.decrypt.cipher.algo.join(".")], s = t.algorithm.decrypt.cipher.iv, o = t.subjectPrivateKey, f2 = parseInt(n.split("-")[1], 10) / 8, l = HI.pbkdf2Sync(e, r3, i, f2, "sha1"), g5 = zI.createDecipheriv(n, l, s), _ = [];
    return _.push(g5.update(o)), _.push(g5.final()), B1.concat(_);
  }
});
var C1 = k((VN, GI) => {
  GI.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
});
var h6 = k((YN, Xl) => {
  U();
  var Fr = Mt().Buffer, Ls = lp(), $I = Ml(), WI = zl().ec, Jl = El(), VI = ic(), YI = C1();
  function ZI(t, e, r3, i, n) {
    var s = VI(e);
    if (s.curve) {
      if (i !== "ecdsa" && i !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return JI(t, s);
    } else if (s.type === "dsa") {
      if (i !== "dsa")
        throw new Error("wrong private key type");
      return XI(t, s, r3);
    } else if (i !== "rsa" && i !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    t = Fr.concat([n, t]);
    for (var o = s.modulus.byteLength(), f2 = [0, 1]; t.length + f2.length + 1 < o; )
      f2.push(255);
    f2.push(0);
    for (var l = -1; ++l < t.length; )
      f2.push(t[l]);
    var g5 = $I(f2, s);
    return g5;
  }
  function JI(t, e) {
    var r3 = YI[e.curve.join(".")];
    if (!r3)
      throw new Error("unknown curve " + e.curve.join("."));
    var i = new WI(r3), n = i.keyFromPrivate(e.privateKey), s = n.sign(t);
    return Fr.from(s.toDER());
  }
  function XI(t, e, r3) {
    for (var i = e.params.priv_key, n = e.params.p, s = e.params.q, o = e.params.g, f2 = new Jl(0), l, g5 = O1(t, s).mod(s), _ = false, N2 = d6(i, s, t, r3); _ === false; )
      l = l6(s, N2, r3), f2 = tT(o, l, n, s), _ = l.invm(s).imul(g5.add(i.mul(f2))).mod(s), _.cmpn(0) === 0 && (_ = false, f2 = new Jl(0));
    return QI(f2, _);
  }
  function QI(t, e) {
    t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
    var r3 = t.length + e.length + 4, i = [48, r3, 2, t.length];
    return i = i.concat(t, [2, e.length], e), Fr.from(i);
  }
  function d6(t, e, r3, i) {
    if (t = Fr.from(t.toArray()), t.length < e.byteLength()) {
      var n = Fr.alloc(e.byteLength() - t.length);
      t = Fr.concat([n, t]);
    }
    var s = r3.length, o = eT(r3, e), f2 = Fr.alloc(s);
    f2.fill(1);
    var l = Fr.alloc(s);
    return l = Ls(i, l).update(f2).update(Fr.from([0])).update(t).update(o).digest(), f2 = Ls(i, l).update(f2).digest(), l = Ls(i, l).update(f2).update(Fr.from([1])).update(t).update(o).digest(), f2 = Ls(i, l).update(f2).digest(), { k: l, v: f2 };
  }
  function O1(t, e) {
    var r3 = new Jl(t), i = (t.length << 3) - e.bitLength();
    return i > 0 && r3.ishrn(i), r3;
  }
  function eT(t, e) {
    t = O1(t, e), t = t.mod(e);
    var r3 = Fr.from(t.toArray());
    if (r3.length < e.byteLength()) {
      var i = Fr.alloc(e.byteLength() - r3.length);
      r3 = Fr.concat([i, r3]);
    }
    return r3;
  }
  function l6(t, e, r3) {
    var i, n;
    do {
      for (i = Fr.alloc(0); i.length * 8 < t.bitLength(); )
        e.v = Ls(r3, e.k).update(e.v).digest(), i = Fr.concat([i, e.v]);
      n = O1(i, t), e.k = Ls(r3, e.k).update(e.v).update(Fr.from([0])).digest(), e.v = Ls(r3, e.k).update(e.v).digest();
    } while (n.cmp(t) !== -1);
    return n;
  }
  function tT(t, e, r3, i) {
    return t.toRed(Jl.mont(r3)).redPow(e).fromRed().mod(i);
  }
  Xl.exports = ZI;
  Xl.exports.getKey = d6;
  Xl.exports.makeKey = l6;
});
var y6 = k((ZN, m6) => {
  U();
  var j1 = Mt().Buffer, nc = El(), rT = zl().ec, g6 = ic(), iT = C1();
  function nT(t, e, r3, i, n) {
    var s = g6(r3);
    if (s.type === "ec") {
      if (i !== "ecdsa" && i !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return sT(t, e, s);
    } else if (s.type === "dsa") {
      if (i !== "dsa")
        throw new Error("wrong public key type");
      return oT(t, e, s);
    } else if (i !== "rsa" && i !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    e = j1.concat([n, e]);
    for (var o = s.modulus.byteLength(), f2 = [1], l = 0; e.length + f2.length + 2 < o; )
      f2.push(255), l++;
    f2.push(0);
    for (var g5 = -1; ++g5 < e.length; )
      f2.push(e[g5]);
    f2 = j1.from(f2);
    var _ = nc.mont(s.modulus);
    t = new nc(t).toRed(_), t = t.redPow(new nc(s.publicExponent)), t = j1.from(t.fromRed().toArray());
    var N2 = l < 8 ? 1 : 0;
    for (o = Math.min(t.length, f2.length), t.length !== f2.length && (N2 = 1), g5 = -1; ++g5 < o; )
      N2 |= t[g5] ^ f2[g5];
    return N2 === 0;
  }
  function sT(t, e, r3) {
    var i = iT[r3.data.algorithm.curve.join(".")];
    if (!i)
      throw new Error("unknown curve " + r3.data.algorithm.curve.join("."));
    var n = new rT(i), s = r3.data.subjectPrivateKey.data;
    return n.verify(e, t, s);
  }
  function oT(t, e, r3) {
    var i = r3.data.p, n = r3.data.q, s = r3.data.g, o = r3.data.pub_key, f2 = g6.signature.decode(t, "der"), l = f2.s, g5 = f2.r;
    p6(l, n), p6(g5, n);
    var _ = nc.mont(i), N2 = l.invm(n), U2 = s.toRed(_).redPow(new nc(e).mul(N2).mod(n)).fromRed().mul(o.toRed(_).redPow(g5.mul(N2).mod(n)).fromRed()).mod(i).mod(n);
    return U2.cmp(g5) === 0;
  }
  function p6(t, e) {
    if (t.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (t.cmp(e) >= e)
      throw new Error("invalid sig");
  }
  m6.exports = nT;
});
var A6 = k((JN, _6) => {
  U();
  var Ql = Mt().Buffer, x6 = Bo(), eh = ip(), w6 = At(), aT = h6(), fT = y6(), qs = hp();
  Object.keys(qs).forEach(function(t) {
    qs[t].id = Ql.from(qs[t].id, "hex"), qs[t.toLowerCase()] = qs[t];
  });
  function sc(t) {
    eh.Writable.call(this);
    var e = qs[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hashType = e.hash, this._hash = x6(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  w6(sc, eh.Writable);
  sc.prototype._write = function(e, r3, i) {
    this._hash.update(e), i();
  };
  sc.prototype.update = function(e, r3) {
    return typeof e == "string" && (e = Ql.from(e, r3)), this._hash.update(e), this;
  };
  sc.prototype.sign = function(e, r3) {
    this.end();
    var i = this._hash.digest(), n = aT(i, e, this._hashType, this._signType, this._tag);
    return r3 ? n.toString(r3) : n;
  };
  function oc(t) {
    eh.Writable.call(this);
    var e = qs[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hash = x6(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  w6(oc, eh.Writable);
  oc.prototype._write = function(e, r3, i) {
    this._hash.update(e), i();
  };
  oc.prototype.update = function(e, r3) {
    return typeof e == "string" && (e = Ql.from(e, r3)), this._hash.update(e), this;
  };
  oc.prototype.verify = function(e, r3, i) {
    typeof r3 == "string" && (r3 = Ql.from(r3, i)), this.end();
    var n = this._hash.digest();
    return fT(r3, n, e, this._signType, this._tag);
  };
  function b6(t) {
    return new sc(t);
  }
  function v6(t) {
    return new oc(t);
  }
  _6.exports = { Sign: b6, Verify: v6, createSign: b6, createVerify: v6 };
});
var M6 = k((XN, E6) => {
  U();
  var cT = zl(), uT = dr();
  E6.exports = function(e) {
    return new Ps(e);
  };
  var Gr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  Gr.p224 = Gr.secp224r1;
  Gr.p256 = Gr.secp256r1 = Gr.prime256v1;
  Gr.p192 = Gr.secp192r1 = Gr.prime192v1;
  Gr.p384 = Gr.secp384r1;
  Gr.p521 = Gr.secp521r1;
  function Ps(t) {
    this.curveType = Gr[t], this.curveType || (this.curveType = { name: t }), this.curve = new cT.ec(this.curveType.name), this.keys = void 0;
  }
  Ps.prototype.generateKeys = function(t, e) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
  };
  Ps.prototype.computeSecret = function(t, e, r3) {
    e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e));
    var i = this.curve.keyFromPublic(t).getPublic(), n = i.mul(this.keys.getPrivate()).getX();
    return L1(n, r3, this.curveType.byteLength);
  };
  Ps.prototype.getPublicKey = function(t, e) {
    var r3 = this.keys.getPublic(e === "compressed", true);
    return e === "hybrid" && (r3[r3.length - 1] % 2 ? r3[0] = 7 : r3[0] = 6), L1(r3, t);
  };
  Ps.prototype.getPrivateKey = function(t) {
    return L1(this.keys.getPrivate(), t);
  };
  Ps.prototype.setPublicKey = function(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this.keys._importPublic(t), this;
  };
  Ps.prototype.setPrivateKey = function(t, e) {
    e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e));
    var r3 = new uT(t);
    return r3 = r3.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r3), this;
  };
  function L1(t, e, r3) {
    Array.isArray(t) || (t = t.toArray());
    var i = new b.Buffer(t);
    if (r3 && i.length < r3) {
      var n = new b.Buffer(r3 - i.length);
      n.fill(0), i = b.Buffer.concat([n, i]);
    }
    return e ? i.toString(e) : i;
  }
});
var P1 = k((QN, S6) => {
  U();
  var dT = Bo(), q1 = Mt().Buffer;
  S6.exports = function(t, e) {
    for (var r3 = q1.alloc(0), i = 0, n; r3.length < e; )
      n = lT(i++), r3 = q1.concat([r3, dT("sha1").update(t).update(n).digest()]);
    return r3.slice(0, e);
  };
  function lT(t) {
    var e = q1.allocUnsafe(4);
    return e.writeUInt32BE(t, 0), e;
  }
});
var U1 = k((eB, I6) => {
  U();
  I6.exports = function(e, r3) {
    for (var i = e.length, n = -1; ++n < i; )
      e[n] ^= r3[n];
    return e;
  };
});
var z1 = k((tB, F6) => {
  U();
  var T6 = dr(), hT = Mt().Buffer;
  function pT(t, e) {
    return hT.from(t.toRed(T6.mont(e.modulus)).redPow(new T6(e.publicExponent)).fromRed().toArray());
  }
  F6.exports = pT;
});
var N6 = k((rB, D6) => {
  U();
  var gT = ic(), H1 = us(), mT = Bo(), R6 = P1(), k6 = U1(), K1 = dr(), yT = z1(), bT = Ml(), Ii = Mt().Buffer;
  D6.exports = function(e, r3, i) {
    var n;
    e.padding ? n = e.padding : i ? n = 1 : n = 4;
    var s = gT(e), o;
    if (n === 4)
      o = vT(s, r3);
    else if (n === 1)
      o = xT(s, r3, i);
    else if (n === 3) {
      if (o = new K1(r3), o.cmp(s.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return i ? bT(o, s) : yT(o, s);
  };
  function vT(t, e) {
    var r3 = t.modulus.byteLength(), i = e.length, n = mT("sha1").update(Ii.alloc(0)).digest(), s = n.length, o = 2 * s;
    if (i > r3 - o - 2)
      throw new Error("message too long");
    var f2 = Ii.alloc(r3 - i - o - 2), l = r3 - s - 1, g5 = H1(s), _ = k6(Ii.concat([n, f2, Ii.alloc(1, 1), e], l), R6(g5, l)), N2 = k6(g5, R6(_, s));
    return new K1(Ii.concat([Ii.alloc(1), N2, _], r3));
  }
  function xT(t, e, r3) {
    var i = e.length, n = t.modulus.byteLength();
    if (i > n - 11)
      throw new Error("message too long");
    var s;
    return r3 ? s = Ii.alloc(n - i - 3, 255) : s = wT(n - i - 3), new K1(Ii.concat([Ii.from([0, r3 ? 1 : 2]), s, Ii.alloc(1), e], n));
  }
  function wT(t) {
    for (var e = Ii.allocUnsafe(t), r3 = 0, i = H1(t * 2), n = 0, s; r3 < t; )
      n === i.length && (i = H1(t * 2), n = 0), s = i[n++], s && (e[r3++] = s);
    return e;
  }
});
var L6 = k((iB, j6) => {
  U();
  var _T = ic(), B6 = P1(), C6 = U1(), O6 = dr(), AT = Ml(), ET = Bo(), MT = z1(), ac = Mt().Buffer;
  j6.exports = function(e, r3, i) {
    var n;
    e.padding ? n = e.padding : i ? n = 1 : n = 4;
    var s = _T(e), o = s.modulus.byteLength();
    if (r3.length > o || new O6(r3).cmp(s.modulus) >= 0)
      throw new Error("decryption error");
    var f2;
    i ? f2 = MT(new O6(r3), s) : f2 = AT(r3, s);
    var l = ac.alloc(o - f2.length);
    if (f2 = ac.concat([l, f2], o), n === 4)
      return ST(s, f2);
    if (n === 1)
      return IT(s, f2, i);
    if (n === 3)
      return f2;
    throw new Error("unknown padding");
  };
  function ST(t, e) {
    var r3 = t.modulus.byteLength(), i = ET("sha1").update(ac.alloc(0)).digest(), n = i.length;
    if (e[0] !== 0)
      throw new Error("decryption error");
    var s = e.slice(1, n + 1), o = e.slice(n + 1), f2 = C6(s, B6(o, n)), l = C6(o, B6(f2, r3 - n - 1));
    if (TT(i, l.slice(0, n)))
      throw new Error("decryption error");
    for (var g5 = n; l[g5] === 0; )
      g5++;
    if (l[g5++] !== 1)
      throw new Error("decryption error");
    return l.slice(g5);
  }
  function IT(t, e, r3) {
    for (var i = e.slice(0, 2), n = 2, s = 0; e[n++] !== 0; )
      if (n >= e.length) {
        s++;
        break;
      }
    var o = e.slice(2, n - 1);
    if ((i.toString("hex") !== "0002" && !r3 || i.toString("hex") !== "0001" && r3) && s++, o.length < 8 && s++, s)
      throw new Error("decryption error");
    return e.slice(n);
  }
  function TT(t, e) {
    t = ac.from(t), e = ac.from(e);
    var r3 = 0, i = t.length;
    t.length !== e.length && (r3++, i = Math.min(t.length, e.length));
    for (var n = -1; ++n < i; )
      r3 += t[n] ^ e[n];
    return r3;
  }
});
var q6 = k((Us) => {
  U();
  Us.publicEncrypt = N6();
  Us.privateDecrypt = L6();
  Us.privateEncrypt = function(e, r3) {
    return Us.publicEncrypt(e, r3, true);
  };
  Us.publicDecrypt = function(e, r3) {
    return Us.privateDecrypt(e, r3, true);
  };
});
var Y6 = k((fc) => {
  U();
  function P6() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var z6 = Mt(), U6 = us(), H6 = z6.Buffer, K6 = z6.kMaxLength, G1 = N.crypto || N.msCrypto, G6 = Math.pow(2, 32) - 1;
  function $6(t, e) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("offset must be a number");
    if (t > G6 || t < 0)
      throw new TypeError("offset must be a uint32");
    if (t > K6 || t > e)
      throw new RangeError("offset out of range");
  }
  function W6(t, e, r3) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("size must be a number");
    if (t > G6 || t < 0)
      throw new TypeError("size must be a uint32");
    if (t + e > r3 || t > K6)
      throw new RangeError("buffer too small");
  }
  G1 && G1.getRandomValues || !W.default.browser ? (fc.randomFill = FT, fc.randomFillSync = RT) : (fc.randomFill = P6, fc.randomFillSync = P6);
  function FT(t, e, r3, i) {
    if (!H6.isBuffer(t) && !(t instanceof N.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof e == "function")
      i = e, e = 0, r3 = t.length;
    else if (typeof r3 == "function")
      i = r3, r3 = t.length - e;
    else if (typeof i != "function")
      throw new TypeError('"cb" argument must be a function');
    return $6(e, t.length), W6(r3, e, t.length), V6(t, e, r3, i);
  }
  function V6(t, e, r3, i) {
    if (W.default.browser) {
      var n = t.buffer, s = new Uint8Array(n, e, r3);
      if (G1.getRandomValues(s), i) {
        W.default.nextTick(function() {
          i(null, t);
        });
        return;
      }
      return t;
    }
    if (i) {
      U6(r3, function(f2, l) {
        if (f2)
          return i(f2);
        l.copy(t, e), i(null, t);
      });
      return;
    }
    var o = U6(r3);
    return o.copy(t, e), t;
  }
  function RT(t, e, r3) {
    if (typeof e > "u" && (e = 0), !H6.isBuffer(t) && !(t instanceof N.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return $6(e, t.length), r3 === void 0 && (r3 = t.length - e), W6(r3, e, t.length), V6(t, e, r3);
  }
});
var Gp = k((St) => {
  U();
  St.randomBytes = St.rng = St.pseudoRandomBytes = St.prng = us();
  St.createHash = St.Hash = Bo();
  St.createHmac = St.Hmac = lp();
  var kT = g2(), DT = Object.keys(kT), NT = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(DT);
  St.getHashes = function() {
    return NT;
  };
  var Z6 = _p();
  St.pbkdf2 = Z6.pbkdf2;
  St.pbkdf2Sync = Z6.pbkdf2Sync;
  var Gi = jv();
  St.Cipher = Gi.Cipher;
  St.createCipher = Gi.createCipher;
  St.Cipheriv = Gi.Cipheriv;
  St.createCipheriv = Gi.createCipheriv;
  St.Decipher = Gi.Decipher;
  St.createDecipher = Gi.createDecipher;
  St.Decipheriv = Gi.Decipheriv;
  St.createDecipheriv = Gi.createDecipheriv;
  St.getCiphers = Gi.getCiphers;
  St.listCiphers = Gi.listCiphers;
  var cc = Zv();
  St.DiffieHellmanGroup = cc.DiffieHellmanGroup;
  St.createDiffieHellmanGroup = cc.createDiffieHellmanGroup;
  St.getDiffieHellman = cc.getDiffieHellman;
  St.createDiffieHellman = cc.createDiffieHellman;
  St.DiffieHellman = cc.DiffieHellman;
  var th = A6();
  St.createSign = th.createSign;
  St.Sign = th.Sign;
  St.createVerify = th.createVerify;
  St.Verify = th.Verify;
  St.createECDH = M6();
  var rh = q6();
  St.publicEncrypt = rh.publicEncrypt;
  St.privateEncrypt = rh.privateEncrypt;
  St.publicDecrypt = rh.publicDecrypt;
  St.privateDecrypt = rh.privateDecrypt;
  var J6 = Y6();
  St.randomFill = J6.randomFill;
  St.randomFillSync = J6.randomFillSync;
  St.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  };
  St.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
});
var X6 = k((aB, ih) => {
  U();
  (function(t) {
    var e = function(S2) {
      var D2, k2 = new Float64Array(16);
      if (S2)
        for (D2 = 0; D2 < S2.length; D2++)
          k2[D2] = S2[D2];
      return k2;
    }, r3 = function() {
      throw new Error("no PRNG");
    }, i = new Uint8Array(16), n = new Uint8Array(32);
    n[0] = 9;
    var s = e(), o = e([1]), f2 = e([56129, 1]), l = e([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), g5 = e([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), _ = e([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), N2 = e([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), U2 = e([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function V(S2, D2, k2, p2) {
      S2[D2] = k2 >> 24 & 255, S2[D2 + 1] = k2 >> 16 & 255, S2[D2 + 2] = k2 >> 8 & 255, S2[D2 + 3] = k2 & 255, S2[D2 + 4] = p2 >> 24 & 255, S2[D2 + 5] = p2 >> 16 & 255, S2[D2 + 6] = p2 >> 8 & 255, S2[D2 + 7] = p2 & 255;
    }
    function G(S2, D2, k2, p2, C2) {
      var Q2, he = 0;
      for (Q2 = 0; Q2 < C2; Q2++)
        he |= S2[D2 + Q2] ^ k2[p2 + Q2];
      return (1 & he - 1 >>> 8) - 1;
    }
    function ee2(S2, D2, k2, p2) {
      return G(S2, D2, k2, p2, 16);
    }
    function W5(S2, D2, k2, p2) {
      return G(S2, D2, k2, p2, 32);
    }
    function Z(S2, D2, k2, p2) {
      for (var C2 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, Q2 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, he = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, ge2 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, Ee = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, Ve2 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, Ne = D2[0] & 255 | (D2[1] & 255) << 8 | (D2[2] & 255) << 16 | (D2[3] & 255) << 24, tt = D2[4] & 255 | (D2[5] & 255) << 8 | (D2[6] & 255) << 16 | (D2[7] & 255) << 24, He = D2[8] & 255 | (D2[9] & 255) << 8 | (D2[10] & 255) << 16 | (D2[11] & 255) << 24, it = D2[12] & 255 | (D2[13] & 255) << 8 | (D2[14] & 255) << 16 | (D2[15] & 255) << 24, nt = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, dt = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, ut = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, st = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, at = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, ot = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, Ge2 = C2, Ye2 = Q2, ze = he, $e = ge2, We = Ee, qe = Ve2, ve = Ne, xe2 = tt, ke = He, Ie = it, Te = nt, Be = dt, ft = ut, vt = st, _t = at, xt = ot, Y, It = 0; It < 20; It += 2)
        Y = Ge2 + ft | 0, We ^= Y << 7 | Y >>> 32 - 7, Y = We + Ge2 | 0, ke ^= Y << 9 | Y >>> 32 - 9, Y = ke + We | 0, ft ^= Y << 13 | Y >>> 32 - 13, Y = ft + ke | 0, Ge2 ^= Y << 18 | Y >>> 32 - 18, Y = qe + Ye2 | 0, Ie ^= Y << 7 | Y >>> 32 - 7, Y = Ie + qe | 0, vt ^= Y << 9 | Y >>> 32 - 9, Y = vt + Ie | 0, Ye2 ^= Y << 13 | Y >>> 32 - 13, Y = Ye2 + vt | 0, qe ^= Y << 18 | Y >>> 32 - 18, Y = Te + ve | 0, _t ^= Y << 7 | Y >>> 32 - 7, Y = _t + Te | 0, ze ^= Y << 9 | Y >>> 32 - 9, Y = ze + _t | 0, ve ^= Y << 13 | Y >>> 32 - 13, Y = ve + ze | 0, Te ^= Y << 18 | Y >>> 32 - 18, Y = xt + Be | 0, $e ^= Y << 7 | Y >>> 32 - 7, Y = $e + xt | 0, xe2 ^= Y << 9 | Y >>> 32 - 9, Y = xe2 + $e | 0, Be ^= Y << 13 | Y >>> 32 - 13, Y = Be + xe2 | 0, xt ^= Y << 18 | Y >>> 32 - 18, Y = Ge2 + $e | 0, Ye2 ^= Y << 7 | Y >>> 32 - 7, Y = Ye2 + Ge2 | 0, ze ^= Y << 9 | Y >>> 32 - 9, Y = ze + Ye2 | 0, $e ^= Y << 13 | Y >>> 32 - 13, Y = $e + ze | 0, Ge2 ^= Y << 18 | Y >>> 32 - 18, Y = qe + We | 0, ve ^= Y << 7 | Y >>> 32 - 7, Y = ve + qe | 0, xe2 ^= Y << 9 | Y >>> 32 - 9, Y = xe2 + ve | 0, We ^= Y << 13 | Y >>> 32 - 13, Y = We + xe2 | 0, qe ^= Y << 18 | Y >>> 32 - 18, Y = Te + Ie | 0, Be ^= Y << 7 | Y >>> 32 - 7, Y = Be + Te | 0, ke ^= Y << 9 | Y >>> 32 - 9, Y = ke + Be | 0, Ie ^= Y << 13 | Y >>> 32 - 13, Y = Ie + ke | 0, Te ^= Y << 18 | Y >>> 32 - 18, Y = xt + _t | 0, ft ^= Y << 7 | Y >>> 32 - 7, Y = ft + xt | 0, vt ^= Y << 9 | Y >>> 32 - 9, Y = vt + ft | 0, _t ^= Y << 13 | Y >>> 32 - 13, Y = _t + vt | 0, xt ^= Y << 18 | Y >>> 32 - 18;
      Ge2 = Ge2 + C2 | 0, Ye2 = Ye2 + Q2 | 0, ze = ze + he | 0, $e = $e + ge2 | 0, We = We + Ee | 0, qe = qe + Ve2 | 0, ve = ve + Ne | 0, xe2 = xe2 + tt | 0, ke = ke + He | 0, Ie = Ie + it | 0, Te = Te + nt | 0, Be = Be + dt | 0, ft = ft + ut | 0, vt = vt + st | 0, _t = _t + at | 0, xt = xt + ot | 0, S2[0] = Ge2 >>> 0 & 255, S2[1] = Ge2 >>> 8 & 255, S2[2] = Ge2 >>> 16 & 255, S2[3] = Ge2 >>> 24 & 255, S2[4] = Ye2 >>> 0 & 255, S2[5] = Ye2 >>> 8 & 255, S2[6] = Ye2 >>> 16 & 255, S2[7] = Ye2 >>> 24 & 255, S2[8] = ze >>> 0 & 255, S2[9] = ze >>> 8 & 255, S2[10] = ze >>> 16 & 255, S2[11] = ze >>> 24 & 255, S2[12] = $e >>> 0 & 255, S2[13] = $e >>> 8 & 255, S2[14] = $e >>> 16 & 255, S2[15] = $e >>> 24 & 255, S2[16] = We >>> 0 & 255, S2[17] = We >>> 8 & 255, S2[18] = We >>> 16 & 255, S2[19] = We >>> 24 & 255, S2[20] = qe >>> 0 & 255, S2[21] = qe >>> 8 & 255, S2[22] = qe >>> 16 & 255, S2[23] = qe >>> 24 & 255, S2[24] = ve >>> 0 & 255, S2[25] = ve >>> 8 & 255, S2[26] = ve >>> 16 & 255, S2[27] = ve >>> 24 & 255, S2[28] = xe2 >>> 0 & 255, S2[29] = xe2 >>> 8 & 255, S2[30] = xe2 >>> 16 & 255, S2[31] = xe2 >>> 24 & 255, S2[32] = ke >>> 0 & 255, S2[33] = ke >>> 8 & 255, S2[34] = ke >>> 16 & 255, S2[35] = ke >>> 24 & 255, S2[36] = Ie >>> 0 & 255, S2[37] = Ie >>> 8 & 255, S2[38] = Ie >>> 16 & 255, S2[39] = Ie >>> 24 & 255, S2[40] = Te >>> 0 & 255, S2[41] = Te >>> 8 & 255, S2[42] = Te >>> 16 & 255, S2[43] = Te >>> 24 & 255, S2[44] = Be >>> 0 & 255, S2[45] = Be >>> 8 & 255, S2[46] = Be >>> 16 & 255, S2[47] = Be >>> 24 & 255, S2[48] = ft >>> 0 & 255, S2[49] = ft >>> 8 & 255, S2[50] = ft >>> 16 & 255, S2[51] = ft >>> 24 & 255, S2[52] = vt >>> 0 & 255, S2[53] = vt >>> 8 & 255, S2[54] = vt >>> 16 & 255, S2[55] = vt >>> 24 & 255, S2[56] = _t >>> 0 & 255, S2[57] = _t >>> 8 & 255, S2[58] = _t >>> 16 & 255, S2[59] = _t >>> 24 & 255, S2[60] = xt >>> 0 & 255, S2[61] = xt >>> 8 & 255, S2[62] = xt >>> 16 & 255, S2[63] = xt >>> 24 & 255;
    }
    function le(S2, D2, k2, p2) {
      for (var C2 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, Q2 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, he = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, ge2 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, Ee = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, Ve2 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, Ne = D2[0] & 255 | (D2[1] & 255) << 8 | (D2[2] & 255) << 16 | (D2[3] & 255) << 24, tt = D2[4] & 255 | (D2[5] & 255) << 8 | (D2[6] & 255) << 16 | (D2[7] & 255) << 24, He = D2[8] & 255 | (D2[9] & 255) << 8 | (D2[10] & 255) << 16 | (D2[11] & 255) << 24, it = D2[12] & 255 | (D2[13] & 255) << 8 | (D2[14] & 255) << 16 | (D2[15] & 255) << 24, nt = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, dt = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, ut = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, st = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, at = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, ot = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, Ge2 = C2, Ye2 = Q2, ze = he, $e = ge2, We = Ee, qe = Ve2, ve = Ne, xe2 = tt, ke = He, Ie = it, Te = nt, Be = dt, ft = ut, vt = st, _t = at, xt = ot, Y, It = 0; It < 20; It += 2)
        Y = Ge2 + ft | 0, We ^= Y << 7 | Y >>> 32 - 7, Y = We + Ge2 | 0, ke ^= Y << 9 | Y >>> 32 - 9, Y = ke + We | 0, ft ^= Y << 13 | Y >>> 32 - 13, Y = ft + ke | 0, Ge2 ^= Y << 18 | Y >>> 32 - 18, Y = qe + Ye2 | 0, Ie ^= Y << 7 | Y >>> 32 - 7, Y = Ie + qe | 0, vt ^= Y << 9 | Y >>> 32 - 9, Y = vt + Ie | 0, Ye2 ^= Y << 13 | Y >>> 32 - 13, Y = Ye2 + vt | 0, qe ^= Y << 18 | Y >>> 32 - 18, Y = Te + ve | 0, _t ^= Y << 7 | Y >>> 32 - 7, Y = _t + Te | 0, ze ^= Y << 9 | Y >>> 32 - 9, Y = ze + _t | 0, ve ^= Y << 13 | Y >>> 32 - 13, Y = ve + ze | 0, Te ^= Y << 18 | Y >>> 32 - 18, Y = xt + Be | 0, $e ^= Y << 7 | Y >>> 32 - 7, Y = $e + xt | 0, xe2 ^= Y << 9 | Y >>> 32 - 9, Y = xe2 + $e | 0, Be ^= Y << 13 | Y >>> 32 - 13, Y = Be + xe2 | 0, xt ^= Y << 18 | Y >>> 32 - 18, Y = Ge2 + $e | 0, Ye2 ^= Y << 7 | Y >>> 32 - 7, Y = Ye2 + Ge2 | 0, ze ^= Y << 9 | Y >>> 32 - 9, Y = ze + Ye2 | 0, $e ^= Y << 13 | Y >>> 32 - 13, Y = $e + ze | 0, Ge2 ^= Y << 18 | Y >>> 32 - 18, Y = qe + We | 0, ve ^= Y << 7 | Y >>> 32 - 7, Y = ve + qe | 0, xe2 ^= Y << 9 | Y >>> 32 - 9, Y = xe2 + ve | 0, We ^= Y << 13 | Y >>> 32 - 13, Y = We + xe2 | 0, qe ^= Y << 18 | Y >>> 32 - 18, Y = Te + Ie | 0, Be ^= Y << 7 | Y >>> 32 - 7, Y = Be + Te | 0, ke ^= Y << 9 | Y >>> 32 - 9, Y = ke + Be | 0, Ie ^= Y << 13 | Y >>> 32 - 13, Y = Ie + ke | 0, Te ^= Y << 18 | Y >>> 32 - 18, Y = xt + _t | 0, ft ^= Y << 7 | Y >>> 32 - 7, Y = ft + xt | 0, vt ^= Y << 9 | Y >>> 32 - 9, Y = vt + ft | 0, _t ^= Y << 13 | Y >>> 32 - 13, Y = _t + vt | 0, xt ^= Y << 18 | Y >>> 32 - 18;
      S2[0] = Ge2 >>> 0 & 255, S2[1] = Ge2 >>> 8 & 255, S2[2] = Ge2 >>> 16 & 255, S2[3] = Ge2 >>> 24 & 255, S2[4] = qe >>> 0 & 255, S2[5] = qe >>> 8 & 255, S2[6] = qe >>> 16 & 255, S2[7] = qe >>> 24 & 255, S2[8] = Te >>> 0 & 255, S2[9] = Te >>> 8 & 255, S2[10] = Te >>> 16 & 255, S2[11] = Te >>> 24 & 255, S2[12] = xt >>> 0 & 255, S2[13] = xt >>> 8 & 255, S2[14] = xt >>> 16 & 255, S2[15] = xt >>> 24 & 255, S2[16] = ve >>> 0 & 255, S2[17] = ve >>> 8 & 255, S2[18] = ve >>> 16 & 255, S2[19] = ve >>> 24 & 255, S2[20] = xe2 >>> 0 & 255, S2[21] = xe2 >>> 8 & 255, S2[22] = xe2 >>> 16 & 255, S2[23] = xe2 >>> 24 & 255, S2[24] = ke >>> 0 & 255, S2[25] = ke >>> 8 & 255, S2[26] = ke >>> 16 & 255, S2[27] = ke >>> 24 & 255, S2[28] = Ie >>> 0 & 255, S2[29] = Ie >>> 8 & 255, S2[30] = Ie >>> 16 & 255, S2[31] = Ie >>> 24 & 255;
    }
    function be2(S2, D2, k2, p2) {
      Z(S2, D2, k2, p2);
    }
    function Ae(S2, D2, k2, p2) {
      le(S2, D2, k2, p2);
    }
    var me = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function H5(S2, D2, k2, p2, C2, Q2, he) {
      var ge2 = new Uint8Array(16), Ee = new Uint8Array(64), Ve2, Ne;
      for (Ne = 0; Ne < 16; Ne++)
        ge2[Ne] = 0;
      for (Ne = 0; Ne < 8; Ne++)
        ge2[Ne] = Q2[Ne];
      for (; C2 >= 64; ) {
        for (be2(Ee, ge2, he, me), Ne = 0; Ne < 64; Ne++)
          S2[D2 + Ne] = k2[p2 + Ne] ^ Ee[Ne];
        for (Ve2 = 1, Ne = 8; Ne < 16; Ne++)
          Ve2 = Ve2 + (ge2[Ne] & 255) | 0, ge2[Ne] = Ve2 & 255, Ve2 >>>= 8;
        C2 -= 64, D2 += 64, p2 += 64;
      }
      if (C2 > 0)
        for (be2(Ee, ge2, he, me), Ne = 0; Ne < C2; Ne++)
          S2[D2 + Ne] = k2[p2 + Ne] ^ Ee[Ne];
      return 0;
    }
    function ue(S2, D2, k2, p2, C2) {
      var Q2 = new Uint8Array(16), he = new Uint8Array(64), ge2, Ee;
      for (Ee = 0; Ee < 16; Ee++)
        Q2[Ee] = 0;
      for (Ee = 0; Ee < 8; Ee++)
        Q2[Ee] = p2[Ee];
      for (; k2 >= 64; ) {
        for (be2(he, Q2, C2, me), Ee = 0; Ee < 64; Ee++)
          S2[D2 + Ee] = he[Ee];
        for (ge2 = 1, Ee = 8; Ee < 16; Ee++)
          ge2 = ge2 + (Q2[Ee] & 255) | 0, Q2[Ee] = ge2 & 255, ge2 >>>= 8;
        k2 -= 64, D2 += 64;
      }
      if (k2 > 0)
        for (be2(he, Q2, C2, me), Ee = 0; Ee < k2; Ee++)
          S2[D2 + Ee] = he[Ee];
      return 0;
    }
    function se2(S2, D2, k2, p2, C2) {
      var Q2 = new Uint8Array(32);
      Ae(Q2, p2, C2, me);
      for (var he = new Uint8Array(8), ge2 = 0; ge2 < 8; ge2++)
        he[ge2] = p2[ge2 + 16];
      return ue(S2, D2, k2, he, Q2);
    }
    function ne2(S2, D2, k2, p2, C2, Q2, he) {
      var ge2 = new Uint8Array(32);
      Ae(ge2, Q2, he, me);
      for (var Ee = new Uint8Array(8), Ve2 = 0; Ve2 < 8; Ve2++)
        Ee[Ve2] = Q2[Ve2 + 16];
      return H5(S2, D2, k2, p2, C2, Ee, ge2);
    }
    var E2 = function(S2) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var D2, k2, p2, C2, Q2, he, ge2, Ee;
      D2 = S2[0] & 255 | (S2[1] & 255) << 8, this.r[0] = D2 & 8191, k2 = S2[2] & 255 | (S2[3] & 255) << 8, this.r[1] = (D2 >>> 13 | k2 << 3) & 8191, p2 = S2[4] & 255 | (S2[5] & 255) << 8, this.r[2] = (k2 >>> 10 | p2 << 6) & 7939, C2 = S2[6] & 255 | (S2[7] & 255) << 8, this.r[3] = (p2 >>> 7 | C2 << 9) & 8191, Q2 = S2[8] & 255 | (S2[9] & 255) << 8, this.r[4] = (C2 >>> 4 | Q2 << 12) & 255, this.r[5] = Q2 >>> 1 & 8190, he = S2[10] & 255 | (S2[11] & 255) << 8, this.r[6] = (Q2 >>> 14 | he << 2) & 8191, ge2 = S2[12] & 255 | (S2[13] & 255) << 8, this.r[7] = (he >>> 11 | ge2 << 5) & 8065, Ee = S2[14] & 255 | (S2[15] & 255) << 8, this.r[8] = (ge2 >>> 8 | Ee << 8) & 8191, this.r[9] = Ee >>> 5 & 127, this.pad[0] = S2[16] & 255 | (S2[17] & 255) << 8, this.pad[1] = S2[18] & 255 | (S2[19] & 255) << 8, this.pad[2] = S2[20] & 255 | (S2[21] & 255) << 8, this.pad[3] = S2[22] & 255 | (S2[23] & 255) << 8, this.pad[4] = S2[24] & 255 | (S2[25] & 255) << 8, this.pad[5] = S2[26] & 255 | (S2[27] & 255) << 8, this.pad[6] = S2[28] & 255 | (S2[29] & 255) << 8, this.pad[7] = S2[30] & 255 | (S2[31] & 255) << 8;
    };
    E2.prototype.blocks = function(S2, D2, k2) {
      for (var p2 = this.fin ? 0 : 2048, C2, Q2, he, ge2, Ee, Ve2, Ne, tt, He, it, nt, dt, ut, st, at, ot, Ge2, Ye2, ze, $e = this.h[0], We = this.h[1], qe = this.h[2], ve = this.h[3], xe2 = this.h[4], ke = this.h[5], Ie = this.h[6], Te = this.h[7], Be = this.h[8], ft = this.h[9], vt = this.r[0], _t = this.r[1], xt = this.r[2], Y = this.r[3], It = this.r[4], Ot = this.r[5], jt = this.r[6], Et = this.r[7], Nt = this.r[8], Bt = this.r[9]; k2 >= 16; )
        C2 = S2[D2 + 0] & 255 | (S2[D2 + 1] & 255) << 8, $e += C2 & 8191, Q2 = S2[D2 + 2] & 255 | (S2[D2 + 3] & 255) << 8, We += (C2 >>> 13 | Q2 << 3) & 8191, he = S2[D2 + 4] & 255 | (S2[D2 + 5] & 255) << 8, qe += (Q2 >>> 10 | he << 6) & 8191, ge2 = S2[D2 + 6] & 255 | (S2[D2 + 7] & 255) << 8, ve += (he >>> 7 | ge2 << 9) & 8191, Ee = S2[D2 + 8] & 255 | (S2[D2 + 9] & 255) << 8, xe2 += (ge2 >>> 4 | Ee << 12) & 8191, ke += Ee >>> 1 & 8191, Ve2 = S2[D2 + 10] & 255 | (S2[D2 + 11] & 255) << 8, Ie += (Ee >>> 14 | Ve2 << 2) & 8191, Ne = S2[D2 + 12] & 255 | (S2[D2 + 13] & 255) << 8, Te += (Ve2 >>> 11 | Ne << 5) & 8191, tt = S2[D2 + 14] & 255 | (S2[D2 + 15] & 255) << 8, Be += (Ne >>> 8 | tt << 8) & 8191, ft += tt >>> 5 | p2, He = 0, it = He, it += $e * vt, it += We * (5 * Bt), it += qe * (5 * Nt), it += ve * (5 * Et), it += xe2 * (5 * jt), He = it >>> 13, it &= 8191, it += ke * (5 * Ot), it += Ie * (5 * It), it += Te * (5 * Y), it += Be * (5 * xt), it += ft * (5 * _t), He += it >>> 13, it &= 8191, nt = He, nt += $e * _t, nt += We * vt, nt += qe * (5 * Bt), nt += ve * (5 * Nt), nt += xe2 * (5 * Et), He = nt >>> 13, nt &= 8191, nt += ke * (5 * jt), nt += Ie * (5 * Ot), nt += Te * (5 * It), nt += Be * (5 * Y), nt += ft * (5 * xt), He += nt >>> 13, nt &= 8191, dt = He, dt += $e * xt, dt += We * _t, dt += qe * vt, dt += ve * (5 * Bt), dt += xe2 * (5 * Nt), He = dt >>> 13, dt &= 8191, dt += ke * (5 * Et), dt += Ie * (5 * jt), dt += Te * (5 * Ot), dt += Be * (5 * It), dt += ft * (5 * Y), He += dt >>> 13, dt &= 8191, ut = He, ut += $e * Y, ut += We * xt, ut += qe * _t, ut += ve * vt, ut += xe2 * (5 * Bt), He = ut >>> 13, ut &= 8191, ut += ke * (5 * Nt), ut += Ie * (5 * Et), ut += Te * (5 * jt), ut += Be * (5 * Ot), ut += ft * (5 * It), He += ut >>> 13, ut &= 8191, st = He, st += $e * It, st += We * Y, st += qe * xt, st += ve * _t, st += xe2 * vt, He = st >>> 13, st &= 8191, st += ke * (5 * Bt), st += Ie * (5 * Nt), st += Te * (5 * Et), st += Be * (5 * jt), st += ft * (5 * Ot), He += st >>> 13, st &= 8191, at = He, at += $e * Ot, at += We * It, at += qe * Y, at += ve * xt, at += xe2 * _t, He = at >>> 13, at &= 8191, at += ke * vt, at += Ie * (5 * Bt), at += Te * (5 * Nt), at += Be * (5 * Et), at += ft * (5 * jt), He += at >>> 13, at &= 8191, ot = He, ot += $e * jt, ot += We * Ot, ot += qe * It, ot += ve * Y, ot += xe2 * xt, He = ot >>> 13, ot &= 8191, ot += ke * _t, ot += Ie * vt, ot += Te * (5 * Bt), ot += Be * (5 * Nt), ot += ft * (5 * Et), He += ot >>> 13, ot &= 8191, Ge2 = He, Ge2 += $e * Et, Ge2 += We * jt, Ge2 += qe * Ot, Ge2 += ve * It, Ge2 += xe2 * Y, He = Ge2 >>> 13, Ge2 &= 8191, Ge2 += ke * xt, Ge2 += Ie * _t, Ge2 += Te * vt, Ge2 += Be * (5 * Bt), Ge2 += ft * (5 * Nt), He += Ge2 >>> 13, Ge2 &= 8191, Ye2 = He, Ye2 += $e * Nt, Ye2 += We * Et, Ye2 += qe * jt, Ye2 += ve * Ot, Ye2 += xe2 * It, He = Ye2 >>> 13, Ye2 &= 8191, Ye2 += ke * Y, Ye2 += Ie * xt, Ye2 += Te * _t, Ye2 += Be * vt, Ye2 += ft * (5 * Bt), He += Ye2 >>> 13, Ye2 &= 8191, ze = He, ze += $e * Bt, ze += We * Nt, ze += qe * Et, ze += ve * jt, ze += xe2 * Ot, He = ze >>> 13, ze &= 8191, ze += ke * It, ze += Ie * Y, ze += Te * xt, ze += Be * _t, ze += ft * vt, He += ze >>> 13, ze &= 8191, He = (He << 2) + He | 0, He = He + it | 0, it = He & 8191, He = He >>> 13, nt += He, $e = it, We = nt, qe = dt, ve = ut, xe2 = st, ke = at, Ie = ot, Te = Ge2, Be = Ye2, ft = ze, D2 += 16, k2 -= 16;
      this.h[0] = $e, this.h[1] = We, this.h[2] = qe, this.h[3] = ve, this.h[4] = xe2, this.h[5] = ke, this.h[6] = Ie, this.h[7] = Te, this.h[8] = Be, this.h[9] = ft;
    }, E2.prototype.finish = function(S2, D2) {
      var k2 = new Uint16Array(10), p2, C2, Q2, he;
      if (this.leftover) {
        for (he = this.leftover, this.buffer[he++] = 1; he < 16; he++)
          this.buffer[he] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (p2 = this.h[1] >>> 13, this.h[1] &= 8191, he = 2; he < 10; he++)
        this.h[he] += p2, p2 = this.h[he] >>> 13, this.h[he] &= 8191;
      for (this.h[0] += p2 * 5, p2 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += p2, p2 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += p2, k2[0] = this.h[0] + 5, p2 = k2[0] >>> 13, k2[0] &= 8191, he = 1; he < 10; he++)
        k2[he] = this.h[he] + p2, p2 = k2[he] >>> 13, k2[he] &= 8191;
      for (k2[9] -= 1 << 13, C2 = (p2 ^ 1) - 1, he = 0; he < 10; he++)
        k2[he] &= C2;
      for (C2 = ~C2, he = 0; he < 10; he++)
        this.h[he] = this.h[he] & C2 | k2[he];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Q2 = this.h[0] + this.pad[0], this.h[0] = Q2 & 65535, he = 1; he < 8; he++)
        Q2 = (this.h[he] + this.pad[he] | 0) + (Q2 >>> 16) | 0, this.h[he] = Q2 & 65535;
      S2[D2 + 0] = this.h[0] >>> 0 & 255, S2[D2 + 1] = this.h[0] >>> 8 & 255, S2[D2 + 2] = this.h[1] >>> 0 & 255, S2[D2 + 3] = this.h[1] >>> 8 & 255, S2[D2 + 4] = this.h[2] >>> 0 & 255, S2[D2 + 5] = this.h[2] >>> 8 & 255, S2[D2 + 6] = this.h[3] >>> 0 & 255, S2[D2 + 7] = this.h[3] >>> 8 & 255, S2[D2 + 8] = this.h[4] >>> 0 & 255, S2[D2 + 9] = this.h[4] >>> 8 & 255, S2[D2 + 10] = this.h[5] >>> 0 & 255, S2[D2 + 11] = this.h[5] >>> 8 & 255, S2[D2 + 12] = this.h[6] >>> 0 & 255, S2[D2 + 13] = this.h[6] >>> 8 & 255, S2[D2 + 14] = this.h[7] >>> 0 & 255, S2[D2 + 15] = this.h[7] >>> 8 & 255;
    }, E2.prototype.update = function(S2, D2, k2) {
      var p2, C2;
      if (this.leftover) {
        for (C2 = 16 - this.leftover, C2 > k2 && (C2 = k2), p2 = 0; p2 < C2; p2++)
          this.buffer[this.leftover + p2] = S2[D2 + p2];
        if (k2 -= C2, D2 += C2, this.leftover += C2, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (k2 >= 16 && (C2 = k2 - k2 % 16, this.blocks(S2, D2, C2), D2 += C2, k2 -= C2), k2) {
        for (p2 = 0; p2 < k2; p2++)
          this.buffer[this.leftover + p2] = S2[D2 + p2];
        this.leftover += k2;
      }
    };
    function c(S2, D2, k2, p2, C2, Q2) {
      var he = new E2(Q2);
      return he.update(k2, p2, C2), he.finish(S2, D2), 0;
    }
    function m2(S2, D2, k2, p2, C2, Q2) {
      var he = new Uint8Array(16);
      return c(he, 0, k2, p2, C2, Q2), ee2(S2, D2, he, 0);
    }
    function h2(S2, D2, k2, p2, C2) {
      var Q2;
      if (k2 < 32)
        return -1;
      for (ne2(S2, 0, D2, 0, k2, p2, C2), c(S2, 16, S2, 32, k2 - 32, S2), Q2 = 0; Q2 < 16; Q2++)
        S2[Q2] = 0;
      return 0;
    }
    function a(S2, D2, k2, p2, C2) {
      var Q2, he = new Uint8Array(32);
      if (k2 < 32 || (se2(he, 0, 32, p2, C2), m2(D2, 16, D2, 32, k2 - 32, he) !== 0))
        return -1;
      for (ne2(S2, 0, D2, 0, k2, p2, C2), Q2 = 0; Q2 < 32; Q2++)
        S2[Q2] = 0;
      return 0;
    }
    function u3(S2, D2) {
      var k2;
      for (k2 = 0; k2 < 16; k2++)
        S2[k2] = D2[k2] | 0;
    }
    function b2(S2) {
      var D2, k2, p2 = 1;
      for (D2 = 0; D2 < 16; D2++)
        k2 = S2[D2] + p2 + 65535, p2 = Math.floor(k2 / 65536), S2[D2] = k2 - p2 * 65536;
      S2[0] += p2 - 1 + 37 * (p2 - 1);
    }
    function A2(S2, D2, k2) {
      for (var p2, C2 = ~(k2 - 1), Q2 = 0; Q2 < 16; Q2++)
        p2 = C2 & (S2[Q2] ^ D2[Q2]), S2[Q2] ^= p2, D2[Q2] ^= p2;
    }
    function v2(S2, D2) {
      var k2, p2, C2, Q2 = e(), he = e();
      for (k2 = 0; k2 < 16; k2++)
        he[k2] = D2[k2];
      for (b2(he), b2(he), b2(he), p2 = 0; p2 < 2; p2++) {
        for (Q2[0] = he[0] - 65517, k2 = 1; k2 < 15; k2++)
          Q2[k2] = he[k2] - 65535 - (Q2[k2 - 1] >> 16 & 1), Q2[k2 - 1] &= 65535;
        Q2[15] = he[15] - 32767 - (Q2[14] >> 16 & 1), C2 = Q2[15] >> 16 & 1, Q2[14] &= 65535, A2(he, Q2, 1 - C2);
      }
      for (k2 = 0; k2 < 16; k2++)
        S2[2 * k2] = he[k2] & 255, S2[2 * k2 + 1] = he[k2] >> 8;
    }
    function d2(S2, D2) {
      var k2 = new Uint8Array(32), p2 = new Uint8Array(32);
      return v2(k2, S2), v2(p2, D2), W5(k2, 0, p2, 0);
    }
    function M(S2) {
      var D2 = new Uint8Array(32);
      return v2(D2, S2), D2[0] & 1;
    }
    function B2(S2, D2) {
      var k2;
      for (k2 = 0; k2 < 16; k2++)
        S2[k2] = D2[2 * k2] + (D2[2 * k2 + 1] << 8);
      S2[15] &= 32767;
    }
    function y2(S2, D2, k2) {
      for (var p2 = 0; p2 < 16; p2++)
        S2[p2] = D2[p2] + k2[p2];
    }
    function I(S2, D2, k2) {
      for (var p2 = 0; p2 < 16; p2++)
        S2[p2] = D2[p2] - k2[p2];
    }
    function de(S2, D2, k2) {
      var p2, C2, Q2 = 0, he = 0, ge2 = 0, Ee = 0, Ve2 = 0, Ne = 0, tt = 0, He = 0, it = 0, nt = 0, dt = 0, ut = 0, st = 0, at = 0, ot = 0, Ge2 = 0, Ye2 = 0, ze = 0, $e = 0, We = 0, qe = 0, ve = 0, xe2 = 0, ke = 0, Ie = 0, Te = 0, Be = 0, ft = 0, vt = 0, _t = 0, xt = 0, Y = k2[0], It = k2[1], Ot = k2[2], jt = k2[3], Et = k2[4], Nt = k2[5], Bt = k2[6], or2 = k2[7], Ht = k2[8], Qt = k2[9], er = k2[10], tr = k2[11], cr = k2[12], wr = k2[13], _r = k2[14], Ar = k2[15];
      p2 = D2[0], Q2 += p2 * Y, he += p2 * It, ge2 += p2 * Ot, Ee += p2 * jt, Ve2 += p2 * Et, Ne += p2 * Nt, tt += p2 * Bt, He += p2 * or2, it += p2 * Ht, nt += p2 * Qt, dt += p2 * er, ut += p2 * tr, st += p2 * cr, at += p2 * wr, ot += p2 * _r, Ge2 += p2 * Ar, p2 = D2[1], he += p2 * Y, ge2 += p2 * It, Ee += p2 * Ot, Ve2 += p2 * jt, Ne += p2 * Et, tt += p2 * Nt, He += p2 * Bt, it += p2 * or2, nt += p2 * Ht, dt += p2 * Qt, ut += p2 * er, st += p2 * tr, at += p2 * cr, ot += p2 * wr, Ge2 += p2 * _r, Ye2 += p2 * Ar, p2 = D2[2], ge2 += p2 * Y, Ee += p2 * It, Ve2 += p2 * Ot, Ne += p2 * jt, tt += p2 * Et, He += p2 * Nt, it += p2 * Bt, nt += p2 * or2, dt += p2 * Ht, ut += p2 * Qt, st += p2 * er, at += p2 * tr, ot += p2 * cr, Ge2 += p2 * wr, Ye2 += p2 * _r, ze += p2 * Ar, p2 = D2[3], Ee += p2 * Y, Ve2 += p2 * It, Ne += p2 * Ot, tt += p2 * jt, He += p2 * Et, it += p2 * Nt, nt += p2 * Bt, dt += p2 * or2, ut += p2 * Ht, st += p2 * Qt, at += p2 * er, ot += p2 * tr, Ge2 += p2 * cr, Ye2 += p2 * wr, ze += p2 * _r, $e += p2 * Ar, p2 = D2[4], Ve2 += p2 * Y, Ne += p2 * It, tt += p2 * Ot, He += p2 * jt, it += p2 * Et, nt += p2 * Nt, dt += p2 * Bt, ut += p2 * or2, st += p2 * Ht, at += p2 * Qt, ot += p2 * er, Ge2 += p2 * tr, Ye2 += p2 * cr, ze += p2 * wr, $e += p2 * _r, We += p2 * Ar, p2 = D2[5], Ne += p2 * Y, tt += p2 * It, He += p2 * Ot, it += p2 * jt, nt += p2 * Et, dt += p2 * Nt, ut += p2 * Bt, st += p2 * or2, at += p2 * Ht, ot += p2 * Qt, Ge2 += p2 * er, Ye2 += p2 * tr, ze += p2 * cr, $e += p2 * wr, We += p2 * _r, qe += p2 * Ar, p2 = D2[6], tt += p2 * Y, He += p2 * It, it += p2 * Ot, nt += p2 * jt, dt += p2 * Et, ut += p2 * Nt, st += p2 * Bt, at += p2 * or2, ot += p2 * Ht, Ge2 += p2 * Qt, Ye2 += p2 * er, ze += p2 * tr, $e += p2 * cr, We += p2 * wr, qe += p2 * _r, ve += p2 * Ar, p2 = D2[7], He += p2 * Y, it += p2 * It, nt += p2 * Ot, dt += p2 * jt, ut += p2 * Et, st += p2 * Nt, at += p2 * Bt, ot += p2 * or2, Ge2 += p2 * Ht, Ye2 += p2 * Qt, ze += p2 * er, $e += p2 * tr, We += p2 * cr, qe += p2 * wr, ve += p2 * _r, xe2 += p2 * Ar, p2 = D2[8], it += p2 * Y, nt += p2 * It, dt += p2 * Ot, ut += p2 * jt, st += p2 * Et, at += p2 * Nt, ot += p2 * Bt, Ge2 += p2 * or2, Ye2 += p2 * Ht, ze += p2 * Qt, $e += p2 * er, We += p2 * tr, qe += p2 * cr, ve += p2 * wr, xe2 += p2 * _r, ke += p2 * Ar, p2 = D2[9], nt += p2 * Y, dt += p2 * It, ut += p2 * Ot, st += p2 * jt, at += p2 * Et, ot += p2 * Nt, Ge2 += p2 * Bt, Ye2 += p2 * or2, ze += p2 * Ht, $e += p2 * Qt, We += p2 * er, qe += p2 * tr, ve += p2 * cr, xe2 += p2 * wr, ke += p2 * _r, Ie += p2 * Ar, p2 = D2[10], dt += p2 * Y, ut += p2 * It, st += p2 * Ot, at += p2 * jt, ot += p2 * Et, Ge2 += p2 * Nt, Ye2 += p2 * Bt, ze += p2 * or2, $e += p2 * Ht, We += p2 * Qt, qe += p2 * er, ve += p2 * tr, xe2 += p2 * cr, ke += p2 * wr, Ie += p2 * _r, Te += p2 * Ar, p2 = D2[11], ut += p2 * Y, st += p2 * It, at += p2 * Ot, ot += p2 * jt, Ge2 += p2 * Et, Ye2 += p2 * Nt, ze += p2 * Bt, $e += p2 * or2, We += p2 * Ht, qe += p2 * Qt, ve += p2 * er, xe2 += p2 * tr, ke += p2 * cr, Ie += p2 * wr, Te += p2 * _r, Be += p2 * Ar, p2 = D2[12], st += p2 * Y, at += p2 * It, ot += p2 * Ot, Ge2 += p2 * jt, Ye2 += p2 * Et, ze += p2 * Nt, $e += p2 * Bt, We += p2 * or2, qe += p2 * Ht, ve += p2 * Qt, xe2 += p2 * er, ke += p2 * tr, Ie += p2 * cr, Te += p2 * wr, Be += p2 * _r, ft += p2 * Ar, p2 = D2[13], at += p2 * Y, ot += p2 * It, Ge2 += p2 * Ot, Ye2 += p2 * jt, ze += p2 * Et, $e += p2 * Nt, We += p2 * Bt, qe += p2 * or2, ve += p2 * Ht, xe2 += p2 * Qt, ke += p2 * er, Ie += p2 * tr, Te += p2 * cr, Be += p2 * wr, ft += p2 * _r, vt += p2 * Ar, p2 = D2[14], ot += p2 * Y, Ge2 += p2 * It, Ye2 += p2 * Ot, ze += p2 * jt, $e += p2 * Et, We += p2 * Nt, qe += p2 * Bt, ve += p2 * or2, xe2 += p2 * Ht, ke += p2 * Qt, Ie += p2 * er, Te += p2 * tr, Be += p2 * cr, ft += p2 * wr, vt += p2 * _r, _t += p2 * Ar, p2 = D2[15], Ge2 += p2 * Y, Ye2 += p2 * It, ze += p2 * Ot, $e += p2 * jt, We += p2 * Et, qe += p2 * Nt, ve += p2 * Bt, xe2 += p2 * or2, ke += p2 * Ht, Ie += p2 * Qt, Te += p2 * er, Be += p2 * tr, ft += p2 * cr, vt += p2 * wr, _t += p2 * _r, xt += p2 * Ar, Q2 += 38 * Ye2, he += 38 * ze, ge2 += 38 * $e, Ee += 38 * We, Ve2 += 38 * qe, Ne += 38 * ve, tt += 38 * xe2, He += 38 * ke, it += 38 * Ie, nt += 38 * Te, dt += 38 * Be, ut += 38 * ft, st += 38 * vt, at += 38 * _t, ot += 38 * xt, C2 = 1, p2 = Q2 + C2 + 65535, C2 = Math.floor(p2 / 65536), Q2 = p2 - C2 * 65536, p2 = he + C2 + 65535, C2 = Math.floor(p2 / 65536), he = p2 - C2 * 65536, p2 = ge2 + C2 + 65535, C2 = Math.floor(p2 / 65536), ge2 = p2 - C2 * 65536, p2 = Ee + C2 + 65535, C2 = Math.floor(p2 / 65536), Ee = p2 - C2 * 65536, p2 = Ve2 + C2 + 65535, C2 = Math.floor(p2 / 65536), Ve2 = p2 - C2 * 65536, p2 = Ne + C2 + 65535, C2 = Math.floor(p2 / 65536), Ne = p2 - C2 * 65536, p2 = tt + C2 + 65535, C2 = Math.floor(p2 / 65536), tt = p2 - C2 * 65536, p2 = He + C2 + 65535, C2 = Math.floor(p2 / 65536), He = p2 - C2 * 65536, p2 = it + C2 + 65535, C2 = Math.floor(p2 / 65536), it = p2 - C2 * 65536, p2 = nt + C2 + 65535, C2 = Math.floor(p2 / 65536), nt = p2 - C2 * 65536, p2 = dt + C2 + 65535, C2 = Math.floor(p2 / 65536), dt = p2 - C2 * 65536, p2 = ut + C2 + 65535, C2 = Math.floor(p2 / 65536), ut = p2 - C2 * 65536, p2 = st + C2 + 65535, C2 = Math.floor(p2 / 65536), st = p2 - C2 * 65536, p2 = at + C2 + 65535, C2 = Math.floor(p2 / 65536), at = p2 - C2 * 65536, p2 = ot + C2 + 65535, C2 = Math.floor(p2 / 65536), ot = p2 - C2 * 65536, p2 = Ge2 + C2 + 65535, C2 = Math.floor(p2 / 65536), Ge2 = p2 - C2 * 65536, Q2 += C2 - 1 + 37 * (C2 - 1), C2 = 1, p2 = Q2 + C2 + 65535, C2 = Math.floor(p2 / 65536), Q2 = p2 - C2 * 65536, p2 = he + C2 + 65535, C2 = Math.floor(p2 / 65536), he = p2 - C2 * 65536, p2 = ge2 + C2 + 65535, C2 = Math.floor(p2 / 65536), ge2 = p2 - C2 * 65536, p2 = Ee + C2 + 65535, C2 = Math.floor(p2 / 65536), Ee = p2 - C2 * 65536, p2 = Ve2 + C2 + 65535, C2 = Math.floor(p2 / 65536), Ve2 = p2 - C2 * 65536, p2 = Ne + C2 + 65535, C2 = Math.floor(p2 / 65536), Ne = p2 - C2 * 65536, p2 = tt + C2 + 65535, C2 = Math.floor(p2 / 65536), tt = p2 - C2 * 65536, p2 = He + C2 + 65535, C2 = Math.floor(p2 / 65536), He = p2 - C2 * 65536, p2 = it + C2 + 65535, C2 = Math.floor(p2 / 65536), it = p2 - C2 * 65536, p2 = nt + C2 + 65535, C2 = Math.floor(p2 / 65536), nt = p2 - C2 * 65536, p2 = dt + C2 + 65535, C2 = Math.floor(p2 / 65536), dt = p2 - C2 * 65536, p2 = ut + C2 + 65535, C2 = Math.floor(p2 / 65536), ut = p2 - C2 * 65536, p2 = st + C2 + 65535, C2 = Math.floor(p2 / 65536), st = p2 - C2 * 65536, p2 = at + C2 + 65535, C2 = Math.floor(p2 / 65536), at = p2 - C2 * 65536, p2 = ot + C2 + 65535, C2 = Math.floor(p2 / 65536), ot = p2 - C2 * 65536, p2 = Ge2 + C2 + 65535, C2 = Math.floor(p2 / 65536), Ge2 = p2 - C2 * 65536, Q2 += C2 - 1 + 37 * (C2 - 1), S2[0] = Q2, S2[1] = he, S2[2] = ge2, S2[3] = Ee, S2[4] = Ve2, S2[5] = Ne, S2[6] = tt, S2[7] = He, S2[8] = it, S2[9] = nt, S2[10] = dt, S2[11] = ut, S2[12] = st, S2[13] = at, S2[14] = ot, S2[15] = Ge2;
    }
    function Me2(S2, D2) {
      de(S2, D2, D2);
    }
    function Se(S2, D2) {
      var k2 = e(), p2;
      for (p2 = 0; p2 < 16; p2++)
        k2[p2] = D2[p2];
      for (p2 = 253; p2 >= 0; p2--)
        Me2(k2, k2), p2 !== 2 && p2 !== 4 && de(k2, k2, D2);
      for (p2 = 0; p2 < 16; p2++)
        S2[p2] = k2[p2];
    }
    function Oe(S2, D2) {
      var k2 = e(), p2;
      for (p2 = 0; p2 < 16; p2++)
        k2[p2] = D2[p2];
      for (p2 = 250; p2 >= 0; p2--)
        Me2(k2, k2), p2 !== 1 && de(k2, k2, D2);
      for (p2 = 0; p2 < 16; p2++)
        S2[p2] = k2[p2];
    }
    function ye(S2, D2, k2) {
      var p2 = new Uint8Array(32), C2 = new Float64Array(80), Q2, he, ge2 = e(), Ee = e(), Ve2 = e(), Ne = e(), tt = e(), He = e();
      for (he = 0; he < 31; he++)
        p2[he] = D2[he];
      for (p2[31] = D2[31] & 127 | 64, p2[0] &= 248, B2(C2, k2), he = 0; he < 16; he++)
        Ee[he] = C2[he], Ne[he] = ge2[he] = Ve2[he] = 0;
      for (ge2[0] = Ne[0] = 1, he = 254; he >= 0; --he)
        Q2 = p2[he >>> 3] >>> (he & 7) & 1, A2(ge2, Ee, Q2), A2(Ve2, Ne, Q2), y2(tt, ge2, Ve2), I(ge2, ge2, Ve2), y2(Ve2, Ee, Ne), I(Ee, Ee, Ne), Me2(Ne, tt), Me2(He, ge2), de(ge2, Ve2, ge2), de(Ve2, Ee, tt), y2(tt, ge2, Ve2), I(ge2, ge2, Ve2), Me2(Ee, ge2), I(Ve2, Ne, He), de(ge2, Ve2, f2), y2(ge2, ge2, Ne), de(Ve2, Ve2, ge2), de(ge2, Ne, He), de(Ne, Ee, C2), Me2(Ee, tt), A2(ge2, Ee, Q2), A2(Ve2, Ne, Q2);
      for (he = 0; he < 16; he++)
        C2[he + 16] = ge2[he], C2[he + 32] = Ve2[he], C2[he + 48] = Ee[he], C2[he + 64] = Ne[he];
      var it = C2.subarray(32), nt = C2.subarray(16);
      return Se(it, it), de(nt, nt, it), v2(S2, nt), 0;
    }
    function T(S2, D2) {
      return ye(S2, D2, n);
    }
    function j2(S2, D2) {
      return r3(D2, 32), T(S2, D2);
    }
    function P5(S2, D2, k2) {
      var p2 = new Uint8Array(32);
      return ye(p2, k2, D2), Ae(S2, i, p2, me);
    }
    var te2 = h2, oe2 = a;
    function re(S2, D2, k2, p2, C2, Q2) {
      var he = new Uint8Array(32);
      return P5(he, C2, Q2), te2(S2, D2, k2, p2, he);
    }
    function ae(S2, D2, k2, p2, C2, Q2) {
      var he = new Uint8Array(32);
      return P5(he, C2, Q2), oe2(S2, D2, k2, p2, he);
    }
    var ie = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function X2(S2, D2, k2, p2) {
      for (var C2 = new Int32Array(16), Q2 = new Int32Array(16), he, ge2, Ee, Ve2, Ne, tt, He, it, nt, dt, ut, st, at, ot, Ge2, Ye2, ze, $e, We, qe, ve, xe2, ke, Ie, Te, Be, ft = S2[0], vt = S2[1], _t = S2[2], xt = S2[3], Y = S2[4], It = S2[5], Ot = S2[6], jt = S2[7], Et = D2[0], Nt = D2[1], Bt = D2[2], or2 = D2[3], Ht = D2[4], Qt = D2[5], er = D2[6], tr = D2[7], cr = 0; p2 >= 128; ) {
        for (We = 0; We < 16; We++)
          qe = 8 * We + cr, C2[We] = k2[qe + 0] << 24 | k2[qe + 1] << 16 | k2[qe + 2] << 8 | k2[qe + 3], Q2[We] = k2[qe + 4] << 24 | k2[qe + 5] << 16 | k2[qe + 6] << 8 | k2[qe + 7];
        for (We = 0; We < 80; We++)
          if (he = ft, ge2 = vt, Ee = _t, Ve2 = xt, Ne = Y, tt = It, He = Ot, it = jt, nt = Et, dt = Nt, ut = Bt, st = or2, at = Ht, ot = Qt, Ge2 = er, Ye2 = tr, ve = jt, xe2 = tr, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = (Y >>> 14 | Ht << 32 - 14) ^ (Y >>> 18 | Ht << 32 - 18) ^ (Ht >>> 41 - 32 | Y << 32 - (41 - 32)), xe2 = (Ht >>> 14 | Y << 32 - 14) ^ (Ht >>> 18 | Y << 32 - 18) ^ (Y >>> 41 - 32 | Ht << 32 - (41 - 32)), ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, ve = Y & It ^ ~Y & Ot, xe2 = Ht & Qt ^ ~Ht & er, ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, ve = ie[We * 2], xe2 = ie[We * 2 + 1], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, ve = C2[We % 16], xe2 = Q2[We % 16], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, ze = Te & 65535 | Be << 16, $e = ke & 65535 | Ie << 16, ve = ze, xe2 = $e, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = (ft >>> 28 | Et << 32 - 28) ^ (Et >>> 34 - 32 | ft << 32 - (34 - 32)) ^ (Et >>> 39 - 32 | ft << 32 - (39 - 32)), xe2 = (Et >>> 28 | ft << 32 - 28) ^ (ft >>> 34 - 32 | Et << 32 - (34 - 32)) ^ (ft >>> 39 - 32 | Et << 32 - (39 - 32)), ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, ve = ft & vt ^ ft & _t ^ vt & _t, xe2 = Et & Nt ^ Et & Bt ^ Nt & Bt, ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, it = Te & 65535 | Be << 16, Ye2 = ke & 65535 | Ie << 16, ve = Ve2, xe2 = st, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = ze, xe2 = $e, ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, Ve2 = Te & 65535 | Be << 16, st = ke & 65535 | Ie << 16, vt = he, _t = ge2, xt = Ee, Y = Ve2, It = Ne, Ot = tt, jt = He, ft = it, Nt = nt, Bt = dt, or2 = ut, Ht = st, Qt = at, er = ot, tr = Ge2, Et = Ye2, We % 16 === 15)
            for (qe = 0; qe < 16; qe++)
              ve = C2[qe], xe2 = Q2[qe], ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = C2[(qe + 9) % 16], xe2 = Q2[(qe + 9) % 16], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, ze = C2[(qe + 1) % 16], $e = Q2[(qe + 1) % 16], ve = (ze >>> 1 | $e << 32 - 1) ^ (ze >>> 8 | $e << 32 - 8) ^ ze >>> 7, xe2 = ($e >>> 1 | ze << 32 - 1) ^ ($e >>> 8 | ze << 32 - 8) ^ ($e >>> 7 | ze << 32 - 7), ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, ze = C2[(qe + 14) % 16], $e = Q2[(qe + 14) % 16], ve = (ze >>> 19 | $e << 32 - 19) ^ ($e >>> 61 - 32 | ze << 32 - (61 - 32)) ^ ze >>> 6, xe2 = ($e >>> 19 | ze << 32 - 19) ^ (ze >>> 61 - 32 | $e << 32 - (61 - 32)) ^ ($e >>> 6 | ze << 32 - 6), ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, C2[qe] = Te & 65535 | Be << 16, Q2[qe] = ke & 65535 | Ie << 16;
        ve = ft, xe2 = Et, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[0], xe2 = D2[0], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[0] = ft = Te & 65535 | Be << 16, D2[0] = Et = ke & 65535 | Ie << 16, ve = vt, xe2 = Nt, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[1], xe2 = D2[1], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[1] = vt = Te & 65535 | Be << 16, D2[1] = Nt = ke & 65535 | Ie << 16, ve = _t, xe2 = Bt, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[2], xe2 = D2[2], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[2] = _t = Te & 65535 | Be << 16, D2[2] = Bt = ke & 65535 | Ie << 16, ve = xt, xe2 = or2, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[3], xe2 = D2[3], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[3] = xt = Te & 65535 | Be << 16, D2[3] = or2 = ke & 65535 | Ie << 16, ve = Y, xe2 = Ht, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[4], xe2 = D2[4], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[4] = Y = Te & 65535 | Be << 16, D2[4] = Ht = ke & 65535 | Ie << 16, ve = It, xe2 = Qt, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[5], xe2 = D2[5], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[5] = It = Te & 65535 | Be << 16, D2[5] = Qt = ke & 65535 | Ie << 16, ve = Ot, xe2 = er, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[6], xe2 = D2[6], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[6] = Ot = Te & 65535 | Be << 16, D2[6] = er = ke & 65535 | Ie << 16, ve = jt, xe2 = tr, ke = xe2 & 65535, Ie = xe2 >>> 16, Te = ve & 65535, Be = ve >>> 16, ve = S2[7], xe2 = D2[7], ke += xe2 & 65535, Ie += xe2 >>> 16, Te += ve & 65535, Be += ve >>> 16, Ie += ke >>> 16, Te += Ie >>> 16, Be += Te >>> 16, S2[7] = jt = Te & 65535 | Be << 16, D2[7] = tr = ke & 65535 | Ie << 16, cr += 128, p2 -= 128;
      }
      return p2;
    }
    function R5(S2, D2, k2) {
      var p2 = new Int32Array(8), C2 = new Int32Array(8), Q2 = new Uint8Array(256), he, ge2 = k2;
      for (p2[0] = 1779033703, p2[1] = 3144134277, p2[2] = 1013904242, p2[3] = 2773480762, p2[4] = 1359893119, p2[5] = 2600822924, p2[6] = 528734635, p2[7] = 1541459225, C2[0] = 4089235720, C2[1] = 2227873595, C2[2] = 4271175723, C2[3] = 1595750129, C2[4] = 2917565137, C2[5] = 725511199, C2[6] = 4215389547, C2[7] = 327033209, X2(p2, C2, D2, k2), k2 %= 128, he = 0; he < k2; he++)
        Q2[he] = D2[ge2 - k2 + he];
      for (Q2[k2] = 128, k2 = 256 - 128 * (k2 < 112 ? 1 : 0), Q2[k2 - 9] = 0, V(Q2, k2 - 8, ge2 / 536870912 | 0, ge2 << 3), X2(p2, C2, Q2, k2), he = 0; he < 8; he++)
        V(S2, 8 * he, p2[he], C2[he]);
      return 0;
    }
    function x2(S2, D2) {
      var k2 = e(), p2 = e(), C2 = e(), Q2 = e(), he = e(), ge2 = e(), Ee = e(), Ve2 = e(), Ne = e();
      I(k2, S2[1], S2[0]), I(Ne, D2[1], D2[0]), de(k2, k2, Ne), y2(p2, S2[0], S2[1]), y2(Ne, D2[0], D2[1]), de(p2, p2, Ne), de(C2, S2[3], D2[3]), de(C2, C2, g5), de(Q2, S2[2], D2[2]), y2(Q2, Q2, Q2), I(he, p2, k2), I(ge2, Q2, C2), y2(Ee, Q2, C2), y2(Ve2, p2, k2), de(S2[0], he, ge2), de(S2[1], Ve2, Ee), de(S2[2], Ee, ge2), de(S2[3], he, Ve2);
    }
    function F2(S2, D2, k2) {
      var p2;
      for (p2 = 0; p2 < 4; p2++)
        A2(S2[p2], D2[p2], k2);
    }
    function q2(S2, D2) {
      var k2 = e(), p2 = e(), C2 = e();
      Se(C2, D2[2]), de(k2, D2[0], C2), de(p2, D2[1], C2), v2(S2, p2), S2[31] ^= M(k2) << 7;
    }
    function L2(S2, D2, k2) {
      var p2, C2;
      for (u3(S2[0], s), u3(S2[1], o), u3(S2[2], o), u3(S2[3], s), C2 = 255; C2 >= 0; --C2)
        p2 = k2[C2 / 8 | 0] >> (C2 & 7) & 1, F2(S2, D2, p2), x2(D2, S2), x2(S2, S2), F2(S2, D2, p2);
    }
    function K5(S2, D2) {
      var k2 = [e(), e(), e(), e()];
      u3(k2[0], _), u3(k2[1], N2), u3(k2[2], o), de(k2[3], _, N2), L2(S2, k2, D2);
    }
    function $(S2, D2, k2) {
      var p2 = new Uint8Array(64), C2 = [e(), e(), e(), e()], Q2;
      for (k2 || r3(D2, 32), R5(p2, D2, 32), p2[0] &= 248, p2[31] &= 127, p2[31] |= 64, K5(C2, p2), q2(S2, C2), Q2 = 0; Q2 < 32; Q2++)
        D2[Q2 + 32] = S2[Q2];
      return 0;
    }
    var we2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function pe(S2, D2) {
      var k2, p2, C2, Q2;
      for (p2 = 63; p2 >= 32; --p2) {
        for (k2 = 0, C2 = p2 - 32, Q2 = p2 - 12; C2 < Q2; ++C2)
          D2[C2] += k2 - 16 * D2[p2] * we2[C2 - (p2 - 32)], k2 = Math.floor((D2[C2] + 128) / 256), D2[C2] -= k2 * 256;
        D2[C2] += k2, D2[p2] = 0;
      }
      for (k2 = 0, C2 = 0; C2 < 32; C2++)
        D2[C2] += k2 - (D2[31] >> 4) * we2[C2], k2 = D2[C2] >> 8, D2[C2] &= 255;
      for (C2 = 0; C2 < 32; C2++)
        D2[C2] -= k2 * we2[C2];
      for (p2 = 0; p2 < 32; p2++)
        D2[p2 + 1] += D2[p2] >> 8, S2[p2] = D2[p2] & 255;
    }
    function _e(S2) {
      var D2 = new Float64Array(64), k2;
      for (k2 = 0; k2 < 64; k2++)
        D2[k2] = S2[k2];
      for (k2 = 0; k2 < 64; k2++)
        S2[k2] = 0;
      pe(S2, D2);
    }
    function fe2(S2, D2, k2, p2) {
      var C2 = new Uint8Array(64), Q2 = new Uint8Array(64), he = new Uint8Array(64), ge2, Ee, Ve2 = new Float64Array(64), Ne = [e(), e(), e(), e()];
      R5(C2, p2, 32), C2[0] &= 248, C2[31] &= 127, C2[31] |= 64;
      var tt = k2 + 64;
      for (ge2 = 0; ge2 < k2; ge2++)
        S2[64 + ge2] = D2[ge2];
      for (ge2 = 0; ge2 < 32; ge2++)
        S2[32 + ge2] = C2[32 + ge2];
      for (R5(he, S2.subarray(32), k2 + 32), _e(he), K5(Ne, he), q2(S2, Ne), ge2 = 32; ge2 < 64; ge2++)
        S2[ge2] = p2[ge2];
      for (R5(Q2, S2, k2 + 64), _e(Q2), ge2 = 0; ge2 < 64; ge2++)
        Ve2[ge2] = 0;
      for (ge2 = 0; ge2 < 32; ge2++)
        Ve2[ge2] = he[ge2];
      for (ge2 = 0; ge2 < 32; ge2++)
        for (Ee = 0; Ee < 32; Ee++)
          Ve2[ge2 + Ee] += Q2[ge2] * C2[Ee];
      return pe(S2.subarray(32), Ve2), tt;
    }
    function Fe(S2, D2) {
      var k2 = e(), p2 = e(), C2 = e(), Q2 = e(), he = e(), ge2 = e(), Ee = e();
      return u3(S2[2], o), B2(S2[1], D2), Me2(C2, S2[1]), de(Q2, C2, l), I(C2, C2, S2[2]), y2(Q2, S2[2], Q2), Me2(he, Q2), Me2(ge2, he), de(Ee, ge2, he), de(k2, Ee, C2), de(k2, k2, Q2), Oe(k2, k2), de(k2, k2, C2), de(k2, k2, Q2), de(k2, k2, Q2), de(S2[0], k2, Q2), Me2(p2, S2[0]), de(p2, p2, Q2), d2(p2, C2) && de(S2[0], S2[0], U2), Me2(p2, S2[0]), de(p2, p2, Q2), d2(p2, C2) ? -1 : (M(S2[0]) === D2[31] >> 7 && I(S2[0], s, S2[0]), de(S2[3], S2[0], S2[1]), 0);
    }
    function De(S2, D2, k2, p2) {
      var C2, Q2 = new Uint8Array(32), he = new Uint8Array(64), ge2 = [e(), e(), e(), e()], Ee = [e(), e(), e(), e()];
      if (k2 < 64 || Fe(Ee, p2))
        return -1;
      for (C2 = 0; C2 < k2; C2++)
        S2[C2] = D2[C2];
      for (C2 = 0; C2 < 32; C2++)
        S2[C2 + 32] = p2[C2];
      if (R5(he, S2, k2), _e(he), L2(ge2, Ee, he), K5(Ee, D2.subarray(32)), x2(ge2, Ee), q2(Q2, ge2), k2 -= 64, W5(D2, 0, Q2, 0)) {
        for (C2 = 0; C2 < k2; C2++)
          S2[C2] = 0;
        return -1;
      }
      for (C2 = 0; C2 < k2; C2++)
        S2[C2] = D2[C2 + 64];
      return k2;
    }
    var pt$1 = 32, je = 24, Ke = 32, wt = 16, Pe = 32, Le2 = 32, Vt = 32, Je = 32, Xe2 = 32, Jt = je, Qe = Ke, et = wt, Ut = 64, lt = 32, ht = 64, tn = 32, gt = 64;
    t.lowlevel = { crypto_core_hsalsa20: Ae, crypto_stream_xor: ne2, crypto_stream: se2, crypto_stream_salsa20_xor: H5, crypto_stream_salsa20: ue, crypto_onetimeauth: c, crypto_onetimeauth_verify: m2, crypto_verify_16: ee2, crypto_verify_32: W5, crypto_secretbox: h2, crypto_secretbox_open: a, crypto_scalarmult: ye, crypto_scalarmult_base: T, crypto_box_beforenm: P5, crypto_box_afternm: te2, crypto_box: re, crypto_box_open: ae, crypto_box_keypair: j2, crypto_hash: R5, crypto_sign: fe2, crypto_sign_keypair: $, crypto_sign_open: De, crypto_secretbox_KEYBYTES: pt$1, crypto_secretbox_NONCEBYTES: je, crypto_secretbox_ZEROBYTES: Ke, crypto_secretbox_BOXZEROBYTES: wt, crypto_scalarmult_BYTES: Pe, crypto_scalarmult_SCALARBYTES: Le2, crypto_box_PUBLICKEYBYTES: Vt, crypto_box_SECRETKEYBYTES: Je, crypto_box_BEFORENMBYTES: Xe2, crypto_box_NONCEBYTES: Jt, crypto_box_ZEROBYTES: Qe, crypto_box_BOXZEROBYTES: et, crypto_sign_BYTES: Ut, crypto_sign_PUBLICKEYBYTES: lt, crypto_sign_SECRETKEYBYTES: ht, crypto_sign_SEEDBYTES: tn, crypto_hash_BYTES: gt, gf: e, D: l, L: we2, pack25519: v2, unpack25519: B2, M: de, A: y2, S: Me2, Z: I, pow2523: Oe, add: x2, set25519: u3, modL: pe, scalarmult: L2, scalarbase: K5 };
    function yt(S2, D2) {
      if (S2.length !== pt$1)
        throw new Error("bad key size");
      if (D2.length !== je)
        throw new Error("bad nonce size");
    }
    function fs(S2, D2) {
      if (S2.length !== Vt)
        throw new Error("bad public key size");
      if (D2.length !== Je)
        throw new Error("bad secret key size");
    }
    function rt() {
      for (var S2 = 0; S2 < arguments.length; S2++)
        if (!(arguments[S2] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function bt(S2) {
      for (var D2 = 0; D2 < S2.length; D2++)
        S2[D2] = 0;
    }
    t.randomBytes = function(S2) {
      var D2 = new Uint8Array(S2);
      return r3(D2, S2), D2;
    }, t.secretbox = function(S2, D2, k2) {
      rt(S2, D2, k2), yt(k2, D2);
      for (var p2 = new Uint8Array(Ke + S2.length), C2 = new Uint8Array(p2.length), Q2 = 0; Q2 < S2.length; Q2++)
        p2[Q2 + Ke] = S2[Q2];
      return h2(C2, p2, p2.length, D2, k2), C2.subarray(wt);
    }, t.secretbox.open = function(S2, D2, k2) {
      rt(S2, D2, k2), yt(k2, D2);
      for (var p2 = new Uint8Array(wt + S2.length), C2 = new Uint8Array(p2.length), Q2 = 0; Q2 < S2.length; Q2++)
        p2[Q2 + wt] = S2[Q2];
      return p2.length < 32 || a(C2, p2, p2.length, D2, k2) !== 0 ? null : C2.subarray(Ke);
    }, t.secretbox.keyLength = pt$1, t.secretbox.nonceLength = je, t.secretbox.overheadLength = wt, t.scalarMult = function(S2, D2) {
      if (rt(S2, D2), S2.length !== Le2)
        throw new Error("bad n size");
      if (D2.length !== Pe)
        throw new Error("bad p size");
      var k2 = new Uint8Array(Pe);
      return ye(k2, S2, D2), k2;
    }, t.scalarMult.base = function(S2) {
      if (rt(S2), S2.length !== Le2)
        throw new Error("bad n size");
      var D2 = new Uint8Array(Pe);
      return T(D2, S2), D2;
    }, t.scalarMult.scalarLength = Le2, t.scalarMult.groupElementLength = Pe, t.box = function(S2, D2, k2, p2) {
      var C2 = t.box.before(k2, p2);
      return t.secretbox(S2, D2, C2);
    }, t.box.before = function(S2, D2) {
      rt(S2, D2), fs(S2, D2);
      var k2 = new Uint8Array(Xe2);
      return P5(k2, S2, D2), k2;
    }, t.box.after = t.secretbox, t.box.open = function(S2, D2, k2, p2) {
      var C2 = t.box.before(k2, p2);
      return t.secretbox.open(S2, D2, C2);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var S2 = new Uint8Array(Vt), D2 = new Uint8Array(Je);
      return j2(S2, D2), { publicKey: S2, secretKey: D2 };
    }, t.box.keyPair.fromSecretKey = function(S2) {
      if (rt(S2), S2.length !== Je)
        throw new Error("bad secret key size");
      var D2 = new Uint8Array(Vt);
      return T(D2, S2), { publicKey: D2, secretKey: new Uint8Array(S2) };
    }, t.box.publicKeyLength = Vt, t.box.secretKeyLength = Je, t.box.sharedKeyLength = Xe2, t.box.nonceLength = Jt, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(S2, D2) {
      if (rt(S2, D2), D2.length !== ht)
        throw new Error("bad secret key size");
      var k2 = new Uint8Array(Ut + S2.length);
      return fe2(k2, S2, S2.length, D2), k2;
    }, t.sign.open = function(S2, D2) {
      if (rt(S2, D2), D2.length !== lt)
        throw new Error("bad public key size");
      var k2 = new Uint8Array(S2.length), p2 = De(k2, S2, S2.length, D2);
      if (p2 < 0)
        return null;
      for (var C2 = new Uint8Array(p2), Q2 = 0; Q2 < C2.length; Q2++)
        C2[Q2] = k2[Q2];
      return C2;
    }, t.sign.detached = function(S2, D2) {
      for (var k2 = t.sign(S2, D2), p2 = new Uint8Array(Ut), C2 = 0; C2 < p2.length; C2++)
        p2[C2] = k2[C2];
      return p2;
    }, t.sign.detached.verify = function(S2, D2, k2) {
      if (rt(S2, D2, k2), D2.length !== Ut)
        throw new Error("bad signature size");
      if (k2.length !== lt)
        throw new Error("bad public key size");
      var p2 = new Uint8Array(Ut + S2.length), C2 = new Uint8Array(Ut + S2.length), Q2;
      for (Q2 = 0; Q2 < Ut; Q2++)
        p2[Q2] = D2[Q2];
      for (Q2 = 0; Q2 < S2.length; Q2++)
        p2[Q2 + Ut] = S2[Q2];
      return De(C2, p2, p2.length, k2) >= 0;
    }, t.sign.keyPair = function() {
      var S2 = new Uint8Array(lt), D2 = new Uint8Array(ht);
      return $(S2, D2), { publicKey: S2, secretKey: D2 };
    }, t.sign.keyPair.fromSecretKey = function(S2) {
      if (rt(S2), S2.length !== ht)
        throw new Error("bad secret key size");
      for (var D2 = new Uint8Array(lt), k2 = 0; k2 < D2.length; k2++)
        D2[k2] = S2[32 + k2];
      return { publicKey: D2, secretKey: new Uint8Array(S2) };
    }, t.sign.keyPair.fromSeed = function(S2) {
      if (rt(S2), S2.length !== tn)
        throw new Error("bad seed size");
      for (var D2 = new Uint8Array(lt), k2 = new Uint8Array(ht), p2 = 0; p2 < 32; p2++)
        k2[p2] = S2[p2];
      return $(D2, k2, true), { publicKey: D2, secretKey: k2 };
    }, t.sign.publicKeyLength = lt, t.sign.secretKeyLength = ht, t.sign.seedLength = tn, t.sign.signatureLength = Ut, t.hash = function(S2) {
      rt(S2);
      var D2 = new Uint8Array(gt);
      return R5(D2, S2, S2.length), D2;
    }, t.hash.hashLength = gt, t.verify = function(S2, D2) {
      return rt(S2, D2), S2.length === 0 || D2.length === 0 || S2.length !== D2.length ? false : G(S2, 0, D2, 0, S2.length) === 0;
    }, t.setPRNG = function(S2) {
      r3 = S2;
    }, function() {
      var S2 = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (S2 && S2.getRandomValues) {
        var D2 = 65536;
        t.setPRNG(function(k2, p2) {
          var C2, Q2 = new Uint8Array(p2);
          for (C2 = 0; C2 < p2; C2 += D2)
            S2.getRandomValues(Q2.subarray(C2, C2 + Math.min(p2 - C2, D2)));
          for (C2 = 0; C2 < p2; C2++)
            k2[C2] = Q2[C2];
          bt(Q2);
        });
      } else
        typeof pt < "u" && (S2 = Gp(), S2 && S2.randomBytes && t.setPRNG(function(k2, p2) {
          var C2, Q2 = S2.randomBytes(p2);
          for (C2 = 0; C2 < p2; C2++)
            k2[C2] = Q2[C2];
          bt(Q2);
        }));
    }();
  })(typeof ih < "u" && ih.exports ? ih.exports : self.nacl = self.nacl || {});
});
var Q6 = k((fB, nh) => {
  U();
  (function() {
    var t = "input is invalid type", e = "finalize already called", r3 = typeof window == "object", i = r3 ? window : {};
    i.JS_SHA512_NO_WINDOW && (r3 = false);
    var n = !r3 && typeof self == "object", s = !i.JS_SHA512_NO_NODE_JS && typeof W.default == "object" && W.default.versions && W.default.versions.node;
    s ? i = N : n && (i = self);
    var o = !i.JS_SHA512_NO_COMMON_JS && typeof nh == "object" && nh.exports, f2 = typeof define == "function" && define.amd, l = !i.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", g5 = "0123456789abcdef".split(""), _ = [-2147483648, 8388608, 32768, 128], N$12 = [24, 16, 8, 0], U2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], V = ["hex", "array", "digest", "arrayBuffer"], G = [];
    (i.JS_SHA512_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(H5) {
      return Object.prototype.toString.call(H5) === "[object Array]";
    }), l && (i.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(H5) {
      return typeof H5 == "object" && H5.buffer && H5.buffer.constructor === ArrayBuffer;
    });
    var ee2 = function(H5, ue) {
      return function(se2) {
        return new be2(ue, true).update(se2)[H5]();
      };
    }, W$1 = function(H5) {
      var ue = ee2("hex", H5);
      ue.create = function() {
        return new be2(H5);
      }, ue.update = function(E2) {
        return ue.create().update(E2);
      };
      for (var se2 = 0; se2 < V.length; ++se2) {
        var ne2 = V[se2];
        ue[ne2] = ee2(ne2, H5);
      }
      return ue;
    }, Z = function(H5, ue) {
      return function(se2, ne2) {
        return new Ae(se2, ue, true).update(ne2)[H5]();
      };
    }, le = function(H5) {
      var ue = Z("hex", H5);
      ue.create = function(E2) {
        return new Ae(E2, H5);
      }, ue.update = function(E2, c) {
        return ue.create(E2).update(c);
      };
      for (var se2 = 0; se2 < V.length; ++se2) {
        var ne2 = V[se2];
        ue[ne2] = Z(ne2, H5);
      }
      return ue;
    };
    function be2(H5, ue) {
      ue ? (G[0] = G[1] = G[2] = G[3] = G[4] = G[5] = G[6] = G[7] = G[8] = G[9] = G[10] = G[11] = G[12] = G[13] = G[14] = G[15] = G[16] = G[17] = G[18] = G[19] = G[20] = G[21] = G[22] = G[23] = G[24] = G[25] = G[26] = G[27] = G[28] = G[29] = G[30] = G[31] = G[32] = 0, this.blocks = G) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], H5 == 384 ? (this.h0h = 3418070365, this.h0l = 3238371032, this.h1h = 1654270250, this.h1l = 914150663, this.h2h = 2438529370, this.h2l = 812702999, this.h3h = 355462360, this.h3l = 4144912697, this.h4h = 1731405415, this.h4l = 4290775857, this.h5h = 2394180231, this.h5l = 1750603025, this.h6h = 3675008525, this.h6l = 1694076839, this.h7h = 1203062813, this.h7l = 3204075428) : H5 == 256 ? (this.h0h = 573645204, this.h0l = 4230739756, this.h1h = 2673172387, this.h1l = 3360449730, this.h2h = 596883563, this.h2l = 1867755857, this.h3h = 2520282905, this.h3l = 1497426621, this.h4h = 2519219938, this.h4l = 2827943907, this.h5h = 3193839141, this.h5l = 1401305490, this.h6h = 721525244, this.h6l = 746961066, this.h7h = 246885852, this.h7l = 2177182882) : H5 == 224 ? (this.h0h = 2352822216, this.h0l = 424955298, this.h1h = 1944164710, this.h1l = 2312950998, this.h2h = 502970286, this.h2l = 855612546, this.h3h = 1738396948, this.h3l = 1479516111, this.h4h = 258812777, this.h4l = 2077511080, this.h5h = 2011393907, this.h5l = 79989058, this.h6h = 1067287976, this.h6l = 1780299464, this.h7h = 286451373, this.h7l = 2446758561) : (this.h0h = 1779033703, this.h0l = 4089235720, this.h1h = 3144134277, this.h1l = 2227873595, this.h2h = 1013904242, this.h2l = 4271175723, this.h3h = 2773480762, this.h3l = 1595750129, this.h4h = 1359893119, this.h4l = 2917565137, this.h5h = 2600822924, this.h5l = 725511199, this.h6h = 528734635, this.h6l = 4215389547, this.h7h = 1541459225, this.h7l = 327033209), this.bits = H5, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false;
    }
    be2.prototype.update = function(H5) {
      if (this.finalized)
        throw new Error(e);
      var ue, se2 = typeof H5;
      if (se2 !== "string") {
        if (se2 === "object") {
          if (H5 === null)
            throw new Error(t);
          if (l && H5.constructor === ArrayBuffer)
            H5 = new Uint8Array(H5);
          else if (!Array.isArray(H5) && (!l || !ArrayBuffer.isView(H5)))
            throw new Error(t);
        } else
          throw new Error(t);
        ue = true;
      }
      for (var ne2, E2 = 0, c, m2 = H5.length, h2 = this.blocks; E2 < m2; ) {
        if (this.hashed && (this.hashed = false, h2[0] = this.block, h2[1] = h2[2] = h2[3] = h2[4] = h2[5] = h2[6] = h2[7] = h2[8] = h2[9] = h2[10] = h2[11] = h2[12] = h2[13] = h2[14] = h2[15] = h2[16] = h2[17] = h2[18] = h2[19] = h2[20] = h2[21] = h2[22] = h2[23] = h2[24] = h2[25] = h2[26] = h2[27] = h2[28] = h2[29] = h2[30] = h2[31] = h2[32] = 0), ue)
          for (c = this.start; E2 < m2 && c < 128; ++E2)
            h2[c >> 2] |= H5[E2] << N$12[c++ & 3];
        else
          for (c = this.start; E2 < m2 && c < 128; ++E2)
            ne2 = H5.charCodeAt(E2), ne2 < 128 ? h2[c >> 2] |= ne2 << N$12[c++ & 3] : ne2 < 2048 ? (h2[c >> 2] |= (192 | ne2 >> 6) << N$12[c++ & 3], h2[c >> 2] |= (128 | ne2 & 63) << N$12[c++ & 3]) : ne2 < 55296 || ne2 >= 57344 ? (h2[c >> 2] |= (224 | ne2 >> 12) << N$12[c++ & 3], h2[c >> 2] |= (128 | ne2 >> 6 & 63) << N$12[c++ & 3], h2[c >> 2] |= (128 | ne2 & 63) << N$12[c++ & 3]) : (ne2 = 65536 + ((ne2 & 1023) << 10 | H5.charCodeAt(++E2) & 1023), h2[c >> 2] |= (240 | ne2 >> 18) << N$12[c++ & 3], h2[c >> 2] |= (128 | ne2 >> 12 & 63) << N$12[c++ & 3], h2[c >> 2] |= (128 | ne2 >> 6 & 63) << N$12[c++ & 3], h2[c >> 2] |= (128 | ne2 & 63) << N$12[c++ & 3]);
        this.lastByteIndex = c, this.bytes += c - this.start, c >= 128 ? (this.block = h2[32], this.start = c - 128, this.hash(), this.hashed = true) : this.start = c;
      }
      return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
    }, be2.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var H5 = this.blocks, ue = this.lastByteIndex;
        H5[32] = this.block, H5[ue >> 2] |= _[ue & 3], this.block = H5[32], ue >= 112 && (this.hashed || this.hash(), H5[0] = this.block, H5[1] = H5[2] = H5[3] = H5[4] = H5[5] = H5[6] = H5[7] = H5[8] = H5[9] = H5[10] = H5[11] = H5[12] = H5[13] = H5[14] = H5[15] = H5[16] = H5[17] = H5[18] = H5[19] = H5[20] = H5[21] = H5[22] = H5[23] = H5[24] = H5[25] = H5[26] = H5[27] = H5[28] = H5[29] = H5[30] = H5[31] = H5[32] = 0), H5[30] = this.hBytes << 3 | this.bytes >>> 29, H5[31] = this.bytes << 3, this.hash();
      }
    }, be2.prototype.hash = function() {
      var H5 = this.h0h, ue = this.h0l, se2 = this.h1h, ne2 = this.h1l, E2 = this.h2h, c = this.h2l, m2 = this.h3h, h2 = this.h3l, a = this.h4h, u3 = this.h4l, b2 = this.h5h, A2 = this.h5l, v2 = this.h6h, d2 = this.h6l, M = this.h7h, B2 = this.h7l, y2 = this.blocks, I, de, Me2, Se, Oe, ye, T, j2, P5, te2, oe2, re, ae, ie, X2, R5, x2, F2, q2, L2, K5, $, we2, pe, _e;
      for (I = 32; I < 160; I += 2)
        L2 = y2[I - 30], K5 = y2[I - 29], de = (L2 >>> 1 | K5 << 31) ^ (L2 >>> 8 | K5 << 24) ^ L2 >>> 7, Me2 = (K5 >>> 1 | L2 << 31) ^ (K5 >>> 8 | L2 << 24) ^ (K5 >>> 7 | L2 << 25), L2 = y2[I - 4], K5 = y2[I - 3], Se = (L2 >>> 19 | K5 << 13) ^ (K5 >>> 29 | L2 << 3) ^ L2 >>> 6, Oe = (K5 >>> 19 | L2 << 13) ^ (L2 >>> 29 | K5 << 3) ^ (K5 >>> 6 | L2 << 26), L2 = y2[I - 32], K5 = y2[I - 31], $ = y2[I - 14], we2 = y2[I - 13], ye = (we2 & 65535) + (K5 & 65535) + (Me2 & 65535) + (Oe & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (Me2 >>> 16) + (Oe >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (de & 65535) + (Se & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (de >>> 16) + (Se >>> 16) + (j2 >>> 16), y2[I] = P5 << 16 | j2 & 65535, y2[I + 1] = T << 16 | ye & 65535;
      var fe2 = H5, Fe = ue, De = se2, pt2 = ne2, je = E2, Ke = c, wt = m2, Pe = h2, Le2 = a, Vt = u3, Je = b2, Xe2 = A2, Jt = v2, Qe = d2, et = M, Ut = B2;
      for (R5 = De & je, x2 = pt2 & Ke, I = 0; I < 160; I += 8)
        de = (fe2 >>> 28 | Fe << 4) ^ (Fe >>> 2 | fe2 << 30) ^ (Fe >>> 7 | fe2 << 25), Me2 = (Fe >>> 28 | fe2 << 4) ^ (fe2 >>> 2 | Fe << 30) ^ (fe2 >>> 7 | Fe << 25), Se = (Le2 >>> 14 | Vt << 18) ^ (Le2 >>> 18 | Vt << 14) ^ (Vt >>> 9 | Le2 << 23), Oe = (Vt >>> 14 | Le2 << 18) ^ (Vt >>> 18 | Le2 << 14) ^ (Le2 >>> 9 | Vt << 23), te2 = fe2 & De, oe2 = Fe & pt2, F2 = te2 ^ fe2 & je ^ R5, q2 = oe2 ^ Fe & Ke ^ x2, pe = Le2 & Je ^ ~Le2 & Jt, _e = Vt & Xe2 ^ ~Vt & Qe, L2 = y2[I], K5 = y2[I + 1], $ = U2[I], we2 = U2[I + 1], ye = (we2 & 65535) + (K5 & 65535) + (_e & 65535) + (Oe & 65535) + (Ut & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (_e >>> 16) + (Oe >>> 16) + (Ut >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (pe & 65535) + (Se & 65535) + (et & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (pe >>> 16) + (Se >>> 16) + (et >>> 16) + (j2 >>> 16), L2 = P5 << 16 | j2 & 65535, K5 = T << 16 | ye & 65535, ye = (q2 & 65535) + (Me2 & 65535), T = (q2 >>> 16) + (Me2 >>> 16) + (ye >>> 16), j2 = (F2 & 65535) + (de & 65535) + (T >>> 16), P5 = (F2 >>> 16) + (de >>> 16) + (j2 >>> 16), $ = P5 << 16 | j2 & 65535, we2 = T << 16 | ye & 65535, ye = (Pe & 65535) + (K5 & 65535), T = (Pe >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = (wt & 65535) + (L2 & 65535) + (T >>> 16), P5 = (wt >>> 16) + (L2 >>> 16) + (j2 >>> 16), et = P5 << 16 | j2 & 65535, Ut = T << 16 | ye & 65535, ye = (we2 & 65535) + (K5 & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (j2 >>> 16), wt = P5 << 16 | j2 & 65535, Pe = T << 16 | ye & 65535, de = (wt >>> 28 | Pe << 4) ^ (Pe >>> 2 | wt << 30) ^ (Pe >>> 7 | wt << 25), Me2 = (Pe >>> 28 | wt << 4) ^ (wt >>> 2 | Pe << 30) ^ (wt >>> 7 | Pe << 25), Se = (et >>> 14 | Ut << 18) ^ (et >>> 18 | Ut << 14) ^ (Ut >>> 9 | et << 23), Oe = (Ut >>> 14 | et << 18) ^ (Ut >>> 18 | et << 14) ^ (et >>> 9 | Ut << 23), re = wt & fe2, ae = Pe & Fe, F2 = re ^ wt & De ^ te2, q2 = ae ^ Pe & pt2 ^ oe2, pe = et & Le2 ^ ~et & Je, _e = Ut & Vt ^ ~Ut & Xe2, L2 = y2[I + 2], K5 = y2[I + 3], $ = U2[I + 2], we2 = U2[I + 3], ye = (we2 & 65535) + (K5 & 65535) + (_e & 65535) + (Oe & 65535) + (Qe & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (_e >>> 16) + (Oe >>> 16) + (Qe >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (pe & 65535) + (Se & 65535) + (Jt & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (pe >>> 16) + (Se >>> 16) + (Jt >>> 16) + (j2 >>> 16), L2 = P5 << 16 | j2 & 65535, K5 = T << 16 | ye & 65535, ye = (q2 & 65535) + (Me2 & 65535), T = (q2 >>> 16) + (Me2 >>> 16) + (ye >>> 16), j2 = (F2 & 65535) + (de & 65535) + (T >>> 16), P5 = (F2 >>> 16) + (de >>> 16) + (j2 >>> 16), $ = P5 << 16 | j2 & 65535, we2 = T << 16 | ye & 65535, ye = (Ke & 65535) + (K5 & 65535), T = (Ke >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = (je & 65535) + (L2 & 65535) + (T >>> 16), P5 = (je >>> 16) + (L2 >>> 16) + (j2 >>> 16), Jt = P5 << 16 | j2 & 65535, Qe = T << 16 | ye & 65535, ye = (we2 & 65535) + (K5 & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (j2 >>> 16), je = P5 << 16 | j2 & 65535, Ke = T << 16 | ye & 65535, de = (je >>> 28 | Ke << 4) ^ (Ke >>> 2 | je << 30) ^ (Ke >>> 7 | je << 25), Me2 = (Ke >>> 28 | je << 4) ^ (je >>> 2 | Ke << 30) ^ (je >>> 7 | Ke << 25), Se = (Jt >>> 14 | Qe << 18) ^ (Jt >>> 18 | Qe << 14) ^ (Qe >>> 9 | Jt << 23), Oe = (Qe >>> 14 | Jt << 18) ^ (Qe >>> 18 | Jt << 14) ^ (Jt >>> 9 | Qe << 23), ie = je & wt, X2 = Ke & Pe, F2 = ie ^ je & fe2 ^ re, q2 = X2 ^ Ke & Fe ^ ae, pe = Jt & et ^ ~Jt & Le2, _e = Qe & Ut ^ ~Qe & Vt, L2 = y2[I + 4], K5 = y2[I + 5], $ = U2[I + 4], we2 = U2[I + 5], ye = (we2 & 65535) + (K5 & 65535) + (_e & 65535) + (Oe & 65535) + (Xe2 & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (_e >>> 16) + (Oe >>> 16) + (Xe2 >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (pe & 65535) + (Se & 65535) + (Je & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (pe >>> 16) + (Se >>> 16) + (Je >>> 16) + (j2 >>> 16), L2 = P5 << 16 | j2 & 65535, K5 = T << 16 | ye & 65535, ye = (q2 & 65535) + (Me2 & 65535), T = (q2 >>> 16) + (Me2 >>> 16) + (ye >>> 16), j2 = (F2 & 65535) + (de & 65535) + (T >>> 16), P5 = (F2 >>> 16) + (de >>> 16) + (j2 >>> 16), $ = P5 << 16 | j2 & 65535, we2 = T << 16 | ye & 65535, ye = (pt2 & 65535) + (K5 & 65535), T = (pt2 >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = (De & 65535) + (L2 & 65535) + (T >>> 16), P5 = (De >>> 16) + (L2 >>> 16) + (j2 >>> 16), Je = P5 << 16 | j2 & 65535, Xe2 = T << 16 | ye & 65535, ye = (we2 & 65535) + (K5 & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (j2 >>> 16), De = P5 << 16 | j2 & 65535, pt2 = T << 16 | ye & 65535, de = (De >>> 28 | pt2 << 4) ^ (pt2 >>> 2 | De << 30) ^ (pt2 >>> 7 | De << 25), Me2 = (pt2 >>> 28 | De << 4) ^ (De >>> 2 | pt2 << 30) ^ (De >>> 7 | pt2 << 25), Se = (Je >>> 14 | Xe2 << 18) ^ (Je >>> 18 | Xe2 << 14) ^ (Xe2 >>> 9 | Je << 23), Oe = (Xe2 >>> 14 | Je << 18) ^ (Xe2 >>> 18 | Je << 14) ^ (Je >>> 9 | Xe2 << 23), R5 = De & je, x2 = pt2 & Ke, F2 = R5 ^ De & wt ^ ie, q2 = x2 ^ pt2 & Pe ^ X2, pe = Je & Jt ^ ~Je & et, _e = Xe2 & Qe ^ ~Xe2 & Ut, L2 = y2[I + 6], K5 = y2[I + 7], $ = U2[I + 6], we2 = U2[I + 7], ye = (we2 & 65535) + (K5 & 65535) + (_e & 65535) + (Oe & 65535) + (Vt & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (_e >>> 16) + (Oe >>> 16) + (Vt >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (pe & 65535) + (Se & 65535) + (Le2 & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (pe >>> 16) + (Se >>> 16) + (Le2 >>> 16) + (j2 >>> 16), L2 = P5 << 16 | j2 & 65535, K5 = T << 16 | ye & 65535, ye = (q2 & 65535) + (Me2 & 65535), T = (q2 >>> 16) + (Me2 >>> 16) + (ye >>> 16), j2 = (F2 & 65535) + (de & 65535) + (T >>> 16), P5 = (F2 >>> 16) + (de >>> 16) + (j2 >>> 16), $ = P5 << 16 | j2 & 65535, we2 = T << 16 | ye & 65535, ye = (Fe & 65535) + (K5 & 65535), T = (Fe >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = (fe2 & 65535) + (L2 & 65535) + (T >>> 16), P5 = (fe2 >>> 16) + (L2 >>> 16) + (j2 >>> 16), Le2 = P5 << 16 | j2 & 65535, Vt = T << 16 | ye & 65535, ye = (we2 & 65535) + (K5 & 65535), T = (we2 >>> 16) + (K5 >>> 16) + (ye >>> 16), j2 = ($ & 65535) + (L2 & 65535) + (T >>> 16), P5 = ($ >>> 16) + (L2 >>> 16) + (j2 >>> 16), fe2 = P5 << 16 | j2 & 65535, Fe = T << 16 | ye & 65535;
      ye = (ue & 65535) + (Fe & 65535), T = (ue >>> 16) + (Fe >>> 16) + (ye >>> 16), j2 = (H5 & 65535) + (fe2 & 65535) + (T >>> 16), P5 = (H5 >>> 16) + (fe2 >>> 16) + (j2 >>> 16), this.h0h = P5 << 16 | j2 & 65535, this.h0l = T << 16 | ye & 65535, ye = (ne2 & 65535) + (pt2 & 65535), T = (ne2 >>> 16) + (pt2 >>> 16) + (ye >>> 16), j2 = (se2 & 65535) + (De & 65535) + (T >>> 16), P5 = (se2 >>> 16) + (De >>> 16) + (j2 >>> 16), this.h1h = P5 << 16 | j2 & 65535, this.h1l = T << 16 | ye & 65535, ye = (c & 65535) + (Ke & 65535), T = (c >>> 16) + (Ke >>> 16) + (ye >>> 16), j2 = (E2 & 65535) + (je & 65535) + (T >>> 16), P5 = (E2 >>> 16) + (je >>> 16) + (j2 >>> 16), this.h2h = P5 << 16 | j2 & 65535, this.h2l = T << 16 | ye & 65535, ye = (h2 & 65535) + (Pe & 65535), T = (h2 >>> 16) + (Pe >>> 16) + (ye >>> 16), j2 = (m2 & 65535) + (wt & 65535) + (T >>> 16), P5 = (m2 >>> 16) + (wt >>> 16) + (j2 >>> 16), this.h3h = P5 << 16 | j2 & 65535, this.h3l = T << 16 | ye & 65535, ye = (u3 & 65535) + (Vt & 65535), T = (u3 >>> 16) + (Vt >>> 16) + (ye >>> 16), j2 = (a & 65535) + (Le2 & 65535) + (T >>> 16), P5 = (a >>> 16) + (Le2 >>> 16) + (j2 >>> 16), this.h4h = P5 << 16 | j2 & 65535, this.h4l = T << 16 | ye & 65535, ye = (A2 & 65535) + (Xe2 & 65535), T = (A2 >>> 16) + (Xe2 >>> 16) + (ye >>> 16), j2 = (b2 & 65535) + (Je & 65535) + (T >>> 16), P5 = (b2 >>> 16) + (Je >>> 16) + (j2 >>> 16), this.h5h = P5 << 16 | j2 & 65535, this.h5l = T << 16 | ye & 65535, ye = (d2 & 65535) + (Qe & 65535), T = (d2 >>> 16) + (Qe >>> 16) + (ye >>> 16), j2 = (v2 & 65535) + (Jt & 65535) + (T >>> 16), P5 = (v2 >>> 16) + (Jt >>> 16) + (j2 >>> 16), this.h6h = P5 << 16 | j2 & 65535, this.h6l = T << 16 | ye & 65535, ye = (B2 & 65535) + (Ut & 65535), T = (B2 >>> 16) + (Ut >>> 16) + (ye >>> 16), j2 = (M & 65535) + (et & 65535) + (T >>> 16), P5 = (M >>> 16) + (et >>> 16) + (j2 >>> 16), this.h7h = P5 << 16 | j2 & 65535, this.h7l = T << 16 | ye & 65535;
    }, be2.prototype.hex = function() {
      this.finalize();
      var H5 = this.h0h, ue = this.h0l, se2 = this.h1h, ne2 = this.h1l, E2 = this.h2h, c = this.h2l, m2 = this.h3h, h2 = this.h3l, a = this.h4h, u3 = this.h4l, b2 = this.h5h, A2 = this.h5l, v2 = this.h6h, d2 = this.h6l, M = this.h7h, B2 = this.h7l, y2 = this.bits, I = g5[H5 >> 28 & 15] + g5[H5 >> 24 & 15] + g5[H5 >> 20 & 15] + g5[H5 >> 16 & 15] + g5[H5 >> 12 & 15] + g5[H5 >> 8 & 15] + g5[H5 >> 4 & 15] + g5[H5 & 15] + g5[ue >> 28 & 15] + g5[ue >> 24 & 15] + g5[ue >> 20 & 15] + g5[ue >> 16 & 15] + g5[ue >> 12 & 15] + g5[ue >> 8 & 15] + g5[ue >> 4 & 15] + g5[ue & 15] + g5[se2 >> 28 & 15] + g5[se2 >> 24 & 15] + g5[se2 >> 20 & 15] + g5[se2 >> 16 & 15] + g5[se2 >> 12 & 15] + g5[se2 >> 8 & 15] + g5[se2 >> 4 & 15] + g5[se2 & 15] + g5[ne2 >> 28 & 15] + g5[ne2 >> 24 & 15] + g5[ne2 >> 20 & 15] + g5[ne2 >> 16 & 15] + g5[ne2 >> 12 & 15] + g5[ne2 >> 8 & 15] + g5[ne2 >> 4 & 15] + g5[ne2 & 15] + g5[E2 >> 28 & 15] + g5[E2 >> 24 & 15] + g5[E2 >> 20 & 15] + g5[E2 >> 16 & 15] + g5[E2 >> 12 & 15] + g5[E2 >> 8 & 15] + g5[E2 >> 4 & 15] + g5[E2 & 15] + g5[c >> 28 & 15] + g5[c >> 24 & 15] + g5[c >> 20 & 15] + g5[c >> 16 & 15] + g5[c >> 12 & 15] + g5[c >> 8 & 15] + g5[c >> 4 & 15] + g5[c & 15] + g5[m2 >> 28 & 15] + g5[m2 >> 24 & 15] + g5[m2 >> 20 & 15] + g5[m2 >> 16 & 15] + g5[m2 >> 12 & 15] + g5[m2 >> 8 & 15] + g5[m2 >> 4 & 15] + g5[m2 & 15];
      return y2 >= 256 && (I += g5[h2 >> 28 & 15] + g5[h2 >> 24 & 15] + g5[h2 >> 20 & 15] + g5[h2 >> 16 & 15] + g5[h2 >> 12 & 15] + g5[h2 >> 8 & 15] + g5[h2 >> 4 & 15] + g5[h2 & 15]), y2 >= 384 && (I += g5[a >> 28 & 15] + g5[a >> 24 & 15] + g5[a >> 20 & 15] + g5[a >> 16 & 15] + g5[a >> 12 & 15] + g5[a >> 8 & 15] + g5[a >> 4 & 15] + g5[a & 15] + g5[u3 >> 28 & 15] + g5[u3 >> 24 & 15] + g5[u3 >> 20 & 15] + g5[u3 >> 16 & 15] + g5[u3 >> 12 & 15] + g5[u3 >> 8 & 15] + g5[u3 >> 4 & 15] + g5[u3 & 15] + g5[b2 >> 28 & 15] + g5[b2 >> 24 & 15] + g5[b2 >> 20 & 15] + g5[b2 >> 16 & 15] + g5[b2 >> 12 & 15] + g5[b2 >> 8 & 15] + g5[b2 >> 4 & 15] + g5[b2 & 15] + g5[A2 >> 28 & 15] + g5[A2 >> 24 & 15] + g5[A2 >> 20 & 15] + g5[A2 >> 16 & 15] + g5[A2 >> 12 & 15] + g5[A2 >> 8 & 15] + g5[A2 >> 4 & 15] + g5[A2 & 15]), y2 == 512 && (I += g5[v2 >> 28 & 15] + g5[v2 >> 24 & 15] + g5[v2 >> 20 & 15] + g5[v2 >> 16 & 15] + g5[v2 >> 12 & 15] + g5[v2 >> 8 & 15] + g5[v2 >> 4 & 15] + g5[v2 & 15] + g5[d2 >> 28 & 15] + g5[d2 >> 24 & 15] + g5[d2 >> 20 & 15] + g5[d2 >> 16 & 15] + g5[d2 >> 12 & 15] + g5[d2 >> 8 & 15] + g5[d2 >> 4 & 15] + g5[d2 & 15] + g5[M >> 28 & 15] + g5[M >> 24 & 15] + g5[M >> 20 & 15] + g5[M >> 16 & 15] + g5[M >> 12 & 15] + g5[M >> 8 & 15] + g5[M >> 4 & 15] + g5[M & 15] + g5[B2 >> 28 & 15] + g5[B2 >> 24 & 15] + g5[B2 >> 20 & 15] + g5[B2 >> 16 & 15] + g5[B2 >> 12 & 15] + g5[B2 >> 8 & 15] + g5[B2 >> 4 & 15] + g5[B2 & 15]), I;
    }, be2.prototype.toString = be2.prototype.hex, be2.prototype.digest = function() {
      this.finalize();
      var H5 = this.h0h, ue = this.h0l, se2 = this.h1h, ne2 = this.h1l, E2 = this.h2h, c = this.h2l, m2 = this.h3h, h2 = this.h3l, a = this.h4h, u3 = this.h4l, b2 = this.h5h, A2 = this.h5l, v2 = this.h6h, d2 = this.h6l, M = this.h7h, B2 = this.h7l, y2 = this.bits, I = [H5 >> 24 & 255, H5 >> 16 & 255, H5 >> 8 & 255, H5 & 255, ue >> 24 & 255, ue >> 16 & 255, ue >> 8 & 255, ue & 255, se2 >> 24 & 255, se2 >> 16 & 255, se2 >> 8 & 255, se2 & 255, ne2 >> 24 & 255, ne2 >> 16 & 255, ne2 >> 8 & 255, ne2 & 255, E2 >> 24 & 255, E2 >> 16 & 255, E2 >> 8 & 255, E2 & 255, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, c & 255, m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, m2 & 255];
      return y2 >= 256 && I.push(h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255), y2 >= 384 && I.push(a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255, u3 >> 24 & 255, u3 >> 16 & 255, u3 >> 8 & 255, u3 & 255, b2 >> 24 & 255, b2 >> 16 & 255, b2 >> 8 & 255, b2 & 255, A2 >> 24 & 255, A2 >> 16 & 255, A2 >> 8 & 255, A2 & 255), y2 == 512 && I.push(v2 >> 24 & 255, v2 >> 16 & 255, v2 >> 8 & 255, v2 & 255, d2 >> 24 & 255, d2 >> 16 & 255, d2 >> 8 & 255, d2 & 255, M >> 24 & 255, M >> 16 & 255, M >> 8 & 255, M & 255, B2 >> 24 & 255, B2 >> 16 & 255, B2 >> 8 & 255, B2 & 255), I;
    }, be2.prototype.array = be2.prototype.digest, be2.prototype.arrayBuffer = function() {
      this.finalize();
      var H5 = this.bits, ue = new ArrayBuffer(H5 / 8), se2 = new DataView(ue);
      return se2.setUint32(0, this.h0h), se2.setUint32(4, this.h0l), se2.setUint32(8, this.h1h), se2.setUint32(12, this.h1l), se2.setUint32(16, this.h2h), se2.setUint32(20, this.h2l), se2.setUint32(24, this.h3h), H5 >= 256 && se2.setUint32(28, this.h3l), H5 >= 384 && (se2.setUint32(32, this.h4h), se2.setUint32(36, this.h4l), se2.setUint32(40, this.h5h), se2.setUint32(44, this.h5l)), H5 == 512 && (se2.setUint32(48, this.h6h), se2.setUint32(52, this.h6l), se2.setUint32(56, this.h7h), se2.setUint32(60, this.h7l)), ue;
    }, be2.prototype.clone = function() {
      var H5 = new be2(this.bits, false);
      return this.copyTo(H5), H5;
    }, be2.prototype.copyTo = function(H5) {
      var ue = 0, se2 = ["h0h", "h0l", "h1h", "h1l", "h2h", "h2l", "h3h", "h3l", "h4h", "h4l", "h5h", "h5l", "h6h", "h6l", "h7h", "h7l", "start", "bytes", "hBytes", "finalized", "hashed", "lastByteIndex"];
      for (ue = 0; ue < se2.length; ++ue)
        H5[se2[ue]] = this[se2[ue]];
      for (ue = 0; ue < this.blocks.length; ++ue)
        H5.blocks[ue] = this.blocks[ue];
    };
    function Ae(H5, ue, se2) {
      var ne2, E2 = typeof H5;
      if (E2 !== "string") {
        if (E2 === "object") {
          if (H5 === null)
            throw new Error(t);
          if (l && H5.constructor === ArrayBuffer)
            H5 = new Uint8Array(H5);
          else if (!Array.isArray(H5) && (!l || !ArrayBuffer.isView(H5)))
            throw new Error(t);
        } else
          throw new Error(t);
        ne2 = true;
      }
      var c = H5.length;
      if (!ne2) {
        for (var m2 = [], c = H5.length, h2 = 0, a, u3 = 0; u3 < c; ++u3)
          a = H5.charCodeAt(u3), a < 128 ? m2[h2++] = a : a < 2048 ? (m2[h2++] = 192 | a >> 6, m2[h2++] = 128 | a & 63) : a < 55296 || a >= 57344 ? (m2[h2++] = 224 | a >> 12, m2[h2++] = 128 | a >> 6 & 63, m2[h2++] = 128 | a & 63) : (a = 65536 + ((a & 1023) << 10 | H5.charCodeAt(++u3) & 1023), m2[h2++] = 240 | a >> 18, m2[h2++] = 128 | a >> 12 & 63, m2[h2++] = 128 | a >> 6 & 63, m2[h2++] = 128 | a & 63);
        H5 = m2;
      }
      H5.length > 128 && (H5 = new be2(ue, true).update(H5).array());
      for (var b2 = [], A2 = [], u3 = 0; u3 < 128; ++u3) {
        var v2 = H5[u3] || 0;
        b2[u3] = 92 ^ v2, A2[u3] = 54 ^ v2;
      }
      be2.call(this, ue, se2), this.update(A2), this.oKeyPad = b2, this.inner = true, this.sharedMemory = se2;
    }
    Ae.prototype = new be2(), Ae.prototype.finalize = function() {
      if (be2.prototype.finalize.call(this), this.inner) {
        this.inner = false;
        var H5 = this.array();
        be2.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(H5), be2.prototype.finalize.call(this);
      }
    }, Ae.prototype.clone = function() {
      var H5 = new Ae([], this.bits, false);
      this.copyTo(H5), H5.inner = this.inner;
      for (var ue = 0; ue < this.oKeyPad.length; ++ue)
        H5.oKeyPad[ue] = this.oKeyPad[ue];
      return H5;
    };
    var me = W$1(512);
    me.sha512 = me, me.sha384 = W$1(384), me.sha512_256 = W$1(256), me.sha512_224 = W$1(224), me.sha512.hmac = le(512), me.sha384.hmac = le(384), me.sha512_256.hmac = le(256), me.sha512_224.hmac = le(224), o ? nh.exports = me : (i.sha512 = me.sha512, i.sha384 = me.sha384, i.sha512_256 = me.sha512_256, i.sha512_224 = me.sha512_224, f2 && define(function() {
      return me;
    }));
  })();
});
var V1 = k((uB, fh) => {
  U();
  (function() {
    var t = typeof window == "object" ? window : {}, e = !t.HI_BASE32_NO_NODE_JS && typeof W.default == "object" && W.default.versions && W.default.versions.node;
    e && (t = N);
    var r3 = !t.HI_BASE32_NO_COMMON_JS && typeof fh == "object" && fh.exports, i = typeof define == "function" && define.amd, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""), s = { A: 0, B: 1, C: 2, D: 3, E: 4, F: 5, G: 6, H: 7, I: 8, J: 9, K: 10, L: 11, M: 12, N: 13, O: 14, P: 15, Q: 16, R: 17, S: 18, T: 19, U: 20, V: 21, W: 22, X: 23, Y: 24, Z: 25, 2: 26, 3: 27, 4: 28, 5: 29, 6: 30, 7: 31 }, o = [0, 0, 0, 0, 0, 0, 0, 0], f2 = function(W5, Z) {
      Z.length > 10 && (Z = "..." + Z.substr(-10));
      var le = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + W5 + " bytes: " + Z + " <-");
      throw le.position = W5, le;
    }, l = function(W5) {
      for (var Z = "", le = W5.length, be2 = 0, Ae = 0, me, H5; be2 < le; ) {
        if (me = W5[be2++], me <= 127) {
          Z += String.fromCharCode(me);
          continue;
        } else
          me > 191 && me <= 223 ? (H5 = me & 31, Ae = 1) : me <= 239 ? (H5 = me & 15, Ae = 2) : me <= 247 ? (H5 = me & 7, Ae = 3) : f2(be2, Z);
        for (var ue = 0; ue < Ae; ++ue)
          me = W5[be2++], (me < 128 || me > 191) && f2(be2, Z), H5 <<= 6, H5 += me & 63;
        H5 >= 55296 && H5 <= 57343 && f2(be2, Z), H5 > 1114111 && f2(be2, Z), H5 <= 65535 ? Z += String.fromCharCode(H5) : (H5 -= 65536, Z += String.fromCharCode((H5 >> 10) + 55296), Z += String.fromCharCode((H5 & 1023) + 56320));
      }
      return Z;
    }, g5 = function(W5) {
      if (W5 === "")
        return [];
      if (!/^[A-Z2-7=]+$/.test(W5))
        throw new Error("Invalid base32 characters");
      W5 = W5.replace(/=/g, "");
      for (var Z, le, be2, Ae, me, H5, ue, se2, ne2 = [], E2 = 0, c = W5.length, m2 = 0, h2 = c >> 3 << 3; m2 < h2; )
        Z = s[W5.charAt(m2++)], le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], me = s[W5.charAt(m2++)], H5 = s[W5.charAt(m2++)], ue = s[W5.charAt(m2++)], se2 = s[W5.charAt(m2++)], ne2[E2++] = (Z << 3 | le >>> 2) & 255, ne2[E2++] = (le << 6 | be2 << 1 | Ae >>> 4) & 255, ne2[E2++] = (Ae << 4 | me >>> 1) & 255, ne2[E2++] = (me << 7 | H5 << 2 | ue >>> 3) & 255, ne2[E2++] = (ue << 5 | se2) & 255;
      var a = c - h2;
      return a === 2 ? (Z = s[W5.charAt(m2++)], le = s[W5.charAt(m2++)], ne2[E2++] = (Z << 3 | le >>> 2) & 255) : a === 4 ? (Z = s[W5.charAt(m2++)], le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], ne2[E2++] = (Z << 3 | le >>> 2) & 255, ne2[E2++] = (le << 6 | be2 << 1 | Ae >>> 4) & 255) : a === 5 ? (Z = s[W5.charAt(m2++)], le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], me = s[W5.charAt(m2++)], ne2[E2++] = (Z << 3 | le >>> 2) & 255, ne2[E2++] = (le << 6 | be2 << 1 | Ae >>> 4) & 255, ne2[E2++] = (Ae << 4 | me >>> 1) & 255) : a === 7 && (Z = s[W5.charAt(m2++)], le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], me = s[W5.charAt(m2++)], H5 = s[W5.charAt(m2++)], ue = s[W5.charAt(m2++)], ne2[E2++] = (Z << 3 | le >>> 2) & 255, ne2[E2++] = (le << 6 | be2 << 1 | Ae >>> 4) & 255, ne2[E2++] = (Ae << 4 | me >>> 1) & 255, ne2[E2++] = (me << 7 | H5 << 2 | ue >>> 3) & 255), ne2;
    }, _ = function(W5) {
      for (var Z, le, be2, Ae, me, H5 = "", ue = W5.length, se2 = 0, ne2 = parseInt(ue / 5) * 5; se2 < ne2; )
        Z = W5.charCodeAt(se2++), le = W5.charCodeAt(se2++), be2 = W5.charCodeAt(se2++), Ae = W5.charCodeAt(se2++), me = W5.charCodeAt(se2++), H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[(be2 << 1 | Ae >>> 7) & 31] + n[Ae >>> 2 & 31] + n[(Ae << 3 | me >>> 5) & 31] + n[me & 31];
      var E2 = ue - ne2;
      return E2 === 1 ? (Z = W5.charCodeAt(se2), H5 += n[Z >>> 3] + n[Z << 2 & 31] + "======") : E2 === 2 ? (Z = W5.charCodeAt(se2++), le = W5.charCodeAt(se2), H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[le << 4 & 31] + "====") : E2 === 3 ? (Z = W5.charCodeAt(se2++), le = W5.charCodeAt(se2++), be2 = W5.charCodeAt(se2), H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[be2 << 1 & 31] + "===") : E2 === 4 && (Z = W5.charCodeAt(se2++), le = W5.charCodeAt(se2++), be2 = W5.charCodeAt(se2++), Ae = W5.charCodeAt(se2), H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[(be2 << 1 | Ae >>> 7) & 31] + n[Ae >>> 2 & 31] + n[Ae << 3 & 31] + "="), H5;
    }, N$12 = function(W5) {
      var Z, le, be2, Ae, me, H5, ue = false, se2 = "", ne2 = 0, E2, c = 0, h2 = W5.length;
      if (W5 === "")
        return se2;
      do {
        for (o[0] = o[5], o[1] = o[6], o[2] = o[7], E2 = c; ne2 < h2 && E2 < 5; ++ne2)
          H5 = W5.charCodeAt(ne2), H5 < 128 ? o[E2++] = H5 : H5 < 2048 ? (o[E2++] = 192 | H5 >> 6, o[E2++] = 128 | H5 & 63) : H5 < 55296 || H5 >= 57344 ? (o[E2++] = 224 | H5 >> 12, o[E2++] = 128 | H5 >> 6 & 63, o[E2++] = 128 | H5 & 63) : (H5 = 65536 + ((H5 & 1023) << 10 | W5.charCodeAt(++ne2) & 1023), o[E2++] = 240 | H5 >> 18, o[E2++] = 128 | H5 >> 12 & 63, o[E2++] = 128 | H5 >> 6 & 63, o[E2++] = 128 | H5 & 63);
        c = E2 - 5, ne2 === h2 && ++ne2, ne2 > h2 && E2 < 6 && (ue = true), Z = o[0], E2 > 4 ? (le = o[1], be2 = o[2], Ae = o[3], me = o[4], se2 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[(be2 << 1 | Ae >>> 7) & 31] + n[Ae >>> 2 & 31] + n[(Ae << 3 | me >>> 5) & 31] + n[me & 31]) : E2 === 1 ? se2 += n[Z >>> 3] + n[Z << 2 & 31] + "======" : E2 === 2 ? (le = o[1], se2 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[le << 4 & 31] + "====") : E2 === 3 ? (le = o[1], be2 = o[2], se2 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[be2 << 1 & 31] + "===") : (le = o[1], be2 = o[2], Ae = o[3], se2 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[(be2 << 1 | Ae >>> 7) & 31] + n[Ae >>> 2 & 31] + n[Ae << 3 & 31] + "=");
      } while (!ue);
      return se2;
    }, U2 = function(W5) {
      for (var Z, le, be2, Ae, me, H5 = "", ue = W5.length, se2 = 0, ne2 = parseInt(ue / 5) * 5; se2 < ne2; )
        Z = W5[se2++], le = W5[se2++], be2 = W5[se2++], Ae = W5[se2++], me = W5[se2++], H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[(be2 << 1 | Ae >>> 7) & 31] + n[Ae >>> 2 & 31] + n[(Ae << 3 | me >>> 5) & 31] + n[me & 31];
      var E2 = ue - ne2;
      return E2 === 1 ? (Z = W5[se2], H5 += n[Z >>> 3] + n[Z << 2 & 31] + "======") : E2 === 2 ? (Z = W5[se2++], le = W5[se2], H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[le << 4 & 31] + "====") : E2 === 3 ? (Z = W5[se2++], le = W5[se2++], be2 = W5[se2], H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[be2 << 1 & 31] + "===") : E2 === 4 && (Z = W5[se2++], le = W5[se2++], be2 = W5[se2++], Ae = W5[se2], H5 += n[Z >>> 3] + n[(Z << 2 | le >>> 6) & 31] + n[le >>> 1 & 31] + n[(le << 4 | be2 >>> 4) & 31] + n[(be2 << 1 | Ae >>> 7) & 31] + n[Ae >>> 2 & 31] + n[Ae << 3 & 31] + "="), H5;
    }, V = function(W5, Z) {
      var le = typeof W5 != "string";
      return le && W5.constructor === ArrayBuffer && (W5 = new Uint8Array(W5)), le ? U2(W5) : Z ? _(W5) : N$12(W5);
    }, G = function(W5, Z) {
      if (!Z)
        return l(g5(W5));
      if (W5 === "")
        return "";
      if (!/^[A-Z2-7=]+$/.test(W5))
        throw new Error("Invalid base32 characters");
      var le, be2, Ae, me, H5, ue, se2, ne2, E2 = "", c = W5.indexOf("=");
      c === -1 && (c = W5.length);
      for (var m2 = 0, h2 = c >> 3 << 3; m2 < h2; )
        le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], me = s[W5.charAt(m2++)], H5 = s[W5.charAt(m2++)], ue = s[W5.charAt(m2++)], se2 = s[W5.charAt(m2++)], ne2 = s[W5.charAt(m2++)], E2 += String.fromCharCode((le << 3 | be2 >>> 2) & 255) + String.fromCharCode((be2 << 6 | Ae << 1 | me >>> 4) & 255) + String.fromCharCode((me << 4 | H5 >>> 1) & 255) + String.fromCharCode((H5 << 7 | ue << 2 | se2 >>> 3) & 255) + String.fromCharCode((se2 << 5 | ne2) & 255);
      var a = c - h2;
      return a === 2 ? (le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], E2 += String.fromCharCode((le << 3 | be2 >>> 2) & 255)) : a === 4 ? (le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], me = s[W5.charAt(m2++)], E2 += String.fromCharCode((le << 3 | be2 >>> 2) & 255) + String.fromCharCode((be2 << 6 | Ae << 1 | me >>> 4) & 255)) : a === 5 ? (le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], me = s[W5.charAt(m2++)], H5 = s[W5.charAt(m2++)], E2 += String.fromCharCode((le << 3 | be2 >>> 2) & 255) + String.fromCharCode((be2 << 6 | Ae << 1 | me >>> 4) & 255) + String.fromCharCode((me << 4 | H5 >>> 1) & 255)) : a === 7 && (le = s[W5.charAt(m2++)], be2 = s[W5.charAt(m2++)], Ae = s[W5.charAt(m2++)], me = s[W5.charAt(m2++)], H5 = s[W5.charAt(m2++)], ue = s[W5.charAt(m2++)], se2 = s[W5.charAt(m2++)], E2 += String.fromCharCode((le << 3 | be2 >>> 2) & 255) + String.fromCharCode((be2 << 6 | Ae << 1 | me >>> 4) & 255) + String.fromCharCode((me << 4 | H5 >>> 1) & 255) + String.fromCharCode((H5 << 7 | ue << 2 | se2 >>> 3) & 255)), E2;
    }, ee2 = { encode: V, decode: G };
    G.asBytes = g5, r3 ? fh.exports = ee2 : (t.base32 = ee2, i && define(function() {
      return ee2;
    }));
  })();
});
var Y1 = k((r3, ch) => {
  U();
  (function(t) {
    var e, r5 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i = Math.ceil, n = Math.floor, s = "[BigNumber Error] ", o = s + "Number primitive has more than 15 significant digits: ", f2 = 1e14, l = 14, g5 = 9007199254740991, _ = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], N2 = 1e7, U2 = 1e9;
    function V(me) {
      var H5, ue, se2, ne2 = I.prototype = { constructor: I, toString: null, valueOf: null }, E2 = new I(1), c = 20, m2 = 4, h2 = -7, a = 21, u3 = -1e7, b2 = 1e7, A2 = false, v2 = 1, d2 = 0, M = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, B2 = "0123456789abcdefghijklmnopqrstuvwxyz", y2 = true;
      function I(T, j2) {
        var P5, te2, oe2, re, ae, ie, X2, R5, x2 = this;
        if (!(x2 instanceof I))
          return new I(T, j2);
        if (j2 == null) {
          if (T && T._isBigNumber === true) {
            x2.s = T.s, !T.c || T.e > b2 ? x2.c = x2.e = null : T.e < u3 ? x2.c = [x2.e = 0] : (x2.e = T.e, x2.c = T.c.slice());
            return;
          }
          if ((ie = typeof T == "number") && T * 0 == 0) {
            if (x2.s = 1 / T < 0 ? (T = -T, -1) : 1, T === ~~T) {
              for (re = 0, ae = T; ae >= 10; ae /= 10, re++)
                ;
              re > b2 ? x2.c = x2.e = null : (x2.e = re, x2.c = [T]);
              return;
            }
            R5 = String(T);
          } else {
            if (!r5.test(R5 = String(T)))
              return se2(x2, R5, ie);
            x2.s = R5.charCodeAt(0) == 45 ? (R5 = R5.slice(1), -1) : 1;
          }
          (re = R5.indexOf(".")) > -1 && (R5 = R5.replace(".", "")), (ae = R5.search(/e/i)) > 0 ? (re < 0 && (re = ae), re += +R5.slice(ae + 1), R5 = R5.substring(0, ae)) : re < 0 && (re = R5.length);
        } else {
          if (Z(j2, 2, B2.length, "Base"), j2 == 10 && y2)
            return x2 = new I(T), Oe(x2, c + x2.e + 1, m2);
          if (R5 = String(T), ie = typeof T == "number") {
            if (T * 0 != 0)
              return se2(x2, R5, ie, j2);
            if (x2.s = 1 / T < 0 ? (R5 = R5.slice(1), -1) : 1, I.DEBUG && R5.replace(/^0\.0*|\./, "").length > 15)
              throw Error(o + T);
          } else
            x2.s = R5.charCodeAt(0) === 45 ? (R5 = R5.slice(1), -1) : 1;
          for (P5 = B2.slice(0, j2), re = ae = 0, X2 = R5.length; ae < X2; ae++)
            if (P5.indexOf(te2 = R5.charAt(ae)) < 0) {
              if (te2 == ".") {
                if (ae > re) {
                  re = X2;
                  continue;
                }
              } else if (!oe2 && (R5 == R5.toUpperCase() && (R5 = R5.toLowerCase()) || R5 == R5.toLowerCase() && (R5 = R5.toUpperCase()))) {
                oe2 = true, ae = -1, re = 0;
                continue;
              }
              return se2(x2, String(T), ie, j2);
            }
          ie = false, R5 = ue(R5, j2, 10, x2.s), (re = R5.indexOf(".")) > -1 ? R5 = R5.replace(".", "") : re = R5.length;
        }
        for (ae = 0; R5.charCodeAt(ae) === 48; ae++)
          ;
        for (X2 = R5.length; R5.charCodeAt(--X2) === 48; )
          ;
        if (R5 = R5.slice(ae, ++X2)) {
          if (X2 -= ae, ie && I.DEBUG && X2 > 15 && (T > g5 || T !== n(T)))
            throw Error(o + x2.s * T);
          if ((re = re - ae - 1) > b2)
            x2.c = x2.e = null;
          else if (re < u3)
            x2.c = [x2.e = 0];
          else {
            if (x2.e = re, x2.c = [], ae = (re + 1) % l, re < 0 && (ae += l), ae < X2) {
              for (ae && x2.c.push(+R5.slice(0, ae)), X2 -= l; ae < X2; )
                x2.c.push(+R5.slice(ae, ae += l));
              ae = l - (R5 = R5.slice(ae)).length;
            } else
              ae -= X2;
            for (; ae--; R5 += "0")
              ;
            x2.c.push(+R5);
          }
        } else
          x2.c = [x2.e = 0];
      }
      I.clone = V, I.ROUND_UP = 0, I.ROUND_DOWN = 1, I.ROUND_CEIL = 2, I.ROUND_FLOOR = 3, I.ROUND_HALF_UP = 4, I.ROUND_HALF_DOWN = 5, I.ROUND_HALF_EVEN = 6, I.ROUND_HALF_CEIL = 7, I.ROUND_HALF_FLOOR = 8, I.EUCLID = 9, I.config = I.set = function(T) {
        var j2, P5;
        if (T != null)
          if (typeof T == "object") {
            if (T.hasOwnProperty(j2 = "DECIMAL_PLACES") && (P5 = T[j2], Z(P5, 0, U2, j2), c = P5), T.hasOwnProperty(j2 = "ROUNDING_MODE") && (P5 = T[j2], Z(P5, 0, 8, j2), m2 = P5), T.hasOwnProperty(j2 = "EXPONENTIAL_AT") && (P5 = T[j2], P5 && P5.pop ? (Z(P5[0], -U2, 0, j2), Z(P5[1], 0, U2, j2), h2 = P5[0], a = P5[1]) : (Z(P5, -U2, U2, j2), h2 = -(a = P5 < 0 ? -P5 : P5))), T.hasOwnProperty(j2 = "RANGE"))
              if (P5 = T[j2], P5 && P5.pop)
                Z(P5[0], -U2, -1, j2), Z(P5[1], 1, U2, j2), u3 = P5[0], b2 = P5[1];
              else if (Z(P5, -U2, U2, j2), P5)
                u3 = -(b2 = P5 < 0 ? -P5 : P5);
              else
                throw Error(s + j2 + " cannot be zero: " + P5);
            if (T.hasOwnProperty(j2 = "CRYPTO"))
              if (P5 = T[j2], P5 === !!P5)
                if (P5)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    A2 = P5;
                  else
                    throw A2 = !P5, Error(s + "crypto unavailable");
                else
                  A2 = P5;
              else
                throw Error(s + j2 + " not true or false: " + P5);
            if (T.hasOwnProperty(j2 = "MODULO_MODE") && (P5 = T[j2], Z(P5, 0, 9, j2), v2 = P5), T.hasOwnProperty(j2 = "POW_PRECISION") && (P5 = T[j2], Z(P5, 0, U2, j2), d2 = P5), T.hasOwnProperty(j2 = "FORMAT"))
              if (P5 = T[j2], typeof P5 == "object")
                M = P5;
              else
                throw Error(s + j2 + " not an object: " + P5);
            if (T.hasOwnProperty(j2 = "ALPHABET"))
              if (P5 = T[j2], typeof P5 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(P5))
                y2 = P5.slice(0, 10) == "0123456789", B2 = P5;
              else
                throw Error(s + j2 + " invalid: " + P5);
          } else
            throw Error(s + "Object expected: " + T);
        return { DECIMAL_PLACES: c, ROUNDING_MODE: m2, EXPONENTIAL_AT: [h2, a], RANGE: [u3, b2], CRYPTO: A2, MODULO_MODE: v2, POW_PRECISION: d2, FORMAT: M, ALPHABET: B2 };
      }, I.isBigNumber = function(T) {
        if (!T || T._isBigNumber !== true)
          return false;
        if (!I.DEBUG)
          return true;
        var j2, P5, te2 = T.c, oe2 = T.e, re = T.s;
        e:
          if ({}.toString.call(te2) == "[object Array]") {
            if ((re === 1 || re === -1) && oe2 >= -U2 && oe2 <= U2 && oe2 === n(oe2)) {
              if (te2[0] === 0) {
                if (oe2 === 0 && te2.length === 1)
                  return true;
                break e;
              }
              if (j2 = (oe2 + 1) % l, j2 < 1 && (j2 += l), String(te2[0]).length == j2) {
                for (j2 = 0; j2 < te2.length; j2++)
                  if (P5 = te2[j2], P5 < 0 || P5 >= f2 || P5 !== n(P5))
                    break e;
                if (P5 !== 0)
                  return true;
              }
            }
          } else if (te2 === null && oe2 === null && (re === null || re === 1 || re === -1))
            return true;
        throw Error(s + "Invalid BigNumber: " + T);
      }, I.maximum = I.max = function() {
        return Me2(arguments, ne2.lt);
      }, I.minimum = I.min = function() {
        return Me2(arguments, ne2.gt);
      }, I.random = function() {
        var T = 9007199254740992, j2 = Math.random() * T & 2097151 ? function() {
          return n(Math.random() * T);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(P5) {
          var te2, oe2, re, ae, ie, X2 = 0, R5 = [], x2 = new I(E2);
          if (P5 == null ? P5 = c : Z(P5, 0, U2), ae = i(P5 / l), A2)
            if (crypto.getRandomValues) {
              for (te2 = crypto.getRandomValues(new Uint32Array(ae *= 2)); X2 < ae; )
                ie = te2[X2] * 131072 + (te2[X2 + 1] >>> 11), ie >= 9e15 ? (oe2 = crypto.getRandomValues(new Uint32Array(2)), te2[X2] = oe2[0], te2[X2 + 1] = oe2[1]) : (R5.push(ie % 1e14), X2 += 2);
              X2 = ae / 2;
            } else if (crypto.randomBytes) {
              for (te2 = crypto.randomBytes(ae *= 7); X2 < ae; )
                ie = (te2[X2] & 31) * 281474976710656 + te2[X2 + 1] * 1099511627776 + te2[X2 + 2] * 4294967296 + te2[X2 + 3] * 16777216 + (te2[X2 + 4] << 16) + (te2[X2 + 5] << 8) + te2[X2 + 6], ie >= 9e15 ? crypto.randomBytes(7).copy(te2, X2) : (R5.push(ie % 1e14), X2 += 7);
              X2 = ae / 7;
            } else
              throw A2 = false, Error(s + "crypto unavailable");
          if (!A2)
            for (; X2 < ae; )
              ie = j2(), ie < 9e15 && (R5[X2++] = ie % 1e14);
          for (ae = R5[--X2], P5 %= l, ae && P5 && (ie = _[l - P5], R5[X2] = n(ae / ie) * ie); R5[X2] === 0; R5.pop(), X2--)
            ;
          if (X2 < 0)
            R5 = [re = 0];
          else {
            for (re = -1; R5[0] === 0; R5.splice(0, 1), re -= l)
              ;
            for (X2 = 1, ie = R5[0]; ie >= 10; ie /= 10, X2++)
              ;
            X2 < l && (re -= l - X2);
          }
          return x2.e = re, x2.c = R5, x2;
        };
      }(), I.sum = function() {
        for (var T = 1, j2 = arguments, P5 = new I(j2[0]); T < j2.length; )
          P5 = P5.plus(j2[T++]);
        return P5;
      }, ue = function() {
        var T = "0123456789";
        function j2(P5, te2, oe2, re) {
          for (var ae, ie = [0], X2, R5 = 0, x2 = P5.length; R5 < x2; ) {
            for (X2 = ie.length; X2--; ie[X2] *= te2)
              ;
            for (ie[0] += re.indexOf(P5.charAt(R5++)), ae = 0; ae < ie.length; ae++)
              ie[ae] > oe2 - 1 && (ie[ae + 1] == null && (ie[ae + 1] = 0), ie[ae + 1] += ie[ae] / oe2 | 0, ie[ae] %= oe2);
          }
          return ie.reverse();
        }
        return function(P5, te2, oe2, re, ae) {
          var ie, X2, R5, x2, F2, q2, L2, K5, $ = P5.indexOf("."), we2 = c, pe = m2;
          for ($ >= 0 && (x2 = d2, d2 = 0, P5 = P5.replace(".", ""), K5 = new I(te2), q2 = K5.pow(P5.length - $), d2 = x2, K5.c = j2(Ae(ee2(q2.c), q2.e, "0"), 10, oe2, T), K5.e = K5.c.length), L2 = j2(P5, te2, oe2, ae ? (ie = B2, T) : (ie = T, B2)), R5 = x2 = L2.length; L2[--x2] == 0; L2.pop())
            ;
          if (!L2[0])
            return ie.charAt(0);
          if ($ < 0 ? --R5 : (q2.c = L2, q2.e = R5, q2.s = re, q2 = H5(q2, K5, we2, pe, oe2), L2 = q2.c, F2 = q2.r, R5 = q2.e), X2 = R5 + we2 + 1, $ = L2[X2], x2 = oe2 / 2, F2 = F2 || X2 < 0 || L2[X2 + 1] != null, F2 = pe < 4 ? ($ != null || F2) && (pe == 0 || pe == (q2.s < 0 ? 3 : 2)) : $ > x2 || $ == x2 && (pe == 4 || F2 || pe == 6 && L2[X2 - 1] & 1 || pe == (q2.s < 0 ? 8 : 7)), X2 < 1 || !L2[0])
            P5 = F2 ? Ae(ie.charAt(1), -we2, ie.charAt(0)) : ie.charAt(0);
          else {
            if (L2.length = X2, F2)
              for (--oe2; ++L2[--X2] > oe2; )
                L2[X2] = 0, X2 || (++R5, L2 = [1].concat(L2));
            for (x2 = L2.length; !L2[--x2]; )
              ;
            for ($ = 0, P5 = ""; $ <= x2; P5 += ie.charAt(L2[$++]))
              ;
            P5 = Ae(P5, R5, ie.charAt(0));
          }
          return P5;
        };
      }(), H5 = function() {
        function T(te2, oe2, re) {
          var ae, ie, X2, R5, x2 = 0, F2 = te2.length, q2 = oe2 % N2, L2 = oe2 / N2 | 0;
          for (te2 = te2.slice(); F2--; )
            X2 = te2[F2] % N2, R5 = te2[F2] / N2 | 0, ae = L2 * X2 + R5 * q2, ie = q2 * X2 + ae % N2 * N2 + x2, x2 = (ie / re | 0) + (ae / N2 | 0) + L2 * R5, te2[F2] = ie % re;
          return x2 && (te2 = [x2].concat(te2)), te2;
        }
        function j2(te2, oe2, re, ae) {
          var ie, X2;
          if (re != ae)
            X2 = re > ae ? 1 : -1;
          else
            for (ie = X2 = 0; ie < re; ie++)
              if (te2[ie] != oe2[ie]) {
                X2 = te2[ie] > oe2[ie] ? 1 : -1;
                break;
              }
          return X2;
        }
        function P5(te2, oe2, re, ae) {
          for (var ie = 0; re--; )
            te2[re] -= ie, ie = te2[re] < oe2[re] ? 1 : 0, te2[re] = ie * ae + te2[re] - oe2[re];
          for (; !te2[0] && te2.length > 1; te2.splice(0, 1))
            ;
        }
        return function(te2, oe2, re, ae, ie) {
          var X2, R5, x2, F2, q2, L2, K5, $, we2, pe, _e, fe2, Fe, De, pt2, je, Ke, wt = te2.s == oe2.s ? 1 : -1, Pe = te2.c, Le2 = oe2.c;
          if (!Pe || !Pe[0] || !Le2 || !Le2[0])
            return new I(!te2.s || !oe2.s || (Pe ? Le2 && Pe[0] == Le2[0] : !Le2) ? NaN : Pe && Pe[0] == 0 || !Le2 ? wt * 0 : wt / 0);
          for ($ = new I(wt), we2 = $.c = [], R5 = te2.e - oe2.e, wt = re + R5 + 1, ie || (ie = f2, R5 = G(te2.e / l) - G(oe2.e / l), wt = wt / l | 0), x2 = 0; Le2[x2] == (Pe[x2] || 0); x2++)
            ;
          if (Le2[x2] > (Pe[x2] || 0) && R5--, wt < 0)
            we2.push(1), F2 = true;
          else {
            for (De = Pe.length, je = Le2.length, x2 = 0, wt += 2, q2 = n(ie / (Le2[0] + 1)), q2 > 1 && (Le2 = T(Le2, q2, ie), Pe = T(Pe, q2, ie), je = Le2.length, De = Pe.length), Fe = je, pe = Pe.slice(0, je), _e = pe.length; _e < je; pe[_e++] = 0)
              ;
            Ke = Le2.slice(), Ke = [0].concat(Ke), pt2 = Le2[0], Le2[1] >= ie / 2 && pt2++;
            do {
              if (q2 = 0, X2 = j2(Le2, pe, je, _e), X2 < 0) {
                if (fe2 = pe[0], je != _e && (fe2 = fe2 * ie + (pe[1] || 0)), q2 = n(fe2 / pt2), q2 > 1)
                  for (q2 >= ie && (q2 = ie - 1), L2 = T(Le2, q2, ie), K5 = L2.length, _e = pe.length; j2(L2, pe, K5, _e) == 1; )
                    q2--, P5(L2, je < K5 ? Ke : Le2, K5, ie), K5 = L2.length, X2 = 1;
                else
                  q2 == 0 && (X2 = q2 = 1), L2 = Le2.slice(), K5 = L2.length;
                if (K5 < _e && (L2 = [0].concat(L2)), P5(pe, L2, _e, ie), _e = pe.length, X2 == -1)
                  for (; j2(Le2, pe, je, _e) < 1; )
                    q2++, P5(pe, je < _e ? Ke : Le2, _e, ie), _e = pe.length;
              } else
                X2 === 0 && (q2++, pe = [0]);
              we2[x2++] = q2, pe[0] ? pe[_e++] = Pe[Fe] || 0 : (pe = [Pe[Fe]], _e = 1);
            } while ((Fe++ < De || pe[0] != null) && wt--);
            F2 = pe[0] != null, we2[0] || we2.splice(0, 1);
          }
          if (ie == f2) {
            for (x2 = 1, wt = we2[0]; wt >= 10; wt /= 10, x2++)
              ;
            Oe($, re + ($.e = x2 + R5 * l - 1) + 1, ae, F2);
          } else
            $.e = R5, $.r = +F2;
          return $;
        };
      }();
      function de(T, j2, P5, te2) {
        var oe2, re, ae, ie, X2;
        if (P5 == null ? P5 = m2 : Z(P5, 0, 8), !T.c)
          return T.toString();
        if (oe2 = T.c[0], ae = T.e, j2 == null)
          X2 = ee2(T.c), X2 = te2 == 1 || te2 == 2 && (ae <= h2 || ae >= a) ? be2(X2, ae) : Ae(X2, ae, "0");
        else if (T = Oe(new I(T), j2, P5), re = T.e, X2 = ee2(T.c), ie = X2.length, te2 == 1 || te2 == 2 && (j2 <= re || re <= h2)) {
          for (; ie < j2; X2 += "0", ie++)
            ;
          X2 = be2(X2, re);
        } else if (j2 -= ae, X2 = Ae(X2, re, "0"), re + 1 > ie) {
          if (--j2 > 0)
            for (X2 += "."; j2--; X2 += "0")
              ;
        } else if (j2 += re - ie, j2 > 0)
          for (re + 1 == ie && (X2 += "."); j2--; X2 += "0")
            ;
        return T.s < 0 && oe2 ? "-" + X2 : X2;
      }
      function Me2(T, j2) {
        for (var P5, te2 = 1, oe2 = new I(T[0]); te2 < T.length; te2++)
          if (P5 = new I(T[te2]), P5.s)
            j2.call(oe2, P5) && (oe2 = P5);
          else {
            oe2 = P5;
            break;
          }
        return oe2;
      }
      function Se(T, j2, P5) {
        for (var te2 = 1, oe2 = j2.length; !j2[--oe2]; j2.pop())
          ;
        for (oe2 = j2[0]; oe2 >= 10; oe2 /= 10, te2++)
          ;
        return (P5 = te2 + P5 * l - 1) > b2 ? T.c = T.e = null : P5 < u3 ? T.c = [T.e = 0] : (T.e = P5, T.c = j2), T;
      }
      se2 = function() {
        var T = /^(-?)0([xbo])(?=\w[\w.]*$)/i, j2 = /^([^.]+)\.$/, P5 = /^\.([^.]+)$/, te2 = /^-?(Infinity|NaN)$/, oe2 = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(re, ae, ie, X2) {
          var R5, x2 = ie ? ae : ae.replace(oe2, "");
          if (te2.test(x2))
            re.s = isNaN(x2) ? null : x2 < 0 ? -1 : 1;
          else {
            if (!ie && (x2 = x2.replace(T, function(F2, q2, L2) {
              return R5 = (L2 = L2.toLowerCase()) == "x" ? 16 : L2 == "b" ? 2 : 8, !X2 || X2 == R5 ? q2 : F2;
            }), X2 && (R5 = X2, x2 = x2.replace(j2, "$1").replace(P5, "0.$1")), ae != x2))
              return new I(x2, R5);
            if (I.DEBUG)
              throw Error(s + "Not a" + (X2 ? " base " + X2 : "") + " number: " + ae);
            re.s = null;
          }
          re.c = re.e = null;
        };
      }();
      function Oe(T, j2, P5, te2) {
        var oe2, re, ae, ie, X2, R5, x2, F2 = T.c, q2 = _;
        if (F2) {
          e: {
            for (oe2 = 1, ie = F2[0]; ie >= 10; ie /= 10, oe2++)
              ;
            if (re = j2 - oe2, re < 0)
              re += l, ae = j2, X2 = F2[R5 = 0], x2 = X2 / q2[oe2 - ae - 1] % 10 | 0;
            else if (R5 = i((re + 1) / l), R5 >= F2.length)
              if (te2) {
                for (; F2.length <= R5; F2.push(0))
                  ;
                X2 = x2 = 0, oe2 = 1, re %= l, ae = re - l + 1;
              } else
                break e;
            else {
              for (X2 = ie = F2[R5], oe2 = 1; ie >= 10; ie /= 10, oe2++)
                ;
              re %= l, ae = re - l + oe2, x2 = ae < 0 ? 0 : X2 / q2[oe2 - ae - 1] % 10 | 0;
            }
            if (te2 = te2 || j2 < 0 || F2[R5 + 1] != null || (ae < 0 ? X2 : X2 % q2[oe2 - ae - 1]), te2 = P5 < 4 ? (x2 || te2) && (P5 == 0 || P5 == (T.s < 0 ? 3 : 2)) : x2 > 5 || x2 == 5 && (P5 == 4 || te2 || P5 == 6 && (re > 0 ? ae > 0 ? X2 / q2[oe2 - ae] : 0 : F2[R5 - 1]) % 10 & 1 || P5 == (T.s < 0 ? 8 : 7)), j2 < 1 || !F2[0])
              return F2.length = 0, te2 ? (j2 -= T.e + 1, F2[0] = q2[(l - j2 % l) % l], T.e = -j2 || 0) : F2[0] = T.e = 0, T;
            if (re == 0 ? (F2.length = R5, ie = 1, R5--) : (F2.length = R5 + 1, ie = q2[l - re], F2[R5] = ae > 0 ? n(X2 / q2[oe2 - ae] % q2[ae]) * ie : 0), te2)
              for (; ; )
                if (R5 == 0) {
                  for (re = 1, ae = F2[0]; ae >= 10; ae /= 10, re++)
                    ;
                  for (ae = F2[0] += ie, ie = 1; ae >= 10; ae /= 10, ie++)
                    ;
                  re != ie && (T.e++, F2[0] == f2 && (F2[0] = 1));
                  break;
                } else {
                  if (F2[R5] += ie, F2[R5] != f2)
                    break;
                  F2[R5--] = 0, ie = 1;
                }
            for (re = F2.length; F2[--re] === 0; F2.pop())
              ;
          }
          T.e > b2 ? T.c = T.e = null : T.e < u3 && (T.c = [T.e = 0]);
        }
        return T;
      }
      function ye(T) {
        var j2, P5 = T.e;
        return P5 === null ? T.toString() : (j2 = ee2(T.c), j2 = P5 <= h2 || P5 >= a ? be2(j2, P5) : Ae(j2, P5, "0"), T.s < 0 ? "-" + j2 : j2);
      }
      return ne2.absoluteValue = ne2.abs = function() {
        var T = new I(this);
        return T.s < 0 && (T.s = 1), T;
      }, ne2.comparedTo = function(T, j2) {
        return W5(this, new I(T, j2));
      }, ne2.decimalPlaces = ne2.dp = function(T, j2) {
        var P5, te2, oe2, re = this;
        if (T != null)
          return Z(T, 0, U2), j2 == null ? j2 = m2 : Z(j2, 0, 8), Oe(new I(re), T + re.e + 1, j2);
        if (!(P5 = re.c))
          return null;
        if (te2 = ((oe2 = P5.length - 1) - G(this.e / l)) * l, oe2 = P5[oe2])
          for (; oe2 % 10 == 0; oe2 /= 10, te2--)
            ;
        return te2 < 0 && (te2 = 0), te2;
      }, ne2.dividedBy = ne2.div = function(T, j2) {
        return H5(this, new I(T, j2), c, m2);
      }, ne2.dividedToIntegerBy = ne2.idiv = function(T, j2) {
        return H5(this, new I(T, j2), 0, 1);
      }, ne2.exponentiatedBy = ne2.pow = function(T, j2) {
        var P5, te2, oe2, re, ae, ie, X2, R5, x2, F2 = this;
        if (T = new I(T), T.c && !T.isInteger())
          throw Error(s + "Exponent not an integer: " + ye(T));
        if (j2 != null && (j2 = new I(j2)), ie = T.e > 14, !F2.c || !F2.c[0] || F2.c[0] == 1 && !F2.e && F2.c.length == 1 || !T.c || !T.c[0])
          return x2 = new I(Math.pow(+ye(F2), ie ? T.s * (2 - le(T)) : +ye(T))), j2 ? x2.mod(j2) : x2;
        if (X2 = T.s < 0, j2) {
          if (j2.c ? !j2.c[0] : !j2.s)
            return new I(NaN);
          te2 = !X2 && F2.isInteger() && j2.isInteger(), te2 && (F2 = F2.mod(j2));
        } else {
          if (T.e > 9 && (F2.e > 0 || F2.e < -1 || (F2.e == 0 ? F2.c[0] > 1 || ie && F2.c[1] >= 24e7 : F2.c[0] < 8e13 || ie && F2.c[0] <= 9999975e7)))
            return re = F2.s < 0 && le(T) ? -0 : 0, F2.e > -1 && (re = 1 / re), new I(X2 ? 1 / re : re);
          d2 && (re = i(d2 / l + 2));
        }
        for (ie ? (P5 = new I(0.5), X2 && (T.s = 1), R5 = le(T)) : (oe2 = Math.abs(+ye(T)), R5 = oe2 % 2), x2 = new I(E2); ; ) {
          if (R5) {
            if (x2 = x2.times(F2), !x2.c)
              break;
            re ? x2.c.length > re && (x2.c.length = re) : te2 && (x2 = x2.mod(j2));
          }
          if (oe2) {
            if (oe2 = n(oe2 / 2), oe2 === 0)
              break;
            R5 = oe2 % 2;
          } else if (T = T.times(P5), Oe(T, T.e + 1, 1), T.e > 14)
            R5 = le(T);
          else {
            if (oe2 = +ye(T), oe2 === 0)
              break;
            R5 = oe2 % 2;
          }
          F2 = F2.times(F2), re ? F2.c && F2.c.length > re && (F2.c.length = re) : te2 && (F2 = F2.mod(j2));
        }
        return te2 ? x2 : (X2 && (x2 = E2.div(x2)), j2 ? x2.mod(j2) : re ? Oe(x2, d2, m2, ae) : x2);
      }, ne2.integerValue = function(T) {
        var j2 = new I(this);
        return T == null ? T = m2 : Z(T, 0, 8), Oe(j2, j2.e + 1, T);
      }, ne2.isEqualTo = ne2.eq = function(T, j2) {
        return W5(this, new I(T, j2)) === 0;
      }, ne2.isFinite = function() {
        return !!this.c;
      }, ne2.isGreaterThan = ne2.gt = function(T, j2) {
        return W5(this, new I(T, j2)) > 0;
      }, ne2.isGreaterThanOrEqualTo = ne2.gte = function(T, j2) {
        return (j2 = W5(this, new I(T, j2))) === 1 || j2 === 0;
      }, ne2.isInteger = function() {
        return !!this.c && G(this.e / l) > this.c.length - 2;
      }, ne2.isLessThan = ne2.lt = function(T, j2) {
        return W5(this, new I(T, j2)) < 0;
      }, ne2.isLessThanOrEqualTo = ne2.lte = function(T, j2) {
        return (j2 = W5(this, new I(T, j2))) === -1 || j2 === 0;
      }, ne2.isNaN = function() {
        return !this.s;
      }, ne2.isNegative = function() {
        return this.s < 0;
      }, ne2.isPositive = function() {
        return this.s > 0;
      }, ne2.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, ne2.minus = function(T, j2) {
        var P5, te2, oe2, re, ae = this, ie = ae.s;
        if (T = new I(T, j2), j2 = T.s, !ie || !j2)
          return new I(NaN);
        if (ie != j2)
          return T.s = -j2, ae.plus(T);
        var X2 = ae.e / l, R5 = T.e / l, x2 = ae.c, F2 = T.c;
        if (!X2 || !R5) {
          if (!x2 || !F2)
            return x2 ? (T.s = -j2, T) : new I(F2 ? ae : NaN);
          if (!x2[0] || !F2[0])
            return F2[0] ? (T.s = -j2, T) : new I(x2[0] ? ae : m2 == 3 ? -0 : 0);
        }
        if (X2 = G(X2), R5 = G(R5), x2 = x2.slice(), ie = X2 - R5) {
          for ((re = ie < 0) ? (ie = -ie, oe2 = x2) : (R5 = X2, oe2 = F2), oe2.reverse(), j2 = ie; j2--; oe2.push(0))
            ;
          oe2.reverse();
        } else
          for (te2 = (re = (ie = x2.length) < (j2 = F2.length)) ? ie : j2, ie = j2 = 0; j2 < te2; j2++)
            if (x2[j2] != F2[j2]) {
              re = x2[j2] < F2[j2];
              break;
            }
        if (re && (oe2 = x2, x2 = F2, F2 = oe2, T.s = -T.s), j2 = (te2 = F2.length) - (P5 = x2.length), j2 > 0)
          for (; j2--; x2[P5++] = 0)
            ;
        for (j2 = f2 - 1; te2 > ie; ) {
          if (x2[--te2] < F2[te2]) {
            for (P5 = te2; P5 && !x2[--P5]; x2[P5] = j2)
              ;
            --x2[P5], x2[te2] += f2;
          }
          x2[te2] -= F2[te2];
        }
        for (; x2[0] == 0; x2.splice(0, 1), --R5)
          ;
        return x2[0] ? Se(T, x2, R5) : (T.s = m2 == 3 ? -1 : 1, T.c = [T.e = 0], T);
      }, ne2.modulo = ne2.mod = function(T, j2) {
        var P5, te2, oe2 = this;
        return T = new I(T, j2), !oe2.c || !T.s || T.c && !T.c[0] ? new I(NaN) : !T.c || oe2.c && !oe2.c[0] ? new I(oe2) : (v2 == 9 ? (te2 = T.s, T.s = 1, P5 = H5(oe2, T, 0, 3), T.s = te2, P5.s *= te2) : P5 = H5(oe2, T, 0, v2), T = oe2.minus(P5.times(T)), !T.c[0] && v2 == 1 && (T.s = oe2.s), T);
      }, ne2.multipliedBy = ne2.times = function(T, j2) {
        var P5, te2, oe2, re, ae, ie, X2, R5, x2, F2, q2, L2, K5, $, we2, pe = this, _e = pe.c, fe2 = (T = new I(T, j2)).c;
        if (!_e || !fe2 || !_e[0] || !fe2[0])
          return !pe.s || !T.s || _e && !_e[0] && !fe2 || fe2 && !fe2[0] && !_e ? T.c = T.e = T.s = null : (T.s *= pe.s, !_e || !fe2 ? T.c = T.e = null : (T.c = [0], T.e = 0)), T;
        for (te2 = G(pe.e / l) + G(T.e / l), T.s *= pe.s, X2 = _e.length, F2 = fe2.length, X2 < F2 && (K5 = _e, _e = fe2, fe2 = K5, oe2 = X2, X2 = F2, F2 = oe2), oe2 = X2 + F2, K5 = []; oe2--; K5.push(0))
          ;
        for ($ = f2, we2 = N2, oe2 = F2; --oe2 >= 0; ) {
          for (P5 = 0, q2 = fe2[oe2] % we2, L2 = fe2[oe2] / we2 | 0, ae = X2, re = oe2 + ae; re > oe2; )
            R5 = _e[--ae] % we2, x2 = _e[ae] / we2 | 0, ie = L2 * R5 + x2 * q2, R5 = q2 * R5 + ie % we2 * we2 + K5[re] + P5, P5 = (R5 / $ | 0) + (ie / we2 | 0) + L2 * x2, K5[re--] = R5 % $;
          K5[re] = P5;
        }
        return P5 ? ++te2 : K5.splice(0, 1), Se(T, K5, te2);
      }, ne2.negated = function() {
        var T = new I(this);
        return T.s = -T.s || null, T;
      }, ne2.plus = function(T, j2) {
        var P5, te2 = this, oe2 = te2.s;
        if (T = new I(T, j2), j2 = T.s, !oe2 || !j2)
          return new I(NaN);
        if (oe2 != j2)
          return T.s = -j2, te2.minus(T);
        var re = te2.e / l, ae = T.e / l, ie = te2.c, X2 = T.c;
        if (!re || !ae) {
          if (!ie || !X2)
            return new I(oe2 / 0);
          if (!ie[0] || !X2[0])
            return X2[0] ? T : new I(ie[0] ? te2 : oe2 * 0);
        }
        if (re = G(re), ae = G(ae), ie = ie.slice(), oe2 = re - ae) {
          for (oe2 > 0 ? (ae = re, P5 = X2) : (oe2 = -oe2, P5 = ie), P5.reverse(); oe2--; P5.push(0))
            ;
          P5.reverse();
        }
        for (oe2 = ie.length, j2 = X2.length, oe2 - j2 < 0 && (P5 = X2, X2 = ie, ie = P5, j2 = oe2), oe2 = 0; j2; )
          oe2 = (ie[--j2] = ie[j2] + X2[j2] + oe2) / f2 | 0, ie[j2] = f2 === ie[j2] ? 0 : ie[j2] % f2;
        return oe2 && (ie = [oe2].concat(ie), ++ae), Se(T, ie, ae);
      }, ne2.precision = ne2.sd = function(T, j2) {
        var P5, te2, oe2, re = this;
        if (T != null && T !== !!T)
          return Z(T, 1, U2), j2 == null ? j2 = m2 : Z(j2, 0, 8), Oe(new I(re), T, j2);
        if (!(P5 = re.c))
          return null;
        if (oe2 = P5.length - 1, te2 = oe2 * l + 1, oe2 = P5[oe2]) {
          for (; oe2 % 10 == 0; oe2 /= 10, te2--)
            ;
          for (oe2 = P5[0]; oe2 >= 10; oe2 /= 10, te2++)
            ;
        }
        return T && re.e + 1 > te2 && (te2 = re.e + 1), te2;
      }, ne2.shiftedBy = function(T) {
        return Z(T, -g5, g5), this.times("1e" + T);
      }, ne2.squareRoot = ne2.sqrt = function() {
        var T, j2, P5, te2, oe2, re = this, ae = re.c, ie = re.s, X2 = re.e, R5 = c + 4, x2 = new I("0.5");
        if (ie !== 1 || !ae || !ae[0])
          return new I(!ie || ie < 0 && (!ae || ae[0]) ? NaN : ae ? re : 1 / 0);
        if (ie = Math.sqrt(+ye(re)), ie == 0 || ie == 1 / 0 ? (j2 = ee2(ae), (j2.length + X2) % 2 == 0 && (j2 += "0"), ie = Math.sqrt(+j2), X2 = G((X2 + 1) / 2) - (X2 < 0 || X2 % 2), ie == 1 / 0 ? j2 = "5e" + X2 : (j2 = ie.toExponential(), j2 = j2.slice(0, j2.indexOf("e") + 1) + X2), P5 = new I(j2)) : P5 = new I(ie + ""), P5.c[0]) {
          for (X2 = P5.e, ie = X2 + R5, ie < 3 && (ie = 0); ; )
            if (oe2 = P5, P5 = x2.times(oe2.plus(H5(re, oe2, R5, 1))), ee2(oe2.c).slice(0, ie) === (j2 = ee2(P5.c)).slice(0, ie))
              if (P5.e < X2 && --ie, j2 = j2.slice(ie - 3, ie + 1), j2 == "9999" || !te2 && j2 == "4999") {
                if (!te2 && (Oe(oe2, oe2.e + c + 2, 0), oe2.times(oe2).eq(re))) {
                  P5 = oe2;
                  break;
                }
                R5 += 4, ie += 4, te2 = 1;
              } else {
                (!+j2 || !+j2.slice(1) && j2.charAt(0) == "5") && (Oe(P5, P5.e + c + 2, 1), T = !P5.times(P5).eq(re));
                break;
              }
        }
        return Oe(P5, P5.e + c + 1, m2, T);
      }, ne2.toExponential = function(T, j2) {
        return T != null && (Z(T, 0, U2), T++), de(this, T, j2, 1);
      }, ne2.toFixed = function(T, j2) {
        return T != null && (Z(T, 0, U2), T = T + this.e + 1), de(this, T, j2);
      }, ne2.toFormat = function(T, j2, P5) {
        var te2, oe2 = this;
        if (P5 == null)
          T != null && j2 && typeof j2 == "object" ? (P5 = j2, j2 = null) : T && typeof T == "object" ? (P5 = T, T = j2 = null) : P5 = M;
        else if (typeof P5 != "object")
          throw Error(s + "Argument not an object: " + P5);
        if (te2 = oe2.toFixed(T, j2), oe2.c) {
          var re, ae = te2.split("."), ie = +P5.groupSize, X2 = +P5.secondaryGroupSize, R5 = P5.groupSeparator || "", x2 = ae[0], F2 = ae[1], q2 = oe2.s < 0, L2 = q2 ? x2.slice(1) : x2, K5 = L2.length;
          if (X2 && (re = ie, ie = X2, X2 = re, K5 -= re), ie > 0 && K5 > 0) {
            for (re = K5 % ie || ie, x2 = L2.substr(0, re); re < K5; re += ie)
              x2 += R5 + L2.substr(re, ie);
            X2 > 0 && (x2 += R5 + L2.slice(re)), q2 && (x2 = "-" + x2);
          }
          te2 = F2 ? x2 + (P5.decimalSeparator || "") + ((X2 = +P5.fractionGroupSize) ? F2.replace(new RegExp("\\d{" + X2 + "}\\B", "g"), "$&" + (P5.fractionGroupSeparator || "")) : F2) : x2;
        }
        return (P5.prefix || "") + te2 + (P5.suffix || "");
      }, ne2.toFraction = function(T) {
        var j2, P5, te2, oe2, re, ae, ie, X2, R5, x2, F2, q2, L2 = this, K5 = L2.c;
        if (T != null && (ie = new I(T), !ie.isInteger() && (ie.c || ie.s !== 1) || ie.lt(E2)))
          throw Error(s + "Argument " + (ie.isInteger() ? "out of range: " : "not an integer: ") + ye(ie));
        if (!K5)
          return new I(L2);
        for (j2 = new I(E2), R5 = P5 = new I(E2), te2 = X2 = new I(E2), q2 = ee2(K5), re = j2.e = q2.length - L2.e - 1, j2.c[0] = _[(ae = re % l) < 0 ? l + ae : ae], T = !T || ie.comparedTo(j2) > 0 ? re > 0 ? j2 : R5 : ie, ae = b2, b2 = 1 / 0, ie = new I(q2), X2.c[0] = 0; x2 = H5(ie, j2, 0, 1), oe2 = P5.plus(x2.times(te2)), oe2.comparedTo(T) != 1; )
          P5 = te2, te2 = oe2, R5 = X2.plus(x2.times(oe2 = R5)), X2 = oe2, j2 = ie.minus(x2.times(oe2 = j2)), ie = oe2;
        return oe2 = H5(T.minus(P5), te2, 0, 1), X2 = X2.plus(oe2.times(R5)), P5 = P5.plus(oe2.times(te2)), X2.s = R5.s = L2.s, re = re * 2, F2 = H5(R5, te2, re, m2).minus(L2).abs().comparedTo(H5(X2, P5, re, m2).minus(L2).abs()) < 1 ? [R5, te2] : [X2, P5], b2 = ae, F2;
      }, ne2.toNumber = function() {
        return +ye(this);
      }, ne2.toPrecision = function(T, j2) {
        return T != null && Z(T, 1, U2), de(this, T, j2, 2);
      }, ne2.toString = function(T) {
        var j2, P5 = this, te2 = P5.s, oe2 = P5.e;
        return oe2 === null ? te2 ? (j2 = "Infinity", te2 < 0 && (j2 = "-" + j2)) : j2 = "NaN" : (T == null ? j2 = oe2 <= h2 || oe2 >= a ? be2(ee2(P5.c), oe2) : Ae(ee2(P5.c), oe2, "0") : T === 10 && y2 ? (P5 = Oe(new I(P5), c + oe2 + 1, m2), j2 = Ae(ee2(P5.c), P5.e, "0")) : (Z(T, 2, B2.length, "Base"), j2 = ue(Ae(ee2(P5.c), oe2, "0"), 10, T, te2, true)), te2 < 0 && P5.c[0] && (j2 = "-" + j2)), j2;
      }, ne2.valueOf = ne2.toJSON = function() {
        return ye(this);
      }, ne2._isBigNumber = true, me != null && I.set(me), I;
    }
    function G(me) {
      var H5 = me | 0;
      return me > 0 || me === H5 ? H5 : H5 - 1;
    }
    function ee2(me) {
      for (var H5, ue, se2 = 1, ne2 = me.length, E2 = me[0] + ""; se2 < ne2; ) {
        for (H5 = me[se2++] + "", ue = l - H5.length; ue--; H5 = "0" + H5)
          ;
        E2 += H5;
      }
      for (ne2 = E2.length; E2.charCodeAt(--ne2) === 48; )
        ;
      return E2.slice(0, ne2 + 1 || 1);
    }
    function W5(me, H5) {
      var ue, se2, ne2 = me.c, E2 = H5.c, c = me.s, m2 = H5.s, h2 = me.e, a = H5.e;
      if (!c || !m2)
        return null;
      if (ue = ne2 && !ne2[0], se2 = E2 && !E2[0], ue || se2)
        return ue ? se2 ? 0 : -m2 : c;
      if (c != m2)
        return c;
      if (ue = c < 0, se2 = h2 == a, !ne2 || !E2)
        return se2 ? 0 : !ne2 ^ ue ? 1 : -1;
      if (!se2)
        return h2 > a ^ ue ? 1 : -1;
      for (m2 = (h2 = ne2.length) < (a = E2.length) ? h2 : a, c = 0; c < m2; c++)
        if (ne2[c] != E2[c])
          return ne2[c] > E2[c] ^ ue ? 1 : -1;
      return h2 == a ? 0 : h2 > a ^ ue ? 1 : -1;
    }
    function Z(me, H5, ue, se2) {
      if (me < H5 || me > ue || me !== n(me))
        throw Error(s + (se2 || "Argument") + (typeof me == "number" ? me < H5 || me > ue ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(me));
    }
    function le(me) {
      var H5 = me.c.length - 1;
      return G(me.e / l) == H5 && me.c[H5] % 2 != 0;
    }
    function be2(me, H5) {
      return (me.length > 1 ? me.charAt(0) + "." + me.slice(1) : me) + (H5 < 0 ? "e" : "e+") + H5;
    }
    function Ae(me, H5, ue) {
      var se2, ne2;
      if (H5 < 0) {
        for (ne2 = ue + "."; ++H5; ne2 += ue)
          ;
        me = ne2 + me;
      } else if (se2 = me.length, ++H5 > se2) {
        for (ne2 = ue, H5 -= se2; --H5; ne2 += ue)
          ;
        me += ne2;
      } else
        H5 < se2 && (me = me.slice(0, H5) + "." + me.slice(H5));
      return me;
    }
    e = V(), e.default = e.BigNumber = e, typeof define == "function" && define.amd ? define(function() {
      return e;
    }) : typeof ch < "u" && ch.exports ? ch.exports = e : (t || (t = typeof self < "u" && self ? self : window), t.BigNumber = e);
  })(r3);
});
var o3 = k((dB, s3) => {
  U();
  var i3 = Y1(), n3 = s3.exports;
  (function() {
    var r3 = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, i, n, s = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, o;
    function f2(g5) {
      return r3.lastIndex = 0, r3.test(g5) ? '"' + g5.replace(r3, function(_) {
        var N2 = s[_];
        return typeof N2 == "string" ? N2 : "\\u" + ("0000" + _.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + g5 + '"';
    }
    function l(g5, _) {
      var N2, U2, V, G, ee2 = i, W5, Z = _[g5], le = Z != null && (Z instanceof i3 || i3.isBigNumber(Z));
      switch (Z && typeof Z == "object" && typeof Z.toJSON == "function" && (Z = Z.toJSON(g5)), typeof o == "function" && (Z = o.call(_, g5, Z)), typeof Z) {
        case "string":
          return le ? Z : f2(Z);
        case "number":
          return isFinite(Z) ? String(Z) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(Z);
        case "object":
          if (!Z)
            return "null";
          if (i += n, W5 = [], Object.prototype.toString.apply(Z) === "[object Array]") {
            for (G = Z.length, N2 = 0; N2 < G; N2 += 1)
              W5[N2] = l(N2, Z) || "null";
            return V = W5.length === 0 ? "[]" : i ? `[
` + i + W5.join(`,
` + i) + `
` + ee2 + "]" : "[" + W5.join(",") + "]", i = ee2, V;
          }
          if (o && typeof o == "object")
            for (G = o.length, N2 = 0; N2 < G; N2 += 1)
              typeof o[N2] == "string" && (U2 = o[N2], V = l(U2, Z), V && W5.push(f2(U2) + (i ? ": " : ":") + V));
          else
            Object.keys(Z).forEach(function(be2) {
              var Ae = l(be2, Z);
              Ae && W5.push(f2(be2) + (i ? ": " : ":") + Ae);
            });
          return V = W5.length === 0 ? "{}" : i ? `{
` + i + W5.join(`,
` + i) + `
` + ee2 + "}" : "{" + W5.join(",") + "}", i = ee2, V;
      }
    }
    typeof n3.stringify != "function" && (n3.stringify = function(g5, _, N2) {
      var U2;
      if (i = "", n = "", typeof N2 == "number")
        for (U2 = 0; U2 < N2; U2 += 1)
          n += " ";
      else
        typeof N2 == "string" && (n = N2);
      if (o = _, _ && typeof _ != "function" && (typeof _ != "object" || typeof _.length != "number"))
        throw new Error("JSON.stringify");
      return l("", { "": g5 });
    });
  })();
});
var f3 = k((lB, a3) => {
  U();
  var uh = null, CT = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, OT = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/, jT = function(t) {
    var e = { strict: false, storeAsString: false, alwaysParseAsBig: false, useNativeBigInt: false, protoAction: "error", constructorAction: "error" };
    if (t != null) {
      if (t.strict === true && (e.strict = true), t.storeAsString === true && (e.storeAsString = true), e.alwaysParseAsBig = t.alwaysParseAsBig === true ? t.alwaysParseAsBig : false, e.useNativeBigInt = t.useNativeBigInt === true ? t.useNativeBigInt : false, typeof t.constructorAction < "u")
        if (t.constructorAction === "error" || t.constructorAction === "ignore" || t.constructorAction === "preserve")
          e.constructorAction = t.constructorAction;
        else
          throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${t.constructorAction}`);
      if (typeof t.protoAction < "u")
        if (t.protoAction === "error" || t.protoAction === "ignore" || t.protoAction === "preserve")
          e.protoAction = t.protoAction;
        else
          throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${t.protoAction}`);
    }
    var r3, i, n = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: `
`, r: "\r", t: "	" }, s, o = function(ee2) {
      throw { name: "SyntaxError", message: ee2, at: r3, text: s };
    }, f2 = function(ee2) {
      return ee2 && ee2 !== i && o("Expected '" + ee2 + "' instead of '" + i + "'"), i = s.charAt(r3), r3 += 1, i;
    }, l = function() {
      var ee2, W5 = "";
      for (i === "-" && (W5 = "-", f2("-")); i >= "0" && i <= "9"; )
        W5 += i, f2();
      if (i === ".")
        for (W5 += "."; f2() && i >= "0" && i <= "9"; )
          W5 += i;
      if (i === "e" || i === "E")
        for (W5 += i, f2(), (i === "-" || i === "+") && (W5 += i, f2()); i >= "0" && i <= "9"; )
          W5 += i, f2();
      if (ee2 = +W5, !isFinite(ee2))
        o("Bad number");
      else
        return uh == null && (uh = Y1()), W5.length > 15 ? e.storeAsString ? W5 : e.useNativeBigInt ? BigInt(W5) : new uh(W5) : e.alwaysParseAsBig ? e.useNativeBigInt ? BigInt(ee2) : new uh(ee2) : ee2;
    }, g5 = function() {
      var ee2, W5, Z = "", le;
      if (i === '"')
        for (var be2 = r3; f2(); ) {
          if (i === '"')
            return r3 - 1 > be2 && (Z += s.substring(be2, r3 - 1)), f2(), Z;
          if (i === "\\") {
            if (r3 - 1 > be2 && (Z += s.substring(be2, r3 - 1)), f2(), i === "u") {
              for (le = 0, W5 = 0; W5 < 4 && (ee2 = parseInt(f2(), 16), !!isFinite(ee2)); W5 += 1)
                le = le * 16 + ee2;
              Z += String.fromCharCode(le);
            } else if (typeof n[i] == "string")
              Z += n[i];
            else
              break;
            be2 = r3;
          }
        }
      o("Bad string");
    }, _ = function() {
      for (; i && i <= " "; )
        f2();
    }, N2 = function() {
      switch (i) {
        case "t":
          return f2("t"), f2("r"), f2("u"), f2("e"), true;
        case "f":
          return f2("f"), f2("a"), f2("l"), f2("s"), f2("e"), false;
        case "n":
          return f2("n"), f2("u"), f2("l"), f2("l"), null;
      }
      o("Unexpected '" + i + "'");
    }, U2, V = function() {
      var ee2 = [];
      if (i === "[") {
        if (f2("["), _(), i === "]")
          return f2("]"), ee2;
        for (; i; ) {
          if (ee2.push(U2()), _(), i === "]")
            return f2("]"), ee2;
          f2(","), _();
        }
      }
      o("Bad array");
    }, G = function() {
      var ee2, W5 = /* @__PURE__ */ Object.create(null);
      if (i === "{") {
        if (f2("{"), _(), i === "}")
          return f2("}"), W5;
        for (; i; ) {
          if (ee2 = g5(), _(), f2(":"), e.strict === true && Object.hasOwnProperty.call(W5, ee2) && o('Duplicate key "' + ee2 + '"'), CT.test(ee2) === true ? e.protoAction === "error" ? o("Object contains forbidden prototype property") : e.protoAction === "ignore" ? U2() : W5[ee2] = U2() : OT.test(ee2) === true ? e.constructorAction === "error" ? o("Object contains forbidden constructor property") : e.constructorAction === "ignore" ? U2() : W5[ee2] = U2() : W5[ee2] = U2(), _(), i === "}")
            return f2("}"), W5;
          f2(","), _();
        }
      }
      o("Bad object");
    };
    return U2 = function() {
      switch (_(), i) {
        case "{":
          return G();
        case "[":
          return V();
        case '"':
          return g5();
        case "-":
          return l();
        default:
          return i >= "0" && i <= "9" ? l() : N2();
      }
    }, function(ee2, W5) {
      var Z;
      return s = ee2 + "", r3 = 0, i = " ", Z = U2(), _(), i && o("Syntax error"), typeof W5 == "function" ? function le(be2, Ae) {
        var H5, ue = be2[Ae];
        return ue && typeof ue == "object" && Object.keys(ue).forEach(function(se2) {
          H5 = le(ue, se2), H5 !== void 0 ? ue[se2] = H5 : delete ue[se2];
        }), W5.call(be2, Ae, ue);
      }({ "": Z }, "") : Z;
    };
  };
  a3.exports = jT;
});
var d3 = k((hB, dh) => {
  U();
  var c3 = o3().stringify, u3 = f3();
  dh.exports = function(t) {
    return { parse: u3(t), stringify: c3 };
  };
  dh.exports.parse = u3();
  dh.exports.stringify = c3;
});
var x3 = k((lc, Q1) => {
  U();
  (function(t, e) {
    typeof lc == "object" && typeof Q1 == "object" ? Q1.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof lc == "object" ? lc.MessagePack = e() : t.MessagePack = e();
  })(lc, function() {
    return function(t) {
      var e = {};
      function r3(i) {
        if (e[i])
          return e[i].exports;
        var n = e[i] = { i, l: false, exports: {} };
        return t[i].call(n.exports, n, n.exports, r3), n.l = true, n.exports;
      }
      return r3.m = t, r3.c = e, r3.d = function(i, n, s) {
        r3.o(i, n) || Object.defineProperty(i, n, { enumerable: true, get: s });
      }, r3.r = function(i) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: true });
      }, r3.t = function(i, n) {
        if (1 & n && (i = r3(i)), 8 & n || 4 & n && typeof i == "object" && i && i.__esModule)
          return i;
        var s = /* @__PURE__ */ Object.create(null);
        if (r3.r(s), Object.defineProperty(s, "default", { enumerable: true, value: i }), 2 & n && typeof i != "string")
          for (var o in i)
            r3.d(s, o, function(f2) {
              return i[f2];
            }.bind(null, o));
        return s;
      }, r3.n = function(i) {
        var n = i && i.__esModule ? function() {
          return i.default;
        } : function() {
          return i;
        };
        return r3.d(n, "a", n), n;
      }, r3.o = function(i, n) {
        return Object.prototype.hasOwnProperty.call(i, n);
      }, r3.p = "", r3(r3.s = 0);
    }([function(t, e, r3) {
      r3.r(e), r3.d(e, "encode", function() {
        return m2;
      }), r3.d(e, "decode", function() {
        return Oe;
      }), r3.d(e, "decodeAsync", function() {
        return ae;
      }), r3.d(e, "decodeArrayStream", function() {
        return ie;
      }), r3.d(e, "decodeStream", function() {
        return X2;
      }), r3.d(e, "Decoder", function() {
        return Me2;
      }), r3.d(e, "Encoder", function() {
        return E2;
      }), r3.d(e, "ExtensionCodec", function() {
        return ue;
      }), r3.d(e, "ExtData", function() {
        return V;
      }), r3.d(e, "EXT_TIMESTAMP", function() {
        return W$1;
      }), r3.d(e, "encodeDateToTimeSpec", function() {
        return le;
      }), r3.d(e, "encodeTimeSpecToTimestamp", function() {
        return Z;
      }), r3.d(e, "decodeTimestampToTimeSpec", function() {
        return Ae;
      }), r3.d(e, "encodeTimestampExtension", function() {
        return be2;
      }), r3.d(e, "decodeTimestampExtension", function() {
        return me;
      });
      var i = function(R5, x2) {
        var F2 = typeof Symbol == "function" && R5[Symbol.iterator];
        if (!F2)
          return R5;
        var q2, L2, K5 = F2.call(R5), $ = [];
        try {
          for (; (x2 === void 0 || x2-- > 0) && !(q2 = K5.next()).done; )
            $.push(q2.value);
        } catch (we2) {
          L2 = { error: we2 };
        } finally {
          try {
            q2 && !q2.done && (F2 = K5.return) && F2.call(K5);
          } finally {
            if (L2)
              throw L2.error;
          }
        }
        return $;
      }, n = function() {
        for (var R5 = [], x2 = 0; x2 < arguments.length; x2++)
          R5 = R5.concat(i(arguments[x2]));
        return R5;
      }, s = typeof W.default < "u" && typeof TextEncoder < "u" && typeof TextDecoder < "u";
      function o(R5) {
        for (var x2 = R5.length, F2 = 0, q2 = 0; q2 < x2; ) {
          var L2 = R5.charCodeAt(q2++);
          if ((4294967168 & L2) != 0)
            if ((4294965248 & L2) == 0)
              F2 += 2;
            else {
              if (L2 >= 55296 && L2 <= 56319 && q2 < x2) {
                var K5 = R5.charCodeAt(q2);
                (64512 & K5) == 56320 && (++q2, L2 = ((1023 & L2) << 10) + (1023 & K5) + 65536);
              }
              F2 += (4294901760 & L2) == 0 ? 3 : 4;
            }
          else
            F2++;
        }
        return F2;
      }
      var f2 = s ? new TextEncoder() : void 0, l = typeof W.default < "u" ? 200 : 0, g5 = (f2 == null ? void 0 : f2.encodeInto) ? function(R5, x2, F2) {
        f2.encodeInto(R5, x2.subarray(F2));
      } : function(R5, x2, F2) {
        x2.set(f2.encode(R5), F2);
      };
      function _(R5, x2, F2) {
        for (var q2 = x2, L2 = q2 + F2, K5 = [], $ = ""; q2 < L2; ) {
          var we2 = R5[q2++];
          if ((128 & we2) == 0)
            K5.push(we2);
          else if ((224 & we2) == 192) {
            var pe = 63 & R5[q2++];
            K5.push((31 & we2) << 6 | pe);
          } else if ((240 & we2) == 224) {
            pe = 63 & R5[q2++];
            var _e = 63 & R5[q2++];
            K5.push((31 & we2) << 12 | pe << 6 | _e);
          } else if ((248 & we2) == 240) {
            var fe2 = (7 & we2) << 18 | (pe = 63 & R5[q2++]) << 12 | (_e = 63 & R5[q2++]) << 6 | 63 & R5[q2++];
            fe2 > 65535 && (fe2 -= 65536, K5.push(fe2 >>> 10 & 1023 | 55296), fe2 = 56320 | 1023 & fe2), K5.push(fe2);
          } else
            K5.push(we2);
          K5.length >= 4096 && ($ += String.fromCharCode.apply(String, n(K5)), K5.length = 0);
        }
        return K5.length > 0 && ($ += String.fromCharCode.apply(String, n(K5))), $;
      }
      var N2 = s ? new TextDecoder() : null, U2 = typeof W.default < "u" ? 200 : 0, V = function(R5, x2) {
        this.type = R5, this.data = x2;
      };
      function G(R5, x2, F2) {
        var q2 = Math.floor(F2 / 4294967296), L2 = F2;
        R5.setUint32(x2, q2), R5.setUint32(x2 + 4, L2);
      }
      function ee2(R5, x2) {
        var F2 = R5.getInt32(x2), q2 = R5.getUint32(x2 + 4), L2 = F2 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || F2 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && q2 === 0, K5 = F2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        return L2 || K5 ? BigInt(F2) * BigInt(4294967296) + BigInt(q2) : 4294967296 * F2 + q2;
      }
      var W$1 = -1;
      function Z(R5) {
        var x2 = R5.sec, F2 = R5.nsec;
        if (x2 >= 0 && F2 >= 0 && x2 <= 17179869183) {
          if (F2 === 0 && x2 <= 4294967295) {
            var q2 = new Uint8Array(4);
            return ($ = new DataView(q2.buffer)).setUint32(0, x2), q2;
          }
          var L2 = x2 / 4294967296, K5 = 4294967295 & x2;
          return q2 = new Uint8Array(8), ($ = new DataView(q2.buffer)).setUint32(0, F2 << 2 | 3 & L2), $.setUint32(4, K5), q2;
        }
        var $;
        return q2 = new Uint8Array(12), ($ = new DataView(q2.buffer)).setUint32(0, F2), G($, 4, x2), q2;
      }
      function le(R5) {
        var x2 = R5.getTime(), F2 = Math.floor(x2 / 1e3), q2 = 1e6 * (x2 - 1e3 * F2), L2 = Math.floor(q2 / 1e9);
        return { sec: F2 + L2, nsec: q2 - 1e9 * L2 };
      }
      function be2(R5) {
        return R5 instanceof Date ? Z(le(R5)) : null;
      }
      function Ae(R5) {
        var x2 = new DataView(R5.buffer, R5.byteOffset, R5.byteLength);
        switch (R5.byteLength) {
          case 4:
            return { sec: x2.getUint32(0), nsec: 0 };
          case 8:
            var F2 = x2.getUint32(0);
            return { sec: 4294967296 * (3 & F2) + x2.getUint32(4), nsec: F2 >>> 2 };
          case 12:
            return { sec: ee2(x2, 4), nsec: x2.getUint32(0) };
          default:
            throw new Error("Unrecognized data size for timestamp: " + R5.length);
        }
      }
      function me(R5) {
        var x2 = Ae(R5);
        return new Date(1e3 * x2.sec + x2.nsec / 1e6);
      }
      var H5 = { type: W$1, encode: be2, decode: me }, ue = function() {
        function R5() {
          this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(H5);
        }
        return R5.prototype.register = function(x2) {
          var F2 = x2.type, q2 = x2.encode, L2 = x2.decode;
          if (F2 >= 0)
            this.encoders[F2] = q2, this.decoders[F2] = L2;
          else {
            var K5 = 1 + F2;
            this.builtInEncoders[K5] = q2, this.builtInDecoders[K5] = L2;
          }
        }, R5.prototype.tryToEncode = function(x2, F2) {
          for (var q2 = 0; q2 < this.builtInEncoders.length; q2++)
            if ((L2 = this.builtInEncoders[q2]) != null && (K5 = L2(x2, F2)) != null)
              return new V(-1 - q2, K5);
          for (q2 = 0; q2 < this.encoders.length; q2++) {
            var L2, K5;
            if ((L2 = this.encoders[q2]) != null && (K5 = L2(x2, F2)) != null)
              return new V(q2, K5);
          }
          return x2 instanceof V ? x2 : null;
        }, R5.prototype.decode = function(x2, F2, q2) {
          var L2 = F2 < 0 ? this.builtInDecoders[-1 - F2] : this.decoders[F2];
          return L2 ? L2(x2, F2, q2) : new V(F2, x2);
        }, R5.defaultCodec = new R5(), R5;
      }();
      function se2(R5) {
        return R5 instanceof Uint8Array ? R5 : ArrayBuffer.isView(R5) ? new Uint8Array(R5.buffer, R5.byteOffset, R5.byteLength) : R5 instanceof ArrayBuffer ? new Uint8Array(R5) : Uint8Array.from(R5);
      }
      var ne2 = function(R5) {
        var x2 = typeof Symbol == "function" && Symbol.iterator, F2 = x2 && R5[x2], q2 = 0;
        if (F2)
          return F2.call(R5);
        if (R5 && typeof R5.length == "number")
          return { next: function() {
            return R5 && q2 >= R5.length && (R5 = void 0), { value: R5 && R5[q2++], done: !R5 };
          } };
        throw new TypeError(x2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, E2 = function() {
        function R5(x2, F2, q2, L2, K5, $, we2, pe) {
          x2 === void 0 && (x2 = ue.defaultCodec), F2 === void 0 && (F2 = void 0), q2 === void 0 && (q2 = 100), L2 === void 0 && (L2 = 2048), K5 === void 0 && (K5 = false), $ === void 0 && ($ = false), we2 === void 0 && (we2 = false), pe === void 0 && (pe = false), this.extensionCodec = x2, this.context = F2, this.maxDepth = q2, this.initialBufferSize = L2, this.sortKeys = K5, this.forceFloat32 = $, this.ignoreUndefined = we2, this.forceIntegerToFloat = pe, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
        }
        return R5.prototype.getUint8Array = function() {
          return this.bytes.subarray(0, this.pos);
        }, R5.prototype.reinitializeState = function() {
          this.pos = 0;
        }, R5.prototype.encode = function(x2) {
          return this.reinitializeState(), this.doEncode(x2, 1), this.getUint8Array();
        }, R5.prototype.doEncode = function(x2, F2) {
          if (F2 > this.maxDepth)
            throw new Error("Too deep objects in depth " + F2);
          x2 == null ? this.encodeNil() : typeof x2 == "boolean" ? this.encodeBoolean(x2) : typeof x2 == "number" ? this.encodeNumber(x2) : typeof x2 == "string" ? this.encodeString(x2) : typeof x2 == "bigint" ? this.encodebigint(x2) : this.encodeObject(x2, F2);
        }, R5.prototype.ensureBufferSizeToWrite = function(x2) {
          var F2 = this.pos + x2;
          this.view.byteLength < F2 && this.resizeBuffer(2 * F2);
        }, R5.prototype.resizeBuffer = function(x2) {
          var F2 = new ArrayBuffer(x2), q2 = new Uint8Array(F2), L2 = new DataView(F2);
          q2.set(this.bytes), this.view = L2, this.bytes = q2;
        }, R5.prototype.encodeNil = function() {
          this.writeU8(192);
        }, R5.prototype.encodeBoolean = function(x2) {
          x2 === false ? this.writeU8(194) : this.writeU8(195);
        }, R5.prototype.encodeNumber = function(x2) {
          Number.isSafeInteger(x2) && !this.forceIntegerToFloat ? x2 >= 0 ? x2 < 128 ? this.writeU8(x2) : x2 < 256 ? (this.writeU8(204), this.writeU8(x2)) : x2 < 65536 ? (this.writeU8(205), this.writeU16(x2)) : x2 < 4294967296 ? (this.writeU8(206), this.writeU32(x2)) : (this.writeU8(207), this.writeU64(x2)) : x2 >= -32 ? this.writeU8(224 | x2 + 32) : x2 >= -128 ? (this.writeU8(208), this.writeI8(x2)) : x2 >= -32768 ? (this.writeU8(209), this.writeI16(x2)) : x2 >= -2147483648 ? (this.writeU8(210), this.writeI32(x2)) : (this.writeU8(211), this.writeI64(x2)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(x2)) : (this.writeU8(203), this.writeF64(x2));
        }, R5.prototype.encodebigint = function(x2) {
          x2 >= BigInt(0) ? x2 < BigInt(128) ? this.writeU8(Number(x2)) : x2 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(x2))) : x2 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(x2))) : x2 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(x2))) : (this.writeU8(207), this.writeBig64(x2)) : x2 >= BigInt(-32) ? this.writeU8(224 | Number(x2) + 32) : x2 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(x2))) : x2 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(x2))) : x2 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(x2))) : (this.writeU8(211), this.writeBig64(x2));
        }, R5.prototype.writeStringHeader = function(x2) {
          if (x2 < 32)
            this.writeU8(160 + x2);
          else if (x2 < 256)
            this.writeU8(217), this.writeU8(x2);
          else if (x2 < 65536)
            this.writeU8(218), this.writeU16(x2);
          else {
            if (!(x2 < 4294967296))
              throw new Error("Too long string: " + x2 + " bytes in UTF-8");
            this.writeU8(219), this.writeU32(x2);
          }
        }, R5.prototype.encodeString = function(x2) {
          var F2 = x2.length;
          if (s && F2 > l) {
            var q2 = o(x2);
            this.ensureBufferSizeToWrite(5 + q2), this.writeStringHeader(q2), g5(x2, this.bytes, this.pos), this.pos += q2;
          } else
            q2 = o(x2), this.ensureBufferSizeToWrite(5 + q2), this.writeStringHeader(q2), function(L2, K5, $) {
              for (var we2 = L2.length, pe = $, _e = 0; _e < we2; ) {
                var fe2 = L2.charCodeAt(_e++);
                if ((4294967168 & fe2) != 0) {
                  if ((4294965248 & fe2) == 0)
                    K5[pe++] = fe2 >> 6 & 31 | 192;
                  else {
                    if (fe2 >= 55296 && fe2 <= 56319 && _e < we2) {
                      var Fe = L2.charCodeAt(_e);
                      (64512 & Fe) == 56320 && (++_e, fe2 = ((1023 & fe2) << 10) + (1023 & Fe) + 65536);
                    }
                    (4294901760 & fe2) == 0 ? (K5[pe++] = fe2 >> 12 & 15 | 224, K5[pe++] = fe2 >> 6 & 63 | 128) : (K5[pe++] = fe2 >> 18 & 7 | 240, K5[pe++] = fe2 >> 12 & 63 | 128, K5[pe++] = fe2 >> 6 & 63 | 128);
                  }
                  K5[pe++] = 63 & fe2 | 128;
                } else
                  K5[pe++] = fe2;
              }
            }(x2, this.bytes, this.pos), this.pos += q2;
        }, R5.prototype.encodeObject = function(x2, F2) {
          var q2 = this.extensionCodec.tryToEncode(x2, this.context);
          if (q2 != null)
            this.encodeExtension(q2);
          else if (Array.isArray(x2))
            this.encodeArray(x2, F2);
          else if (ArrayBuffer.isView(x2))
            this.encodeBinary(x2);
          else {
            if (typeof x2 != "object")
              throw new Error("Unrecognized object: " + Object.prototype.toString.apply(x2));
            this.encodeMap(x2, F2);
          }
        }, R5.prototype.encodeBinary = function(x2) {
          var F2 = x2.byteLength;
          if (F2 < 256)
            this.writeU8(196), this.writeU8(F2);
          else if (F2 < 65536)
            this.writeU8(197), this.writeU16(F2);
          else {
            if (!(F2 < 4294967296))
              throw new Error("Too large binary: " + F2);
            this.writeU8(198), this.writeU32(F2);
          }
          var q2 = se2(x2);
          this.writeU8a(q2);
        }, R5.prototype.encodeArray = function(x2, F2) {
          var q2, L2, K5 = x2.length;
          if (K5 < 16)
            this.writeU8(144 + K5);
          else if (K5 < 65536)
            this.writeU8(220), this.writeU16(K5);
          else {
            if (!(K5 < 4294967296))
              throw new Error("Too large array: " + K5);
            this.writeU8(221), this.writeU32(K5);
          }
          try {
            for (var $ = ne2(x2), we2 = $.next(); !we2.done; we2 = $.next()) {
              var pe = we2.value;
              this.doEncode(pe, F2 + 1);
            }
          } catch (_e) {
            q2 = { error: _e };
          } finally {
            try {
              we2 && !we2.done && (L2 = $.return) && L2.call($);
            } finally {
              if (q2)
                throw q2.error;
            }
          }
        }, R5.prototype.countWithoutUndefined = function(x2, F2) {
          var q2, L2, K5 = 0;
          try {
            for (var $ = ne2(F2), we2 = $.next(); !we2.done; we2 = $.next())
              x2[we2.value] !== void 0 && K5++;
          } catch (pe) {
            q2 = { error: pe };
          } finally {
            try {
              we2 && !we2.done && (L2 = $.return) && L2.call($);
            } finally {
              if (q2)
                throw q2.error;
            }
          }
          return K5;
        }, R5.prototype.encodeMap = function(x2, F2) {
          var q2, L2, K5 = Object.keys(x2);
          this.sortKeys && K5.sort();
          var $ = this.ignoreUndefined ? this.countWithoutUndefined(x2, K5) : K5.length;
          if ($ < 16)
            this.writeU8(128 + $);
          else if ($ < 65536)
            this.writeU8(222), this.writeU16($);
          else {
            if (!($ < 4294967296))
              throw new Error("Too large map object: " + $);
            this.writeU8(223), this.writeU32($);
          }
          try {
            for (var we2 = ne2(K5), pe = we2.next(); !pe.done; pe = we2.next()) {
              var _e = pe.value, fe2 = x2[_e];
              this.ignoreUndefined && fe2 === void 0 || (this.encodeString(_e), this.doEncode(fe2, F2 + 1));
            }
          } catch (Fe) {
            q2 = { error: Fe };
          } finally {
            try {
              pe && !pe.done && (L2 = we2.return) && L2.call(we2);
            } finally {
              if (q2)
                throw q2.error;
            }
          }
        }, R5.prototype.encodeExtension = function(x2) {
          var F2 = x2.data.length;
          if (F2 === 1)
            this.writeU8(212);
          else if (F2 === 2)
            this.writeU8(213);
          else if (F2 === 4)
            this.writeU8(214);
          else if (F2 === 8)
            this.writeU8(215);
          else if (F2 === 16)
            this.writeU8(216);
          else if (F2 < 256)
            this.writeU8(199), this.writeU8(F2);
          else if (F2 < 65536)
            this.writeU8(200), this.writeU16(F2);
          else {
            if (!(F2 < 4294967296))
              throw new Error("Too large extension object: " + F2);
            this.writeU8(201), this.writeU32(F2);
          }
          this.writeI8(x2.type), this.writeU8a(x2.data);
        }, R5.prototype.writeU8 = function(x2) {
          this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, x2), this.pos++;
        }, R5.prototype.writeU8a = function(x2) {
          var F2 = x2.length;
          this.ensureBufferSizeToWrite(F2), this.bytes.set(x2, this.pos), this.pos += F2;
        }, R5.prototype.writeI8 = function(x2) {
          this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, x2), this.pos++;
        }, R5.prototype.writeU16 = function(x2) {
          this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, x2), this.pos += 2;
        }, R5.prototype.writeI16 = function(x2) {
          this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, x2), this.pos += 2;
        }, R5.prototype.writeU32 = function(x2) {
          this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, x2), this.pos += 4;
        }, R5.prototype.writeI32 = function(x2) {
          this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, x2), this.pos += 4;
        }, R5.prototype.writeF32 = function(x2) {
          this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, x2), this.pos += 4;
        }, R5.prototype.writeF64 = function(x2) {
          this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, x2), this.pos += 8;
        }, R5.prototype.writeU64 = function(x2) {
          this.ensureBufferSizeToWrite(8), function(F2, q2, L2) {
            var K5 = L2 / 4294967296, $ = L2;
            F2.setUint32(q2, K5), F2.setUint32(q2 + 4, $);
          }(this.view, this.pos, x2), this.pos += 8;
        }, R5.prototype.writeI64 = function(x2) {
          this.ensureBufferSizeToWrite(8), G(this.view, this.pos, x2), this.pos += 8;
        }, R5.prototype.writeBig64 = function(x2) {
          this.ensureBufferSizeToWrite(8), function(F2, q2, L2) {
            var K5 = Number(L2 / BigInt(4294967296)), $ = Number(L2 % BigInt(4294967296));
            K5 < 0 && $ !== 0 && (K5 -= 1), F2.setUint32(q2, K5), F2.setUint32(q2 + 4, $);
          }(this.view, this.pos, x2), this.pos += 8;
        }, R5;
      }(), c = {};
      function m2(R5, x2) {
        return x2 === void 0 && (x2 = c), new E2(x2.extensionCodec, x2.context, x2.maxDepth, x2.initialBufferSize, x2.sortKeys, x2.forceFloat32, x2.ignoreUndefined, x2.forceIntegerToFloat).encode(R5);
      }
      function h2(R5) {
        return (R5 < 0 ? "-" : "") + "0x" + Math.abs(R5).toString(16).padStart(2, "0");
      }
      var a = function() {
        function R5(x2, F2) {
          x2 === void 0 && (x2 = 16), F2 === void 0 && (F2 = 16), this.maxKeyLength = x2, this.maxLengthPerKey = F2, this.hit = 0, this.miss = 0, this.caches = [];
          for (var q2 = 0; q2 < this.maxKeyLength; q2++)
            this.caches.push([]);
        }
        return R5.prototype.canBeCached = function(x2) {
          return x2 > 0 && x2 <= this.maxKeyLength;
        }, R5.prototype.get = function(x2, F2, q2) {
          var L2 = this.caches[q2 - 1], K5 = L2.length;
          e:
            for (var $ = 0; $ < K5; $++) {
              for (var we2 = L2[$], pe = we2.bytes, _e = 0; _e < q2; _e++)
                if (pe[_e] !== x2[F2 + _e])
                  continue e;
              return we2.value;
            }
          return null;
        }, R5.prototype.store = function(x2, F2) {
          var q2 = this.caches[x2.length - 1], L2 = { bytes: x2, value: F2 };
          q2.length >= this.maxLengthPerKey ? q2[Math.random() * q2.length | 0] = L2 : q2.push(L2);
        }, R5.prototype.decode = function(x2, F2, q2) {
          var L2 = this.get(x2, F2, q2);
          if (L2 != null)
            return this.hit++, L2;
          this.miss++;
          var K5 = _(x2, F2, q2), $ = Uint8Array.prototype.slice.call(x2, F2, F2 + q2);
          return this.store($, K5), K5;
        }, R5;
      }(), u3 = function(R5, x2, F2, q2) {
        return new (F2 || (F2 = Promise))(function(L2, K5) {
          function $(_e) {
            try {
              pe(q2.next(_e));
            } catch (fe2) {
              K5(fe2);
            }
          }
          function we2(_e) {
            try {
              pe(q2.throw(_e));
            } catch (fe2) {
              K5(fe2);
            }
          }
          function pe(_e) {
            var fe2;
            _e.done ? L2(_e.value) : (fe2 = _e.value, fe2 instanceof F2 ? fe2 : new F2(function(Fe) {
              Fe(fe2);
            })).then($, we2);
          }
          pe((q2 = q2.apply(R5, x2 || [])).next());
        });
      }, b2 = function(R5, x2) {
        var F2, q2, L2, K5, $ = { label: 0, sent: function() {
          if (1 & L2[0])
            throw L2[1];
          return L2[1];
        }, trys: [], ops: [] };
        return K5 = { next: we2(0), throw: we2(1), return: we2(2) }, typeof Symbol == "function" && (K5[Symbol.iterator] = function() {
          return this;
        }), K5;
        function we2(pe) {
          return function(_e) {
            return function(fe2) {
              if (F2)
                throw new TypeError("Generator is already executing.");
              for (; $; )
                try {
                  if (F2 = 1, q2 && (L2 = 2 & fe2[0] ? q2.return : fe2[0] ? q2.throw || ((L2 = q2.return) && L2.call(q2), 0) : q2.next) && !(L2 = L2.call(q2, fe2[1])).done)
                    return L2;
                  switch (q2 = 0, L2 && (fe2 = [2 & fe2[0], L2.value]), fe2[0]) {
                    case 0:
                    case 1:
                      L2 = fe2;
                      break;
                    case 4:
                      return $.label++, { value: fe2[1], done: false };
                    case 5:
                      $.label++, q2 = fe2[1], fe2 = [0];
                      continue;
                    case 7:
                      fe2 = $.ops.pop(), $.trys.pop();
                      continue;
                    default:
                      if (L2 = $.trys, !((L2 = L2.length > 0 && L2[L2.length - 1]) || fe2[0] !== 6 && fe2[0] !== 2)) {
                        $ = 0;
                        continue;
                      }
                      if (fe2[0] === 3 && (!L2 || fe2[1] > L2[0] && fe2[1] < L2[3])) {
                        $.label = fe2[1];
                        break;
                      }
                      if (fe2[0] === 6 && $.label < L2[1]) {
                        $.label = L2[1], L2 = fe2;
                        break;
                      }
                      if (L2 && $.label < L2[2]) {
                        $.label = L2[2], $.ops.push(fe2);
                        break;
                      }
                      L2[2] && $.ops.pop(), $.trys.pop();
                      continue;
                  }
                  fe2 = x2.call(R5, $);
                } catch (Fe) {
                  fe2 = [6, Fe], q2 = 0;
                } finally {
                  F2 = L2 = 0;
                }
              if (5 & fe2[0])
                throw fe2[1];
              return { value: fe2[0] ? fe2[1] : void 0, done: true };
            }([pe, _e]);
          };
        }
      }, A2 = function(R5) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var x2, F2 = R5[Symbol.asyncIterator];
        return F2 ? F2.call(R5) : (R5 = typeof __values == "function" ? __values(R5) : R5[Symbol.iterator](), x2 = {}, q2("next"), q2("throw"), q2("return"), x2[Symbol.asyncIterator] = function() {
          return this;
        }, x2);
        function q2(L2) {
          x2[L2] = R5[L2] && function(K5) {
            return new Promise(function($, we2) {
              (function(pe, _e, fe2, Fe) {
                Promise.resolve(Fe).then(function(De) {
                  pe({ value: De, done: fe2 });
                }, _e);
              })($, we2, (K5 = R5[L2](K5)).done, K5.value);
            });
          };
        }
      }, v2 = function(R5) {
        return this instanceof v2 ? (this.v = R5, this) : new v2(R5);
      }, d2 = function(R5, x2, F2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var q2, L2 = F2.apply(R5, x2 || []), K5 = [];
        return q2 = {}, $("next"), $("throw"), $("return"), q2[Symbol.asyncIterator] = function() {
          return this;
        }, q2;
        function $(Fe) {
          L2[Fe] && (q2[Fe] = function(De) {
            return new Promise(function(pt2, je) {
              K5.push([Fe, De, pt2, je]) > 1 || we2(Fe, De);
            });
          });
        }
        function we2(Fe, De) {
          try {
            (pt2 = L2[Fe](De)).value instanceof v2 ? Promise.resolve(pt2.value.v).then(pe, _e) : fe2(K5[0][2], pt2);
          } catch (je) {
            fe2(K5[0][3], je);
          }
          var pt2;
        }
        function pe(Fe) {
          we2("next", Fe);
        }
        function _e(Fe) {
          we2("throw", Fe);
        }
        function fe2(Fe, De) {
          Fe(De), K5.shift(), K5.length && we2(K5[0][0], K5[0][1]);
        }
      }, M = new DataView(new ArrayBuffer(0)), B2 = new Uint8Array(M.buffer), y2 = function() {
        try {
          M.getInt8(0);
        } catch (R5) {
          return R5.constructor;
        }
        throw new Error("never reached");
      }(), I = new y2("Insufficient data"), de = new a(), Me2 = function() {
        function R5(x2, F2, q2, L2, K5, $, we2, pe) {
          x2 === void 0 && (x2 = ue.defaultCodec), F2 === void 0 && (F2 = void 0), q2 === void 0 && (q2 = 4294967295), L2 === void 0 && (L2 = 4294967295), K5 === void 0 && (K5 = 4294967295), $ === void 0 && ($ = 4294967295), we2 === void 0 && (we2 = 4294967295), pe === void 0 && (pe = de), this.extensionCodec = x2, this.context = F2, this.maxStrLength = q2, this.maxBinLength = L2, this.maxArrayLength = K5, this.maxMapLength = $, this.maxExtLength = we2, this.keyDecoder = pe, this.totalPos = 0, this.pos = 0, this.view = M, this.bytes = B2, this.headByte = -1, this.stack = [];
        }
        return R5.prototype.reinitializeState = function() {
          this.totalPos = 0, this.headByte = -1;
        }, R5.prototype.setBuffer = function(x2) {
          this.bytes = se2(x2), this.view = function(F2) {
            if (F2 instanceof ArrayBuffer)
              return new DataView(F2);
            var q2 = se2(F2);
            return new DataView(q2.buffer, q2.byteOffset, q2.byteLength);
          }(this.bytes), this.pos = 0;
        }, R5.prototype.appendBuffer = function(x2) {
          if (this.headByte !== -1 || this.hasRemaining()) {
            var F2 = this.bytes.subarray(this.pos), q2 = se2(x2), L2 = new Uint8Array(F2.length + q2.length);
            L2.set(F2), L2.set(q2, F2.length), this.setBuffer(L2);
          } else
            this.setBuffer(x2);
        }, R5.prototype.hasRemaining = function(x2) {
          return x2 === void 0 && (x2 = 1), this.view.byteLength - this.pos >= x2;
        }, R5.prototype.createNoExtraBytesError = function(x2) {
          var F2 = this.view, q2 = this.pos;
          return new RangeError("Extra " + (F2.byteLength - q2) + " of " + F2.byteLength + " byte(s) found at buffer[" + x2 + "]");
        }, R5.prototype.decode = function(x2) {
          return this.reinitializeState(), this.setBuffer(x2), this.doDecodeSingleSync();
        }, R5.prototype.doDecodeSingleSync = function() {
          var x2 = this.doDecodeSync();
          if (this.hasRemaining())
            throw this.createNoExtraBytesError(this.pos);
          return x2;
        }, R5.prototype.decodeAsync = function(x2) {
          var F2, q2, L2, K5;
          return u3(this, void 0, void 0, function() {
            var $, we2, pe, _e, fe2, Fe, De, pt2;
            return b2(this, function(je) {
              switch (je.label) {
                case 0:
                  $ = false, je.label = 1;
                case 1:
                  je.trys.push([1, 6, 7, 12]), F2 = A2(x2), je.label = 2;
                case 2:
                  return [4, F2.next()];
                case 3:
                  if ((q2 = je.sent()).done)
                    return [3, 5];
                  if (pe = q2.value, $)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(pe);
                  try {
                    we2 = this.doDecodeSync(), $ = true;
                  } catch (Ke) {
                    if (!(Ke instanceof y2))
                      throw Ke;
                  }
                  this.totalPos += this.pos, je.label = 4;
                case 4:
                  return [3, 2];
                case 5:
                  return [3, 12];
                case 6:
                  return _e = je.sent(), L2 = { error: _e }, [3, 12];
                case 7:
                  return je.trys.push([7, , 10, 11]), q2 && !q2.done && (K5 = F2.return) ? [4, K5.call(F2)] : [3, 9];
                case 8:
                  je.sent(), je.label = 9;
                case 9:
                  return [3, 11];
                case 10:
                  if (L2)
                    throw L2.error;
                  return [7];
                case 11:
                  return [7];
                case 12:
                  if ($) {
                    if (this.hasRemaining())
                      throw this.createNoExtraBytesError(this.totalPos);
                    return [2, we2];
                  }
                  throw Fe = (fe2 = this).headByte, De = fe2.pos, pt2 = fe2.totalPos, new RangeError("Insufficient data in parcing " + h2(Fe) + " at " + pt2 + " (" + De + " in the current buffer)");
              }
            });
          });
        }, R5.prototype.decodeArrayStream = function(x2) {
          return this.decodeMultiAsync(x2, true);
        }, R5.prototype.decodeStream = function(x2) {
          return this.decodeMultiAsync(x2, false);
        }, R5.prototype.decodeMultiAsync = function(x2, F2) {
          return d2(this, arguments, function() {
            var q2, L2, K5, $, we2, pe, _e, fe2, Fe;
            return b2(this, function(De) {
              switch (De.label) {
                case 0:
                  q2 = F2, L2 = -1, De.label = 1;
                case 1:
                  De.trys.push([1, 13, 14, 19]), K5 = A2(x2), De.label = 2;
                case 2:
                  return [4, v2(K5.next())];
                case 3:
                  if (($ = De.sent()).done)
                    return [3, 12];
                  if (we2 = $.value, F2 && L2 === 0)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(we2), q2 && (L2 = this.readArraySize(), q2 = false, this.complete()), De.label = 4;
                case 4:
                  De.trys.push([4, 9, , 10]), De.label = 5;
                case 5:
                  return [4, v2(this.doDecodeSync())];
                case 6:
                  return [4, De.sent()];
                case 7:
                  return De.sent(), --L2 == 0 ? [3, 8] : [3, 5];
                case 8:
                  return [3, 10];
                case 9:
                  if (!((pe = De.sent()) instanceof y2))
                    throw pe;
                  return [3, 10];
                case 10:
                  this.totalPos += this.pos, De.label = 11;
                case 11:
                  return [3, 2];
                case 12:
                  return [3, 19];
                case 13:
                  return _e = De.sent(), fe2 = { error: _e }, [3, 19];
                case 14:
                  return De.trys.push([14, , 17, 18]), $ && !$.done && (Fe = K5.return) ? [4, v2(Fe.call(K5))] : [3, 16];
                case 15:
                  De.sent(), De.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  if (fe2)
                    throw fe2.error;
                  return [7];
                case 18:
                  return [7];
                case 19:
                  return [2];
              }
            });
          });
        }, R5.prototype.doDecodeSync = function() {
          e:
            for (; ; ) {
              var x2 = this.readHeadByte(), F2 = void 0;
              if (x2 >= 224)
                F2 = x2 - 256;
              else if (x2 < 192)
                if (x2 < 128)
                  F2 = x2;
                else if (x2 < 144) {
                  if ((L2 = x2 - 128) !== 0) {
                    this.pushMapState(L2), this.complete();
                    continue e;
                  }
                  F2 = {};
                } else if (x2 < 160) {
                  if ((L2 = x2 - 144) !== 0) {
                    this.pushArrayState(L2), this.complete();
                    continue e;
                  }
                  F2 = [];
                } else {
                  var q2 = x2 - 160;
                  F2 = this.decodeUtf8String(q2, 0);
                }
              else if (x2 === 192)
                F2 = null;
              else if (x2 === 194)
                F2 = false;
              else if (x2 === 195)
                F2 = true;
              else if (x2 === 202)
                F2 = this.readF32();
              else if (x2 === 203)
                F2 = this.readF64();
              else if (x2 === 204)
                F2 = this.readU8();
              else if (x2 === 205)
                F2 = this.readU16();
              else if (x2 === 206)
                F2 = this.readU32();
              else if (x2 === 207)
                F2 = this.readU64();
              else if (x2 === 208)
                F2 = this.readI8();
              else if (x2 === 209)
                F2 = this.readI16();
              else if (x2 === 210)
                F2 = this.readI32();
              else if (x2 === 211)
                F2 = this.readI64();
              else if (x2 === 217)
                q2 = this.lookU8(), F2 = this.decodeUtf8String(q2, 1);
              else if (x2 === 218)
                q2 = this.lookU16(), F2 = this.decodeUtf8String(q2, 2);
              else if (x2 === 219)
                q2 = this.lookU32(), F2 = this.decodeUtf8String(q2, 4);
              else if (x2 === 220) {
                if ((L2 = this.readU16()) !== 0) {
                  this.pushArrayState(L2), this.complete();
                  continue e;
                }
                F2 = [];
              } else if (x2 === 221) {
                if ((L2 = this.readU32()) !== 0) {
                  this.pushArrayState(L2), this.complete();
                  continue e;
                }
                F2 = [];
              } else if (x2 === 222) {
                if ((L2 = this.readU16()) !== 0) {
                  this.pushMapState(L2), this.complete();
                  continue e;
                }
                F2 = {};
              } else if (x2 === 223) {
                if ((L2 = this.readU32()) !== 0) {
                  this.pushMapState(L2), this.complete();
                  continue e;
                }
                F2 = {};
              } else if (x2 === 196) {
                var L2 = this.lookU8();
                F2 = this.decodeBinary(L2, 1);
              } else if (x2 === 197)
                L2 = this.lookU16(), F2 = this.decodeBinary(L2, 2);
              else if (x2 === 198)
                L2 = this.lookU32(), F2 = this.decodeBinary(L2, 4);
              else if (x2 === 212)
                F2 = this.decodeExtension(1, 0);
              else if (x2 === 213)
                F2 = this.decodeExtension(2, 0);
              else if (x2 === 214)
                F2 = this.decodeExtension(4, 0);
              else if (x2 === 215)
                F2 = this.decodeExtension(8, 0);
              else if (x2 === 216)
                F2 = this.decodeExtension(16, 0);
              else if (x2 === 199)
                L2 = this.lookU8(), F2 = this.decodeExtension(L2, 1);
              else if (x2 === 200)
                L2 = this.lookU16(), F2 = this.decodeExtension(L2, 2);
              else {
                if (x2 !== 201)
                  throw new Error("Unrecognized type byte: " + h2(x2));
                L2 = this.lookU32(), F2 = this.decodeExtension(L2, 4);
              }
              this.complete();
              for (var K5 = this.stack; K5.length > 0; ) {
                var $ = K5[K5.length - 1];
                if ($.type === 0) {
                  if ($.array[$.position] = F2, $.position++, $.position !== $.size)
                    continue e;
                  K5.pop(), F2 = $.array;
                } else {
                  if ($.type === 1) {
                    if (we2 = void 0, (we2 = typeof F2) != "string" && we2 !== "number")
                      throw new Error("The type of key must be string or number but " + typeof F2);
                    $.key = F2, $.type = 2;
                    continue e;
                  }
                  if ($.map[$.key] = F2, $.readCount++, $.readCount !== $.size) {
                    $.key = null, $.type = 1;
                    continue e;
                  }
                  K5.pop(), F2 = $.map;
                }
              }
              return F2;
            }
          var we2;
        }, R5.prototype.readHeadByte = function() {
          return this.headByte === -1 && (this.headByte = this.readU8()), this.headByte;
        }, R5.prototype.complete = function() {
          this.headByte = -1;
        }, R5.prototype.readArraySize = function() {
          var x2 = this.readHeadByte();
          switch (x2) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default:
              if (x2 < 160)
                return x2 - 144;
              throw new Error("Unrecognized array type byte: " + h2(x2));
          }
        }, R5.prototype.pushMapState = function(x2) {
          if (x2 > this.maxMapLength)
            throw new Error("Max length exceeded: map length (" + x2 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
          this.stack.push({ type: 1, size: x2, key: null, readCount: 0, map: {} });
        }, R5.prototype.pushArrayState = function(x2) {
          if (x2 > this.maxArrayLength)
            throw new Error("Max length exceeded: array length (" + x2 + ") > maxArrayLength (" + this.maxArrayLength + ")");
          this.stack.push({ type: 0, size: x2, array: new Array(x2), position: 0 });
        }, R5.prototype.decodeUtf8String = function(x2, F2) {
          var q2;
          if (x2 > this.maxStrLength)
            throw new Error("Max length exceeded: UTF-8 byte length (" + x2 + ") > maxStrLength (" + this.maxStrLength + ")");
          if (this.bytes.byteLength < this.pos + F2 + x2)
            throw I;
          var L2, K5 = this.pos + F2;
          return L2 = this.stateIsMapKey() && ((q2 = this.keyDecoder) === null || q2 === void 0 ? void 0 : q2.canBeCached(x2)) ? this.keyDecoder.decode(this.bytes, K5, x2) : s && x2 > U2 ? function($, we2, pe) {
            var _e = $.subarray(we2, we2 + pe);
            return N2.decode(_e);
          }(this.bytes, K5, x2) : _(this.bytes, K5, x2), this.pos += F2 + x2, L2;
        }, R5.prototype.stateIsMapKey = function() {
          return this.stack.length > 0 && this.stack[this.stack.length - 1].type === 1;
        }, R5.prototype.decodeBinary = function(x2, F2) {
          if (x2 > this.maxBinLength)
            throw new Error("Max length exceeded: bin length (" + x2 + ") > maxBinLength (" + this.maxBinLength + ")");
          if (!this.hasRemaining(x2 + F2))
            throw I;
          var q2 = this.pos + F2, L2 = this.bytes.subarray(q2, q2 + x2);
          return this.pos += F2 + x2, L2;
        }, R5.prototype.decodeExtension = function(x2, F2) {
          if (x2 > this.maxExtLength)
            throw new Error("Max length exceeded: ext length (" + x2 + ") > maxExtLength (" + this.maxExtLength + ")");
          var q2 = this.view.getInt8(this.pos + F2), L2 = this.decodeBinary(x2, F2 + 1);
          return this.extensionCodec.decode(L2, q2, this.context);
        }, R5.prototype.lookU8 = function() {
          return this.view.getUint8(this.pos);
        }, R5.prototype.lookU16 = function() {
          return this.view.getUint16(this.pos);
        }, R5.prototype.lookU32 = function() {
          return this.view.getUint32(this.pos);
        }, R5.prototype.readU8 = function() {
          var x2 = this.view.getUint8(this.pos);
          return this.pos++, x2;
        }, R5.prototype.readI8 = function() {
          var x2 = this.view.getInt8(this.pos);
          return this.pos++, x2;
        }, R5.prototype.readU16 = function() {
          var x2 = this.view.getUint16(this.pos);
          return this.pos += 2, x2;
        }, R5.prototype.readI16 = function() {
          var x2 = this.view.getInt16(this.pos);
          return this.pos += 2, x2;
        }, R5.prototype.readU32 = function() {
          var x2 = this.view.getUint32(this.pos);
          return this.pos += 4, x2;
        }, R5.prototype.readI32 = function() {
          var x2 = this.view.getInt32(this.pos);
          return this.pos += 4, x2;
        }, R5.prototype.readU64 = function() {
          var x2, F2, q2, L2, K5 = (x2 = this.view, F2 = this.pos, q2 = x2.getUint32(F2), L2 = x2.getUint32(F2 + 4), q2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(q2) * BigInt(4294967296) + BigInt(L2) : 4294967296 * q2 + L2);
          return this.pos += 8, K5;
        }, R5.prototype.readI64 = function() {
          var x2 = ee2(this.view, this.pos);
          return this.pos += 8, x2;
        }, R5.prototype.readF32 = function() {
          var x2 = this.view.getFloat32(this.pos);
          return this.pos += 4, x2;
        }, R5.prototype.readF64 = function() {
          var x2 = this.view.getFloat64(this.pos);
          return this.pos += 8, x2;
        }, R5;
      }(), Se = {};
      function Oe(R5, x2) {
        return x2 === void 0 && (x2 = Se), new Me2(x2.extensionCodec, x2.context, x2.maxStrLength, x2.maxBinLength, x2.maxArrayLength, x2.maxMapLength, x2.maxExtLength).decode(R5);
      }
      var ye = function(R5, x2) {
        var F2, q2, L2, K5, $ = { label: 0, sent: function() {
          if (1 & L2[0])
            throw L2[1];
          return L2[1];
        }, trys: [], ops: [] };
        return K5 = { next: we2(0), throw: we2(1), return: we2(2) }, typeof Symbol == "function" && (K5[Symbol.iterator] = function() {
          return this;
        }), K5;
        function we2(pe) {
          return function(_e) {
            return function(fe2) {
              if (F2)
                throw new TypeError("Generator is already executing.");
              for (; $; )
                try {
                  if (F2 = 1, q2 && (L2 = 2 & fe2[0] ? q2.return : fe2[0] ? q2.throw || ((L2 = q2.return) && L2.call(q2), 0) : q2.next) && !(L2 = L2.call(q2, fe2[1])).done)
                    return L2;
                  switch (q2 = 0, L2 && (fe2 = [2 & fe2[0], L2.value]), fe2[0]) {
                    case 0:
                    case 1:
                      L2 = fe2;
                      break;
                    case 4:
                      return $.label++, { value: fe2[1], done: false };
                    case 5:
                      $.label++, q2 = fe2[1], fe2 = [0];
                      continue;
                    case 7:
                      fe2 = $.ops.pop(), $.trys.pop();
                      continue;
                    default:
                      if (L2 = $.trys, !((L2 = L2.length > 0 && L2[L2.length - 1]) || fe2[0] !== 6 && fe2[0] !== 2)) {
                        $ = 0;
                        continue;
                      }
                      if (fe2[0] === 3 && (!L2 || fe2[1] > L2[0] && fe2[1] < L2[3])) {
                        $.label = fe2[1];
                        break;
                      }
                      if (fe2[0] === 6 && $.label < L2[1]) {
                        $.label = L2[1], L2 = fe2;
                        break;
                      }
                      if (L2 && $.label < L2[2]) {
                        $.label = L2[2], $.ops.push(fe2);
                        break;
                      }
                      L2[2] && $.ops.pop(), $.trys.pop();
                      continue;
                  }
                  fe2 = x2.call(R5, $);
                } catch (Fe) {
                  fe2 = [6, Fe], q2 = 0;
                } finally {
                  F2 = L2 = 0;
                }
              if (5 & fe2[0])
                throw fe2[1];
              return { value: fe2[0] ? fe2[1] : void 0, done: true };
            }([pe, _e]);
          };
        }
      }, T = function(R5) {
        return this instanceof T ? (this.v = R5, this) : new T(R5);
      }, j2 = function(R5, x2, F2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var q2, L2 = F2.apply(R5, x2 || []), K5 = [];
        return q2 = {}, $("next"), $("throw"), $("return"), q2[Symbol.asyncIterator] = function() {
          return this;
        }, q2;
        function $(Fe) {
          L2[Fe] && (q2[Fe] = function(De) {
            return new Promise(function(pt2, je) {
              K5.push([Fe, De, pt2, je]) > 1 || we2(Fe, De);
            });
          });
        }
        function we2(Fe, De) {
          try {
            (pt2 = L2[Fe](De)).value instanceof T ? Promise.resolve(pt2.value.v).then(pe, _e) : fe2(K5[0][2], pt2);
          } catch (je) {
            fe2(K5[0][3], je);
          }
          var pt2;
        }
        function pe(Fe) {
          we2("next", Fe);
        }
        function _e(Fe) {
          we2("throw", Fe);
        }
        function fe2(Fe, De) {
          Fe(De), K5.shift(), K5.length && we2(K5[0][0], K5[0][1]);
        }
      };
      function P5(R5) {
        if (R5 == null)
          throw new Error("Assertion Failure: value must not be null nor undefined");
      }
      function te2(R5) {
        return R5[Symbol.asyncIterator] != null ? R5 : function(x2) {
          return j2(this, arguments, function() {
            var F2, q2, L2, K5;
            return ye(this, function($) {
              switch ($.label) {
                case 0:
                  F2 = x2.getReader(), $.label = 1;
                case 1:
                  $.trys.push([1, , 9, 10]), $.label = 2;
                case 2:
                  return [4, T(F2.read())];
                case 3:
                  return q2 = $.sent(), L2 = q2.done, K5 = q2.value, L2 ? [4, T(void 0)] : [3, 5];
                case 4:
                  return [2, $.sent()];
                case 5:
                  return P5(K5), [4, T(K5)];
                case 6:
                  return [4, $.sent()];
                case 7:
                  return $.sent(), [3, 2];
                case 8:
                  return [3, 10];
                case 9:
                  return F2.releaseLock(), [7];
                case 10:
                  return [2];
              }
            });
          });
        }(R5);
      }
      var oe2 = function(R5, x2, F2, q2) {
        return new (F2 || (F2 = Promise))(function(L2, K5) {
          function $(_e) {
            try {
              pe(q2.next(_e));
            } catch (fe2) {
              K5(fe2);
            }
          }
          function we2(_e) {
            try {
              pe(q2.throw(_e));
            } catch (fe2) {
              K5(fe2);
            }
          }
          function pe(_e) {
            var fe2;
            _e.done ? L2(_e.value) : (fe2 = _e.value, fe2 instanceof F2 ? fe2 : new F2(function(Fe) {
              Fe(fe2);
            })).then($, we2);
          }
          pe((q2 = q2.apply(R5, x2 || [])).next());
        });
      }, re = function(R5, x2) {
        var F2, q2, L2, K5, $ = { label: 0, sent: function() {
          if (1 & L2[0])
            throw L2[1];
          return L2[1];
        }, trys: [], ops: [] };
        return K5 = { next: we2(0), throw: we2(1), return: we2(2) }, typeof Symbol == "function" && (K5[Symbol.iterator] = function() {
          return this;
        }), K5;
        function we2(pe) {
          return function(_e) {
            return function(fe2) {
              if (F2)
                throw new TypeError("Generator is already executing.");
              for (; $; )
                try {
                  if (F2 = 1, q2 && (L2 = 2 & fe2[0] ? q2.return : fe2[0] ? q2.throw || ((L2 = q2.return) && L2.call(q2), 0) : q2.next) && !(L2 = L2.call(q2, fe2[1])).done)
                    return L2;
                  switch (q2 = 0, L2 && (fe2 = [2 & fe2[0], L2.value]), fe2[0]) {
                    case 0:
                    case 1:
                      L2 = fe2;
                      break;
                    case 4:
                      return $.label++, { value: fe2[1], done: false };
                    case 5:
                      $.label++, q2 = fe2[1], fe2 = [0];
                      continue;
                    case 7:
                      fe2 = $.ops.pop(), $.trys.pop();
                      continue;
                    default:
                      if (L2 = $.trys, !((L2 = L2.length > 0 && L2[L2.length - 1]) || fe2[0] !== 6 && fe2[0] !== 2)) {
                        $ = 0;
                        continue;
                      }
                      if (fe2[0] === 3 && (!L2 || fe2[1] > L2[0] && fe2[1] < L2[3])) {
                        $.label = fe2[1];
                        break;
                      }
                      if (fe2[0] === 6 && $.label < L2[1]) {
                        $.label = L2[1], L2 = fe2;
                        break;
                      }
                      if (L2 && $.label < L2[2]) {
                        $.label = L2[2], $.ops.push(fe2);
                        break;
                      }
                      L2[2] && $.ops.pop(), $.trys.pop();
                      continue;
                  }
                  fe2 = x2.call(R5, $);
                } catch (Fe) {
                  fe2 = [6, Fe], q2 = 0;
                } finally {
                  F2 = L2 = 0;
                }
              if (5 & fe2[0])
                throw fe2[1];
              return { value: fe2[0] ? fe2[1] : void 0, done: true };
            }([pe, _e]);
          };
        }
      };
      function ae(R5, x2) {
        return x2 === void 0 && (x2 = Se), oe2(this, void 0, void 0, function() {
          var F2;
          return re(this, function(q2) {
            return F2 = te2(R5), [2, new Me2(x2.extensionCodec, x2.context, x2.maxStrLength, x2.maxBinLength, x2.maxArrayLength, x2.maxMapLength, x2.maxExtLength).decodeAsync(F2)];
          });
        });
      }
      function ie(R5, x2) {
        x2 === void 0 && (x2 = Se);
        var F2 = te2(R5);
        return new Me2(x2.extensionCodec, x2.context, x2.maxStrLength, x2.maxBinLength, x2.maxArrayLength, x2.maxMapLength, x2.maxExtLength).decodeArrayStream(F2);
      }
      function X2(R5, x2) {
        x2 === void 0 && (x2 = Se);
        var F2 = te2(R5);
        return new Me2(x2.extensionCodec, x2.context, x2.maxStrLength, x2.maxBinLength, x2.maxArrayLength, x2.maxMapLength, x2.maxExtLength).decodeStream(F2);
      }
    }]);
  });
});
var F3 = k((xn, T3) => {
  U();
  var I3 = typeof self < "u" ? self : xn, mh = function() {
    function t() {
      this.fetch = false, this.DOMException = I3.DOMException;
    }
    return t.prototype = I3, new t();
  }();
  (function(t) {
    (function(r3) {
      var i = { searchParams: "URLSearchParams" in t, iterable: "Symbol" in t && "iterator" in Symbol, blob: "FileReader" in t && "Blob" in t && function() {
        try {
          return new Blob(), true;
        } catch {
          return false;
        }
      }(), formData: "FormData" in t, arrayBuffer: "ArrayBuffer" in t };
      function n(E2) {
        return E2 && DataView.prototype.isPrototypeOf(E2);
      }
      if (i.arrayBuffer)
        var s = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], o = ArrayBuffer.isView || function(E2) {
          return E2 && s.indexOf(Object.prototype.toString.call(E2)) > -1;
        };
      function f2(E2) {
        if (typeof E2 != "string" && (E2 = String(E2)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(E2))
          throw new TypeError("Invalid character in header field name");
        return E2.toLowerCase();
      }
      function l(E2) {
        return typeof E2 != "string" && (E2 = String(E2)), E2;
      }
      function g5(E2) {
        var c = { next: function() {
          var m2 = E2.shift();
          return { done: m2 === void 0, value: m2 };
        } };
        return i.iterable && (c[Symbol.iterator] = function() {
          return c;
        }), c;
      }
      function _(E2) {
        this.map = {}, E2 instanceof _ ? E2.forEach(function(c, m2) {
          this.append(m2, c);
        }, this) : Array.isArray(E2) ? E2.forEach(function(c) {
          this.append(c[0], c[1]);
        }, this) : E2 && Object.getOwnPropertyNames(E2).forEach(function(c) {
          this.append(c, E2[c]);
        }, this);
      }
      _.prototype.append = function(E2, c) {
        E2 = f2(E2), c = l(c);
        var m2 = this.map[E2];
        this.map[E2] = m2 ? m2 + ", " + c : c;
      }, _.prototype.delete = function(E2) {
        delete this.map[f2(E2)];
      }, _.prototype.get = function(E2) {
        return E2 = f2(E2), this.has(E2) ? this.map[E2] : null;
      }, _.prototype.has = function(E2) {
        return this.map.hasOwnProperty(f2(E2));
      }, _.prototype.set = function(E2, c) {
        this.map[f2(E2)] = l(c);
      }, _.prototype.forEach = function(E2, c) {
        for (var m2 in this.map)
          this.map.hasOwnProperty(m2) && E2.call(c, this.map[m2], m2, this);
      }, _.prototype.keys = function() {
        var E2 = [];
        return this.forEach(function(c, m2) {
          E2.push(m2);
        }), g5(E2);
      }, _.prototype.values = function() {
        var E2 = [];
        return this.forEach(function(c) {
          E2.push(c);
        }), g5(E2);
      }, _.prototype.entries = function() {
        var E2 = [];
        return this.forEach(function(c, m2) {
          E2.push([m2, c]);
        }), g5(E2);
      }, i.iterable && (_.prototype[Symbol.iterator] = _.prototype.entries);
      function N2(E2) {
        if (E2.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        E2.bodyUsed = true;
      }
      function U2(E2) {
        return new Promise(function(c, m2) {
          E2.onload = function() {
            c(E2.result);
          }, E2.onerror = function() {
            m2(E2.error);
          };
        });
      }
      function V(E2) {
        var c = new FileReader(), m2 = U2(c);
        return c.readAsArrayBuffer(E2), m2;
      }
      function G(E2) {
        var c = new FileReader(), m2 = U2(c);
        return c.readAsText(E2), m2;
      }
      function ee2(E2) {
        for (var c = new Uint8Array(E2), m2 = new Array(c.length), h2 = 0; h2 < c.length; h2++)
          m2[h2] = String.fromCharCode(c[h2]);
        return m2.join("");
      }
      function W5(E2) {
        if (E2.slice)
          return E2.slice(0);
        var c = new Uint8Array(E2.byteLength);
        return c.set(new Uint8Array(E2)), c.buffer;
      }
      function Z() {
        return this.bodyUsed = false, this._initBody = function(E2) {
          this._bodyInit = E2, E2 ? typeof E2 == "string" ? this._bodyText = E2 : i.blob && Blob.prototype.isPrototypeOf(E2) ? this._bodyBlob = E2 : i.formData && FormData.prototype.isPrototypeOf(E2) ? this._bodyFormData = E2 : i.searchParams && URLSearchParams.prototype.isPrototypeOf(E2) ? this._bodyText = E2.toString() : i.arrayBuffer && i.blob && n(E2) ? (this._bodyArrayBuffer = W5(E2.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : i.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(E2) || o(E2)) ? this._bodyArrayBuffer = W5(E2) : this._bodyText = E2 = Object.prototype.toString.call(E2) : this._bodyText = "", this.headers.get("content-type") || (typeof E2 == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : i.searchParams && URLSearchParams.prototype.isPrototypeOf(E2) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, i.blob && (this.blob = function() {
          var E2 = N2(this);
          if (E2)
            return E2;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? N2(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(V);
        }), this.text = function() {
          var E2 = N2(this);
          if (E2)
            return E2;
          if (this._bodyBlob)
            return G(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(ee2(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, i.formData && (this.formData = function() {
          return this.text().then(me);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var le = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function be2(E2) {
        var c = E2.toUpperCase();
        return le.indexOf(c) > -1 ? c : E2;
      }
      function Ae(E2, c) {
        c = c || {};
        var m2 = c.body;
        if (E2 instanceof Ae) {
          if (E2.bodyUsed)
            throw new TypeError("Already read");
          this.url = E2.url, this.credentials = E2.credentials, c.headers || (this.headers = new _(E2.headers)), this.method = E2.method, this.mode = E2.mode, this.signal = E2.signal, !m2 && E2._bodyInit != null && (m2 = E2._bodyInit, E2.bodyUsed = true);
        } else
          this.url = String(E2);
        if (this.credentials = c.credentials || this.credentials || "same-origin", (c.headers || !this.headers) && (this.headers = new _(c.headers)), this.method = be2(c.method || this.method || "GET"), this.mode = c.mode || this.mode || null, this.signal = c.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && m2)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(m2);
      }
      Ae.prototype.clone = function() {
        return new Ae(this, { body: this._bodyInit });
      };
      function me(E2) {
        var c = new FormData();
        return E2.trim().split("&").forEach(function(m2) {
          if (m2) {
            var h2 = m2.split("="), a = h2.shift().replace(/\+/g, " "), u3 = h2.join("=").replace(/\+/g, " ");
            c.append(decodeURIComponent(a), decodeURIComponent(u3));
          }
        }), c;
      }
      function H5(E2) {
        var c = new _(), m2 = E2.replace(/\r?\n[\t ]+/g, " ");
        return m2.split(/\r?\n/).forEach(function(h2) {
          var a = h2.split(":"), u3 = a.shift().trim();
          if (u3) {
            var b2 = a.join(":").trim();
            c.append(u3, b2);
          }
        }), c;
      }
      Z.call(Ae.prototype);
      function ue(E2, c) {
        c || (c = {}), this.type = "default", this.status = c.status === void 0 ? 200 : c.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in c ? c.statusText : "OK", this.headers = new _(c.headers), this.url = c.url || "", this._initBody(E2);
      }
      Z.call(ue.prototype), ue.prototype.clone = function() {
        return new ue(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new _(this.headers), url: this.url });
      }, ue.error = function() {
        var E2 = new ue(null, { status: 0, statusText: "" });
        return E2.type = "error", E2;
      };
      var se2 = [301, 302, 303, 307, 308];
      ue.redirect = function(E2, c) {
        if (se2.indexOf(c) === -1)
          throw new RangeError("Invalid status code");
        return new ue(null, { status: c, headers: { location: E2 } });
      }, r3.DOMException = t.DOMException;
      try {
        new r3.DOMException();
      } catch {
        r3.DOMException = function(c, m2) {
          this.message = c, this.name = m2;
          var h2 = Error(c);
          this.stack = h2.stack;
        }, r3.DOMException.prototype = Object.create(Error.prototype), r3.DOMException.prototype.constructor = r3.DOMException;
      }
      function ne2(E2, c) {
        return new Promise(function(m2, h2) {
          var a = new Ae(E2, c);
          if (a.signal && a.signal.aborted)
            return h2(new r3.DOMException("Aborted", "AbortError"));
          var u3 = new XMLHttpRequest();
          function b2() {
            u3.abort();
          }
          u3.onload = function() {
            var A2 = { status: u3.status, statusText: u3.statusText, headers: H5(u3.getAllResponseHeaders() || "") };
            A2.url = "responseURL" in u3 ? u3.responseURL : A2.headers.get("X-Request-URL");
            var v2 = "response" in u3 ? u3.response : u3.responseText;
            m2(new ue(v2, A2));
          }, u3.onerror = function() {
            h2(new TypeError("Network request failed"));
          }, u3.ontimeout = function() {
            h2(new TypeError("Network request failed"));
          }, u3.onabort = function() {
            h2(new r3.DOMException("Aborted", "AbortError"));
          }, u3.open(a.method, a.url, true), a.credentials === "include" ? u3.withCredentials = true : a.credentials === "omit" && (u3.withCredentials = false), "responseType" in u3 && i.blob && (u3.responseType = "blob"), a.headers.forEach(function(A2, v2) {
            u3.setRequestHeader(v2, A2);
          }), a.signal && (a.signal.addEventListener("abort", b2), u3.onreadystatechange = function() {
            u3.readyState === 4 && a.signal.removeEventListener("abort", b2);
          }), u3.send(typeof a._bodyInit > "u" ? null : a._bodyInit);
        });
      }
      return ne2.polyfill = true, t.fetch || (t.fetch = ne2, t.Headers = _, t.Request = Ae, t.Response = ue), r3.Headers = _, r3.Request = Ae, r3.Response = ue, r3.fetch = ne2, Object.defineProperty(r3, "__esModule", { value: true }), r3;
    })({});
  })(mh);
  mh.fetch.ponyfill = true;
  delete mh.fetch.polyfill;
  var ua = mh;
  xn = ua.fetch;
  xn.default = ua.fetch;
  xn.fetch = ua.fetch;
  xn.Headers = ua.Headers;
  xn.Request = ua.Request;
  xn.Response = ua.Response;
  T3.exports = xn;
});
U();
var Ur = rr(or(), 1);
U();
var Sg = {};
ct$1(Sg, { ABIAddressType: () => ts, ABIArrayDynamicType: () => ff, ABIArrayStaticType: () => af, ABIBoolType: () => ki, ABIByteType: () => sf, ABIContract: () => _g, ABIInterface: () => Ag, ABIMethod: () => Ji, ABIReferenceType: () => Zi, ABIStringType: () => of, ABITransactionType: () => Di, ABITupleType: () => $r, ABIType: () => hr, ABIUfixedType: () => nf, ABIUintType: () => Yi, ADDR_BYTE_SIZE: () => b4, ALGORAND_MIN_TX_FEE: () => tg, Algodv2: () => ro, AtomicTransactionComposer: () => Xi, AtomicTransactionComposerStatus: () => Br, DryrunResult: () => mg, ERROR_INVALID_MICROALGOS: () => ZF, ERROR_MULTISIG_BAD_SENDER: () => YF, INVALID_MICROALGOS_ERROR_MSG: () => gc, Indexer: () => po, IntDecoding: () => Gn, Kmd: () => su, LENGTH_ENCODE_BYTE_SIZE: () => Nr, LogicSig: () => Ri, LogicSigAccount: () => Vi, MAX_LEN: () => yo, MULTISIG_BAD_SENDER_ERROR_MSG: () => _4, OnApplicationComplete: () => lr, SINGLE_BOOL_SIZE: () => x4, SINGLE_BYTE_SIZE: () => v4, SourceMap: () => Ih, Transaction: () => zt, TransactionType: () => Pt, abiCheckTransactionType: () => wg, abiTypeIsReference: () => Wu, abiTypeIsTransaction: () => cf, algosToMicroalgos: () => S3, appendSignMultisigTransaction: () => J3, appendSignRawMultisigSignature: () => X3, assignGroupID: () => Eh, bigIntToBytes: () => Sn, bytesToBigInt: () => zu, computeGroupID: () => cg, createDryrun: () => MF, createMultisigTransaction: () => ug, decodeAddress: () => ct, decodeObj: () => Cr, decodeSignedTransaction: () => vn, decodeUint64: () => g3, decodeUnsignedTransaction: () => $s, encodeAddress: () => Ue, encodeObj: () => VF, encodeUint64: () => Ks, encodeUnsignedTransaction: () => rF, generateAccount: () => Hu, getApplicationAddress: () => Gs, getMethodByName: () => Vu, indexerModels: () => og, instantiateTxnIfNeeded: () => ci, isTransactionWithSigner: () => Ch, isValidAddress: () => aa, logicSigFromByte: () => r4, makeApplicationCallTxnFromObject: () => xg, makeApplicationClearStateTxn: () => m4, makeApplicationClearStateTxnFromObject: () => CF, makeApplicationCloseOutTxn: () => g4, makeApplicationCloseOutTxnFromObject: () => vg, makeApplicationCreateTxn: () => Gu, makeApplicationCreateTxnFromObject: () => yg, makeApplicationDeleteTxn: () => Nh, makeApplicationDeleteTxnFromObject: () => BF, makeApplicationNoOpTxn: () => y4, makeApplicationNoOpTxnFromObject: () => Bh, makeApplicationOptInTxn: () => p4, makeApplicationOptInTxnFromObject: () => bg, makeApplicationUpdateTxn: () => Dh, makeApplicationUpdateTxnFromObject: () => NF, makeAssetConfigTxnWithSuggestedParams: () => d4, makeAssetConfigTxnWithSuggestedParamsFromObject: () => RF, makeAssetCreateTxnWithSuggestedParams: () => Rh, makeAssetCreateTxnWithSuggestedParamsFromObject: () => FF, makeAssetDestroyTxnWithSuggestedParams: () => kh, makeAssetDestroyTxnWithSuggestedParamsFromObject: () => kF, makeAssetFreezeTxnWithSuggestedParams: () => l4, makeAssetFreezeTxnWithSuggestedParamsFromObject: () => DF, makeAssetTransferTxnWithSuggestedParams: () => h4, makeAssetTransferTxnWithSuggestedParamsFromObject: () => Ku, makeBasicAccountTransactionSigner: () => OF, makeKeyRegistrationTxnWithSuggestedParams: () => u4, makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => TF, makeLogicSigAccountTransactionSigner: () => jF, makeMultiSigAccountTransactionSigner: () => LF, makePaymentTxnWithSuggestedParams: () => c4, makePaymentTxnWithSuggestedParamsFromObject: () => Fh, masterDerivationKeyToMnemonic: () => $3, mergeMultisigTransactions: () => Qa, microalgosToAlgos: () => gh, mnemonicFromSeed: () => wh, mnemonicToMasterDerivationKey: () => G3, mnemonicToSecretKey: () => go, modelsv2: () => sg, multisigAddress: () => Q3, secretKeyToMnemonic: () => Ah, seedFromMnemonic: () => _h, signBid: () => GF, signBytes: () => $F, signLogicSigTransaction: () => t4, signLogicSigTransactionObject: () => mo, signMultisigTransaction: () => Sh, signTransaction: () => KF, tealSign: () => dg, tealSignFromProgram: () => s4, verifyBytes: () => WF, verifyMultisig: () => Mh, verifyTealSign: () => n4, waitForConfirmation: () => vh });
U();
var Oh = rr(or());
U();
var Ti = rr(X6()), e3 = rr(Q6());
function Rr(t) {
  return e3.default.sha512_256.array(t);
}
function BT(t) {
  return Ti.default.randomBytes(t);
}
function $1(t) {
  return Ti.default.sign.keyPair.fromSeed(t);
}
function t3() {
  let t = BT(Ti.default.box.secretKeyLength);
  return $1(t);
}
function sh(t) {
  return t === Ti.default.sign.signatureLength;
}
function mn(t) {
  return Ti.default.sign.keyPair.fromSecretKey(t);
}
function yn(t, e) {
  return Ti.default.sign.detached(t, e);
}
function oh(t, e) {
  return Ti.default.verify(t, e);
}
function zs(t, e, r3) {
  return Ti.default.sign.detached.verify(t, e, r3);
}
var uc = Ti.default.sign.publicKeyLength;
Ti.default.sign.secretKeyLength;
var W1 = 32, ah = 32;
U();
var y3 = rr(or()), J1 = rr(V1());
U();
var l3 = rr(d3());
U();
var Z1;
(function(t) {
  t.DEFAULT = "default", t.SAFE = "safe", t.MIXED = "mixed", t.BIGINT = "bigint";
})(Z1 || (Z1 = {}));
var Gn = Z1;
var LT = (0, l3.default)({ useNativeBigInt: true, strict: true });
function h3(t, e) {
  let r3 = e && e.intDecoding ? e.intDecoding : Gn.DEFAULT;
  return LT.parse(t, (i, n) => {
    if (n != null && typeof n == "object" && Object.getPrototypeOf(n) == null && Object.setPrototypeOf(n, Object.prototype), typeof n == "bigint") {
      if (r3 === "safe" && n > Number.MAX_SAFE_INTEGER)
        throw new Error(`Integer exceeds maximum safe integer: ${n.toString()}. Try parsing with a different intDecoding option.`);
      return r3 === "bigint" || r3 === "mixed" && n > Number.MAX_SAFE_INTEGER ? n : Number(n);
    }
    return typeof n == "number" && r3 === "bigint" && Number.isInteger(n) ? BigInt(n) : n;
  });
}
function Hs(t, e) {
  return t.length !== e.length ? false : Array.from(t).every((r3, i) => r3 === e[i]);
}
function $t(...t) {
  let e = t.reduce((n, s) => n + s.length, 0), r3 = new Uint8Array(e), i = 0;
  for (let n = 0; n < t.length; n++)
    r3.set(t[n], i), i += t[n].length;
  return r3;
}
function p3(t) {
  let e = { ...t };
  return Object.keys(e).forEach((r3) => {
    typeof e[r3] > "u" && delete e[r3];
  }), e;
}
U();
function Ks(t) {
  if (!(typeof t == "bigint" || Number.isInteger(t)) || t < 0 || t > BigInt("0xffffffffffffffff"))
    throw new Error("Input is not a 64-bit unsigned integer");
  let r3 = new Uint8Array(8);
  return new DataView(r3.buffer).setBigUint64(0, BigInt(t)), r3;
}
function g3(t, e = "safe") {
  if (e !== "safe" && e !== "mixed" && e !== "bigint")
    throw new Error(`Unknown decodingMode option: ${e}`);
  if (t.byteLength === 0 || t.byteLength > 8)
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${t.byteLength}`);
  let r3 = new Uint8Array(8 - t.byteLength), i = $t(r3, t), s = new DataView(i.buffer).getBigUint64(0), o = s > BigInt(Number.MAX_SAFE_INTEGER);
  if (e === "safe") {
    if (o)
      throw new Error(`Integer exceeds maximum safe integer: ${s.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    return Number(s);
  }
  return e === "mixed" && !o ? Number(s) : s;
}
var lh = 36, hh = 4, b3 = 58, v3 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ", dc = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]), qT = y3.Buffer.from("appID"), m3 = "address seems to be malformed", PT = "wrong checksum for address", UT = "invalid multisig version", zT = "bad multisig threshold", HT = "bad multisig public key - wrong length", KT = "nacl public key length is not 32 bytes";
function ct(t) {
  if (typeof t != "string" || t.length !== b3)
    throw new Error(m3);
  let e = J1.default.decode.asBytes(t.toString());
  if (e.length !== lh)
    throw new Error(m3);
  let r3 = new Uint8Array(e.slice(0, lh - hh)), i = new Uint8Array(e.slice(uc, lh)), n = Rr(r3).slice(W1 - hh, W1);
  if (!Hs(n, i))
    throw new Error(PT);
  return { publicKey: r3, checksum: i };
}
function aa(t) {
  try {
    ct(t);
  } catch {
    return false;
  }
  return true;
}
function Ue(t) {
  let e = Rr(t).slice(uc - hh, uc);
  return J1.default.encode($t(t, e)).toString().slice(0, b3);
}
function $i({ version: t, threshold: e, pks: r3 }) {
  if (t !== 1 || t > 255 || t < 0)
    throw new Error(UT);
  if (e === 0 || r3.length === 0 || e > r3.length || e > 255)
    throw new Error(zT);
  let i = lh - hh;
  if (i !== uc)
    throw new Error(KT);
  let n = new Uint8Array(dc.length + 2 + i * r3.length);
  n.set(dc, 0), n.set([t], dc.length), n.set([e], dc.length + 1);
  for (let s = 0; s < r3.length; s++) {
    if (r3[s].length !== i)
      throw new Error(HT);
    n.set(r3[s], dc.length + 2 + s * i);
  }
  return new Uint8Array(Rr(n));
}
function X1({ version: t, threshold: e, addrs: r3 }) {
  let i = r3.map((n) => ct(n).publicKey);
  return Ue($i({ version: t, threshold: e, pks: i }));
}
function Gs(t) {
  let e = $t(qT, Ks(t)), r3 = Rr(e);
  return Ue(new Uint8Array(r3));
}
U();
var ph = rr(x3()), GT = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function $T(t) {
  for (let e in t)
    if (Object.prototype.hasOwnProperty.call(t, e) && (!t[e] || t[e].length === 0))
      return { containsEmpty: true, firstEmptyKey: e };
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function nr(t) {
  let e = $T(t);
  if (e.containsEmpty)
    throw new Error(GT + e.firstEmptyKey);
  return ph.encode(t, { sortKeys: true });
}
function sr(t) {
  return ph.decode(t);
}
U();
var Ze = rr(or()), M3 = rr(V1());
U();
function WT(t, e, r3) {
  let i = t.appIndex, n = t.name, s = i === 0 || i === r3, o = 0;
  if (e != null && (o = e.indexOf(i) + 1), o === 0 && !s)
    throw new Error(`Box ref with appId ${i} not in foreign-apps`);
  return { i: o, n };
}
function w3(t, e, r3) {
  return t == null ? [] : t.map((i) => WT(i, e, r3));
}
U();
var Pt;
(function(t) {
  t.pay = "pay", t.keyreg = "keyreg", t.acfg = "acfg", t.axfer = "axfer", t.afrz = "afrz", t.appl = "appl", t.stpf = "stpf";
})(Pt || (Pt = {}));
function _3(t) {
  return t === Pt.pay || t === Pt.keyreg || t === Pt.acfg || t === Pt.axfer || t === Pt.afrz || t === Pt.appl || t === Pt.stpf;
}
var lr;
(function(t) {
  t[t.NoOpOC = 0] = "NoOpOC", t[t.OptInOC = 1] = "OptInOC", t[t.CloseOutOC = 2] = "CloseOutOC", t[t.ClearStateOC = 3] = "ClearStateOC", t[t.UpdateApplicationOC = 4] = "UpdateApplicationOC", t[t.DeleteApplicationOC = 5] = "DeleteApplicationOC";
})(lr || (lr = {}));
var VT = 52, tg = 1e3, hc = 32, A3 = 19, YT = 75, ZT = 5, JT = 32, XT = 5, E3 = 32, QT = 32, eF = 32, tF = 64;
function eg(t, e, r3) {
  if (t == null)
    return;
  let i;
  if (typeof t == "string" ? i = Ze.Buffer.from(t, "base64") : t.constructor === Uint8Array ? i = Ze.Buffer.from(t) : Ze.Buffer.isBuffer(t) && (i = t), i == null || i.byteLength !== r3)
    throw Error(`${e} must be a ${r3} byte Uint8Array or Buffer or base64 string.`);
  return i;
}
var zt = class {
  constructor({ ...e }) {
    this.name = "Transaction", this.tag = Ze.Buffer.from("TX");
    let r3 = { type: Pt.pay, flatFee: false, nonParticipation: false };
    if (typeof e.type > "u" && (e.type = r3.type), typeof e.flatFee > "u" && (e.flatFee = r3.flatFee), e.type === Pt.keyreg && typeof e.voteKey < "u" && typeof e.nonParticipation > "u" && (e.nonParticipation = r3.nonParticipation), e.suggestedParams !== void 0) {
      let n = e;
      n.genesisHash = n.suggestedParams.genesisHash, n.fee = n.suggestedParams.fee, n.suggestedParams.flatFee !== void 0 && (n.flatFee = n.suggestedParams.flatFee), n.firstRound = n.suggestedParams.firstRound, n.lastRound = n.suggestedParams.lastRound, n.genesisID = n.suggestedParams.genesisID;
    }
    let i = e;
    if (i.from = ct(i.from), i.to !== void 0 && (i.to = ct(i.to)), i.closeRemainderTo !== void 0 && (i.closeRemainderTo = ct(i.closeRemainderTo)), i.assetManager !== void 0 && (i.assetManager = ct(i.assetManager)), i.assetReserve !== void 0 && (i.assetReserve = ct(i.assetReserve)), i.assetFreeze !== void 0 && (i.assetFreeze = ct(i.assetFreeze)), i.assetClawback !== void 0 && (i.assetClawback = ct(i.assetClawback)), i.assetRevocationTarget !== void 0 && (i.assetRevocationTarget = ct(i.assetRevocationTarget)), i.freezeAccount !== void 0 && (i.freezeAccount = ct(i.freezeAccount)), i.reKeyTo !== void 0 && (i.reKeyTo = ct(i.reKeyTo)), i.genesisHash === void 0)
      throw Error("genesis hash must be specified and in a base64 string.");
    if (i.genesisHash = Ze.Buffer.from(i.genesisHash, "base64"), i.amount !== void 0 && (!(Number.isSafeInteger(i.amount) || typeof i.amount == "bigint" && i.amount <= BigInt("0xffffffffffffffff")) || i.amount < 0))
      throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (!Number.isSafeInteger(i.fee) || i.fee < 0)
      throw Error("fee must be a positive number and smaller than 2^53-1");
    if (!Number.isSafeInteger(i.firstRound) || i.firstRound < 0)
      throw Error("firstRound must be a positive number");
    if (!Number.isSafeInteger(i.lastRound) || i.lastRound < 0)
      throw Error("lastRound must be a positive number");
    if (i.extraPages !== void 0 && (!Number.isInteger(i.extraPages) || i.extraPages < 0 || i.extraPages > 3))
      throw Error("extraPages must be an Integer between and including 0 to 3");
    if (i.assetTotal !== void 0 && (!(Number.isSafeInteger(i.assetTotal) || typeof i.assetTotal == "bigint" && i.assetTotal <= BigInt("0xffffffffffffffff")) || i.assetTotal < 0))
      throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (i.assetDecimals !== void 0 && (!Number.isSafeInteger(i.assetDecimals) || i.assetDecimals < 0 || i.assetDecimals > A3))
      throw Error(`assetDecimals must be a positive number and smaller than ${A3.toString()}`);
    if (i.assetIndex !== void 0 && (!Number.isSafeInteger(i.assetIndex) || i.assetIndex < 0))
      throw Error("Asset index must be a positive number and smaller than 2^53-1");
    if (i.appIndex !== void 0 && (!Number.isSafeInteger(i.appIndex) || i.appIndex < 0))
      throw Error("Application index must be a positive number and smaller than 2^53-1");
    if (i.appLocalInts !== void 0 && (!Number.isSafeInteger(i.appLocalInts) || i.appLocalInts < 0))
      throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
    if (i.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(i.appLocalByteSlices) || i.appLocalByteSlices < 0))
      throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
    if (i.appGlobalInts !== void 0 && (!Number.isSafeInteger(i.appGlobalInts) || i.appGlobalInts < 0))
      throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
    if (i.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(i.appGlobalByteSlices) || i.appGlobalByteSlices < 0))
      throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
    if (i.appApprovalProgram !== void 0 && i.appApprovalProgram.constructor !== Uint8Array)
      throw Error("appApprovalProgram must be a Uint8Array.");
    if (i.appClearProgram !== void 0 && i.appClearProgram.constructor !== Uint8Array)
      throw Error("appClearProgram must be a Uint8Array.");
    if (i.appArgs !== void 0) {
      if (!Array.isArray(i.appArgs))
        throw Error("appArgs must be an Array of Uint8Array.");
      i.appArgs = i.appArgs.slice(), i.appArgs.forEach((n) => {
        if (n.constructor !== Uint8Array)
          throw Error("each element of AppArgs must be a Uint8Array.");
      });
    } else
      i.appArgs = [];
    if (i.appAccounts !== void 0) {
      if (!Array.isArray(i.appAccounts))
        throw Error("appAccounts must be an Array of addresses.");
      i.appAccounts = i.appAccounts.map((n) => ct(n));
    }
    if (i.appForeignApps !== void 0) {
      if (!Array.isArray(i.appForeignApps))
        throw Error("appForeignApps must be an Array of integers.");
      i.appForeignApps = i.appForeignApps.slice(), i.appForeignApps.forEach((n) => {
        if (!Number.isSafeInteger(n) || n < 0)
          throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
      });
    }
    if (i.appForeignAssets !== void 0) {
      if (!Array.isArray(i.appForeignAssets))
        throw Error("appForeignAssets must be an Array of integers.");
      i.appForeignAssets = i.appForeignAssets.slice(), i.appForeignAssets.forEach((n) => {
        if (!Number.isSafeInteger(n) || n < 0)
          throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
      });
    }
    if (i.boxes !== void 0) {
      if (!Array.isArray(i.boxes))
        throw Error("boxes must be an Array of BoxReference.");
      i.boxes = i.boxes.slice(), i.boxes.forEach((n) => {
        if (!Number.isSafeInteger(n.appIndex) || n.name.constructor !== Uint8Array)
          throw Error("box app index must be a number and name must be an Uint8Array.");
      });
    }
    if (i.assetMetadataHash !== void 0 && i.assetMetadataHash.length !== 0) {
      if (typeof i.assetMetadataHash == "string" && (i.assetMetadataHash = new Uint8Array(Ze.Buffer.from(i.assetMetadataHash))), i.assetMetadataHash.constructor !== Uint8Array || i.assetMetadataHash.byteLength !== E3)
        throw Error(`assetMetadataHash must be a ${E3} byte Uint8Array or string.`);
      i.assetMetadataHash.every((n) => n === 0) && (i.assetMetadataHash = void 0);
    } else
      i.assetMetadataHash = void 0;
    if (i.note !== void 0) {
      if (i.note.constructor !== Uint8Array)
        throw Error("note must be a Uint8Array.");
    } else
      i.note = new Uint8Array(0);
    if (i.lease !== void 0) {
      if (i.lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (i.lease.length !== hc)
        throw Error(`lease must be of length ${hc.toString()}.`);
      i.lease.every((n) => n === 0) && (i.lease = new Uint8Array(0));
    } else
      i.lease = new Uint8Array(0);
    if (i.voteKey = eg(i.voteKey, "voteKey", QT), i.selectionKey = eg(i.selectionKey, "selectionKey", eF), i.stateProofKey = eg(i.stateProofKey, "stateProofKey", tF), i.nonParticipation && (i.voteKey || i.selectionKey || i.voteFirst || i.stateProofKey || i.voteLast || i.voteKeyDilution))
      throw new Error("nonParticipation is true but participation params are present.");
    if (!i.nonParticipation && (i.voteKey || i.selectionKey || i.stateProofKey || i.voteFirst || i.voteLast || i.voteKeyDilution) && !(i.voteKey && i.selectionKey && i.voteFirst && i.voteLast && i.voteKeyDilution))
      throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
    if (delete i.suggestedParams, Object.assign(this, p3(i)), i.flatFee || (this.fee *= this.estimateSize(), this.fee < tg && (this.fee = tg)), this.group = void 0, i.stateProofType !== void 0 && (!Number.isSafeInteger(i.stateProofType) || i.stateProofType < 0))
      throw Error("State Proof type must be a positive number and smaller than 2^53-1");
    if (i.stateProofMessage !== void 0) {
      if (i.stateProofMessage.constructor !== Uint8Array)
        throw Error("stateProofMessage must be a Uint8Array.");
    } else
      i.stateProofMessage = new Uint8Array(0);
    if (i.stateProof !== void 0) {
      if (i.stateProof.constructor !== Uint8Array)
        throw Error("stateProof must be a Uint8Array.");
    } else
      i.stateProof = new Uint8Array(0);
  }
  get_obj_for_encoding() {
    if (this.type === "pay") {
      let e = { amt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: "pay", gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group };
      return this.closeRemainderTo !== void 0 && Ue(this.closeRemainderTo.publicKey) !== v3 && (e.close = Ze.Buffer.from(this.closeRemainderTo.publicKey)), this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), this.to !== void 0 && (e.rcv = Ze.Buffer.from(this.to.publicKey)), e.note.length || delete e.note, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, e.lx.length || delete e.lx, e.rekey || delete e.rekey, e;
    }
    if (this.type === "keyreg") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, votekey: this.voteKey, selkey: this.selectionKey, sprfkey: this.stateProofKey, votefst: this.voteFirst, votelst: this.voteLast, votekd: this.voteKeyDilution };
      return e.note.length || delete e.note, e.lx.length || delete e.lx, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), this.nonParticipation && (e.nonpart = true), e.selkey || delete e.selkey, e.votekey || delete e.votekey, e.sprfkey || delete e.sprfkey, e.votefst || delete e.votefst, e.votelst || delete e.votelst, e.votekd || delete e.votekd, e;
    }
    if (this.type === "acfg") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, caid: this.assetIndex, apar: { t: this.assetTotal, df: this.assetDefaultFrozen, dc: this.assetDecimals } };
      return this.assetManager !== void 0 && (e.apar.m = Ze.Buffer.from(this.assetManager.publicKey)), this.assetReserve !== void 0 && (e.apar.r = Ze.Buffer.from(this.assetReserve.publicKey)), this.assetFreeze !== void 0 && (e.apar.f = Ze.Buffer.from(this.assetFreeze.publicKey)), this.assetClawback !== void 0 && (e.apar.c = Ze.Buffer.from(this.assetClawback.publicKey)), this.assetName !== void 0 && (e.apar.an = this.assetName), this.assetUnitName !== void 0 && (e.apar.un = this.assetUnitName), this.assetURL !== void 0 && (e.apar.au = this.assetURL), this.assetMetadataHash !== void 0 && (e.apar.am = Ze.Buffer.from(this.assetMetadataHash)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), e.caid || delete e.caid, !e.apar.t && !e.apar.un && !e.apar.an && !e.apar.df && !e.apar.m && !e.apar.r && !e.apar.f && !e.apar.c && !e.apar.au && !e.apar.am && !e.apar.dc ? delete e.apar : (e.apar.t || delete e.apar.t, e.apar.dc || delete e.apar.dc, e.apar.un || delete e.apar.un, e.apar.an || delete e.apar.an, e.apar.df || delete e.apar.df, e.apar.m || delete e.apar.m, e.apar.r || delete e.apar.r, e.apar.f || delete e.apar.f, e.apar.c || delete e.apar.c, e.apar.au || delete e.apar.au, e.apar.am || delete e.apar.am), e.grp === void 0 && delete e.grp, e;
    }
    if (this.type === "axfer") {
      let e = { aamt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), arcv: Ze.Buffer.from(this.to.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, xaid: this.assetIndex };
      return this.closeRemainderTo !== void 0 && (e.aclose = Ze.Buffer.from(this.closeRemainderTo.publicKey)), this.assetRevocationTarget !== void 0 && (e.asnd = Ze.Buffer.from(this.assetRevocationTarget.publicKey)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.aamt || delete e.aamt, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, e.aclose || delete e.aclose, e.asnd || delete e.asnd, e.rekey || delete e.rekey, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), e;
    }
    if (this.type === "afrz") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, faid: this.assetIndex, afrz: this.freezeState };
      return this.freezeAccount !== void 0 && (e.fadd = Ze.Buffer.from(this.freezeAccount.publicKey)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.afrz || delete e.afrz, e.grp === void 0 && delete e.grp, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), e;
    }
    if (this.type === "appl") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, apid: this.appIndex, apan: this.appOnComplete, apls: { nui: this.appLocalInts, nbs: this.appLocalByteSlices }, apgs: { nui: this.appGlobalInts, nbs: this.appGlobalByteSlices }, apfa: this.appForeignApps, apas: this.appForeignAssets, apep: this.extraPages, apbx: w3(this.boxes, this.appForeignApps, this.appIndex) };
      this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), this.appApprovalProgram !== void 0 && (e.apap = Ze.Buffer.from(this.appApprovalProgram)), this.appClearProgram !== void 0 && (e.apsu = Ze.Buffer.from(this.appClearProgram)), this.appArgs !== void 0 && (e.apaa = this.appArgs.map((r3) => Ze.Buffer.from(r3))), this.appAccounts !== void 0 && (e.apat = this.appAccounts.map((r3) => Ze.Buffer.from(r3.publicKey))), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.apid || delete e.apid, e.apls.nui || delete e.apls.nui, e.apls.nbs || delete e.apls.nbs, !e.apls.nui && !e.apls.nbs && delete e.apls, e.apgs.nui || delete e.apgs.nui, e.apgs.nbs || delete e.apgs.nbs, (!e.apaa || !e.apaa.length) && delete e.apaa, !e.apgs.nui && !e.apgs.nbs && delete e.apgs, e.apap || delete e.apap, e.apsu || delete e.apsu, e.apan || delete e.apan, (!e.apfa || !e.apfa.length) && delete e.apfa, (!e.apas || !e.apas.length) && delete e.apas;
      for (let r3 of e.apbx)
        r3.i || delete r3.i, (!r3.n || !r3.n.length) && delete r3.n;
      return (!e.apbx || !e.apbx.length) && delete e.apbx, (!e.apat || !e.apat.length) && delete e.apat, e.apep || delete e.apep, e.grp === void 0 && delete e.grp, e;
    }
    if (this.type === "stpf") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), sptype: this.stateProofType, spmsg: Ze.Buffer.from(this.stateProofMessage), sp: Ze.Buffer.from(this.stateProof) };
      return e.sptype || delete e.sptype, e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.apid || delete e.apid, (!e.apaa || !e.apaa.length) && delete e.apaa, e.apap || delete e.apap, e.apsu || delete e.apsu, e.apan || delete e.apan, (!e.apfa || !e.apfa.length) && delete e.apfa, (!e.apas || !e.apas.length) && delete e.apas, (!e.apat || !e.apat.length) && delete e.apat, e.apep || delete e.apep, e.grp === void 0 && delete e.grp, e;
    }
  }
  static from_obj_for_encoding(e) {
    let r3 = Object.create(this.prototype);
    if (r3.name = "Transaction", r3.tag = Ze.Buffer.from("TX"), r3.genesisID = e.gen, r3.genesisHash = Ze.Buffer.from(e.gh), !_3(e.type))
      throw new Error(`Unrecognized transaction type: ${e.type}`);
    return r3.type = e.type, r3.fee = e.fee, r3.firstRound = e.fv, r3.lastRound = e.lv, r3.note = new Uint8Array(e.note), r3.lease = new Uint8Array(e.lx), r3.from = ct(Ue(new Uint8Array(e.snd))), e.grp !== void 0 && (r3.group = Ze.Buffer.from(e.grp)), e.rekey !== void 0 && (r3.reKeyTo = ct(Ue(new Uint8Array(e.rekey)))), e.type === "pay" ? (r3.amount = e.amt, r3.to = ct(Ue(new Uint8Array(e.rcv))), e.close !== void 0 && (r3.closeRemainderTo = ct(Ue(e.close)))) : e.type === "keyreg" ? (e.votekey !== void 0 && (r3.voteKey = Ze.Buffer.from(e.votekey)), e.selkey !== void 0 && (r3.selectionKey = Ze.Buffer.from(e.selkey)), e.sprfkey !== void 0 && (r3.stateProofKey = Ze.Buffer.from(e.sprfkey)), e.votekd !== void 0 && (r3.voteKeyDilution = e.votekd), e.votefst !== void 0 && (r3.voteFirst = e.votefst), e.votelst !== void 0 && (r3.voteLast = e.votelst), e.nonpart !== void 0 && (r3.nonParticipation = e.nonpart)) : e.type === "acfg" ? (e.caid !== void 0 && (r3.assetIndex = e.caid), e.apar !== void 0 && (r3.assetTotal = e.apar.t, r3.assetDefaultFrozen = e.apar.df, e.apar.dc !== void 0 && (r3.assetDecimals = e.apar.dc), e.apar.m !== void 0 && (r3.assetManager = ct(Ue(new Uint8Array(e.apar.m)))), e.apar.r !== void 0 && (r3.assetReserve = ct(Ue(new Uint8Array(e.apar.r)))), e.apar.f !== void 0 && (r3.assetFreeze = ct(Ue(new Uint8Array(e.apar.f)))), e.apar.c !== void 0 && (r3.assetClawback = ct(Ue(new Uint8Array(e.apar.c)))), e.apar.un !== void 0 && (r3.assetUnitName = e.apar.un), e.apar.an !== void 0 && (r3.assetName = e.apar.an), e.apar.au !== void 0 && (r3.assetURL = e.apar.au), e.apar.am !== void 0 && (r3.assetMetadataHash = e.apar.am))) : e.type === "axfer" ? (e.xaid !== void 0 && (r3.assetIndex = e.xaid), e.aamt !== void 0 && (r3.amount = e.aamt), e.aclose !== void 0 && (r3.closeRemainderTo = ct(Ue(new Uint8Array(e.aclose)))), e.asnd !== void 0 && (r3.assetRevocationTarget = ct(Ue(new Uint8Array(e.asnd)))), r3.to = ct(Ue(new Uint8Array(e.arcv)))) : e.type === "afrz" ? (e.afrz !== void 0 && (r3.freezeState = e.afrz), e.faid !== void 0 && (r3.assetIndex = e.faid), r3.freezeAccount = ct(Ue(new Uint8Array(e.fadd)))) : e.type === "appl" ? (e.apid !== void 0 && (r3.appIndex = e.apid), e.apan !== void 0 && (r3.appOnComplete = e.apan), e.apls !== void 0 && (e.apls.nui !== void 0 && (r3.appLocalInts = e.apls.nui), e.apls.nbs !== void 0 && (r3.appLocalByteSlices = e.apls.nbs)), e.apgs !== void 0 && (e.apgs.nui !== void 0 && (r3.appGlobalInts = e.apgs.nui), e.apgs.nbs !== void 0 && (r3.appGlobalByteSlices = e.apgs.nbs)), e.apep !== void 0 && (r3.extraPages = e.apep), e.apap !== void 0 && (r3.appApprovalProgram = new Uint8Array(e.apap)), e.apsu !== void 0 && (r3.appClearProgram = new Uint8Array(e.apsu)), e.apaa !== void 0 && (r3.appArgs = e.apaa.map((i) => new Uint8Array(i))), e.apat !== void 0 && (r3.appAccounts = e.apat.map((i) => ct(Ue(new Uint8Array(i))))), e.apfa !== void 0 && (r3.appForeignApps = e.apfa), e.apas !== void 0 && (r3.appForeignAssets = e.apas), e.apbx !== void 0 && (r3.boxes = e.apbx.map((i) => ({ appIndex: i.i ? r3.appForeignApps[i.i - 1] : 0, name: i.n })))) : e.type === "stpf" && (e.sptype !== void 0 && (r3.stateProofType = e.sptype), e.sp !== void 0 && (r3.stateProof = e.sp), e.spmsg !== void 0 && (r3.stateProofMessage = e.spmsg)), r3;
  }
  estimateSize() {
    return this.toByte().length + YT;
  }
  bytesToSign() {
    let e = this.toByte();
    return Ze.Buffer.from($t(this.tag, e));
  }
  toByte() {
    return nr(this.get_obj_for_encoding());
  }
  rawSignTxn(e) {
    let r3 = this.bytesToSign(), i = yn(r3, e);
    return Ze.Buffer.from(i);
  }
  signTxn(e) {
    let r3 = { sig: this.rawSignTxn(e), txn: this.get_obj_for_encoding() }, n = mn(e).publicKey;
    return Ue(n) !== Ue(this.from.publicKey) && (r3.sgnr = Ze.Buffer.from(n)), new Uint8Array(nr(r3));
  }
  attachSignature(e, r3) {
    if (!sh(r3.length))
      throw new Error("Invalid signature length");
    let i = { sig: Ze.Buffer.from(r3), txn: this.get_obj_for_encoding() };
    if (e !== Ue(this.from.publicKey)) {
      let n = ct(e).publicKey;
      i.sgnr = Ze.Buffer.from(n);
    }
    return new Uint8Array(nr(i));
  }
  rawTxID() {
    let e = this.toByte(), r3 = Ze.Buffer.from($t(this.tag, e));
    return Ze.Buffer.from(Rr(r3));
  }
  txID() {
    let e = this.rawTxID();
    return M3.default.encode(e).slice(0, VT);
  }
  addLease(e, r3 = 0) {
    let i;
    if (e !== void 0) {
      if (e.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (e.length !== hc)
        throw Error(`lease must be of length ${hc.toString()}.`);
      i = new Uint8Array(e);
    } else
      i = new Uint8Array(0);
    this.lease = i, r3 !== 0 && (this.fee += (ZT + hc) * r3);
  }
  addRekey(e, r3 = 0) {
    e !== void 0 && (this.reKeyTo = ct(e)), r3 !== 0 && (this.fee += (XT + JT) * r3);
  }
  _getDictForDisplay() {
    let e = { ...this };
    return e.tag = e.tag.toString(), e.from = Ue(e.from.publicKey), e.to !== void 0 && (e.to = Ue(e.to.publicKey)), e.freezeAccount !== void 0 && (e.freezeAccount = Ue(e.freezeAccount.publicKey)), e.closeRemainderTo !== void 0 && (e.closeRemainderTo = Ue(e.closeRemainderTo.publicKey)), e.assetManager !== void 0 && (e.assetManager = Ue(e.assetManager.publicKey)), e.assetReserve !== void 0 && (e.assetReserve = Ue(e.assetReserve.publicKey)), e.assetFreeze !== void 0 && (e.assetFreeze = Ue(e.assetFreeze.publicKey)), e.assetClawback !== void 0 && (e.assetClawback = Ue(e.assetClawback.publicKey)), e.assetRevocationTarget !== void 0 && (e.assetRevocationTarget = Ue(e.assetRevocationTarget.publicKey)), e.reKeyTo !== void 0 && (e.reKeyTo = Ue(e.reKeyTo.publicKey)), e.genesisHash = e.genesisHash.toString("base64"), e;
  }
  prettyPrint() {
    console.log(this._getDictForDisplay());
  }
  toString() {
    return JSON.stringify(this._getDictForDisplay());
  }
};
function rF(t) {
  let e = t.get_obj_for_encoding();
  return nr(e);
}
function $s(t) {
  let e = sr(t);
  return zt.from_obj_for_encoding(e);
}
function vn(t) {
  let e = sr(t);
  return { ...e, txn: zt.from_obj_for_encoding(e.txn) };
}
function ci(t) {
  return t instanceof zt ? t : new zt(t);
}
U();
var ca = rr(or());
var pc = class {
  constructor({ bidderKey: e, bidAmount: r3, bidID: i, auctionKey: n, auctionID: s, maxPrice: o }) {
    this.name = "Bid", this.tag = ca.Buffer.from([97, 66]);
    let f2 = ct(e), l = ct(n);
    if (!Number.isSafeInteger(r3) || r3 < 0)
      throw Error("Bid amount must be positive and 2^53-1");
    if (!Number.isSafeInteger(i) || i < 0)
      throw Error("BidID must be positive and 2^53-1");
    if (!Number.isSafeInteger(s) || s < 0)
      throw Error("auctionID must be positive");
    Object.assign(this, { bidderKey: f2, bidAmount: r3, bidID: i, auctionKey: l, auctionID: s, maxPrice: o });
  }
  get_obj_for_encoding() {
    return { bidder: ca.Buffer.from(this.bidderKey.publicKey), cur: this.bidAmount, price: this.maxPrice, id: this.bidID, auc: ca.Buffer.from(this.auctionKey.publicKey), aid: this.auctionID };
  }
  signBid(e) {
    let r3 = nr(this.get_obj_for_encoding()), i = ca.Buffer.from($t(this.tag, r3)), n = yn(i, e), s = { sig: ca.Buffer.from(n), bid: this.get_obj_for_encoding() }, o = { t: "b", b: s };
    return new Uint8Array(nr(o));
  }
};
U();
var gc = "Microalgos should be positive and less than 2^53 - 1.";
function gh(t) {
  if (t < 0 || !Number.isSafeInteger(t))
    throw new Error(gc);
  return t / 1e6;
}
function S3(t) {
  let e = t * 1e6;
  return Math.round(e);
}
U();
U();
U();
var bh = rr(or());
U();
var R3 = rr(or()), yh = rr(F3()), rg = class extends Error {
  constructor(e, r3) {
    super(e), this.response = r3, this.name = "URLTokenBaseHTTPError", this.response = r3;
  }
}, Wi = class {
  constructor(e, r3, i, n = {}) {
    this.defaultHeaders = n;
    let s = r3.endsWith("/") ? r3 : `${r3}/`, o = new URL(s);
    if (typeof i < "u" && (o.port = i.toString()), o.protocol.length === 0)
      throw new Error("Invalid base server URL, protocol must be defined.");
    this.baseURL = o, this.tokenHeader = e;
  }
  getURL(e, r3) {
    let i;
    e.startsWith("./") ? i = e : e.startsWith("/") ? i = `.${e}` : i = `./${e}`;
    let n = new URL(i, this.baseURL);
    if (r3)
      for (let [s, o] of Object.entries(r3))
        n.searchParams.set(s, o);
    return n.toString();
  }
  static formatFetchResponseHeaders(e) {
    let r3 = {};
    return e.forEach((i, n) => {
      r3[i] = n;
    }), r3;
  }
  static async checkHttpError(e) {
    if (e.ok)
      return;
    let r3 = null, i = null;
    try {
      r3 = new Uint8Array(await e.arrayBuffer());
      let s = JSON.parse(R3.Buffer.from(r3).toString());
      s.message && (i = s.message);
    } catch {
    }
    let n = `Network request error. Received status ${e.status} (${e.statusText})`;
    throw i && (n += `: ${i}`), new rg(n, { body: r3, status: e.status, headers: Wi.formatFetchResponseHeaders(e.headers) });
  }
  static async formatFetchResponse(e) {
    return await this.checkHttpError(e), { body: new Uint8Array(await e.arrayBuffer()), status: e.status, headers: Wi.formatFetchResponseHeaders(e.headers) };
  }
  async get(e, r3, i = {}) {
    let n = { ...this.tokenHeader, ...this.defaultHeaders, ...i }, s = await (0, yh.fetch)(this.getURL(e, r3), { mode: "cors", headers: n });
    return Wi.formatFetchResponse(s);
  }
  async post(e, r3, i, n = {}) {
    let s = { ...this.tokenHeader, ...this.defaultHeaders, ...n }, o = await (0, yh.fetch)(this.getURL(e, i), { method: "POST", mode: "cors", body: r3, headers: s });
    return Wi.formatFetchResponse(o);
  }
  async delete(e, r3, i, n = {}) {
    let s = { ...this.tokenHeader, ...this.defaultHeaders, ...n }, o = await (0, yh.fetch)(this.getURL(e, i), { method: "DELETE", mode: "cors", body: r3, headers: s });
    return Wi.formatFetchResponse(o);
  }
};
function nF(t) {
  for (let e in t)
    Object.prototype.hasOwnProperty.call(t, e) && (!t[e] || t[e].length === 0) && delete t[e];
  return t;
}
function k3(t) {
  return Object.keys(t).reduce((e, r3) => (e[r3.toLowerCase()] = t[r3], e), {});
}
function sF(t) {
  if (t !== void 0 && Object.prototype.hasOwnProperty.call(t, "format"))
    switch (t.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  else
    return "application/json";
}
var kr = class {
  constructor(e, r3, i, n = {}) {
    r3 !== void 0 ? this.bc = new Wi(e, r3, i, n) : this.bc = e;
  }
  static parseJSON(e, r3, i = {}) {
    try {
      return Object.keys(i).length === 0 ? e && JSON.parse(e) : e && h3(e, i);
    } catch (n) {
      let s = n;
      throw s.rawResponse = e || null, s.statusCode = r3, s;
    }
  }
  static serializeData(e, r3) {
    if (!e)
      return new Uint8Array(0);
    if (r3["content-type"] === "application/json")
      return new Uint8Array(bh.Buffer.from(JSON.stringify(e)));
    if (typeof e == "string")
      return new Uint8Array(bh.Buffer.from(e));
    if (e instanceof Uint8Array)
      return e;
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  static prepareResponse(e, r3, i, n = {}) {
    let { body: s } = e, o;
    return r3 !== "application/msgpack" && (o = s && bh.Buffer.from(s).toString() || ""), i && r3 === "application/json" && (s = kr.parseJSON(o, e.status, n)), { ...e, body: s, text: o, ok: Math.trunc(e.status / 100) === 2 };
  }
  static prepareResponseError(e) {
    return e.response && (e.response = kr.prepareResponse(e.response, "application/json", true), e.status = e.response.status), e;
  }
  async get(e, r3, i = {}, n = {}, s = true) {
    let o = sF(r3), f2 = { ...i, accept: o };
    try {
      let l = await this.bc.get(e, nF(r3), f2);
      return kr.prepareResponse(l, o, s, n);
    } catch (l) {
      throw kr.prepareResponseError(l);
    }
  }
  async post(e, r3, i = {}, n, s = true) {
    let o = { "content-type": "application/json", ...k3(i) };
    try {
      let f2 = await this.bc.post(e, kr.serializeData(r3, o), n, o);
      return kr.prepareResponse(f2, "application/json", s);
    } catch (f2) {
      throw kr.prepareResponseError(f2);
    }
  }
  async delete(e, r3, i = {}, n = true) {
    let s = { "content-type": "application/json", ...k3(i) }, o = await this.bc.delete(e, kr.serializeData(r3, s), void 0, s);
    return kr.prepareResponse(o, "application/json", n);
  }
};
function oF(t = "", e) {
  let r3 = {};
  return r3[e] = t, r3;
}
function aF(t) {
  return typeof t.get == "function";
}
var wn = class {
  constructor(e, r3, i, n, s = {}) {
    if (aF(r3))
      this.c = new kr(r3);
    else {
      let o;
      typeof r3 == "string" ? o = oF(r3, e) : o = r3, this.c = new kr(o, i, n, s);
    }
    this.intDecoding = Gn.DEFAULT;
  }
  setIntEncoding(e) {
    this.intDecoding = e;
  }
  getIntEncoding() {
    return this.intDecoding;
  }
};
U();
U();
var Ce = class {
  constructor(e, r3) {
    this.c = e, this.query = {}, this.intDecoding = r3 || Gn.DEFAULT;
  }
  prepare(e) {
    return e;
  }
  async do(e = {}) {
    let r3 = {};
    this.intDecoding !== "default" && (r3.intDecoding = this.intDecoding);
    let i = await this.c.get(this.path(), this.query, e, r3);
    return this.prepare(i.body);
  }
  async doRaw(e = {}) {
    return (await this.c.get(this.path(), this.query, e, {}, false)).body;
  }
  setIntDecoding(e) {
    if (e !== "default" && e !== "safe" && e !== "mixed" && e !== "bigint")
      throw new Error(`Invalid method for int decoding: ${e}`);
    return this.intDecoding = e, this;
  }
};
var mc = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
U();
var yc = class extends Ce {
  constructor(e, r3, i, n) {
    super(e, r3), this.account = i, this.assetID = n, this.account = i, this.assetID = n;
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
};
U();
var bc = class extends Ce {
  constructor(e, r3, i, n) {
    super(e, r3), this.account = i, this.applicationID = n, this.account = i, this.applicationID = n;
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
};
U();
var vc = class extends Ce {
  constructor(e, r3) {
    if (super(e), !Number.isInteger(r3))
      throw Error("roundNumber should be an integer");
    this.round = r3, this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return sr(e);
  }
};
U();
var D3 = rr(or());
function ig(t = {}) {
  let e = t;
  return Object.keys(e).every((r3) => r3.toLowerCase() !== "content-type") && (e = { ...t }, e["Content-Type"] = "text/plain"), e;
}
var xc = class extends Ce {
  constructor(e, r3) {
    super(e), this.source = r3, this.source = r3;
  }
  path() {
    return "/v2/teal/compile";
  }
  sourcemap(e = true) {
    return this.query.sourcemap = e, this;
  }
  async do(e = {}) {
    let r3 = ig(e);
    return (await this.c.post(this.path(), D3.Buffer.from(this.source), r3, this.query)).body;
  }
};
U();
var N3 = rr(or());
var wc = class extends Ce {
  constructor(e, r3) {
    super(e), this.blob = nr(r3.get_obj_for_encoding(true));
  }
  path() {
    return "/v2/teal/dryrun";
  }
  async do(e = {}) {
    let r3 = ig(e);
    return (await this.c.post(this.path(), N3.Buffer.from(this.blob), r3)).body;
  }
};
U();
var _c = class extends Ce {
  path() {
    return "/genesis";
  }
};
U();
var Ac = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
};
U();
var Ec = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
};
U();
var Mc = class extends Ce {
  constructor(e, r3, i) {
    if (super(e, r3), !Number.isInteger(i))
      throw Error("roundNumber should be an integer");
    this.round = i;
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
};
U();
var C3 = rr(or());
var sg = {};
ct$1(sg, { Account: () => da, AccountApplicationResponse: () => Sc, AccountAssetResponse: () => Ic, AccountParticipation: () => la, AccountStateDelta: () => Ws, Application: () => _n, ApplicationLocalState: () => Vs, ApplicationParams: () => An, ApplicationStateSchema: () => ui, Asset: () => ha, AssetHolding: () => Ys, AssetParams: () => Zs, BlockHashResponse: () => Tc, BlockResponse: () => Fc, Box: () => Js, BoxDescriptor: () => pa, BoxesResponse: () => Xs, BuildVersion: () => ga, CompileResponse: () => Rc, DisassembleResponse: () => kc, DryrunRequest: () => Qs, DryrunResponse: () => Dc, DryrunSource: () => ma, DryrunState: () => eo, DryrunTxnResult: () => ya, ErrorResponse: () => Nc, EvalDelta: () => ba, EvalDeltaKeyValue: () => Vn, LightBlockHeaderProof: () => Bc, NodeStatusResponse: () => Cc, PendingTransactionResponse: () => va, PendingTransactionsResponse: () => Oc, PostTransactionsResponse: () => jc, StateProof: () => Lc, StateProofMessage: () => xa, SupplyResponse: () => qc, TealKeyValue: () => to, TealValue: () => Yn, TransactionParametersResponse: () => Pc, TransactionProofResponse: () => Uc, Version: () => zc });
U();
var ar = rr(or());
U();
var B3 = rr(or());
function fF(t) {
  return t === void 0 || t == null || typeof t != "object" && typeof t != "function";
}
function ng(t, e) {
  let r3;
  if (t instanceof Uint8Array)
    r3 = e ? t : B3.Buffer.from(t).toString("base64");
  else if (typeof t.get_obj_for_encoding == "function")
    r3 = t.get_obj_for_encoding(e);
  else if (Array.isArray(t)) {
    r3 = [];
    for (let i of t)
      r3.push(ng(i, e));
  } else if (typeof t == "object") {
    let i = {};
    for (let n of Object.keys(t))
      i[n] = ng(t[n], e);
    r3 = i;
  } else if (fF(t))
    r3 = t;
  else
    throw new Error(`Unsupported value: ${String(t)}`);
  return r3;
}
var Re = class {
  get_obj_for_encoding(e = false) {
    let r3 = {};
    for (let i of Object.keys(this.attribute_map)) {
      let n = this.attribute_map[i], s = this[i];
      typeof s < "u" && (r3[n] = s === null ? null : ng(s, e));
    }
    return r3;
  }
};
var da = class extends Re {
  constructor({ address: e, amount: r3, amountWithoutPendingRewards: i, minBalance: n, pendingRewards: s, rewards: o, round: f2, status: l, totalAppsOptedIn: g5, totalAssetsOptedIn: _, totalCreatedApps: N2, totalCreatedAssets: U2, appsLocalState: V, appsTotalExtraPages: G, appsTotalSchema: ee2, assets: W5, authAddr: Z, createdApps: le, createdAssets: be2, participation: Ae, rewardBase: me, sigType: H5, totalBoxBytes: ue, totalBoxes: se2 }) {
    super(), this.address = e, this.amount = r3, this.amountWithoutPendingRewards = i, this.minBalance = n, this.pendingRewards = s, this.rewards = o, this.round = f2, this.status = l, this.totalAppsOptedIn = g5, this.totalAssetsOptedIn = _, this.totalCreatedApps = N2, this.totalCreatedAssets = U2, this.appsLocalState = V, this.appsTotalExtraPages = G, this.appsTotalSchema = ee2, this.assets = W5, this.authAddr = Z, this.createdApps = le, this.createdAssets = be2, this.participation = Ae, this.rewardBase = me, this.sigType = H5, this.totalBoxBytes = ue, this.totalBoxes = se2, this.attribute_map = { address: "address", amount: "amount", amountWithoutPendingRewards: "amount-without-pending-rewards", minBalance: "min-balance", pendingRewards: "pending-rewards", rewards: "rewards", round: "round", status: "status", totalAppsOptedIn: "total-apps-opted-in", totalAssetsOptedIn: "total-assets-opted-in", totalCreatedApps: "total-created-apps", totalCreatedAssets: "total-created-assets", appsLocalState: "apps-local-state", appsTotalExtraPages: "apps-total-extra-pages", appsTotalSchema: "apps-total-schema", assets: "assets", authAddr: "auth-addr", createdApps: "created-apps", createdAssets: "created-assets", participation: "participation", rewardBase: "reward-base", sigType: "sig-type", totalBoxBytes: "total-box-bytes", totalBoxes: "total-boxes" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["amount-without-pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${e}`);
    if (typeof e["min-balance"] > "u")
      throw new Error(`Response is missing required field 'min-balance': ${e}`);
    if (typeof e["pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'pending-rewards': ${e}`);
    if (typeof e.rewards > "u")
      throw new Error(`Response is missing required field 'rewards': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.status > "u")
      throw new Error(`Response is missing required field 'status': ${e}`);
    if (typeof e["total-apps-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${e}`);
    if (typeof e["total-assets-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${e}`);
    if (typeof e["total-created-apps"] > "u")
      throw new Error(`Response is missing required field 'total-created-apps': ${e}`);
    if (typeof e["total-created-assets"] > "u")
      throw new Error(`Response is missing required field 'total-created-assets': ${e}`);
    return new da({ address: e.address, amount: e.amount, amountWithoutPendingRewards: e["amount-without-pending-rewards"], minBalance: e["min-balance"], pendingRewards: e["pending-rewards"], rewards: e.rewards, round: e.round, status: e.status, totalAppsOptedIn: e["total-apps-opted-in"], totalAssetsOptedIn: e["total-assets-opted-in"], totalCreatedApps: e["total-created-apps"], totalCreatedAssets: e["total-created-assets"], appsLocalState: typeof e["apps-local-state"] < "u" ? e["apps-local-state"].map(Vs.from_obj_for_encoding) : void 0, appsTotalExtraPages: e["apps-total-extra-pages"], appsTotalSchema: typeof e["apps-total-schema"] < "u" ? ui.from_obj_for_encoding(e["apps-total-schema"]) : void 0, assets: typeof e.assets < "u" ? e.assets.map(Ys.from_obj_for_encoding) : void 0, authAddr: e["auth-addr"], createdApps: typeof e["created-apps"] < "u" ? e["created-apps"].map(_n.from_obj_for_encoding) : void 0, createdAssets: typeof e["created-assets"] < "u" ? e["created-assets"].map(ha.from_obj_for_encoding) : void 0, participation: typeof e.participation < "u" ? la.from_obj_for_encoding(e.participation) : void 0, rewardBase: e["reward-base"], sigType: e["sig-type"], totalBoxBytes: e["total-box-bytes"], totalBoxes: e["total-boxes"] });
  }
}, Sc = class extends Re {
  constructor({ round: e, appLocalState: r3, createdApp: i }) {
    super(), this.round = e, this.appLocalState = r3, this.createdApp = i, this.attribute_map = { round: "round", appLocalState: "app-local-state", createdApp: "created-app" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new Sc({ round: e.round, appLocalState: typeof e["app-local-state"] < "u" ? Vs.from_obj_for_encoding(e["app-local-state"]) : void 0, createdApp: typeof e["created-app"] < "u" ? An.from_obj_for_encoding(e["created-app"]) : void 0 });
  }
}, Ic = class extends Re {
  constructor({ round: e, assetHolding: r3, createdAsset: i }) {
    super(), this.round = e, this.assetHolding = r3, this.createdAsset = i, this.attribute_map = { round: "round", assetHolding: "asset-holding", createdAsset: "created-asset" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new Ic({ round: e.round, assetHolding: typeof e["asset-holding"] < "u" ? Ys.from_obj_for_encoding(e["asset-holding"]) : void 0, createdAsset: typeof e["created-asset"] < "u" ? Zs.from_obj_for_encoding(e["created-asset"]) : void 0 });
  }
}, la = class extends Re {
  constructor({ selectionParticipationKey: e, voteFirstValid: r3, voteKeyDilution: i, voteLastValid: n, voteParticipationKey: s, stateProofKey: o }) {
    super(), this.selectionParticipationKey = typeof e == "string" ? new Uint8Array(ar.Buffer.from(e, "base64")) : e, this.voteFirstValid = r3, this.voteKeyDilution = i, this.voteLastValid = n, this.voteParticipationKey = typeof s == "string" ? new Uint8Array(ar.Buffer.from(s, "base64")) : s, this.stateProofKey = typeof o == "string" ? new Uint8Array(ar.Buffer.from(o, "base64")) : o, this.attribute_map = { selectionParticipationKey: "selection-participation-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key", stateProofKey: "state-proof-key" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["selection-participation-key"] > "u")
      throw new Error(`Response is missing required field 'selection-participation-key': ${e}`);
    if (typeof e["vote-first-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-first-valid': ${e}`);
    if (typeof e["vote-key-dilution"] > "u")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${e}`);
    if (typeof e["vote-last-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-last-valid': ${e}`);
    if (typeof e["vote-participation-key"] > "u")
      throw new Error(`Response is missing required field 'vote-participation-key': ${e}`);
    return new la({ selectionParticipationKey: e["selection-participation-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"], stateProofKey: e["state-proof-key"] });
  }
}, Ws = class extends Re {
  constructor({ address: e, delta: r3 }) {
    super(), this.address = e, this.delta = r3, this.attribute_map = { address: "address", delta: "delta" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (!Array.isArray(e.delta))
      throw new Error(`Response is missing required array field 'delta': ${e}`);
    return new Ws({ address: e.address, delta: e.delta.map(Vn.from_obj_for_encoding) });
  }
}, _n = class extends Re {
  constructor({ id: e, params: r3 }) {
    super(), this.id = e, this.params = r3, this.attribute_map = { id: "id", params: "params" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new _n({ id: e.id, params: An.from_obj_for_encoding(e.params) });
  }
}, Vs = class extends Re {
  constructor({ id: e, schema: r3, keyValue: i }) {
    super(), this.id = e, this.schema = r3, this.keyValue = i, this.attribute_map = { id: "id", schema: "schema", keyValue: "key-value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.schema > "u")
      throw new Error(`Response is missing required field 'schema': ${e}`);
    return new Vs({ id: e.id, schema: ui.from_obj_for_encoding(e.schema), keyValue: typeof e["key-value"] < "u" ? e["key-value"].map(to.from_obj_for_encoding) : void 0 });
  }
}, An = class extends Re {
  constructor({ approvalProgram: e, clearStateProgram: r3, creator: i, extraProgramPages: n, globalState: s, globalStateSchema: o, localStateSchema: f2 }) {
    super(), this.approvalProgram = typeof e == "string" ? new Uint8Array(ar.Buffer.from(e, "base64")) : e, this.clearStateProgram = typeof r3 == "string" ? new Uint8Array(ar.Buffer.from(r3, "base64")) : r3, this.creator = i, this.extraProgramPages = n, this.globalState = s, this.globalStateSchema = o, this.localStateSchema = f2, this.attribute_map = { approvalProgram: "approval-program", clearStateProgram: "clear-state-program", creator: "creator", extraProgramPages: "extra-program-pages", globalState: "global-state", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["approval-program"] > "u")
      throw new Error(`Response is missing required field 'approval-program': ${e}`);
    if (typeof e["clear-state-program"] > "u")
      throw new Error(`Response is missing required field 'clear-state-program': ${e}`);
    if (typeof e.creator > "u")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    return new An({ approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], creator: e.creator, extraProgramPages: e["extra-program-pages"], globalState: typeof e["global-state"] < "u" ? e["global-state"].map(to.from_obj_for_encoding) : void 0, globalStateSchema: typeof e["global-state-schema"] < "u" ? ui.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] < "u" ? ui.from_obj_for_encoding(e["local-state-schema"]) : void 0 });
  }
}, ui = class extends Re {
  constructor({ numUint: e, numByteSlice: r3 }) {
    super(), this.numUint = e, this.numByteSlice = r3, this.attribute_map = { numUint: "num-uint", numByteSlice: "num-byte-slice" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-uint"] > "u")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    if (typeof e["num-byte-slice"] > "u")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    return new ui({ numUint: e["num-uint"], numByteSlice: e["num-byte-slice"] });
  }
}, ha = class extends Re {
  constructor({ index: e, params: r3 }) {
    super(), this.index = e, this.params = r3, this.attribute_map = { index: "index", params: "params" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index > "u")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new ha({ index: e.index, params: Zs.from_obj_for_encoding(e.params) });
  }
}, Ys = class extends Re {
  constructor({ amount: e, assetId: r3, isFrozen: i }) {
    super(), this.amount = e, this.assetId = r3, this.isFrozen = i, this.attribute_map = { amount: "amount", assetId: "asset-id", isFrozen: "is-frozen" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["is-frozen"] > "u")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new Ys({ amount: e.amount, assetId: e["asset-id"], isFrozen: e["is-frozen"] });
  }
}, Zs = class extends Re {
  constructor({ creator: e, decimals: r3, total: i, clawback: n, defaultFrozen: s, freeze: o, manager: f2, metadataHash: l, name: g5, nameB64: _, reserve: N2, unitName: U2, unitNameB64: V, url: G, urlB64: ee2 }) {
    super(), this.creator = e, this.decimals = r3, this.total = i, this.clawback = n, this.defaultFrozen = s, this.freeze = o, this.manager = f2, this.metadataHash = typeof l == "string" ? new Uint8Array(ar.Buffer.from(l, "base64")) : l, this.name = g5, this.nameB64 = typeof _ == "string" ? new Uint8Array(ar.Buffer.from(_, "base64")) : _, this.reserve = N2, this.unitName = U2, this.unitNameB64 = typeof V == "string" ? new Uint8Array(ar.Buffer.from(V, "base64")) : V, this.url = G, this.urlB64 = typeof ee2 == "string" ? new Uint8Array(ar.Buffer.from(ee2, "base64")) : ee2, this.attribute_map = { creator: "creator", decimals: "decimals", total: "total", clawback: "clawback", defaultFrozen: "default-frozen", freeze: "freeze", manager: "manager", metadataHash: "metadata-hash", name: "name", nameB64: "name-b64", reserve: "reserve", unitName: "unit-name", unitNameB64: "unit-name-b64", url: "url", urlB64: "url-b64" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.creator > "u")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    if (typeof e.decimals > "u")
      throw new Error(`Response is missing required field 'decimals': ${e}`);
    if (typeof e.total > "u")
      throw new Error(`Response is missing required field 'total': ${e}`);
    return new Zs({ creator: e.creator, decimals: e.decimals, total: e.total, clawback: e.clawback, defaultFrozen: e["default-frozen"], freeze: e.freeze, manager: e.manager, metadataHash: e["metadata-hash"], name: e.name, nameB64: e["name-b64"], reserve: e.reserve, unitName: e["unit-name"], unitNameB64: e["unit-name-b64"], url: e.url, urlB64: e["url-b64"] });
  }
}, Tc = class extends Re {
  constructor({ blockhash: e }) {
    super(), this.blockhash = e, this.attribute_map = { blockhash: "blockHash" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.blockHash > "u")
      throw new Error(`Response is missing required field 'blockHash': ${e}`);
    return new Tc({ blockhash: e.blockHash });
  }
}, Fc = class extends Re {
  constructor({ block: e, cert: r3 }) {
    super(), this.block = e, this.cert = r3, this.attribute_map = { block: "block", cert: "cert" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.block > "u")
      throw new Error(`Response is missing required field 'block': ${e}`);
    return new Fc({ block: e.block, cert: e.cert });
  }
}, Js = class extends Re {
  constructor({ name: e, value: r3 }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(ar.Buffer.from(e, "base64")) : e, this.value = typeof r3 == "string" ? new Uint8Array(ar.Buffer.from(r3, "base64")) : r3, this.attribute_map = { name: "name", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new Js({ name: e.name, value: e.value });
  }
}, pa = class extends Re {
  constructor({ name: e }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(ar.Buffer.from(e, "base64")) : e, this.attribute_map = { name: "name" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    return new pa({ name: e.name });
  }
}, Xs = class extends Re {
  constructor({ boxes: e }) {
    super(), this.boxes = e, this.attribute_map = { boxes: "boxes" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.boxes))
      throw new Error(`Response is missing required array field 'boxes': ${e}`);
    return new Xs({ boxes: e.boxes.map(pa.from_obj_for_encoding) });
  }
}, ga = class extends Re {
  constructor({ branch: e, buildNumber: r3, channel: i, commitHash: n, major: s, minor: o }) {
    super(), this.branch = e, this.buildNumber = r3, this.channel = i, this.commitHash = n, this.major = s, this.minor = o, this.attribute_map = { branch: "branch", buildNumber: "build_number", channel: "channel", commitHash: "commit_hash", major: "major", minor: "minor" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.branch > "u")
      throw new Error(`Response is missing required field 'branch': ${e}`);
    if (typeof e.build_number > "u")
      throw new Error(`Response is missing required field 'build_number': ${e}`);
    if (typeof e.channel > "u")
      throw new Error(`Response is missing required field 'channel': ${e}`);
    if (typeof e.commit_hash > "u")
      throw new Error(`Response is missing required field 'commit_hash': ${e}`);
    if (typeof e.major > "u")
      throw new Error(`Response is missing required field 'major': ${e}`);
    if (typeof e.minor > "u")
      throw new Error(`Response is missing required field 'minor': ${e}`);
    return new ga({ branch: e.branch, buildNumber: e.build_number, channel: e.channel, commitHash: e.commit_hash, major: e.major, minor: e.minor });
  }
}, Rc = class extends Re {
  constructor({ hash: e, result: r3, sourcemap: i }) {
    super(), this.hash = e, this.result = r3, this.sourcemap = i, this.attribute_map = { hash: "hash", result: "result", sourcemap: "sourcemap" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.hash > "u")
      throw new Error(`Response is missing required field 'hash': ${e}`);
    if (typeof e.result > "u")
      throw new Error(`Response is missing required field 'result': ${e}`);
    return new Rc({ hash: e.hash, result: e.result, sourcemap: e.sourcemap });
  }
}, kc = class extends Re {
  constructor({ result: e }) {
    super(), this.result = e, this.attribute_map = { result: "result" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.result > "u")
      throw new Error(`Response is missing required field 'result': ${e}`);
    return new kc({ result: e.result });
  }
}, Qs = class extends Re {
  constructor({ accounts: e, apps: r3, latestTimestamp: i, protocolVersion: n, round: s, sources: o, txns: f2 }) {
    super(), this.accounts = e, this.apps = r3, this.latestTimestamp = i, this.protocolVersion = n, this.round = s, this.sources = o, this.txns = f2, this.attribute_map = { accounts: "accounts", apps: "apps", latestTimestamp: "latest-timestamp", protocolVersion: "protocol-version", round: "round", sources: "sources", txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.accounts))
      throw new Error(`Response is missing required array field 'accounts': ${e}`);
    if (!Array.isArray(e.apps))
      throw new Error(`Response is missing required array field 'apps': ${e}`);
    if (typeof e["latest-timestamp"] > "u")
      throw new Error(`Response is missing required field 'latest-timestamp': ${e}`);
    if (typeof e["protocol-version"] > "u")
      throw new Error(`Response is missing required field 'protocol-version': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (!Array.isArray(e.sources))
      throw new Error(`Response is missing required array field 'sources': ${e}`);
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new Qs({ accounts: e.accounts.map(da.from_obj_for_encoding), apps: e.apps.map(_n.from_obj_for_encoding), latestTimestamp: e["latest-timestamp"], protocolVersion: e["protocol-version"], round: e.round, sources: e.sources.map(ma.from_obj_for_encoding), txns: e.txns });
  }
}, Dc = class extends Re {
  constructor({ error: e, protocolVersion: r3, txns: i }) {
    super(), this.error = e, this.protocolVersion = r3, this.txns = i, this.attribute_map = { error: "error", protocolVersion: "protocol-version", txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.error > "u")
      throw new Error(`Response is missing required field 'error': ${e}`);
    if (typeof e["protocol-version"] > "u")
      throw new Error(`Response is missing required field 'protocol-version': ${e}`);
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new Dc({ error: e.error, protocolVersion: e["protocol-version"], txns: e.txns.map(ya.from_obj_for_encoding) });
  }
}, ma = class extends Re {
  constructor({ fieldName: e, source: r3, txnIndex: i, appIndex: n }) {
    super(), this.fieldName = e, this.source = r3, this.txnIndex = i, this.appIndex = n, this.attribute_map = { fieldName: "field-name", source: "source", txnIndex: "txn-index", appIndex: "app-index" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["field-name"] > "u")
      throw new Error(`Response is missing required field 'field-name': ${e}`);
    if (typeof e.source > "u")
      throw new Error(`Response is missing required field 'source': ${e}`);
    if (typeof e["txn-index"] > "u")
      throw new Error(`Response is missing required field 'txn-index': ${e}`);
    if (typeof e["app-index"] > "u")
      throw new Error(`Response is missing required field 'app-index': ${e}`);
    return new ma({ fieldName: e["field-name"], source: e.source, txnIndex: e["txn-index"], appIndex: e["app-index"] });
  }
}, eo = class extends Re {
  constructor({ line: e, pc: r3, stack: i, error: n, scratch: s }) {
    super(), this.line = e, this.pc = r3, this.stack = i, this.error = n, this.scratch = s, this.attribute_map = { line: "line", pc: "pc", stack: "stack", error: "error", scratch: "scratch" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.line > "u")
      throw new Error(`Response is missing required field 'line': ${e}`);
    if (typeof e.pc > "u")
      throw new Error(`Response is missing required field 'pc': ${e}`);
    if (!Array.isArray(e.stack))
      throw new Error(`Response is missing required array field 'stack': ${e}`);
    return new eo({ line: e.line, pc: e.pc, stack: e.stack.map(Yn.from_obj_for_encoding), error: e.error, scratch: typeof e.scratch < "u" ? e.scratch.map(Yn.from_obj_for_encoding) : void 0 });
  }
}, ya = class extends Re {
  constructor({ disassembly: e, appCallMessages: r3, appCallTrace: i, budgetAdded: n, budgetConsumed: s, globalDelta: o, localDeltas: f2, logicSigDisassembly: l, logicSigMessages: g5, logicSigTrace: _, logs: N2 }) {
    super(), this.disassembly = e, this.appCallMessages = r3, this.appCallTrace = i, this.budgetAdded = n, this.budgetConsumed = s, this.globalDelta = o, this.localDeltas = f2, this.logicSigDisassembly = l, this.logicSigMessages = g5, this.logicSigTrace = _, this.logs = N2, this.attribute_map = { disassembly: "disassembly", appCallMessages: "app-call-messages", appCallTrace: "app-call-trace", budgetAdded: "budget-added", budgetConsumed: "budget-consumed", globalDelta: "global-delta", localDeltas: "local-deltas", logicSigDisassembly: "logic-sig-disassembly", logicSigMessages: "logic-sig-messages", logicSigTrace: "logic-sig-trace", logs: "logs" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.disassembly))
      throw new Error(`Response is missing required array field 'disassembly': ${e}`);
    return new ya({ disassembly: e.disassembly, appCallMessages: e["app-call-messages"], appCallTrace: typeof e["app-call-trace"] < "u" ? e["app-call-trace"].map(eo.from_obj_for_encoding) : void 0, budgetAdded: e["budget-added"], budgetConsumed: e["budget-consumed"], globalDelta: typeof e["global-delta"] < "u" ? e["global-delta"].map(Vn.from_obj_for_encoding) : void 0, localDeltas: typeof e["local-deltas"] < "u" ? e["local-deltas"].map(Ws.from_obj_for_encoding) : void 0, logicSigDisassembly: e["logic-sig-disassembly"], logicSigMessages: e["logic-sig-messages"], logicSigTrace: typeof e["logic-sig-trace"] < "u" ? e["logic-sig-trace"].map(eo.from_obj_for_encoding) : void 0, logs: e.logs });
  }
}, Nc = class extends Re {
  constructor({ message: e, data: r3 }) {
    super(), this.message = e, this.data = r3, this.attribute_map = { message: "message", data: "data" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.message > "u")
      throw new Error(`Response is missing required field 'message': ${e}`);
    return new Nc({ message: e.message, data: e.data });
  }
}, ba = class extends Re {
  constructor({ action: e, bytes: r3, uint: i }) {
    super(), this.action = e, this.bytes = r3, this.uint = i, this.attribute_map = { action: "action", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.action > "u")
      throw new Error(`Response is missing required field 'action': ${e}`);
    return new ba({ action: e.action, bytes: e.bytes, uint: e.uint });
  }
}, Vn = class extends Re {
  constructor({ key: e, value: r3 }) {
    super(), this.key = e, this.value = r3, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new Vn({ key: e.key, value: ba.from_obj_for_encoding(e.value) });
  }
}, Bc = class extends Re {
  constructor({ index: e, proof: r3, treedepth: i }) {
    super(), this.index = e, this.proof = typeof r3 == "string" ? new Uint8Array(ar.Buffer.from(r3, "base64")) : r3, this.treedepth = i, this.attribute_map = { index: "index", proof: "proof", treedepth: "treedepth" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index > "u")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.proof > "u")
      throw new Error(`Response is missing required field 'proof': ${e}`);
    if (typeof e.treedepth > "u")
      throw new Error(`Response is missing required field 'treedepth': ${e}`);
    return new Bc({ index: e.index, proof: e.proof, treedepth: e.treedepth });
  }
}, Cc = class extends Re {
  constructor({ catchupTime: e, lastRound: r3, lastVersion: i, nextVersion: n, nextVersionRound: s, nextVersionSupported: o, stoppedAtUnsupportedRound: f2, timeSinceLastRound: l, catchpoint: g5, catchpointAcquiredBlocks: _, catchpointProcessedAccounts: N2, catchpointProcessedKvs: U2, catchpointTotalAccounts: V, catchpointTotalBlocks: G, catchpointTotalKvs: ee2, catchpointVerifiedAccounts: W5, catchpointVerifiedKvs: Z, lastCatchpoint: le }) {
    super(), this.catchupTime = e, this.lastRound = r3, this.lastVersion = i, this.nextVersion = n, this.nextVersionRound = s, this.nextVersionSupported = o, this.stoppedAtUnsupportedRound = f2, this.timeSinceLastRound = l, this.catchpoint = g5, this.catchpointAcquiredBlocks = _, this.catchpointProcessedAccounts = N2, this.catchpointProcessedKvs = U2, this.catchpointTotalAccounts = V, this.catchpointTotalBlocks = G, this.catchpointTotalKvs = ee2, this.catchpointVerifiedAccounts = W5, this.catchpointVerifiedKvs = Z, this.lastCatchpoint = le, this.attribute_map = { catchupTime: "catchup-time", lastRound: "last-round", lastVersion: "last-version", nextVersion: "next-version", nextVersionRound: "next-version-round", nextVersionSupported: "next-version-supported", stoppedAtUnsupportedRound: "stopped-at-unsupported-round", timeSinceLastRound: "time-since-last-round", catchpoint: "catchpoint", catchpointAcquiredBlocks: "catchpoint-acquired-blocks", catchpointProcessedAccounts: "catchpoint-processed-accounts", catchpointProcessedKvs: "catchpoint-processed-kvs", catchpointTotalAccounts: "catchpoint-total-accounts", catchpointTotalBlocks: "catchpoint-total-blocks", catchpointTotalKvs: "catchpoint-total-kvs", catchpointVerifiedAccounts: "catchpoint-verified-accounts", catchpointVerifiedKvs: "catchpoint-verified-kvs", lastCatchpoint: "last-catchpoint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["catchup-time"] > "u")
      throw new Error(`Response is missing required field 'catchup-time': ${e}`);
    if (typeof e["last-round"] > "u")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (typeof e["last-version"] > "u")
      throw new Error(`Response is missing required field 'last-version': ${e}`);
    if (typeof e["next-version"] > "u")
      throw new Error(`Response is missing required field 'next-version': ${e}`);
    if (typeof e["next-version-round"] > "u")
      throw new Error(`Response is missing required field 'next-version-round': ${e}`);
    if (typeof e["next-version-supported"] > "u")
      throw new Error(`Response is missing required field 'next-version-supported': ${e}`);
    if (typeof e["stopped-at-unsupported-round"] > "u")
      throw new Error(`Response is missing required field 'stopped-at-unsupported-round': ${e}`);
    if (typeof e["time-since-last-round"] > "u")
      throw new Error(`Response is missing required field 'time-since-last-round': ${e}`);
    return new Cc({ catchupTime: e["catchup-time"], lastRound: e["last-round"], lastVersion: e["last-version"], nextVersion: e["next-version"], nextVersionRound: e["next-version-round"], nextVersionSupported: e["next-version-supported"], stoppedAtUnsupportedRound: e["stopped-at-unsupported-round"], timeSinceLastRound: e["time-since-last-round"], catchpoint: e.catchpoint, catchpointAcquiredBlocks: e["catchpoint-acquired-blocks"], catchpointProcessedAccounts: e["catchpoint-processed-accounts"], catchpointProcessedKvs: e["catchpoint-processed-kvs"], catchpointTotalAccounts: e["catchpoint-total-accounts"], catchpointTotalBlocks: e["catchpoint-total-blocks"], catchpointTotalKvs: e["catchpoint-total-kvs"], catchpointVerifiedAccounts: e["catchpoint-verified-accounts"], catchpointVerifiedKvs: e["catchpoint-verified-kvs"], lastCatchpoint: e["last-catchpoint"] });
  }
}, va = class extends Re {
  constructor({ poolError: e, txn: r3, applicationIndex: i, assetClosingAmount: n, assetIndex: s, closeRewards: o, closingAmount: f2, confirmedRound: l, globalStateDelta: g5, innerTxns: _, localStateDelta: N2, logs: U2, receiverRewards: V, senderRewards: G }) {
    super(), this.poolError = e, this.txn = r3, this.applicationIndex = i, this.assetClosingAmount = n, this.assetIndex = s, this.closeRewards = o, this.closingAmount = f2, this.confirmedRound = l, this.globalStateDelta = g5, this.innerTxns = _, this.localStateDelta = N2, this.logs = U2, this.receiverRewards = V, this.senderRewards = G, this.attribute_map = { poolError: "pool-error", txn: "txn", applicationIndex: "application-index", assetClosingAmount: "asset-closing-amount", assetIndex: "asset-index", closeRewards: "close-rewards", closingAmount: "closing-amount", confirmedRound: "confirmed-round", globalStateDelta: "global-state-delta", innerTxns: "inner-txns", localStateDelta: "local-state-delta", logs: "logs", receiverRewards: "receiver-rewards", senderRewards: "sender-rewards" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["pool-error"] > "u")
      throw new Error(`Response is missing required field 'pool-error': ${e}`);
    if (typeof e.txn > "u")
      throw new Error(`Response is missing required field 'txn': ${e}`);
    return new va({ poolError: e["pool-error"], txn: e.txn, applicationIndex: e["application-index"], assetClosingAmount: e["asset-closing-amount"], assetIndex: e["asset-index"], closeRewards: e["close-rewards"], closingAmount: e["closing-amount"], confirmedRound: e["confirmed-round"], globalStateDelta: typeof e["global-state-delta"] < "u" ? e["global-state-delta"].map(Vn.from_obj_for_encoding) : void 0, innerTxns: typeof e["inner-txns"] < "u" ? e["inner-txns"].map(va.from_obj_for_encoding) : void 0, localStateDelta: typeof e["local-state-delta"] < "u" ? e["local-state-delta"].map(Ws.from_obj_for_encoding) : void 0, logs: e.logs, receiverRewards: e["receiver-rewards"], senderRewards: e["sender-rewards"] });
  }
}, Oc = class extends Re {
  constructor({ topTransactions: e, totalTransactions: r3 }) {
    super(), this.topTransactions = e, this.totalTransactions = r3, this.attribute_map = { topTransactions: "top-transactions", totalTransactions: "total-transactions" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["top-transactions"]))
      throw new Error(`Response is missing required array field 'top-transactions': ${e}`);
    if (typeof e["total-transactions"] > "u")
      throw new Error(`Response is missing required field 'total-transactions': ${e}`);
    return new Oc({ topTransactions: e["top-transactions"], totalTransactions: e["total-transactions"] });
  }
}, jc = class extends Re {
  constructor({ txid: e }) {
    super(), this.txid = e, this.attribute_map = { txid: "txId" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.txId > "u")
      throw new Error(`Response is missing required field 'txId': ${e}`);
    return new jc({ txid: e.txId });
  }
}, Lc = class extends Re {
  constructor({ message: e, stateproof: r3 }) {
    super(), this.message = e, this.stateproof = typeof r3 == "string" ? new Uint8Array(ar.Buffer.from(r3, "base64")) : r3, this.attribute_map = { message: "Message", stateproof: "StateProof" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.Message > "u")
      throw new Error(`Response is missing required field 'Message': ${e}`);
    if (typeof e.StateProof > "u")
      throw new Error(`Response is missing required field 'StateProof': ${e}`);
    return new Lc({ message: xa.from_obj_for_encoding(e.Message), stateproof: e.StateProof });
  }
}, xa = class extends Re {
  constructor({ blockheaderscommitment: e, firstattestedround: r3, lastattestedround: i, lnprovenweight: n, voterscommitment: s }) {
    super(), this.blockheaderscommitment = typeof e == "string" ? new Uint8Array(ar.Buffer.from(e, "base64")) : e, this.firstattestedround = r3, this.lastattestedround = i, this.lnprovenweight = n, this.voterscommitment = typeof s == "string" ? new Uint8Array(ar.Buffer.from(s, "base64")) : s, this.attribute_map = { blockheaderscommitment: "BlockHeadersCommitment", firstattestedround: "FirstAttestedRound", lastattestedround: "LastAttestedRound", lnprovenweight: "LnProvenWeight", voterscommitment: "VotersCommitment" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.BlockHeadersCommitment > "u")
      throw new Error(`Response is missing required field 'BlockHeadersCommitment': ${e}`);
    if (typeof e.FirstAttestedRound > "u")
      throw new Error(`Response is missing required field 'FirstAttestedRound': ${e}`);
    if (typeof e.LastAttestedRound > "u")
      throw new Error(`Response is missing required field 'LastAttestedRound': ${e}`);
    if (typeof e.LnProvenWeight > "u")
      throw new Error(`Response is missing required field 'LnProvenWeight': ${e}`);
    if (typeof e.VotersCommitment > "u")
      throw new Error(`Response is missing required field 'VotersCommitment': ${e}`);
    return new xa({ blockheaderscommitment: e.BlockHeadersCommitment, firstattestedround: e.FirstAttestedRound, lastattestedround: e.LastAttestedRound, lnprovenweight: e.LnProvenWeight, voterscommitment: e.VotersCommitment });
  }
}, qc = class extends Re {
  constructor({ currentRound: e, onlineMoney: r3, totalMoney: i }) {
    super(), this.currentRound = e, this.onlineMoney = r3, this.totalMoney = i, this.attribute_map = { currentRound: "current_round", onlineMoney: "online-money", totalMoney: "total-money" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.current_round > "u")
      throw new Error(`Response is missing required field 'current_round': ${e}`);
    if (typeof e["online-money"] > "u")
      throw new Error(`Response is missing required field 'online-money': ${e}`);
    if (typeof e["total-money"] > "u")
      throw new Error(`Response is missing required field 'total-money': ${e}`);
    return new qc({ currentRound: e.current_round, onlineMoney: e["online-money"], totalMoney: e["total-money"] });
  }
}, to = class extends Re {
  constructor({ key: e, value: r3 }) {
    super(), this.key = e, this.value = r3, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new to({ key: e.key, value: Yn.from_obj_for_encoding(e.value) });
  }
}, Yn = class extends Re {
  constructor({ type: e, bytes: r3, uint: i }) {
    super(), this.type = e, this.bytes = r3, this.uint = i, this.attribute_map = { type: "type", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.type > "u")
      throw new Error(`Response is missing required field 'type': ${e}`);
    if (typeof e.bytes > "u")
      throw new Error(`Response is missing required field 'bytes': ${e}`);
    if (typeof e.uint > "u")
      throw new Error(`Response is missing required field 'uint': ${e}`);
    return new Yn({ type: e.type, bytes: e.bytes, uint: e.uint });
  }
}, Pc = class extends Re {
  constructor({ consensusVersion: e, fee: r3, genesisHash: i, genesisId: n, lastRound: s, minFee: o }) {
    super(), this.consensusVersion = e, this.fee = r3, this.genesisHash = typeof i == "string" ? new Uint8Array(ar.Buffer.from(i, "base64")) : i, this.genesisId = n, this.lastRound = s, this.minFee = o, this.attribute_map = { consensusVersion: "consensus-version", fee: "fee", genesisHash: "genesis-hash", genesisId: "genesis-id", lastRound: "last-round", minFee: "min-fee" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["consensus-version"] > "u")
      throw new Error(`Response is missing required field 'consensus-version': ${e}`);
    if (typeof e.fee > "u")
      throw new Error(`Response is missing required field 'fee': ${e}`);
    if (typeof e["genesis-hash"] > "u")
      throw new Error(`Response is missing required field 'genesis-hash': ${e}`);
    if (typeof e["genesis-id"] > "u")
      throw new Error(`Response is missing required field 'genesis-id': ${e}`);
    if (typeof e["last-round"] > "u")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (typeof e["min-fee"] > "u")
      throw new Error(`Response is missing required field 'min-fee': ${e}`);
    return new Pc({ consensusVersion: e["consensus-version"], fee: e.fee, genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], lastRound: e["last-round"], minFee: e["min-fee"] });
  }
}, Uc = class extends Re {
  constructor({ idx: e, proof: r3, stibhash: i, treedepth: n, hashtype: s }) {
    super(), this.idx = e, this.proof = typeof r3 == "string" ? new Uint8Array(ar.Buffer.from(r3, "base64")) : r3, this.stibhash = typeof i == "string" ? new Uint8Array(ar.Buffer.from(i, "base64")) : i, this.treedepth = n, this.hashtype = s, this.attribute_map = { idx: "idx", proof: "proof", stibhash: "stibhash", treedepth: "treedepth", hashtype: "hashtype" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.idx > "u")
      throw new Error(`Response is missing required field 'idx': ${e}`);
    if (typeof e.proof > "u")
      throw new Error(`Response is missing required field 'proof': ${e}`);
    if (typeof e.stibhash > "u")
      throw new Error(`Response is missing required field 'stibhash': ${e}`);
    if (typeof e.treedepth > "u")
      throw new Error(`Response is missing required field 'treedepth': ${e}`);
    return new Uc({ idx: e.idx, proof: e.proof, stibhash: e.stibhash, treedepth: e.treedepth, hashtype: e.hashtype });
  }
}, zc = class extends Re {
  constructor({ build: e, genesisHashB64: r3, genesisId: i, versions: n }) {
    super(), this.build = e, this.genesisHashB64 = typeof r3 == "string" ? new Uint8Array(ar.Buffer.from(r3, "base64")) : r3, this.genesisId = i, this.versions = n, this.attribute_map = { build: "build", genesisHashB64: "genesis_hash_b64", genesisId: "genesis_id", versions: "versions" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.build > "u")
      throw new Error(`Response is missing required field 'build': ${e}`);
    if (typeof e.genesis_hash_b64 > "u")
      throw new Error(`Response is missing required field 'genesis_hash_b64': ${e}`);
    if (typeof e.genesis_id > "u")
      throw new Error(`Response is missing required field 'genesis_id': ${e}`);
    if (!Array.isArray(e.versions))
      throw new Error(`Response is missing required array field 'versions': ${e}`);
    return new zc({ build: ga.from_obj_for_encoding(e.build), genesisHashB64: e.genesis_hash_b64, genesisId: e.genesis_id, versions: e.versions });
  }
};
var Hc = class extends Ce {
  constructor(e, r3, i, n) {
    super(e, r3), this.index = i, this.index = i;
    let s = C3.Buffer.from(n).toString("base64");
    this.query.name = encodeURI(`b64:${s}`);
  }
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  prepare(e) {
    return Js.from_obj_for_encoding(e);
  }
};
U();
var Kc = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i, this.query.max = 0;
  }
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  max(e) {
    return this.query.max = e, this;
  }
  prepare(e) {
    return Xs.from_obj_for_encoding(e);
  }
};
U();
var Gc = class extends Ce {
  path() {
    return "/health";
  }
  async do(e = {}) {
    let r3 = await this.c.get(this.path(), {}, e);
    if (!r3.ok)
      throw new Error(`Health response: ${r3.status}`);
    return {};
  }
};
U();
var $c = class extends Ce {
  constructor(e, r3) {
    super(e), this.txid = r3, this.txid = r3, this.query.format = "msgpack";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return sr(e);
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  max(e) {
    return this.query.max = e, this;
  }
};
U();
var Wc = class extends Ce {
  constructor(e) {
    super(e), this.query.format = "msgpack";
  }
  path() {
    return "/v2/transactions/pending";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return sr(e);
  }
  max(e) {
    return this.query.max = e, this;
  }
};
U();
var Vc = class extends Ce {
  constructor(e, r3) {
    super(e), this.address = r3, this.address = r3, this.query.format = "msgpack";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return sr(e);
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  max(e) {
    return this.query.max = e, this;
  }
};
U();
var Yc = class extends Ce {
  constructor(e, r3, i, n) {
    super(e, r3), this.round = i, this.txID = n, this.round = i, this.txID = n;
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  hashType(e) {
    return this.query.hashtype = e, this;
  }
};
U();
var j3 = rr(or());
function cF(t = {}) {
  let e = t;
  return Object.keys(e).every((r3) => r3.toLowerCase() !== "content-type") && (e = { ...t }, e["Content-Type"] = "application/x-binary"), e;
}
function O3(t) {
  return t && t.byteLength !== void 0;
}
var Zc = class extends Ce {
  constructor(e, r3) {
    super(e);
    let i = r3;
    if (Array.isArray(r3)) {
      if (!r3.every(O3))
        throw new TypeError("Array elements must be byte arrays");
      i = $t(...r3);
    } else if (!O3(i))
      throw new TypeError("Argument must be byte array");
    this.txnBytesToPost = i;
  }
  path() {
    return "/v2/transactions";
  }
  async do(e = {}) {
    let r3 = cF(e);
    return (await this.c.post(this.path(), j3.Buffer.from(this.txnBytesToPost), r3)).body;
  }
};
U();
var Jc = class extends Ce {
  path() {
    return "/v2/status";
  }
};
U();
var Xc = class extends Ce {
  constructor(e, r3, i) {
    if (super(e, r3), this.round = i, !Number.isInteger(i))
      throw Error("round should be an integer");
    this.round = i;
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
};
U();
var Qc = class extends Ce {
  path() {
    return "/v2/transactions/params";
  }
  prepare(e) {
    return { flatFee: false, fee: e.fee, firstRound: e["last-round"], lastRound: e["last-round"] + 1e3, genesisID: e["genesis-id"], genesisHash: e["genesis-hash"] };
  }
};
U();
var eu = class extends Ce {
  path() {
    return "/v2/ledger/supply";
  }
};
U();
var tu = class extends Ce {
  path() {
    return "/versions";
  }
};
U();
var ru = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.round = i, this.round = i;
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
};
U();
var iu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.round = i, this.round = i;
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
};
U();
var L3 = rr(or());
function uF(t = {}) {
  let e = t;
  return Object.keys(e).every((r3) => r3.toLowerCase() !== "content-type") && (e = { ...t }, e["Content-Type"] = "text/plain"), e;
}
var nu = class extends Ce {
  constructor(e, r3) {
    super(e), this.source = r3, this.source = r3;
  }
  path() {
    return "/v2/teal/disassemble";
  }
  async do(e = {}) {
    let r3 = uF(e);
    return (await this.c.post(this.path(), L3.Buffer.from(this.source), r3, this.query)).body;
  }
};
var ro = class extends wn {
  constructor(e, r3, i, n = {}) {
    super("X-Algo-API-Token", e, r3, i, n);
  }
  healthCheck() {
    return new Gc(this.c);
  }
  versionsCheck() {
    return new tu(this.c);
  }
  sendRawTransaction(e) {
    return new Zc(this.c, e);
  }
  accountInformation(e) {
    return new mc(this.c, this.intDecoding, e);
  }
  accountAssetInformation(e, r3) {
    return new yc(this.c, this.intDecoding, e, r3);
  }
  accountApplicationInformation(e, r3) {
    return new bc(this.c, this.intDecoding, e, r3);
  }
  block(e) {
    return new vc(this.c, e);
  }
  getBlockHash(e) {
    return new Mc(this.c, this.intDecoding, e);
  }
  pendingTransactionInformation(e) {
    return new $c(this.c, e);
  }
  pendingTransactionsInformation() {
    return new Wc(this.c);
  }
  pendingTransactionByAddress(e) {
    return new Vc(this.c, e);
  }
  status() {
    return new Jc(this.c, this.intDecoding);
  }
  statusAfterBlock(e) {
    return new Xc(this.c, this.intDecoding, e);
  }
  getTransactionParams() {
    return new Qc(this.c);
  }
  supply() {
    return new eu(this.c, this.intDecoding);
  }
  compile(e) {
    return new xc(this.c, e);
  }
  disassemble(e) {
    return new nu(this.c, e);
  }
  dryrun(e) {
    return new wc(this.c, e);
  }
  getAssetByID(e) {
    return new Ac(this.c, this.intDecoding, e);
  }
  getApplicationByID(e) {
    return new Ec(this.c, this.intDecoding, e);
  }
  getApplicationBoxByName(e, r3) {
    return new Hc(this.c, this.intDecoding, e, r3);
  }
  getApplicationBoxes(e) {
    return new Kc(this.c, this.intDecoding, e);
  }
  genesis() {
    return new _c(this.c, this.intDecoding);
  }
  getTransactionProof(e, r3) {
    return new Yc(this.c, this.intDecoding, e, r3);
  }
  getLightBlockHeaderProof(e) {
    return new ru(this.c, this.intDecoding, e);
  }
  getStateProof(e) {
    return new iu(this.c, this.intDecoding, e);
  }
};
U();
var di = rr(or());
var su = class extends wn {
  constructor(e, r3 = "http://127.0.0.1", i = 7833, n = {}) {
    super("X-KMD-API-Token", e, r3, i, n);
  }
  async versions() {
    return (await this.c.get("/versions")).body;
  }
  async listWallets() {
    return (await this.c.get("/v1/wallets")).body;
  }
  async createWallet(e, r3, i = new Uint8Array(), n = "sqlite") {
    let s = { wallet_name: e, wallet_driver_name: n, wallet_password: r3, master_derivation_key: di.Buffer.from(i).toString("base64") };
    return (await this.c.post("/v1/wallet", s)).body;
  }
  async initWalletHandle(e, r3) {
    let i = { wallet_id: e, wallet_password: r3 };
    return (await this.c.post("/v1/wallet/init", i)).body;
  }
  async releaseWalletHandle(e) {
    let r3 = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/release", r3)).body;
  }
  async renewWalletHandle(e) {
    let r3 = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/renew", r3)).body;
  }
  async renameWallet(e, r3, i) {
    let n = { wallet_id: e, wallet_password: r3, wallet_name: i };
    return (await this.c.post("/v1/wallet/rename", n)).body;
  }
  async getWallet(e) {
    let r3 = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/info", r3)).body;
  }
  async exportMasterDerivationKey(e, r3) {
    let i = { wallet_handle_token: e, wallet_password: r3 }, n = await this.c.post("/v1/master-key/export", i);
    return { master_derivation_key: di.Buffer.from(n.body.master_derivation_key, "base64") };
  }
  async importKey(e, r3) {
    let i = { wallet_handle_token: e, private_key: di.Buffer.from(r3).toString("base64") };
    return (await this.c.post("/v1/key/import", i)).body;
  }
  async exportKey(e, r3, i) {
    let n = { wallet_handle_token: e, address: i, wallet_password: r3 }, s = await this.c.post("/v1/key/export", n);
    return { private_key: di.Buffer.from(s.body.private_key, "base64") };
  }
  async generateKey(e) {
    let r3 = { wallet_handle_token: e, display_mnemonic: false };
    return (await this.c.post("/v1/key", r3)).body;
  }
  async deleteKey(e, r3, i) {
    let n = { wallet_handle_token: e, address: i, wallet_password: r3 };
    return (await this.c.delete("/v1/key", n)).body;
  }
  async listKeys(e) {
    let r3 = { wallet_handle_token: e };
    return (await this.c.post("/v1/key/list", r3)).body;
  }
  async signTransaction(e, r3, i) {
    let n = ci(i), s = { wallet_handle_token: e, wallet_password: r3, transaction: di.Buffer.from(n.toByte()).toString("base64") }, o = await this.c.post("/v1/transaction/sign", s);
    return o.status === 200 ? di.Buffer.from(o.body.signed_transaction, "base64") : o.body;
  }
  async signTransactionWithSpecificPublicKey(e, r3, i, n) {
    let s = ci(i), o = { wallet_handle_token: e, wallet_password: r3, transaction: di.Buffer.from(s.toByte()).toString("base64"), public_key: di.Buffer.from(n).toString("base64") }, f2 = await this.c.post("/v1/transaction/sign", o);
    return f2.status === 200 ? di.Buffer.from(f2.body.signed_transaction, "base64") : f2.body;
  }
  async listMultisig(e) {
    let r3 = { wallet_handle_token: e };
    return (await this.c.post("/v1/multisig/list", r3)).body;
  }
  async importMultisig(e, r3, i, n) {
    let s = { wallet_handle_token: e, multisig_version: r3, threshold: i, pks: n };
    return (await this.c.post("/v1/multisig/import", s)).body;
  }
  async exportMultisig(e, r3) {
    let i = { wallet_handle_token: e, address: r3 };
    return (await this.c.post("/v1/multisig/export", i)).body;
  }
  async signMultisigTransaction(e, r3, i, n, s) {
    let o = ci(i), f2 = { wallet_handle_token: e, transaction: di.Buffer.from(o.toByte()).toString("base64"), public_key: di.Buffer.from(n).toString("base64"), partial_multisig: s, wallet_password: r3 };
    return (await this.c.post("/v1/multisig/sign", f2)).body;
  }
  async deleteMultisig(e, r3, i) {
    let n = { wallet_handle_token: e, address: i, wallet_password: r3 };
    return (await this.c.delete("/v1/multisig", n)).body;
  }
};
U();
U();
var ou = class extends Ce {
  path() {
    return "/health";
  }
};
U();
var au = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
U();
var q3 = rr(or());
function cu(t) {
  return typeof t == "string" ? t : q3.Buffer.from(t).toString("base64");
}
var fu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  notePrefix(e) {
    return this.query["note-prefix"] = cu(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
};
var uu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  notePrefix(e) {
    return this.query["note-prefix"] = cu(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  addressRole(e) {
    return this.query["address-role"] = e, this;
  }
  address(e) {
    return this.query.address = e, this;
  }
  excludeCloseTo(e) {
    return this.query["exclude-close-to"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
};
U();
var du = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.round = i, this.round = i;
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  headerOnly(e) {
    return this.query["header-only"] = e, this;
  }
};
U();
var lu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.txID = i, this.txID = i;
  }
  path() {
    return `/v2/transactions/${this.txID}`;
  }
};
U();
var hu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  round(e) {
    return this.query.round = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
U();
var pu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  assetId(e) {
    return this.query["asset-id"] = e, this;
  }
};
U();
var gu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
};
U();
var mu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
U();
var yu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
U();
var bu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var vu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var xu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.appID = i, this.appID = i;
  }
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  sender(e) {
    return this.query["sender-address"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
};
U();
var P3 = rr(or());
var og = {};
ct$1(og, { Account: () => io, AccountParticipation: () => wa, AccountResponse: () => wu, AccountStateDelta: () => _a, AccountsResponse: () => _u, Application: () => Zn, ApplicationLocalState: () => no, ApplicationLocalStatesResponse: () => Au, ApplicationLogData: () => Aa, ApplicationLogsResponse: () => Eu, ApplicationParams: () => Ea, ApplicationResponse: () => Mu, ApplicationStateSchema: () => En, ApplicationsResponse: () => Su, Asset: () => Jn, AssetBalancesResponse: () => Iu, AssetHolding: () => so, AssetHoldingsResponse: () => Tu, AssetParams: () => oo, AssetResponse: () => Fu, AssetsResponse: () => Ru, Block: () => ku, BlockRewards: () => Ma, BlockUpgradeState: () => Sa, BlockUpgradeVote: () => Ia, Box: () => ao, BoxDescriptor: () => Ta, BoxesResponse: () => fo, ErrorResponse: () => Du, EvalDelta: () => Fa, EvalDeltaKeyValue: () => co, HashFactory: () => Ra, HealthCheck: () => Nu, IndexerStateProofMessage: () => ka, MerkleArrayProof: () => Xn, MiniAssetHolding: () => Da, ParticipationUpdates: () => Na, StateProofFields: () => Ba, StateProofParticipant: () => Ca, StateProofReveal: () => Oa, StateProofSigSlot: () => ja, StateProofSignature: () => La, StateProofTracking: () => qa, StateProofVerifier: () => Pa, StateSchema: () => uo, TealKeyValue: () => lo, TealValue: () => Ua, Transaction: () => Mn, TransactionApplication: () => za, TransactionAssetConfig: () => Ha, TransactionAssetFreeze: () => Ka, TransactionAssetTransfer: () => Ga, TransactionKeyreg: () => $a, TransactionPayment: () => Wa, TransactionResponse: () => Bu, TransactionSignature: () => Va, TransactionSignatureLogicsig: () => Ya, TransactionSignatureMultisig: () => ho, TransactionSignatureMultisigSubsignature: () => Za, TransactionStateProof: () => Ja, TransactionsResponse: () => Cu });
U();
var Tt = rr(or());
var io = class extends Re {
  constructor({ address: e, amount: r3, amountWithoutPendingRewards: i, pendingRewards: n, rewards: s, round: o, status: f2, totalAppsOptedIn: l, totalAssetsOptedIn: g5, totalBoxBytes: _, totalBoxes: N2, totalCreatedApps: U2, totalCreatedAssets: V, appsLocalState: G, appsTotalExtraPages: ee2, appsTotalSchema: W5, assets: Z, authAddr: le, closedAtRound: be2, createdApps: Ae, createdAssets: me, createdAtRound: H5, deleted: ue, participation: se2, rewardBase: ne2, sigType: E2 }) {
    super(), this.address = e, this.amount = r3, this.amountWithoutPendingRewards = i, this.pendingRewards = n, this.rewards = s, this.round = o, this.status = f2, this.totalAppsOptedIn = l, this.totalAssetsOptedIn = g5, this.totalBoxBytes = _, this.totalBoxes = N2, this.totalCreatedApps = U2, this.totalCreatedAssets = V, this.appsLocalState = G, this.appsTotalExtraPages = ee2, this.appsTotalSchema = W5, this.assets = Z, this.authAddr = le, this.closedAtRound = be2, this.createdApps = Ae, this.createdAssets = me, this.createdAtRound = H5, this.deleted = ue, this.participation = se2, this.rewardBase = ne2, this.sigType = E2, this.attribute_map = { address: "address", amount: "amount", amountWithoutPendingRewards: "amount-without-pending-rewards", pendingRewards: "pending-rewards", rewards: "rewards", round: "round", status: "status", totalAppsOptedIn: "total-apps-opted-in", totalAssetsOptedIn: "total-assets-opted-in", totalBoxBytes: "total-box-bytes", totalBoxes: "total-boxes", totalCreatedApps: "total-created-apps", totalCreatedAssets: "total-created-assets", appsLocalState: "apps-local-state", appsTotalExtraPages: "apps-total-extra-pages", appsTotalSchema: "apps-total-schema", assets: "assets", authAddr: "auth-addr", closedAtRound: "closed-at-round", createdApps: "created-apps", createdAssets: "created-assets", createdAtRound: "created-at-round", deleted: "deleted", participation: "participation", rewardBase: "reward-base", sigType: "sig-type" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["amount-without-pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${e}`);
    if (typeof e["pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'pending-rewards': ${e}`);
    if (typeof e.rewards > "u")
      throw new Error(`Response is missing required field 'rewards': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.status > "u")
      throw new Error(`Response is missing required field 'status': ${e}`);
    if (typeof e["total-apps-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${e}`);
    if (typeof e["total-assets-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${e}`);
    if (typeof e["total-box-bytes"] > "u")
      throw new Error(`Response is missing required field 'total-box-bytes': ${e}`);
    if (typeof e["total-boxes"] > "u")
      throw new Error(`Response is missing required field 'total-boxes': ${e}`);
    if (typeof e["total-created-apps"] > "u")
      throw new Error(`Response is missing required field 'total-created-apps': ${e}`);
    if (typeof e["total-created-assets"] > "u")
      throw new Error(`Response is missing required field 'total-created-assets': ${e}`);
    return new io({ address: e.address, amount: e.amount, amountWithoutPendingRewards: e["amount-without-pending-rewards"], pendingRewards: e["pending-rewards"], rewards: e.rewards, round: e.round, status: e.status, totalAppsOptedIn: e["total-apps-opted-in"], totalAssetsOptedIn: e["total-assets-opted-in"], totalBoxBytes: e["total-box-bytes"], totalBoxes: e["total-boxes"], totalCreatedApps: e["total-created-apps"], totalCreatedAssets: e["total-created-assets"], appsLocalState: typeof e["apps-local-state"] < "u" ? e["apps-local-state"].map(no.from_obj_for_encoding) : void 0, appsTotalExtraPages: e["apps-total-extra-pages"], appsTotalSchema: typeof e["apps-total-schema"] < "u" ? En.from_obj_for_encoding(e["apps-total-schema"]) : void 0, assets: typeof e.assets < "u" ? e.assets.map(so.from_obj_for_encoding) : void 0, authAddr: e["auth-addr"], closedAtRound: e["closed-at-round"], createdApps: typeof e["created-apps"] < "u" ? e["created-apps"].map(Zn.from_obj_for_encoding) : void 0, createdAssets: typeof e["created-assets"] < "u" ? e["created-assets"].map(Jn.from_obj_for_encoding) : void 0, createdAtRound: e["created-at-round"], deleted: e.deleted, participation: typeof e.participation < "u" ? wa.from_obj_for_encoding(e.participation) : void 0, rewardBase: e["reward-base"], sigType: e["sig-type"] });
  }
}, wa = class extends Re {
  constructor({ selectionParticipationKey: e, voteFirstValid: r3, voteKeyDilution: i, voteLastValid: n, voteParticipationKey: s, stateProofKey: o }) {
    super(), this.selectionParticipationKey = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.voteFirstValid = r3, this.voteKeyDilution = i, this.voteLastValid = n, this.voteParticipationKey = typeof s == "string" ? new Uint8Array(Tt.Buffer.from(s, "base64")) : s, this.stateProofKey = typeof o == "string" ? new Uint8Array(Tt.Buffer.from(o, "base64")) : o, this.attribute_map = { selectionParticipationKey: "selection-participation-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key", stateProofKey: "state-proof-key" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["selection-participation-key"] > "u")
      throw new Error(`Response is missing required field 'selection-participation-key': ${e}`);
    if (typeof e["vote-first-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-first-valid': ${e}`);
    if (typeof e["vote-key-dilution"] > "u")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${e}`);
    if (typeof e["vote-last-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-last-valid': ${e}`);
    if (typeof e["vote-participation-key"] > "u")
      throw new Error(`Response is missing required field 'vote-participation-key': ${e}`);
    return new wa({ selectionParticipationKey: e["selection-participation-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"], stateProofKey: e["state-proof-key"] });
  }
}, wu = class extends Re {
  constructor({ account: e, currentRound: r3 }) {
    super(), this.account = e, this.currentRound = r3, this.attribute_map = { account: "account", currentRound: "current-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.account > "u")
      throw new Error(`Response is missing required field 'account': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new wu({ account: io.from_obj_for_encoding(e.account), currentRound: e["current-round"] });
  }
}, _a = class extends Re {
  constructor({ address: e, delta: r3 }) {
    super(), this.address = e, this.delta = r3, this.attribute_map = { address: "address", delta: "delta" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (!Array.isArray(e.delta))
      throw new Error(`Response is missing required array field 'delta': ${e}`);
    return new _a({ address: e.address, delta: e.delta.map(co.from_obj_for_encoding) });
  }
}, _u = class extends Re {
  constructor({ accounts: e, currentRound: r3, nextToken: i }) {
    super(), this.accounts = e, this.currentRound = r3, this.nextToken = i, this.attribute_map = { accounts: "accounts", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.accounts))
      throw new Error(`Response is missing required array field 'accounts': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new _u({ accounts: e.accounts.map(io.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, Zn = class extends Re {
  constructor({ id: e, params: r3, createdAtRound: i, deleted: n, deletedAtRound: s }) {
    super(), this.id = e, this.params = r3, this.createdAtRound = i, this.deleted = n, this.deletedAtRound = s, this.attribute_map = { id: "id", params: "params", createdAtRound: "created-at-round", deleted: "deleted", deletedAtRound: "deleted-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new Zn({ id: e.id, params: Ea.from_obj_for_encoding(e.params), createdAtRound: e["created-at-round"], deleted: e.deleted, deletedAtRound: e["deleted-at-round"] });
  }
}, no = class extends Re {
  constructor({ id: e, schema: r3, closedOutAtRound: i, deleted: n, keyValue: s, optedInAtRound: o }) {
    super(), this.id = e, this.schema = r3, this.closedOutAtRound = i, this.deleted = n, this.keyValue = s, this.optedInAtRound = o, this.attribute_map = { id: "id", schema: "schema", closedOutAtRound: "closed-out-at-round", deleted: "deleted", keyValue: "key-value", optedInAtRound: "opted-in-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.schema > "u")
      throw new Error(`Response is missing required field 'schema': ${e}`);
    return new no({ id: e.id, schema: En.from_obj_for_encoding(e.schema), closedOutAtRound: e["closed-out-at-round"], deleted: e.deleted, keyValue: typeof e["key-value"] < "u" ? e["key-value"].map(lo.from_obj_for_encoding) : void 0, optedInAtRound: e["opted-in-at-round"] });
  }
}, Au = class extends Re {
  constructor({ appsLocalStates: e, currentRound: r3, nextToken: i }) {
    super(), this.appsLocalStates = e, this.currentRound = r3, this.nextToken = i, this.attribute_map = { appsLocalStates: "apps-local-states", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["apps-local-states"]))
      throw new Error(`Response is missing required array field 'apps-local-states': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Au({ appsLocalStates: e["apps-local-states"].map(no.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, Aa = class extends Re {
  constructor({ logs: e, txid: r3 }) {
    super(), this.logs = e, this.txid = r3, this.attribute_map = { logs: "logs", txid: "txid" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.logs))
      throw new Error(`Response is missing required array field 'logs': ${e}`);
    if (typeof e.txid > "u")
      throw new Error(`Response is missing required field 'txid': ${e}`);
    return new Aa({ logs: e.logs, txid: e.txid });
  }
}, Eu = class extends Re {
  constructor({ applicationId: e, currentRound: r3, logData: i, nextToken: n }) {
    super(), this.applicationId = e, this.currentRound = r3, this.logData = i, this.nextToken = n, this.attribute_map = { applicationId: "application-id", currentRound: "current-round", logData: "log-data", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] > "u")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Eu({ applicationId: e["application-id"], currentRound: e["current-round"], logData: typeof e["log-data"] < "u" ? e["log-data"].map(Aa.from_obj_for_encoding) : void 0, nextToken: e["next-token"] });
  }
}, Ea = class extends Re {
  constructor({ approvalProgram: e, clearStateProgram: r3, creator: i, extraProgramPages: n, globalState: s, globalStateSchema: o, localStateSchema: f2 }) {
    super(), this.approvalProgram = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.clearStateProgram = typeof r3 == "string" ? new Uint8Array(Tt.Buffer.from(r3, "base64")) : r3, this.creator = i, this.extraProgramPages = n, this.globalState = s, this.globalStateSchema = o, this.localStateSchema = f2, this.attribute_map = { approvalProgram: "approval-program", clearStateProgram: "clear-state-program", creator: "creator", extraProgramPages: "extra-program-pages", globalState: "global-state", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["approval-program"] > "u")
      throw new Error(`Response is missing required field 'approval-program': ${e}`);
    if (typeof e["clear-state-program"] > "u")
      throw new Error(`Response is missing required field 'clear-state-program': ${e}`);
    return new Ea({ approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], creator: e.creator, extraProgramPages: e["extra-program-pages"], globalState: typeof e["global-state"] < "u" ? e["global-state"].map(lo.from_obj_for_encoding) : void 0, globalStateSchema: typeof e["global-state-schema"] < "u" ? En.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] < "u" ? En.from_obj_for_encoding(e["local-state-schema"]) : void 0 });
  }
}, Mu = class extends Re {
  constructor({ currentRound: e, application: r3 }) {
    super(), this.currentRound = e, this.application = r3, this.attribute_map = { currentRound: "current-round", application: "application" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Mu({ currentRound: e["current-round"], application: typeof e.application < "u" ? Zn.from_obj_for_encoding(e.application) : void 0 });
  }
}, En = class extends Re {
  constructor({ numByteSlice: e, numUint: r3 }) {
    super(), this.numByteSlice = e, this.numUint = r3, this.attribute_map = { numByteSlice: "num-byte-slice", numUint: "num-uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-byte-slice"] > "u")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    if (typeof e["num-uint"] > "u")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    return new En({ numByteSlice: e["num-byte-slice"], numUint: e["num-uint"] });
  }
}, Su = class extends Re {
  constructor({ applications: e, currentRound: r3, nextToken: i }) {
    super(), this.applications = e, this.currentRound = r3, this.nextToken = i, this.attribute_map = { applications: "applications", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.applications))
      throw new Error(`Response is missing required array field 'applications': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Su({ applications: e.applications.map(Zn.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, Jn = class extends Re {
  constructor({ index: e, params: r3, createdAtRound: i, deleted: n, destroyedAtRound: s }) {
    super(), this.index = e, this.params = r3, this.createdAtRound = i, this.deleted = n, this.destroyedAtRound = s, this.attribute_map = { index: "index", params: "params", createdAtRound: "created-at-round", deleted: "deleted", destroyedAtRound: "destroyed-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index > "u")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new Jn({ index: e.index, params: oo.from_obj_for_encoding(e.params), createdAtRound: e["created-at-round"], deleted: e.deleted, destroyedAtRound: e["destroyed-at-round"] });
  }
}, Iu = class extends Re {
  constructor({ balances: e, currentRound: r3, nextToken: i }) {
    super(), this.balances = e, this.currentRound = r3, this.nextToken = i, this.attribute_map = { balances: "balances", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.balances))
      throw new Error(`Response is missing required array field 'balances': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Iu({ balances: e.balances.map(Da.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, so = class extends Re {
  constructor({ amount: e, assetId: r3, isFrozen: i, deleted: n, optedInAtRound: s, optedOutAtRound: o }) {
    super(), this.amount = e, this.assetId = r3, this.isFrozen = i, this.deleted = n, this.optedInAtRound = s, this.optedOutAtRound = o, this.attribute_map = { amount: "amount", assetId: "asset-id", isFrozen: "is-frozen", deleted: "deleted", optedInAtRound: "opted-in-at-round", optedOutAtRound: "opted-out-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["is-frozen"] > "u")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new so({ amount: e.amount, assetId: e["asset-id"], isFrozen: e["is-frozen"], deleted: e.deleted, optedInAtRound: e["opted-in-at-round"], optedOutAtRound: e["opted-out-at-round"] });
  }
}, Tu = class extends Re {
  constructor({ assets: e, currentRound: r3, nextToken: i }) {
    super(), this.assets = e, this.currentRound = r3, this.nextToken = i, this.attribute_map = { assets: "assets", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.assets))
      throw new Error(`Response is missing required array field 'assets': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Tu({ assets: e.assets.map(so.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, oo = class extends Re {
  constructor({ creator: e, decimals: r3, total: i, clawback: n, defaultFrozen: s, freeze: o, manager: f2, metadataHash: l, name: g5, nameB64: _, reserve: N2, unitName: U2, unitNameB64: V, url: G, urlB64: ee2 }) {
    super(), this.creator = e, this.decimals = r3, this.total = i, this.clawback = n, this.defaultFrozen = s, this.freeze = o, this.manager = f2, this.metadataHash = typeof l == "string" ? new Uint8Array(Tt.Buffer.from(l, "base64")) : l, this.name = g5, this.nameB64 = typeof _ == "string" ? new Uint8Array(Tt.Buffer.from(_, "base64")) : _, this.reserve = N2, this.unitName = U2, this.unitNameB64 = typeof V == "string" ? new Uint8Array(Tt.Buffer.from(V, "base64")) : V, this.url = G, this.urlB64 = typeof ee2 == "string" ? new Uint8Array(Tt.Buffer.from(ee2, "base64")) : ee2, this.attribute_map = { creator: "creator", decimals: "decimals", total: "total", clawback: "clawback", defaultFrozen: "default-frozen", freeze: "freeze", manager: "manager", metadataHash: "metadata-hash", name: "name", nameB64: "name-b64", reserve: "reserve", unitName: "unit-name", unitNameB64: "unit-name-b64", url: "url", urlB64: "url-b64" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.creator > "u")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    if (typeof e.decimals > "u")
      throw new Error(`Response is missing required field 'decimals': ${e}`);
    if (typeof e.total > "u")
      throw new Error(`Response is missing required field 'total': ${e}`);
    return new oo({ creator: e.creator, decimals: e.decimals, total: e.total, clawback: e.clawback, defaultFrozen: e["default-frozen"], freeze: e.freeze, manager: e.manager, metadataHash: e["metadata-hash"], name: e.name, nameB64: e["name-b64"], reserve: e.reserve, unitName: e["unit-name"], unitNameB64: e["unit-name-b64"], url: e.url, urlB64: e["url-b64"] });
  }
}, Fu = class extends Re {
  constructor({ asset: e, currentRound: r3 }) {
    super(), this.asset = e, this.currentRound = r3, this.attribute_map = { asset: "asset", currentRound: "current-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.asset > "u")
      throw new Error(`Response is missing required field 'asset': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Fu({ asset: Jn.from_obj_for_encoding(e.asset), currentRound: e["current-round"] });
  }
}, Ru = class extends Re {
  constructor({ assets: e, currentRound: r3, nextToken: i }) {
    super(), this.assets = e, this.currentRound = r3, this.nextToken = i, this.attribute_map = { assets: "assets", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.assets))
      throw new Error(`Response is missing required array field 'assets': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Ru({ assets: e.assets.map(Jn.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, ku = class extends Re {
  constructor({ genesisHash: e, genesisId: r3, previousBlockHash: i, round: n, seed: s, timestamp: o, transactionsRoot: f2, transactionsRootSha256: l, participationUpdates: g5, rewards: _, stateProofTracking: N2, transactions: U2, txnCounter: V, upgradeState: G, upgradeVote: ee2 }) {
    super(), this.genesisHash = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.genesisId = r3, this.previousBlockHash = typeof i == "string" ? new Uint8Array(Tt.Buffer.from(i, "base64")) : i, this.round = n, this.seed = typeof s == "string" ? new Uint8Array(Tt.Buffer.from(s, "base64")) : s, this.timestamp = o, this.transactionsRoot = typeof f2 == "string" ? new Uint8Array(Tt.Buffer.from(f2, "base64")) : f2, this.transactionsRootSha256 = typeof l == "string" ? new Uint8Array(Tt.Buffer.from(l, "base64")) : l, this.participationUpdates = g5, this.rewards = _, this.stateProofTracking = N2, this.transactions = U2, this.txnCounter = V, this.upgradeState = G, this.upgradeVote = ee2, this.attribute_map = { genesisHash: "genesis-hash", genesisId: "genesis-id", previousBlockHash: "previous-block-hash", round: "round", seed: "seed", timestamp: "timestamp", transactionsRoot: "transactions-root", transactionsRootSha256: "transactions-root-sha256", participationUpdates: "participation-updates", rewards: "rewards", stateProofTracking: "state-proof-tracking", transactions: "transactions", txnCounter: "txn-counter", upgradeState: "upgrade-state", upgradeVote: "upgrade-vote" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["genesis-hash"] > "u")
      throw new Error(`Response is missing required field 'genesis-hash': ${e}`);
    if (typeof e["genesis-id"] > "u")
      throw new Error(`Response is missing required field 'genesis-id': ${e}`);
    if (typeof e["previous-block-hash"] > "u")
      throw new Error(`Response is missing required field 'previous-block-hash': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.seed > "u")
      throw new Error(`Response is missing required field 'seed': ${e}`);
    if (typeof e.timestamp > "u")
      throw new Error(`Response is missing required field 'timestamp': ${e}`);
    if (typeof e["transactions-root"] > "u")
      throw new Error(`Response is missing required field 'transactions-root': ${e}`);
    if (typeof e["transactions-root-sha256"] > "u")
      throw new Error(`Response is missing required field 'transactions-root-sha256': ${e}`);
    return new ku({ genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], previousBlockHash: e["previous-block-hash"], round: e.round, seed: e.seed, timestamp: e.timestamp, transactionsRoot: e["transactions-root"], transactionsRootSha256: e["transactions-root-sha256"], participationUpdates: typeof e["participation-updates"] < "u" ? Na.from_obj_for_encoding(e["participation-updates"]) : void 0, rewards: typeof e.rewards < "u" ? Ma.from_obj_for_encoding(e.rewards) : void 0, stateProofTracking: typeof e["state-proof-tracking"] < "u" ? e["state-proof-tracking"].map(qa.from_obj_for_encoding) : void 0, transactions: typeof e.transactions < "u" ? e.transactions.map(Mn.from_obj_for_encoding) : void 0, txnCounter: e["txn-counter"], upgradeState: typeof e["upgrade-state"] < "u" ? Sa.from_obj_for_encoding(e["upgrade-state"]) : void 0, upgradeVote: typeof e["upgrade-vote"] < "u" ? Ia.from_obj_for_encoding(e["upgrade-vote"]) : void 0 });
  }
}, Ma = class extends Re {
  constructor({ feeSink: e, rewardsCalculationRound: r3, rewardsLevel: i, rewardsPool: n, rewardsRate: s, rewardsResidue: o }) {
    super(), this.feeSink = e, this.rewardsCalculationRound = r3, this.rewardsLevel = i, this.rewardsPool = n, this.rewardsRate = s, this.rewardsResidue = o, this.attribute_map = { feeSink: "fee-sink", rewardsCalculationRound: "rewards-calculation-round", rewardsLevel: "rewards-level", rewardsPool: "rewards-pool", rewardsRate: "rewards-rate", rewardsResidue: "rewards-residue" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["fee-sink"] > "u")
      throw new Error(`Response is missing required field 'fee-sink': ${e}`);
    if (typeof e["rewards-calculation-round"] > "u")
      throw new Error(`Response is missing required field 'rewards-calculation-round': ${e}`);
    if (typeof e["rewards-level"] > "u")
      throw new Error(`Response is missing required field 'rewards-level': ${e}`);
    if (typeof e["rewards-pool"] > "u")
      throw new Error(`Response is missing required field 'rewards-pool': ${e}`);
    if (typeof e["rewards-rate"] > "u")
      throw new Error(`Response is missing required field 'rewards-rate': ${e}`);
    if (typeof e["rewards-residue"] > "u")
      throw new Error(`Response is missing required field 'rewards-residue': ${e}`);
    return new Ma({ feeSink: e["fee-sink"], rewardsCalculationRound: e["rewards-calculation-round"], rewardsLevel: e["rewards-level"], rewardsPool: e["rewards-pool"], rewardsRate: e["rewards-rate"], rewardsResidue: e["rewards-residue"] });
  }
}, Sa = class extends Re {
  constructor({ currentProtocol: e, nextProtocol: r3, nextProtocolApprovals: i, nextProtocolSwitchOn: n, nextProtocolVoteBefore: s }) {
    super(), this.currentProtocol = e, this.nextProtocol = r3, this.nextProtocolApprovals = i, this.nextProtocolSwitchOn = n, this.nextProtocolVoteBefore = s, this.attribute_map = { currentProtocol: "current-protocol", nextProtocol: "next-protocol", nextProtocolApprovals: "next-protocol-approvals", nextProtocolSwitchOn: "next-protocol-switch-on", nextProtocolVoteBefore: "next-protocol-vote-before" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-protocol"] > "u")
      throw new Error(`Response is missing required field 'current-protocol': ${e}`);
    return new Sa({ currentProtocol: e["current-protocol"], nextProtocol: e["next-protocol"], nextProtocolApprovals: e["next-protocol-approvals"], nextProtocolSwitchOn: e["next-protocol-switch-on"], nextProtocolVoteBefore: e["next-protocol-vote-before"] });
  }
}, Ia = class extends Re {
  constructor({ upgradeApprove: e, upgradeDelay: r3, upgradePropose: i }) {
    super(), this.upgradeApprove = e, this.upgradeDelay = r3, this.upgradePropose = i, this.attribute_map = { upgradeApprove: "upgrade-approve", upgradeDelay: "upgrade-delay", upgradePropose: "upgrade-propose" };
  }
  static from_obj_for_encoding(e) {
    return new Ia({ upgradeApprove: e["upgrade-approve"], upgradeDelay: e["upgrade-delay"], upgradePropose: e["upgrade-propose"] });
  }
}, ao = class extends Re {
  constructor({ name: e, value: r3 }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.value = typeof r3 == "string" ? new Uint8Array(Tt.Buffer.from(r3, "base64")) : r3, this.attribute_map = { name: "name", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new ao({ name: e.name, value: e.value });
  }
}, Ta = class extends Re {
  constructor({ name: e }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.attribute_map = { name: "name" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    return new Ta({ name: e.name });
  }
}, fo = class extends Re {
  constructor({ applicationId: e, boxes: r3, nextToken: i }) {
    super(), this.applicationId = e, this.boxes = r3, this.nextToken = i, this.attribute_map = { applicationId: "application-id", boxes: "boxes", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] > "u")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    if (!Array.isArray(e.boxes))
      throw new Error(`Response is missing required array field 'boxes': ${e}`);
    return new fo({ applicationId: e["application-id"], boxes: e.boxes.map(Ta.from_obj_for_encoding), nextToken: e["next-token"] });
  }
}, Du = class extends Re {
  constructor({ message: e, data: r3 }) {
    super(), this.message = e, this.data = r3, this.attribute_map = { message: "message", data: "data" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.message > "u")
      throw new Error(`Response is missing required field 'message': ${e}`);
    return new Du({ message: e.message, data: e.data });
  }
}, Fa = class extends Re {
  constructor({ action: e, bytes: r3, uint: i }) {
    super(), this.action = e, this.bytes = r3, this.uint = i, this.attribute_map = { action: "action", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.action > "u")
      throw new Error(`Response is missing required field 'action': ${e}`);
    return new Fa({ action: e.action, bytes: e.bytes, uint: e.uint });
  }
}, co = class extends Re {
  constructor({ key: e, value: r3 }) {
    super(), this.key = e, this.value = r3, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new co({ key: e.key, value: Fa.from_obj_for_encoding(e.value) });
  }
}, Ra = class extends Re {
  constructor({ hashType: e }) {
    super(), this.hashType = e, this.attribute_map = { hashType: "hash-type" };
  }
  static from_obj_for_encoding(e) {
    return new Ra({ hashType: e["hash-type"] });
  }
}, Nu = class extends Re {
  constructor({ dbAvailable: e, isMigrating: r3, message: i, round: n, version: s, data: o, errors: f2 }) {
    super(), this.dbAvailable = e, this.isMigrating = r3, this.message = i, this.round = n, this.version = s, this.data = o, this.errors = f2, this.attribute_map = { dbAvailable: "db-available", isMigrating: "is-migrating", message: "message", round: "round", version: "version", data: "data", errors: "errors" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["db-available"] > "u")
      throw new Error(`Response is missing required field 'db-available': ${e}`);
    if (typeof e["is-migrating"] > "u")
      throw new Error(`Response is missing required field 'is-migrating': ${e}`);
    if (typeof e.message > "u")
      throw new Error(`Response is missing required field 'message': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.version > "u")
      throw new Error(`Response is missing required field 'version': ${e}`);
    return new Nu({ dbAvailable: e["db-available"], isMigrating: e["is-migrating"], message: e.message, round: e.round, version: e.version, data: e.data, errors: e.errors });
  }
}, ka = class extends Re {
  constructor({ blockHeadersCommitment: e, firstAttestedRound: r3, latestAttestedRound: i, lnProvenWeight: n, votersCommitment: s }) {
    super(), this.blockHeadersCommitment = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.firstAttestedRound = r3, this.latestAttestedRound = i, this.lnProvenWeight = n, this.votersCommitment = typeof s == "string" ? new Uint8Array(Tt.Buffer.from(s, "base64")) : s, this.attribute_map = { blockHeadersCommitment: "block-headers-commitment", firstAttestedRound: "first-attested-round", latestAttestedRound: "latest-attested-round", lnProvenWeight: "ln-proven-weight", votersCommitment: "voters-commitment" };
  }
  static from_obj_for_encoding(e) {
    return new ka({ blockHeadersCommitment: e["block-headers-commitment"], firstAttestedRound: e["first-attested-round"], latestAttestedRound: e["latest-attested-round"], lnProvenWeight: e["ln-proven-weight"], votersCommitment: e["voters-commitment"] });
  }
}, Xn = class extends Re {
  constructor({ hashFactory: e, path: r3, treeDepth: i }) {
    super(), this.hashFactory = e, this.path = r3, this.treeDepth = i, this.attribute_map = { hashFactory: "hash-factory", path: "path", treeDepth: "tree-depth" };
  }
  static from_obj_for_encoding(e) {
    return new Xn({ hashFactory: typeof e["hash-factory"] < "u" ? Ra.from_obj_for_encoding(e["hash-factory"]) : void 0, path: e.path, treeDepth: e["tree-depth"] });
  }
}, Da = class extends Re {
  constructor({ address: e, amount: r3, isFrozen: i, deleted: n, optedInAtRound: s, optedOutAtRound: o }) {
    super(), this.address = e, this.amount = r3, this.isFrozen = i, this.deleted = n, this.optedInAtRound = s, this.optedOutAtRound = o, this.attribute_map = { address: "address", amount: "amount", isFrozen: "is-frozen", deleted: "deleted", optedInAtRound: "opted-in-at-round", optedOutAtRound: "opted-out-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["is-frozen"] > "u")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new Da({ address: e.address, amount: e.amount, isFrozen: e["is-frozen"], deleted: e.deleted, optedInAtRound: e["opted-in-at-round"], optedOutAtRound: e["opted-out-at-round"] });
  }
}, Na = class extends Re {
  constructor({ expiredParticipationAccounts: e }) {
    super(), this.expiredParticipationAccounts = e, this.attribute_map = { expiredParticipationAccounts: "expired-participation-accounts" };
  }
  static from_obj_for_encoding(e) {
    return new Na({ expiredParticipationAccounts: e["expired-participation-accounts"] });
  }
}, Ba = class extends Re {
  constructor({ partProofs: e, positionsToReveal: r3, reveals: i, saltVersion: n, sigCommit: s, sigProofs: o, signedWeight: f2 }) {
    super(), this.partProofs = e, this.positionsToReveal = r3, this.reveals = i, this.saltVersion = n, this.sigCommit = typeof s == "string" ? new Uint8Array(Tt.Buffer.from(s, "base64")) : s, this.sigProofs = o, this.signedWeight = f2, this.attribute_map = { partProofs: "part-proofs", positionsToReveal: "positions-to-reveal", reveals: "reveals", saltVersion: "salt-version", sigCommit: "sig-commit", sigProofs: "sig-proofs", signedWeight: "signed-weight" };
  }
  static from_obj_for_encoding(e) {
    return new Ba({ partProofs: typeof e["part-proofs"] < "u" ? Xn.from_obj_for_encoding(e["part-proofs"]) : void 0, positionsToReveal: e["positions-to-reveal"], reveals: typeof e.reveals < "u" ? e.reveals.map(Oa.from_obj_for_encoding) : void 0, saltVersion: e["salt-version"], sigCommit: e["sig-commit"], sigProofs: typeof e["sig-proofs"] < "u" ? Xn.from_obj_for_encoding(e["sig-proofs"]) : void 0, signedWeight: e["signed-weight"] });
  }
}, Ca = class extends Re {
  constructor({ verifier: e, weight: r3 }) {
    super(), this.verifier = e, this.weight = r3, this.attribute_map = { verifier: "verifier", weight: "weight" };
  }
  static from_obj_for_encoding(e) {
    return new Ca({ verifier: typeof e.verifier < "u" ? Pa.from_obj_for_encoding(e.verifier) : void 0, weight: e.weight });
  }
}, Oa = class extends Re {
  constructor({ participant: e, position: r3, sigSlot: i }) {
    super(), this.participant = e, this.position = r3, this.sigSlot = i, this.attribute_map = { participant: "participant", position: "position", sigSlot: "sig-slot" };
  }
  static from_obj_for_encoding(e) {
    return new Oa({ participant: typeof e.participant < "u" ? Ca.from_obj_for_encoding(e.participant) : void 0, position: e.position, sigSlot: typeof e["sig-slot"] < "u" ? ja.from_obj_for_encoding(e["sig-slot"]) : void 0 });
  }
}, ja = class extends Re {
  constructor({ lowerSigWeight: e, signature: r3 }) {
    super(), this.lowerSigWeight = e, this.signature = r3, this.attribute_map = { lowerSigWeight: "lower-sig-weight", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    return new ja({ lowerSigWeight: e["lower-sig-weight"], signature: typeof e.signature < "u" ? La.from_obj_for_encoding(e.signature) : void 0 });
  }
}, La = class extends Re {
  constructor({ falconSignature: e, merkleArrayIndex: r3, proof: i, verifyingKey: n }) {
    super(), this.falconSignature = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.merkleArrayIndex = r3, this.proof = i, this.verifyingKey = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.attribute_map = { falconSignature: "falcon-signature", merkleArrayIndex: "merkle-array-index", proof: "proof", verifyingKey: "verifying-key" };
  }
  static from_obj_for_encoding(e) {
    return new La({ falconSignature: e["falcon-signature"], merkleArrayIndex: e["merkle-array-index"], proof: typeof e.proof < "u" ? Xn.from_obj_for_encoding(e.proof) : void 0, verifyingKey: e["verifying-key"] });
  }
}, qa = class extends Re {
  constructor({ nextRound: e, onlineTotalWeight: r3, type: i, votersCommitment: n }) {
    super(), this.nextRound = e, this.onlineTotalWeight = r3, this.type = i, this.votersCommitment = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.attribute_map = { nextRound: "next-round", onlineTotalWeight: "online-total-weight", type: "type", votersCommitment: "voters-commitment" };
  }
  static from_obj_for_encoding(e) {
    return new qa({ nextRound: e["next-round"], onlineTotalWeight: e["online-total-weight"], type: e.type, votersCommitment: e["voters-commitment"] });
  }
}, Pa = class extends Re {
  constructor({ commitment: e, keyLifetime: r3 }) {
    super(), this.commitment = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.keyLifetime = r3, this.attribute_map = { commitment: "commitment", keyLifetime: "key-lifetime" };
  }
  static from_obj_for_encoding(e) {
    return new Pa({ commitment: e.commitment, keyLifetime: e["key-lifetime"] });
  }
}, uo = class extends Re {
  constructor({ numByteSlice: e, numUint: r3 }) {
    super(), this.numByteSlice = e, this.numUint = r3, this.attribute_map = { numByteSlice: "num-byte-slice", numUint: "num-uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-byte-slice"] > "u")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    if (typeof e["num-uint"] > "u")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    return new uo({ numByteSlice: e["num-byte-slice"], numUint: e["num-uint"] });
  }
}, lo = class extends Re {
  constructor({ key: e, value: r3 }) {
    super(), this.key = e, this.value = r3, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new lo({ key: e.key, value: Ua.from_obj_for_encoding(e.value) });
  }
}, Ua = class extends Re {
  constructor({ bytes: e, type: r3, uint: i }) {
    super(), this.bytes = e, this.type = r3, this.uint = i, this.attribute_map = { bytes: "bytes", type: "type", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.bytes > "u")
      throw new Error(`Response is missing required field 'bytes': ${e}`);
    if (typeof e.type > "u")
      throw new Error(`Response is missing required field 'type': ${e}`);
    if (typeof e.uint > "u")
      throw new Error(`Response is missing required field 'uint': ${e}`);
    return new Ua({ bytes: e.bytes, type: e.type, uint: e.uint });
  }
}, Mn = class extends Re {
  constructor({ fee: e, firstValid: r3, lastValid: i, sender: n, applicationTransaction: s, assetConfigTransaction: o, assetFreezeTransaction: f2, assetTransferTransaction: l, authAddr: g5, closeRewards: _, closingAmount: N2, confirmedRound: U2, createdApplicationIndex: V, createdAssetIndex: G, genesisHash: ee2, genesisId: W5, globalStateDelta: Z, group: le, id: be2, innerTxns: Ae, intraRoundOffset: me, keyregTransaction: H5, lease: ue, localStateDelta: se2, logs: ne2, note: E2, paymentTransaction: c, receiverRewards: m2, rekeyTo: h2, roundTime: a, senderRewards: u3, signature: b2, stateProofTransaction: A2, txType: v2 }) {
    super(), this.fee = e, this.firstValid = r3, this.lastValid = i, this.sender = n, this.applicationTransaction = s, this.assetConfigTransaction = o, this.assetFreezeTransaction = f2, this.assetTransferTransaction = l, this.authAddr = g5, this.closeRewards = _, this.closingAmount = N2, this.confirmedRound = U2, this.createdApplicationIndex = V, this.createdAssetIndex = G, this.genesisHash = typeof ee2 == "string" ? new Uint8Array(Tt.Buffer.from(ee2, "base64")) : ee2, this.genesisId = W5, this.globalStateDelta = Z, this.group = typeof le == "string" ? new Uint8Array(Tt.Buffer.from(le, "base64")) : le, this.id = be2, this.innerTxns = Ae, this.intraRoundOffset = me, this.keyregTransaction = H5, this.lease = typeof ue == "string" ? new Uint8Array(Tt.Buffer.from(ue, "base64")) : ue, this.localStateDelta = se2, this.logs = ne2, this.note = typeof E2 == "string" ? new Uint8Array(Tt.Buffer.from(E2, "base64")) : E2, this.paymentTransaction = c, this.receiverRewards = m2, this.rekeyTo = h2, this.roundTime = a, this.senderRewards = u3, this.signature = b2, this.stateProofTransaction = A2, this.txType = v2, this.attribute_map = { fee: "fee", firstValid: "first-valid", lastValid: "last-valid", sender: "sender", applicationTransaction: "application-transaction", assetConfigTransaction: "asset-config-transaction", assetFreezeTransaction: "asset-freeze-transaction", assetTransferTransaction: "asset-transfer-transaction", authAddr: "auth-addr", closeRewards: "close-rewards", closingAmount: "closing-amount", confirmedRound: "confirmed-round", createdApplicationIndex: "created-application-index", createdAssetIndex: "created-asset-index", genesisHash: "genesis-hash", genesisId: "genesis-id", globalStateDelta: "global-state-delta", group: "group", id: "id", innerTxns: "inner-txns", intraRoundOffset: "intra-round-offset", keyregTransaction: "keyreg-transaction", lease: "lease", localStateDelta: "local-state-delta", logs: "logs", note: "note", paymentTransaction: "payment-transaction", receiverRewards: "receiver-rewards", rekeyTo: "rekey-to", roundTime: "round-time", senderRewards: "sender-rewards", signature: "signature", stateProofTransaction: "state-proof-transaction", txType: "tx-type" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.fee > "u")
      throw new Error(`Response is missing required field 'fee': ${e}`);
    if (typeof e["first-valid"] > "u")
      throw new Error(`Response is missing required field 'first-valid': ${e}`);
    if (typeof e["last-valid"] > "u")
      throw new Error(`Response is missing required field 'last-valid': ${e}`);
    if (typeof e.sender > "u")
      throw new Error(`Response is missing required field 'sender': ${e}`);
    return new Mn({ fee: e.fee, firstValid: e["first-valid"], lastValid: e["last-valid"], sender: e.sender, applicationTransaction: typeof e["application-transaction"] < "u" ? za.from_obj_for_encoding(e["application-transaction"]) : void 0, assetConfigTransaction: typeof e["asset-config-transaction"] < "u" ? Ha.from_obj_for_encoding(e["asset-config-transaction"]) : void 0, assetFreezeTransaction: typeof e["asset-freeze-transaction"] < "u" ? Ka.from_obj_for_encoding(e["asset-freeze-transaction"]) : void 0, assetTransferTransaction: typeof e["asset-transfer-transaction"] < "u" ? Ga.from_obj_for_encoding(e["asset-transfer-transaction"]) : void 0, authAddr: e["auth-addr"], closeRewards: e["close-rewards"], closingAmount: e["closing-amount"], confirmedRound: e["confirmed-round"], createdApplicationIndex: e["created-application-index"], createdAssetIndex: e["created-asset-index"], genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], globalStateDelta: typeof e["global-state-delta"] < "u" ? e["global-state-delta"].map(co.from_obj_for_encoding) : void 0, group: e.group, id: e.id, innerTxns: typeof e["inner-txns"] < "u" ? e["inner-txns"].map(Mn.from_obj_for_encoding) : void 0, intraRoundOffset: e["intra-round-offset"], keyregTransaction: typeof e["keyreg-transaction"] < "u" ? $a.from_obj_for_encoding(e["keyreg-transaction"]) : void 0, lease: e.lease, localStateDelta: typeof e["local-state-delta"] < "u" ? e["local-state-delta"].map(_a.from_obj_for_encoding) : void 0, logs: e.logs, note: e.note, paymentTransaction: typeof e["payment-transaction"] < "u" ? Wa.from_obj_for_encoding(e["payment-transaction"]) : void 0, receiverRewards: e["receiver-rewards"], rekeyTo: e["rekey-to"], roundTime: e["round-time"], senderRewards: e["sender-rewards"], signature: typeof e.signature < "u" ? Va.from_obj_for_encoding(e.signature) : void 0, stateProofTransaction: typeof e["state-proof-transaction"] < "u" ? Ja.from_obj_for_encoding(e["state-proof-transaction"]) : void 0, txType: e["tx-type"] });
  }
}, za = class extends Re {
  constructor({ applicationId: e, accounts: r3, applicationArgs: i, approvalProgram: n, clearStateProgram: s, extraProgramPages: o, foreignApps: f2, foreignAssets: l, globalStateSchema: g5, localStateSchema: _, onCompletion: N2 }) {
    super(), this.applicationId = e, this.accounts = r3, this.applicationArgs = i, this.approvalProgram = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.clearStateProgram = typeof s == "string" ? new Uint8Array(Tt.Buffer.from(s, "base64")) : s, this.extraProgramPages = o, this.foreignApps = f2, this.foreignAssets = l, this.globalStateSchema = g5, this.localStateSchema = _, this.onCompletion = N2, this.attribute_map = { applicationId: "application-id", accounts: "accounts", applicationArgs: "application-args", approvalProgram: "approval-program", clearStateProgram: "clear-state-program", extraProgramPages: "extra-program-pages", foreignApps: "foreign-apps", foreignAssets: "foreign-assets", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema", onCompletion: "on-completion" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] > "u")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    return new za({ applicationId: e["application-id"], accounts: e.accounts, applicationArgs: e["application-args"], approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], extraProgramPages: e["extra-program-pages"], foreignApps: e["foreign-apps"], foreignAssets: e["foreign-assets"], globalStateSchema: typeof e["global-state-schema"] < "u" ? uo.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] < "u" ? uo.from_obj_for_encoding(e["local-state-schema"]) : void 0, onCompletion: e["on-completion"] });
  }
}, Ha = class extends Re {
  constructor({ assetId: e, params: r3 }) {
    super(), this.assetId = e, this.params = r3, this.attribute_map = { assetId: "asset-id", params: "params" };
  }
  static from_obj_for_encoding(e) {
    return new Ha({ assetId: e["asset-id"], params: typeof e.params < "u" ? oo.from_obj_for_encoding(e.params) : void 0 });
  }
}, Ka = class extends Re {
  constructor({ address: e, assetId: r3, newFreezeStatus: i }) {
    super(), this.address = e, this.assetId = r3, this.newFreezeStatus = i, this.attribute_map = { address: "address", assetId: "asset-id", newFreezeStatus: "new-freeze-status" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["new-freeze-status"] > "u")
      throw new Error(`Response is missing required field 'new-freeze-status': ${e}`);
    return new Ka({ address: e.address, assetId: e["asset-id"], newFreezeStatus: e["new-freeze-status"] });
  }
}, Ga = class extends Re {
  constructor({ amount: e, assetId: r3, receiver: i, closeAmount: n, closeTo: s, sender: o }) {
    super(), this.amount = e, this.assetId = r3, this.receiver = i, this.closeAmount = n, this.closeTo = s, this.sender = o, this.attribute_map = { amount: "amount", assetId: "asset-id", receiver: "receiver", closeAmount: "close-amount", closeTo: "close-to", sender: "sender" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e.receiver > "u")
      throw new Error(`Response is missing required field 'receiver': ${e}`);
    return new Ga({ amount: e.amount, assetId: e["asset-id"], receiver: e.receiver, closeAmount: e["close-amount"], closeTo: e["close-to"], sender: e.sender });
  }
}, $a = class extends Re {
  constructor({ nonParticipation: e, selectionParticipationKey: r3, stateProofKey: i, voteFirstValid: n, voteKeyDilution: s, voteLastValid: o, voteParticipationKey: f2 }) {
    super(), this.nonParticipation = e, this.selectionParticipationKey = typeof r3 == "string" ? new Uint8Array(Tt.Buffer.from(r3, "base64")) : r3, this.stateProofKey = typeof i == "string" ? new Uint8Array(Tt.Buffer.from(i, "base64")) : i, this.voteFirstValid = n, this.voteKeyDilution = s, this.voteLastValid = o, this.voteParticipationKey = typeof f2 == "string" ? new Uint8Array(Tt.Buffer.from(f2, "base64")) : f2, this.attribute_map = { nonParticipation: "non-participation", selectionParticipationKey: "selection-participation-key", stateProofKey: "state-proof-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key" };
  }
  static from_obj_for_encoding(e) {
    return new $a({ nonParticipation: e["non-participation"], selectionParticipationKey: e["selection-participation-key"], stateProofKey: e["state-proof-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"] });
  }
}, Wa = class extends Re {
  constructor({ amount: e, receiver: r3, closeAmount: i, closeRemainderTo: n }) {
    super(), this.amount = e, this.receiver = r3, this.closeAmount = i, this.closeRemainderTo = n, this.attribute_map = { amount: "amount", receiver: "receiver", closeAmount: "close-amount", closeRemainderTo: "close-remainder-to" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e.receiver > "u")
      throw new Error(`Response is missing required field 'receiver': ${e}`);
    return new Wa({ amount: e.amount, receiver: e.receiver, closeAmount: e["close-amount"], closeRemainderTo: e["close-remainder-to"] });
  }
}, Bu = class extends Re {
  constructor({ currentRound: e, transaction: r3 }) {
    super(), this.currentRound = e, this.transaction = r3, this.attribute_map = { currentRound: "current-round", transaction: "transaction" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    if (typeof e.transaction > "u")
      throw new Error(`Response is missing required field 'transaction': ${e}`);
    return new Bu({ currentRound: e["current-round"], transaction: Mn.from_obj_for_encoding(e.transaction) });
  }
}, Va = class extends Re {
  constructor({ logicsig: e, multisig: r3, sig: i }) {
    super(), this.logicsig = e, this.multisig = r3, this.sig = typeof i == "string" ? new Uint8Array(Tt.Buffer.from(i, "base64")) : i, this.attribute_map = { logicsig: "logicsig", multisig: "multisig", sig: "sig" };
  }
  static from_obj_for_encoding(e) {
    return new Va({ logicsig: typeof e.logicsig < "u" ? Ya.from_obj_for_encoding(e.logicsig) : void 0, multisig: typeof e.multisig < "u" ? ho.from_obj_for_encoding(e.multisig) : void 0, sig: e.sig });
  }
}, Ya = class extends Re {
  constructor({ logic: e, args: r3, multisigSignature: i, signature: n }) {
    super(), this.logic = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.args = r3, this.multisigSignature = i, this.signature = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.attribute_map = { logic: "logic", args: "args", multisigSignature: "multisig-signature", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.logic > "u")
      throw new Error(`Response is missing required field 'logic': ${e}`);
    return new Ya({ logic: e.logic, args: e.args, multisigSignature: typeof e["multisig-signature"] < "u" ? ho.from_obj_for_encoding(e["multisig-signature"]) : void 0, signature: e.signature });
  }
}, ho = class extends Re {
  constructor({ subsignature: e, threshold: r3, version: i }) {
    super(), this.subsignature = e, this.threshold = r3, this.version = i, this.attribute_map = { subsignature: "subsignature", threshold: "threshold", version: "version" };
  }
  static from_obj_for_encoding(e) {
    return new ho({ subsignature: typeof e.subsignature < "u" ? e.subsignature.map(Za.from_obj_for_encoding) : void 0, threshold: e.threshold, version: e.version });
  }
}, Za = class extends Re {
  constructor({ publicKey: e, signature: r3 }) {
    super(), this.publicKey = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.signature = typeof r3 == "string" ? new Uint8Array(Tt.Buffer.from(r3, "base64")) : r3, this.attribute_map = { publicKey: "public-key", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    return new Za({ publicKey: e["public-key"], signature: e.signature });
  }
}, Ja = class extends Re {
  constructor({ message: e, stateProof: r3, stateProofType: i }) {
    super(), this.message = e, this.stateProof = r3, this.stateProofType = i, this.attribute_map = { message: "message", stateProof: "state-proof", stateProofType: "state-proof-type" };
  }
  static from_obj_for_encoding(e) {
    return new Ja({ message: typeof e.message < "u" ? ka.from_obj_for_encoding(e.message) : void 0, stateProof: typeof e["state-proof"] < "u" ? Ba.from_obj_for_encoding(e["state-proof"]) : void 0, stateProofType: e["state-proof-type"] });
  }
}, Cu = class extends Re {
  constructor({ currentRound: e, transactions: r3, nextToken: i }) {
    super(), this.currentRound = e, this.transactions = r3, this.nextToken = i, this.attribute_map = { currentRound: "current-round", transactions: "transactions", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    if (!Array.isArray(e.transactions))
      throw new Error(`Response is missing required array field 'transactions': ${e}`);
    return new Cu({ currentRound: e["current-round"], transactions: e.transactions.map(Mn.from_obj_for_encoding), nextToken: e["next-token"] });
  }
};
var Ou = class extends Ce {
  constructor(e, r3, i, n) {
    super(e, r3), this.index = i, this.index = i;
    let s = P3.Buffer.from(n).toString("base64");
    this.query.name = encodeURI(`b64:${s}`);
  }
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  prepare(e) {
    return ao.from_obj_for_encoding(e);
  }
};
U();
var ju = class extends Ce {
  path() {
    return "/v2/accounts";
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  authAddr(e) {
    return this.query["auth-addr"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
U();
var Lu = class extends Ce {
  path() {
    return "/v2/transactions";
  }
  notePrefix(e) {
    return this.query["note-prefix"] = cu(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  addressRole(e) {
    return this.query["address-role"] = e, this;
  }
  address(e) {
    return this.query.address = e, this;
  }
  excludeCloseTo(e) {
    return this.query["exclude-close-to"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
U();
var qu = class extends Ce {
  path() {
    return "/v2/assets";
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  creator(e) {
    return this.query.creator = e, this;
  }
  name(e) {
    return this.query.name = e, this;
  }
  unit(e) {
    return this.query.unit = e, this;
  }
  index(e) {
    return this.query["asset-id"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var Pu = class extends Ce {
  path() {
    return "/v2/applications";
  }
  index(e) {
    return this.query["application-id"] = e, this;
  }
  creator(e) {
    return this.query.creator = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var Uu = class extends Ce {
  constructor(e, r3, i) {
    super(e, r3), this.index = i, this.index = i;
  }
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  prepare(e) {
    return fo.from_obj_for_encoding(e);
  }
};
var po = class extends wn {
  constructor(e, r3 = "http://127.0.0.1", i = 8080, n = {}) {
    super("X-Indexer-API-Token", e, r3, i, n);
  }
  makeHealthCheck() {
    return new ou(this.c, this.intDecoding);
  }
  lookupAssetBalances(e) {
    return new au(this.c, this.intDecoding, e);
  }
  lookupAssetTransactions(e) {
    return new uu(this.c, this.intDecoding, e);
  }
  lookupAccountTransactions(e) {
    return new fu(this.c, this.intDecoding, e);
  }
  lookupBlock(e) {
    return new du(this.c, this.intDecoding, e);
  }
  lookupTransactionByID(e) {
    return new lu(this.c, this.intDecoding, e);
  }
  lookupAccountByID(e) {
    return new hu(this.c, this.intDecoding, e);
  }
  lookupAccountAssets(e) {
    return new pu(this.c, this.intDecoding, e);
  }
  lookupAccountCreatedAssets(e) {
    return new gu(this.c, this.intDecoding, e);
  }
  lookupAccountAppLocalStates(e) {
    return new mu(this.c, this.intDecoding, e);
  }
  lookupAccountCreatedApplications(e) {
    return new yu(this.c, this.intDecoding, e);
  }
  lookupAssetByID(e) {
    return new bu(this.c, this.intDecoding, e);
  }
  lookupApplications(e) {
    return new vu(this.c, this.intDecoding, e);
  }
  lookupApplicationLogs(e) {
    return new xu(this.c, this.intDecoding, e);
  }
  searchAccounts() {
    return new ju(this.c, this.intDecoding);
  }
  searchForTransactions() {
    return new Lu(this.c, this.intDecoding);
  }
  searchForAssets() {
    return new qu(this.c, this.intDecoding);
  }
  searchForApplications() {
    return new Pu(this.c, this.intDecoding);
  }
  searchForApplicationBoxes(e) {
    return new Uu(this.c, this.intDecoding, e);
  }
  lookupApplicationBoxByIDandName(e, r3) {
    return new Ou(this.c, this.intDecoding, e, r3);
  }
};
U();
async function vh(t, e, r3) {
  let i = await t.status().do();
  if (typeof i > "u")
    throw new Error("Unable to get node status");
  let n = i["last-round"] + 1, s = n;
  for (; s < n + r3; ) {
    let o = false;
    try {
      let f2 = await t.pendingTransactionInformation(e).do();
      if (f2["confirmed-round"])
        return f2;
      if (f2["pool-error"])
        throw o = true, new Error(`Transaction Rejected: ${f2["pool-error"]}`);
    } catch (f2) {
      if (o)
        throw f2;
    }
    await t.statusAfterBlock(s).do(), s += 1;
  }
  throw new Error(`Transaction not confirmed after ${r3} rounds`);
}
U();
var U3 = rr(or());
function Sn(t, e) {
  let r3 = t.toString(16);
  r3.length !== e * 2 && (r3 = r3.padStart(e * 2, "0"));
  let i = new Uint8Array(r3.length / 2);
  for (let n = 0, s = 0; n < r3.length / 2; n++, s += 2)
    i[n] = parseInt(r3.slice(s, s + 2), 16);
  return i;
}
function zu(t) {
  let e = BigInt(0), r3 = U3.Buffer.from(t);
  for (let i = 0; i < t.length; i++)
    e = BigInt(Number(r3.readUIntBE(i, 1))) + e * BigInt(256);
  return e;
}
U();
function Hu() {
  let t = t3();
  return { addr: Ue(t.publicKey), sk: t.secretKey };
}
U();
U();
var dF = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"], xh = dF;
var ag = "failed to decode mnemonic", lF = "the mnemonic contains a word that is not in the wordlist";
function z3(t) {
  let e = [], r3 = 0, i = 0;
  function n(o) {
    r3 |= o << i, i += 8, i >= 11 && (e.push(r3 & 2047), r3 >>= 11, i -= 11);
  }
  function s() {
    i && e.push(r3);
  }
  return t.forEach(n), s(), e;
}
function H3(t) {
  return t.map((e) => xh[e]);
}
function K3(t) {
  let e = Rr(t), r3 = z3(e);
  return H3(r3)[0];
}
function wh(t) {
  if (t.length !== ah)
    throw new RangeError(`Seed length must be ${ah}`);
  let e = z3(t), r3 = H3(e), i = K3(t);
  return `${r3.join(" ")} ${i}`;
}
function hF(t) {
  let e = [], r3 = 0, i = 0;
  function n(o) {
    for (r3 |= o << i, i += 11; i >= 8; )
      e.push(r3 & 255), r3 >>= 8, i -= 8;
  }
  function s() {
    i && e.push(r3);
  }
  return t.forEach(n), s(), new Uint8Array(e);
}
function _h(t) {
  let e = t.split(" "), r3 = e.slice(0, 24);
  for (let f2 of r3)
    if (xh.indexOf(f2) === -1)
      throw new Error(lF);
  let i = e[e.length - 1], n = r3.map((f2) => xh.indexOf(f2)), s = hF(n);
  if (s.length !== 33)
    throw new Error(ag);
  if (s[s.length - 1] !== 0)
    throw new Error(ag);
  if (s = s.slice(0, s.length - 1), K3(s) === i)
    return s;
  throw new Error(ag);
}
function go(t) {
  let e = _h(t), r3 = $1(e);
  return { addr: Ue(r3.publicKey), sk: r3.secretKey };
}
function Ah(t) {
  let e = t.slice(0, ah);
  return wh(e);
}
function G3(t) {
  return _h(t);
}
function $3(t) {
  return wh(t);
}
U();
var Xa = rr(or());
var W3 = 16, fg = class {
  constructor(e) {
    if (this.name = "Transaction group", this.tag = Xa.Buffer.from("TG"), e.length > W3) {
      let r3 = `${e.length.toString()} transactions grouped together but max group size is ${W3.toString()}`;
      throw Error(r3);
    }
    this.txGroupHashes = e;
  }
  get_obj_for_encoding() {
    return { txlist: this.txGroupHashes };
  }
  static from_obj_for_encoding(e) {
    let r3 = Object.create(this.prototype);
    r3.name = "Transaction group", r3.tag = Xa.Buffer.from("TG"), r3.txGroupHashes = [];
    for (let i of e.txlist)
      r3.txGroupHashes.push(Xa.Buffer.from(i));
    return r3;
  }
  toByte() {
    return nr(this.get_obj_for_encoding());
  }
};
function cg(t) {
  let e = [];
  for (let o of t) {
    let f2 = ci(o);
    e.push(f2.rawTxID());
  }
  let r3 = new fg(e), i = r3.toByte(), n = Xa.Buffer.from($t(r3.tag, i)), s = Rr(n);
  return Xa.Buffer.from(s);
}
function Eh(t, e) {
  let r3 = cg(t), i = [];
  for (let n of t) {
    let s = ci(n);
    (!e || Ue(s.from.publicKey) === e) && (s.group = r3, i.push(s));
  }
  return i;
}
U();
var In = rr(or());
U();
var Qn = rr(or());
var pF = "Not enough multisig transactions to merge. Need at least two", gF = "Cannot merge txs. txIDs differ", mF = "Cannot merge txs. Auth addrs differ", V3 = "Cannot merge txs. Multisig preimages differ", yF = "Cannot merge txs. subsigs are mismatched.", bF = "Key does not exist", Y3 = "Cannot mutate a multisig field as it would invalidate all existing signatures.", vF = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.", xF = "Cannot add multisig signature. Signature is not of the correct length.";
function ug(t, { version: e, threshold: r3, addrs: i }) {
  let n = i.map((_) => ct(_).publicKey), s = n.map((_) => ({ pk: Qn.Buffer.from(_) })), o = { v: e, thr: r3, subsig: s }, f2 = t.get_obj_for_encoding(), l = { msig: o, txn: f2 }, g5 = $i({ version: e, threshold: r3, pks: n });
  return Ue(f2.snd) !== Ue(g5) && (l.sgnr = Qn.Buffer.from(g5)), new Uint8Array(nr(l));
}
function Z3(t, { rawSig: e, myPk: r3 }, { version: i, threshold: n, pks: s }) {
  let o = ug(t, { version: i, threshold: n, addrs: s.map((_) => Ue(_)) }), f2 = sr(o), l = false;
  if (f2.msig.subsig.forEach((_, N2) => {
    oh(_.pk, r3) && (l = true, f2.msig.subsig[N2].s = e);
  }), l === false)
    throw new Error(bF);
  let g5 = $i({ version: i, threshold: n, pks: s });
  return Ue(f2.txn.snd) !== Ue(g5) && (f2.sgnr = Qn.Buffer.from(g5)), new Uint8Array(nr(f2));
}
var es = class extends zt {
  addLease() {
    throw new Error(Y3);
  }
  addRekey() {
    throw new Error(Y3);
  }
  signTxn(e) {
    throw new Error(vF);
  }
  partialSignTxn({ version: e, threshold: r3, pks: i }, n) {
    let s = mn(n).publicKey;
    return Z3(this, { rawSig: this.rawSignTxn(n), myPk: s }, { version: e, threshold: r3, pks: i });
  }
  partialSignWithMultisigSignature(e, r3, i) {
    if (!sh(i.length))
      throw new Error(xF);
    return Z3(this, { rawSig: i, myPk: ct(r3).publicKey }, e);
  }
  static from_obj_for_encoding(e) {
    return super.from_obj_for_encoding(e);
  }
};
function Qa(t) {
  if (t.length < 2)
    throw new Error(pF);
  let e = sr(t[0]), r3 = es.from_obj_for_encoding(e.txn).txID(), i = e.sgnr ? Ue(e.sgnr) : void 0, n = { version: e.msig.v, threshold: e.msig.thr, pks: e.msig.subsig.map((g5) => g5.pk) }, s = Ue($i(n)), o = e.msig.subsig.map((g5) => ({ ...g5 }));
  for (let g5 = 1; g5 < t.length; g5++) {
    let _ = sr(t[g5]);
    if (es.from_obj_for_encoding(_.txn).txID() !== r3)
      throw new Error(gF);
    let U2 = _.sgnr ? Ue(_.sgnr) : void 0;
    if (i !== U2)
      throw new Error(mF);
    if (_.msig.subsig.length !== e.msig.subsig.length)
      throw new Error(V3);
    let V = { version: _.msig.v, threshold: _.msig.thr, pks: _.msig.subsig.map((ee2) => ee2.pk) }, G = Ue($i(V));
    if (s !== G)
      throw new Error(V3);
    _.msig.subsig.forEach((ee2, W5) => {
      if (!ee2.s)
        return;
      let Z = o[W5];
      if (Z.s && Qn.Buffer.compare(Qn.Buffer.from(ee2.s), Qn.Buffer.from(Z.s)) !== 0)
        throw new Error(yF);
      Z.s = ee2.s;
    });
  }
  let l = { msig: { v: e.msig.v, thr: e.msig.thr, subsig: o }, txn: e.txn };
  return typeof i < "u" && (l.sgnr = Qn.Buffer.from(ct(i).publicKey)), new Uint8Array(nr(l));
}
function Mh(t, e, r3) {
  let i = e.v, n = e.thr, s = e.subsig, o = s.map((_) => _.pk);
  if (e.subsig.length < n)
    return false;
  let f2;
  try {
    f2 = $i({ version: i, threshold: n, pks: o });
  } catch {
    return false;
  }
  if (!Hs(f2, r3))
    return false;
  let l = 0;
  for (let _ of s)
    _.s !== void 0 && (l += 1);
  if (l < n)
    return false;
  let g5 = 0;
  for (let _ of s)
    _.s !== void 0 && zs(t, _.s, _.pk) && (g5 += 1);
  return !(g5 < n);
}
function Sh(t, { version: e, threshold: r3, addrs: i }, n) {
  let s = X1({ version: e, threshold: r3, addrs: i });
  Object.prototype.hasOwnProperty.call(t, "from") || (t.from = s);
  let o = i.map((_) => ct(_).publicKey), f2 = t instanceof zt, l, g5;
  return f2 ? (l = t, g5 = es.prototype.partialSignTxn.call(l, { version: e, threshold: r3, pks: o }, n)) : (l = new es(t), g5 = l.partialSignTxn({ version: e, threshold: r3, pks: o }, n)), { txID: l.txID().toString(), blob: g5 };
}
function J3(t, { version: e, threshold: r3, addrs: i }, n) {
  let s = i.map((g5) => ct(g5).publicKey), o = sr(t), f2 = es.from_obj_for_encoding(o.txn), l = f2.partialSignTxn({ version: e, threshold: r3, pks: s }, n);
  return { txID: f2.txID().toString(), blob: Qa([t, l]) };
}
function X3(t, { version: e, threshold: r3, addrs: i }, n, s) {
  let o = i.map((_) => ct(_).publicKey), f2 = sr(t), l = es.from_obj_for_encoding(f2.txn), g5 = l.partialSignWithMultisigSignature({ version: e, threshold: r3, pks: o }, n, s);
  return { txID: l.txID().toString(), blob: Qa([t, g5]) };
}
function Q3({ version: t, threshold: e, addrs: r3 }) {
  return X1({ version: t, threshold: e, addrs: r3 });
}
function e4(t) {
  if (!t || t.length === 0)
    throw new Error("empty program");
  let e = `
`.charCodeAt(0), r3 = " ".charCodeAt(0), i = "~".charCodeAt(0), n = (o) => r3 <= o && o <= i;
  if (t.every((o) => o === e || n(o))) {
    let o = In.Buffer.from(t).toString();
    throw aa(o) ? new Error("requesting program bytes, get Algorand address") : In.Buffer.from(o, "base64").toString("base64") === o ? new Error("program should not be b64 encoded") : new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
var Ri = class {
  constructor(e, r3) {
    if (this.tag = In.Buffer.from("Program"), r3 && (!Array.isArray(r3) || !r3.every((n) => n.constructor === Uint8Array || In.Buffer.isBuffer(n))))
      throw new TypeError("Invalid arguments");
    let i;
    r3 != null && (i = r3.map((n) => new Uint8Array(n))), e4(e), this.logic = e, this.args = i, this.sig = void 0, this.msig = void 0;
  }
  get_obj_for_encoding() {
    let e = { l: this.logic };
    return this.args && (e.arg = this.args), this.sig ? e.sig = this.sig : this.msig && (e.msig = this.msig), e;
  }
  static from_obj_for_encoding(e) {
    let r3 = new Ri(e.l, e.arg);
    return r3.sig = e.sig, r3.msig = e.msig, r3;
  }
  verify(e) {
    if (this.sig && this.msig)
      return false;
    try {
      e4(this.logic);
    } catch {
      return false;
    }
    let r3 = $t(this.tag, this.logic);
    if (!this.sig && !this.msig) {
      let i = Rr(r3);
      return Hs(i, e);
    }
    return this.sig ? zs(r3, this.sig, e) : Mh(r3, this.msig, e);
  }
  address() {
    let e = $t(this.tag, this.logic), r3 = Rr(e);
    return Ue(new Uint8Array(r3));
  }
  sign(e, r3) {
    if (r3 == null)
      this.sig = this.signProgram(e);
    else {
      let i = r3.addrs.map((o) => ({ pk: ct(o).publicKey }));
      this.msig = { v: r3.version, thr: r3.threshold, subsig: i };
      let [n, s] = this.singleSignMultisig(e, this.msig);
      this.msig.subsig[s].s = n;
    }
  }
  appendToMultisig(e) {
    if (this.msig === void 0)
      throw new Error("no multisig present");
    let [r3, i] = this.singleSignMultisig(e, this.msig);
    this.msig.subsig[i].s = r3;
  }
  signProgram(e) {
    let r3 = $t(this.tag, this.logic);
    return yn(r3, e);
  }
  singleSignMultisig(e, r3) {
    let i = -1, n = mn(e).publicKey;
    for (let o = 0; o < r3.subsig.length; o++) {
      let { pk: f2 } = r3.subsig[o];
      if (Hs(f2, n)) {
        i = o;
        break;
      }
    }
    if (i === -1)
      throw new Error("invalid secret key");
    return [this.signProgram(e), i];
  }
  toByte() {
    return nr(this.get_obj_for_encoding());
  }
  static fromByte(e) {
    let r3 = sr(e);
    return Ri.from_obj_for_encoding(r3);
  }
}, Vi = class {
  constructor(e, r3) {
    this.lsig = new Ri(e, r3), this.sigkey = void 0;
  }
  get_obj_for_encoding() {
    let e = { lsig: this.lsig.get_obj_for_encoding() };
    return this.sigkey && (e.sigkey = this.sigkey), e;
  }
  static from_obj_for_encoding(e) {
    let r3 = new Vi(e.lsig.l, e.lsig.arg);
    return r3.lsig = Ri.from_obj_for_encoding(e.lsig), r3.sigkey = e.sigkey, r3;
  }
  toByte() {
    return nr(this.get_obj_for_encoding());
  }
  static fromByte(e) {
    let r3 = sr(e);
    return Vi.from_obj_for_encoding(r3);
  }
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig);
  }
  verify() {
    let e = this.address();
    return this.lsig.verify(ct(e).publicKey);
  }
  address() {
    if (this.lsig.sig && this.lsig.msig)
      throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
    if (this.lsig.sig) {
      if (!this.sigkey)
        throw new Error("Signing key for delegated account is missing");
      return Ue(this.sigkey);
    }
    if (this.lsig.msig) {
      let e = { version: this.lsig.msig.v, threshold: this.lsig.msig.thr, pks: this.lsig.msig.subsig.map((r3) => r3.pk) };
      return Ue($i(e));
    }
    return this.lsig.address();
  }
  signMultisig(e, r3) {
    this.lsig.sign(r3, e);
  }
  appendToMultisig(e) {
    this.lsig.appendToMultisig(e);
  }
  sign(e) {
    this.lsig.sign(e), this.sigkey = mn(e).publicKey;
  }
};
function wF(t, e, r3) {
  if (!e.verify(r3))
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  let i = { lsig: e.get_obj_for_encoding(), txn: t.get_obj_for_encoding() };
  return oh(r3, t.from.publicKey) || (i.sgnr = In.Buffer.from(r3)), { txID: t.txID().toString(), blob: nr(i) };
}
function mo(t, e) {
  let r3, i;
  if (e instanceof Vi)
    r3 = e.lsig, i = ct(e.address()).publicKey;
  else if (r3 = e, r3.sig)
    i = t.from.publicKey;
  else if (r3.msig) {
    let n = { version: r3.msig.v, threshold: r3.msig.thr, pks: r3.msig.subsig.map((s) => s.pk) };
    i = $i(n);
  } else
    i = ct(r3.address()).publicKey;
  return wF(t, r3, i);
}
function t4(t, e) {
  let r3 = ci(t);
  return mo(r3, e);
}
function r4(t) {
  return Ri.fromByte(t);
}
var i4 = In.Buffer.from("ProgData");
function dg(t, e, r3) {
  let i = $t(ct(r3).publicKey, e), n = In.Buffer.from($t(i4, i));
  return yn(n, t);
}
function n4(t, e, r3, i) {
  let n = $t(ct(e).publicKey, t), s = In.Buffer.from($t(i4, n));
  return zs(s, r3, i);
}
function s4(t, e, r3) {
  let n = new Ri(r3).address();
  return dg(t, e, n);
}
U();
U();
var o4 = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(t, e) {
  o4[t] = e;
});
function a4(t) {
  let e = [], r3 = 0, i = 0;
  for (let n = 0; n < t.length; n += 1) {
    let s = o4[t[n]];
    if (s === void 0)
      throw new Error("Invalid character (" + t[n] + ")");
    let o = s & 32;
    if (s &= 31, i += s << r3, o)
      r3 += 5;
    else {
      let f2 = i & 1;
      i >>>= 1, f2 ? e.push(i === 0 ? -2147483648 : -i) : e.push(i), i = r3 = 0;
    }
  }
  return e;
}
var Ih = class {
  constructor({ version: e, sources: r3, names: i, mappings: n }) {
    if (this.version = e, this.sources = r3, this.names = i, this.mappings = n, this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    let s = this.mappings.split(";").map((f2) => {
      let l = a4(f2);
      if (l.length > 2)
        return l[2];
    });
    this.pcToLine = {}, this.lineToPc = {};
    let o = 0;
    for (let [f2, l] of s.entries())
      l !== void 0 && (o += l), o in this.lineToPc || (this.lineToPc[o] = []), this.lineToPc[o].push(f2), this.pcToLine[f2] = o;
  }
  getLineForPc(e) {
    return this.pcToLine[e];
  }
  getPcsForLine(e) {
    return this.lineToPc[e];
  }
};
U();
var ef = rr(or());
U();
U();
var EF = 1380011588, lg = 30;
function f4(t) {
  return t.params["approval-program"] = ef.Buffer.from(t.params["approval-program"].toString(), "base64"), t.params["clear-state-program"] = ef.Buffer.from(t.params["clear-state-program"].toString(), "base64"), t;
}
async function MF({ client: t, txns: e, protocolVersion: r3, latestTimestamp: i, round: n, sources: s }) {
  let o = [], f2 = [], l = [], g5 = [], _ = [];
  for (let G of e)
    G.txn.type === Pt.appl && (_.push(Ue(G.txn.from.publicKey)), G.txn.appAccounts && _.push(...G.txn.appAccounts.map((ee2) => Ue(ee2.publicKey))), G.txn.appForeignApps && (l.push(...G.txn.appForeignApps), _.push(...G.txn.appForeignApps.map((ee2) => Gs(ee2)))), G.txn.appForeignAssets && g5.push(...G.txn.appForeignAssets), G.txn.appIndex === void 0 || G.txn.appIndex === 0 ? o.push(new _n({ id: EF, params: new An({ creator: Ue(G.txn.from.publicKey), approvalProgram: G.txn.appApprovalProgram, clearStateProgram: G.txn.appClearProgram, localStateSchema: new ui({ numUint: G.txn.appLocalInts, numByteSlice: G.txn.appLocalByteSlices }), globalStateSchema: new ui({ numUint: G.txn.appGlobalInts, numByteSlice: G.txn.appGlobalByteSlices }) }) })) : (l.push(G.txn.appIndex), _.push(Gs(G.txn.appIndex))));
  let N2 = [];
  for (let G of [...new Set(g5)])
    N2.push(t.getAssetByID(G).do().then((ee2) => {
      _.push(ee2.params.creator);
    }));
  await Promise.all(N2);
  let U2 = [];
  for (let G of [...new Set(l)])
    U2.push(t.getApplicationByID(G).do().then((ee2) => {
      let W5 = f4(ee2);
      o.push(W5), _.push(W5.params.creator);
    }));
  await Promise.all(U2);
  let V = [];
  for (let G of [...new Set(_)])
    V.push(t.accountInformation(G).do().then((ee2) => {
      "created-apps" in ee2 && (ee2["created-apps"] = ee2["created-apps"].map((W5) => f4(W5))), f2.push(ee2);
    }));
  return await Promise.all(V), new Qs({ txns: e.map((G) => ({ ...G, txn: G.txn.get_obj_for_encoding() })), accounts: f2, apps: o, latestTimestamp: i, round: n, protocolVersion: r3, sources: s });
}
var pg = class {
  constructor(e) {
    this.type = 0, this.bytes = "", this.uint = 0, this.type = e.type, this.bytes = e.bytes, this.uint = e.uint;
  }
  toString() {
    return this.type === 1 ? `0x${ef.Buffer.from(this.bytes, "base64").toString("hex")}` : this.uint.toString();
  }
}, gg = class {
  constructor(e) {
    this.error = "", this.line = 0, this.pc = 0, this.scratch = [], this.stack = [], this.error = e.error === void 0 ? "" : e.error, this.line = e.line, this.pc = e.pc, this.scratch = e.scratch, this.stack = e.stack.map((r3) => new pg(r3));
  }
}, Th = class {
  constructor(e) {
    this.trace = [], e != null && (this.trace = e.map((r3) => new gg(r3)));
  }
};
function hg(t, e) {
  return t.length > e && e > 0 ? `${t.slice(0, e)}...` : t;
}
function SF(t, e) {
  if (e.length === 0)
    return "";
  let r3 = null;
  for (let n = 0; n < e.length; n++) {
    if (n > t.length) {
      r3 = n;
      continue;
    }
    JSON.stringify(t[n]) !== JSON.stringify(e[n]) && (r3 = n);
  }
  if (r3 == null)
    return "";
  let i = e[r3];
  return i.bytes.length > 0 ? `${r3} = 0x${ef.Buffer.from(i.bytes, "base64").toString("hex")}` : `${r3} = ${i.uint.toString()}`;
}
function IF(t, e) {
  return `[${(e ? t.reverse() : t).map((i) => {
    switch (i.type) {
      case 1:
        return `0x${ef.Buffer.from(i.bytes, "base64").toString("hex")}`;
      case 2:
        return `${i.uint.toString()}`;
      default:
        return "";
    }
  }).join(", ")}]`;
}
var tf = class {
  constructor(e) {
    this.disassembly = [], this.appCallMessages = [], this.localDeltas = [], this.globalDelta = [], this.cost = 0, this.logicSigMessages = [], this.logicSigDisassembly = [], this.logs = [], this.appCallTrace = void 0, this.logicSigTrace = void 0, this.required = ["disassembly"], this.optionals = ["app-call-messages", "local-deltas", "global-delta", "cost", "logic-sig-messages", "logic-sig-disassembly", "logs"], this.traces = ["app-call-trace", "logic-sig-trace"], this.disassembly = e.disassembly, this.appCallMessages = e["app-call-messages"], this.localDeltas = e["local-deltas"], this.globalDelta = e["global-delta"], this.cost = e.cost, this.logicSigMessages = e["logic-sig-messages"], this.logicSigDisassembly = e["logic-sig-disassembly"], this.logs = e.logs, this.appCallTrace = new Th(e["app-call-trace"]), this.logicSigTrace = new Th(e["logic-sig-trace"]);
  }
  appCallRejected() {
    return this.appCallMessages !== void 0 && this.appCallMessages.includes("REJECT");
  }
  logicSigRejected() {
    return this.logicSigMessages !== void 0 && this.logicSigMessages.includes("REJECT");
  }
  static trace(e, r3, i) {
    let n = i.maxValueWidth || lg, s = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let f2 = 0; f2 < e.trace.length; f2++) {
      let { line: l, error: g5, pc: _, scratch: N2, stack: U2 } = e.trace[f2], V = N2 !== void 0 ? N2 : [], G = f2 > 0 && e.trace[f2 - 1].scratch !== void 0 ? e.trace[f2 - 1].scratch : [], ee2 = g5 === "" ? r3[l] : `!! ${g5} !!`;
      s.push([_.toString().padEnd(3, " "), l.toString().padEnd(3, " "), hg(ee2, n), hg(SF(G, V), n), hg(IF(U2, i.topOfStackFirst), n)]);
    }
    let o = s.reduce((f2, l) => {
      let g5 = new Array(s[0].length).fill(0);
      for (let _ = 0; _ < f2.length; _++)
        g5[_] = l[_].length > f2[_] ? l[_].length : f2[_];
      return g5;
    }, new Array(s[0].length).fill(0));
    return `${s.map((f2) => f2.map((l, g5) => l.padEnd(o[g5] + 1, " ")).join("|").trim()).join(`
`)}
`;
  }
  appTrace(e) {
    if (this.appCallTrace === void 0 || !this.disassembly)
      return "";
    let r3 = e;
    return e === void 0 && (r3 = { maxValueWidth: lg, topOfStackFirst: false }), tf.trace(this.appCallTrace, this.disassembly, r3);
  }
  lsigTrace(e) {
    if (this.logicSigTrace === void 0 || this.logicSigDisassembly === void 0)
      return "";
    let r3 = e;
    return e === void 0 && (r3 = { maxValueWidth: lg, topOfStackFirst: true }), tf.trace(this.logicSigTrace, this.logicSigDisassembly, r3);
  }
}, mg = class {
  constructor(e) {
    this.error = "", this.protocolVersion = "", this.txns = [], this.error = e.error, this.protocolVersion = e["protocol-version"], this.txns = e.txns.map((r3) => new tf(r3));
  }
};
U();
function c4(t, e, r3, i, n, s, o) {
  let f2 = { from: t, to: e, amount: r3, closeRemainderTo: i, note: n, suggestedParams: s, type: Pt.pay, reKeyTo: o };
  return new zt(f2);
}
function Fh(t) {
  return c4(t.from, t.to, t.amount, t.closeRemainderTo, t.note, t.suggestedParams, t.rekeyTo);
}
function u4(t, e, r3, i, n, s, o, f2, l, g5 = false, _ = void 0) {
  let N2 = { from: t, note: e, voteKey: r3, selectionKey: i, voteFirst: n, voteLast: s, voteKeyDilution: o, suggestedParams: f2, type: Pt.keyreg, reKeyTo: l, nonParticipation: g5, stateProofKey: _ };
  return new zt(N2);
}
function TF(t) {
  return u4(t.from, t.note, t.voteKey, t.selectionKey, t.voteFirst, t.voteLast, t.voteKeyDilution, t.suggestedParams, t.rekeyTo, t.nonParticipation, t.stateProofKey);
}
function Rh(t, e, r3, i, n, s, o, f2, l, g5, _, N2, U2, V, G) {
  let ee2 = { from: t, note: e, suggestedParams: V, assetTotal: r3, assetDecimals: i, assetDefaultFrozen: n, assetUnitName: g5, assetName: _, assetURL: N2, assetMetadataHash: U2, assetManager: s, assetReserve: o, assetFreeze: f2, assetClawback: l, type: Pt.acfg, reKeyTo: G };
  return new zt(ee2);
}
function FF(t) {
  return Rh(t.from, t.note, t.total, t.decimals, t.defaultFrozen, t.manager, t.reserve, t.freeze, t.clawback, t.unitName, t.assetName, t.assetURL, t.assetMetadataHash, t.suggestedParams, t.rekeyTo);
}
function d4(t, e, r3, i, n, s, o, f2, l = true, g5) {
  if (l && (i === void 0 || n === void 0 || s === void 0 || o === void 0))
    throw Error("strict empty address checking was turned on, but at least one empty address was provided");
  let _ = { from: t, suggestedParams: f2, assetIndex: r3, assetManager: i, assetReserve: n, assetFreeze: s, assetClawback: o, type: Pt.acfg, note: e, reKeyTo: g5 };
  return new zt(_);
}
function RF(t) {
  return d4(t.from, t.note, t.assetIndex, t.manager, t.reserve, t.freeze, t.clawback, t.suggestedParams, t.strictEmptyAddressChecking, t.rekeyTo);
}
function kh(t, e, r3, i, n) {
  let s = { from: t, suggestedParams: i, assetIndex: r3, type: Pt.acfg, note: e, reKeyTo: n };
  return new zt(s);
}
function kF(t) {
  return kh(t.from, t.note, t.assetIndex, t.suggestedParams, t.rekeyTo);
}
function l4(t, e, r3, i, n, s, o) {
  let f2 = { from: t, type: Pt.afrz, freezeAccount: i, assetIndex: r3, freezeState: n, note: e, suggestedParams: s, reKeyTo: o };
  return new zt(f2);
}
function DF(t) {
  return l4(t.from, t.note, t.assetIndex, t.freezeTarget, t.freezeState, t.suggestedParams, t.rekeyTo);
}
function h4(t, e, r3, i, n, s, o, f2, l) {
  let g5 = { type: Pt.axfer, from: t, to: e, amount: n, suggestedParams: f2, assetIndex: o, note: s, assetRevocationTarget: i, closeRemainderTo: r3, reKeyTo: l };
  return new zt(g5);
}
function Ku(t) {
  return h4(t.from, t.to, t.closeRemainderTo, t.revocationTarget, t.amount, t.note, t.assetIndex, t.suggestedParams, t.rekeyTo);
}
function Gu(t, e, r3, i, n, s, o, f2, l, g5, _, N2, U2, V, G, ee2, W5, Z) {
  let le = { type: Pt.appl, from: t, suggestedParams: e, appIndex: 0, appOnComplete: r3, appLocalInts: s, appLocalByteSlices: o, appGlobalInts: f2, appGlobalByteSlices: l, appApprovalProgram: i, appClearProgram: n, appArgs: g5, appAccounts: _, appForeignApps: N2, appForeignAssets: U2, boxes: Z, note: V, lease: G, reKeyTo: ee2, extraPages: W5 };
  return new zt(le);
}
function yg(t) {
  return Gu(t.from, t.suggestedParams, t.onComplete, t.approvalProgram, t.clearProgram, t.numLocalInts, t.numLocalByteSlices, t.numGlobalInts, t.numGlobalByteSlices, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.extraPages, t.boxes);
}
function Dh(t, e, r3, i, n, s, o, f2, l, g5, _, N2, U2) {
  let V = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r3, appApprovalProgram: i, appOnComplete: lr.UpdateApplicationOC, appClearProgram: n, appArgs: s, appAccounts: o, appForeignApps: f2, appForeignAssets: l, boxes: U2, note: g5, lease: _, reKeyTo: N2 };
  return new zt(V);
}
function NF(t) {
  return Dh(t.from, t.suggestedParams, t.appIndex, t.approvalProgram, t.clearProgram, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function Nh(t, e, r3, i, n, s, o, f2, l, g5, _) {
  let N2 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r3, appOnComplete: lr.DeleteApplicationOC, appArgs: i, appAccounts: n, appForeignApps: s, appForeignAssets: o, boxes: _, note: f2, lease: l, reKeyTo: g5 };
  return new zt(N2);
}
function BF(t) {
  return Nh(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function p4(t, e, r3, i, n, s, o, f2, l, g5, _) {
  let N2 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r3, appOnComplete: lr.OptInOC, appArgs: i, appAccounts: n, appForeignApps: s, appForeignAssets: o, boxes: _, note: f2, lease: l, reKeyTo: g5 };
  return new zt(N2);
}
function bg(t) {
  return p4(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function g4(t, e, r3, i, n, s, o, f2, l, g5, _) {
  let N2 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r3, appOnComplete: lr.CloseOutOC, appArgs: i, appAccounts: n, appForeignApps: s, appForeignAssets: o, boxes: _, note: f2, lease: l, reKeyTo: g5 };
  return new zt(N2);
}
function vg(t) {
  return g4(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function m4(t, e, r3, i, n, s, o, f2, l, g5, _) {
  let N2 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r3, appOnComplete: lr.ClearStateOC, appArgs: i, appAccounts: n, appForeignApps: s, appForeignAssets: o, boxes: _, note: f2, lease: l, reKeyTo: g5 };
  return new zt(N2);
}
function CF(t) {
  return m4(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function y4(t, e, r3, i, n, s, o, f2, l, g5, _) {
  let N2 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r3, appOnComplete: lr.NoOpOC, appArgs: i, appAccounts: n, appForeignApps: s, appForeignAssets: o, boxes: _, note: f2, lease: l, reKeyTo: g5 };
  return new zt(N2);
}
function Bh(t) {
  return y4(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function xg(t) {
  let e = { type: Pt.appl, from: t.from, suggestedParams: t.suggestedParams, appIndex: t.appIndex, appOnComplete: t.onComplete, appLocalInts: t.numLocalInts, appLocalByteSlices: t.numLocalByteSlices, appGlobalInts: t.numGlobalInts, appGlobalByteSlices: t.numGlobalByteSlices, appApprovalProgram: t.approvalProgram, appClearProgram: t.clearProgram, appArgs: t.appArgs, appAccounts: t.accounts, appForeignApps: t.foreignApps, appForeignAssets: t.foreignAssets, boxes: t.boxes, note: t.note, lease: t.lease, reKeyTo: t.rekeyTo, extraPages: t.extraPages };
  return new zt(e);
}
U();
function OF(t) {
  return (e, r3) => {
    let i = [];
    for (let n of r3)
      i.push(e[n].signTxn(t.sk));
    return Promise.resolve(i);
  };
}
function jF(t) {
  return (e, r3) => {
    let i = [];
    for (let n of r3) {
      let { blob: s } = mo(e[n], t);
      i.push(s);
    }
    return Promise.resolve(i);
  };
}
function LF(t, e) {
  return (r3, i) => {
    let n = [];
    for (let s of i) {
      let o = r3[s], f2 = [];
      for (let l of e) {
        let { blob: g5 } = Sh(o, t, l);
        f2.push(g5);
      }
      n.push(Qa(f2));
    }
    return Promise.resolve(n);
  };
}
function Ch(t) {
  return typeof t == "object" && Object.keys(t).length === 2 && typeof t.txn == "object" && typeof t.signer == "function";
}
U();
var Mg = rr(or());
U();
U();
var rf = rr(or());
var yo = 2 ** 16 - 1, b4 = 32, v4 = 1, x4 = 1, Nr = 2, qF = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/, PF = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/, hr = class {
  static from(e) {
    if (e.endsWith("[]")) {
      let r3 = hr.from(e.slice(0, e.length - 2));
      return new ff(r3);
    }
    if (e.endsWith("]")) {
      let r3 = e.match(qF);
      if (r3.length !== 3)
        throw new Error(`malformed static array string: ${e}`);
      let i = r3[2], n = parseInt(i, 10);
      if (n > yo)
        throw new Error(`array length exceeds limit ${yo}`);
      let s = hr.from(r3[1]);
      return new af(s, n);
    }
    if (e.startsWith("uint")) {
      let r3 = (s) => [...s].every((o) => "0123456789".includes(o)), i = e.slice(4, e.length);
      if (!r3(i))
        throw new Error(`malformed uint string: ${i}`);
      let n = parseInt(i, 10);
      if (n > yo)
        throw new Error(`malformed uint string: ${n}`);
      return new Yi(n);
    }
    if (e === "byte")
      return new sf();
    if (e.startsWith("ufixed")) {
      let r3 = e.match(PF);
      if (r3.length !== 3)
        throw new Error(`malformed ufixed type: ${e}`);
      let i = parseInt(r3[1], 10), n = parseInt(r3[2], 10);
      return new nf(i, n);
    }
    if (e === "bool")
      return new ki();
    if (e === "address")
      return new ts();
    if (e === "string")
      return new of();
    if (e.length >= 2 && e[0] === "(" && e[e.length - 1] === ")") {
      let r3 = $r.parseTupleContent(e.slice(1, e.length - 1)), i = [];
      for (let n = 0; n < r3.length; n++) {
        let s = hr.from(r3[n]);
        i.push(s);
      }
      return new $r(i);
    }
    throw new Error(`cannot convert a string ${e} to an ABI type`);
  }
}, Yi = class extends hr {
  constructor(e) {
    if (super(), e % 8 !== 0 || e < 8 || e > 512)
      throw new Error(`unsupported uint type bitSize: ${e}`);
    this.bitSize = e;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(e) {
    return e instanceof Yi && this.bitSize === e.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(e) {
    if (typeof e != "bigint" && typeof e != "number")
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${e}`);
    if (e >= BigInt(2 ** this.bitSize) || e < BigInt(0))
      throw new Error(`${e} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    if (typeof e == "number" && !Number.isSafeInteger(e))
      throw new Error(`${e} should be converted into a BigInt before it is encoded`);
    return Sn(e, this.bitSize / 8);
  }
  decode(e) {
    if (e.length !== this.bitSize / 8)
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    return zu(e);
  }
}, nf = class extends hr {
  constructor(e, r3) {
    if (super(), e % 8 !== 0 || e < 8 || e > 512)
      throw new Error(`unsupported ufixed type bitSize: ${e}`);
    if (r3 > 160 || r3 < 1)
      throw new Error(`unsupported ufixed type precision: ${r3}`);
    this.bitSize = e, this.precision = r3;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(e) {
    return e instanceof nf && this.bitSize === e.bitSize && this.precision === e.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(e) {
    if (typeof e != "bigint" && typeof e != "number")
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (e >= BigInt(2 ** this.bitSize) || e < BigInt(0))
      throw new Error(`${e} is not a non-negative int or too big to fit in size ${this.toString()}`);
    if (typeof e == "number" && !Number.isSafeInteger(e))
      throw new Error(`${e} should be converted into a BigInt before it is encoded`);
    return Sn(e, this.bitSize / 8);
  }
  decode(e) {
    if (e.length !== this.bitSize / 8)
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    return zu(e);
  }
}, ts = class extends hr {
  toString() {
    return "address";
  }
  equals(e) {
    return e instanceof ts;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return b4;
  }
  encode(e) {
    if (typeof e != "string" && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (typeof e == "string")
      return ct(e).publicKey;
    if (e.byteLength !== 32)
      throw new Error("byte string must be 32 bytes long for an address");
    return e;
  }
  decode(e) {
    if (e.byteLength !== 32)
      throw new Error("byte string must be 32 bytes long for an address");
    return Ue(e);
  }
}, ki = class extends hr {
  toString() {
    return "bool";
  }
  equals(e) {
    return e instanceof ki;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return x4;
  }
  encode(e) {
    if (typeof e != "boolean")
      throw new Error(`Cannot encode value as bool: ${e}`);
    return e ? new Uint8Array([128]) : new Uint8Array([0]);
  }
  decode(e) {
    if (e.byteLength !== 1)
      throw new Error("bool string must be 1 byte long");
    let r3 = e[0];
    if (r3 === 128)
      return true;
    if (r3 === 0)
      return false;
    throw new Error("boolean could not be decoded from the byte string");
  }
}, sf = class extends hr {
  toString() {
    return "byte";
  }
  equals(e) {
    return e instanceof sf;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return v4;
  }
  encode(e) {
    if (typeof e != "number" && typeof e != "bigint")
      throw new Error(`Cannot encode value as byte: ${e}`);
    if (typeof e == "bigint" && (e = Number(e)), e < 0 || e > 255)
      throw new Error(`${e} cannot be encoded into a byte`);
    return new Uint8Array([e]);
  }
  decode(e) {
    if (e.byteLength !== 1)
      throw new Error("byte string must be 1 byte long");
    return e[0];
  }
}, of = class extends hr {
  toString() {
    return "string";
  }
  equals(e) {
    return e instanceof of;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(e) {
    if (typeof e != "string" && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as string: ${e}`);
    let r3 = rf.Buffer.from(e), i = Sn(r3.length, Nr), n = new Uint8Array(r3.length + Nr);
    return n.set(i), n.set(r3, Nr), n;
  }
  decode(e) {
    if (e.length < Nr)
      throw new Error(`byte string is too short to be decoded. Actual length is ${e.length}, but expected at least ${Nr}`);
    let i = rf.Buffer.from(e).readUIntBE(0, Nr), n = e.slice(Nr, e.length);
    if (i !== n.length)
      throw new Error(`string length bytes do not match the actual length of string. Expected ${i}, got ${n.length}`);
    return rf.Buffer.from(n).toString("utf-8");
  }
}, af = class extends hr {
  constructor(e, r3) {
    if (super(), r3 < 0)
      throw new Error(`static array must have a non negative length: ${r3}`);
    this.childType = e, this.staticLength = r3;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(e) {
    return e instanceof af && this.staticLength === e.staticLength && this.childType.equals(e.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    return this.childType.constructor === ki ? Math.ceil(this.staticLength / 8) : this.staticLength * this.childType.byteLen();
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (e.length !== this.staticLength)
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${e.length}`);
    return this.toABITupleType().encode(e);
  }
  decode(e) {
    return this.toABITupleType().decode(e);
  }
  toABITupleType() {
    return new $r(Array(this.staticLength).fill(this.childType));
  }
}, ff = class extends hr {
  constructor(e) {
    super(), this.childType = e;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(e) {
    return e instanceof ff && this.childType.equals(e.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    let r3 = this.toABITupleType(e.length), i = r3.encode(e), n = Sn(r3.childTypes.length, Nr);
    return $t(n, i);
  }
  decode(e) {
    let i = rf.Buffer.from(e).readUIntBE(0, Nr);
    return this.toABITupleType(i).decode(e.slice(Nr, e.length));
  }
  toABITupleType(e) {
    return new $r(Array(e).fill(this.childType));
  }
}, $r = class extends hr {
  constructor(e) {
    if (super(), e.length >= yo)
      throw new Error("tuple type child type number larger than maximum uint16 error");
    this.childTypes = e;
  }
  toString() {
    let e = [];
    for (let r3 = 0; r3 < this.childTypes.length; r3++)
      e[r3] = this.childTypes[r3].toString();
    return `(${e.join(",")})`;
  }
  equals(e) {
    return e instanceof $r && this.childTypes.length === e.childTypes.length && this.childTypes.every((r3, i) => r3.equals(e.childTypes[i]));
  }
  isDynamic() {
    let e = (r3) => r3.isDynamic();
    return this.childTypes.some(e);
  }
  byteLen() {
    let e = 0;
    for (let r3 = 0; r3 < this.childTypes.length; r3++)
      if (this.childTypes[r3].constructor === ki) {
        let i = $u(this.childTypes, r3, 1), n = i + 1;
        r3 += i, e += Math.trunc((n + 7) / 8);
      } else
        e += this.childTypes[r3].byteLen();
    return e;
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    let r3 = Array.from(e);
    if (e.length > yo)
      throw new Error("length of tuple array should not exceed a uint16");
    let i = this.childTypes, n = [], s = [], o = /* @__PURE__ */ new Map(), f2 = 0;
    for (; f2 < i.length; ) {
      let _ = i[f2];
      if (_.isDynamic())
        o.set(n.length, true), n.push(new Uint8Array([0, 0])), s.push(_.encode(r3[f2]));
      else {
        if (_.constructor === ki) {
          let N2 = $u(i, f2, -1), U2 = $u(i, f2, 1);
          if (N2 % 8 !== 0)
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          U2 = Math.min(7, U2);
          let V = UF(r3.slice(f2, f2 + U2 + 1));
          n.push(Sn(V, 1)), f2 += U2;
        } else {
          let N2 = _.encode(r3[f2]);
          n.push(N2);
        }
        o.set(f2, false), s.push(new Uint8Array());
      }
      f2 += 1;
    }
    let l = 0;
    for (let _ of n)
      l += _.length;
    let g5 = 0;
    for (let _ = 0; _ < n.length; _++) {
      if (o.get(_)) {
        let N2 = l + g5;
        if (N2 > yo)
          throw new Error(`byte length of ${N2} should not exceed a uint16`);
        n[_] = Sn(N2, Nr);
      }
      g5 += s[_].length;
    }
    return $t(...n, ...s);
  }
  decode(e) {
    let r3 = this.childTypes, i = [], n = [], s = 0, o = 0, f2 = rf.Buffer.from(e);
    for (; s < r3.length; ) {
      let _ = r3[s];
      if (_.isDynamic()) {
        if (e.slice(o, e.length).length < Nr)
          throw new Error("dynamic type in tuple is too short to be decoded");
        let N2 = f2.readUIntBE(o, Nr);
        if (i.length > 0 && (i[i.length - 1].right = N2, N2 < i[i.length - 1].left))
          throw new Error("dynamic index segment miscalculation: left is greater than right index");
        let U2 = { left: N2, right: -1 };
        i.push(U2), n.push(null), o += Nr;
      } else if (_.constructor === ki) {
        let N2 = $u(this.childTypes, s, -1), U2 = $u(this.childTypes, s, 1);
        if (N2 % 8 !== 0)
          throw new Error("expected before bool number mod 8 === 0");
        U2 = Math.min(7, U2);
        for (let V = 0; V <= U2; V++) {
          let G = 128 >> V;
          (e[o] & G) > 0 ? n.push(new Uint8Array([128])) : n.push(new Uint8Array([0]));
        }
        s += U2, o += 1;
      } else {
        let N2 = _.byteLen();
        n.push(e.slice(o, o + N2)), o += N2;
      }
      if (s !== r3.length - 1 && o >= e.length)
        throw new Error("input byte not enough to decode");
      s += 1;
    }
    if (i.length > 0 && (i[i.length - 1].right = e.length, o = e.length), o < e.length)
      throw new Error("input byte not fully consumed");
    for (let _ = 0; _ < i.length; _++) {
      let N2 = i[_];
      if (N2.left > N2.right)
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      if (_ !== i.length - 1 && N2.right !== i[_ + 1].left)
        throw new Error("dynamic segment should be consecutive");
    }
    let l = 0;
    for (let _ = 0; _ < r3.length; _++)
      r3[_].isDynamic() && (n[_] = e.slice(i[l].left, i[l].right), l += 1);
    let g5 = [];
    for (let _ = 0; _ < r3.length; _++) {
      let N2 = r3[_].decode(n[_]);
      g5.push(N2);
    }
    return g5;
  }
  static parseTupleContent(e) {
    if (e.length === 0)
      return [];
    if (e.endsWith(",") || e.startsWith(","))
      throw new Error("tuple string should not start with comma");
    if (e.includes(",,"))
      throw new Error("tuple string should not have consecutive commas");
    let r3 = [], i = 0, n = "";
    for (let s of e)
      n += s, s === "(" ? i += 1 : s === ")" ? i -= 1 : s === "," && i === 0 && (r3.push(n.slice(0, n.length - 1)), n = "");
    if (n.length !== 0 && r3.push(n), i !== 0)
      throw new Error("tuple string has mismatched parentheses");
    return r3;
  }
};
function UF(t) {
  let e = 0;
  if (t.length > 8)
    throw new Error("value list passed in should be no greater than length 8");
  for (let r3 = 0; r3 < t.length; r3++) {
    let i = t[r3];
    if (typeof i != "boolean")
      throw new Error("non-boolean values cannot be compressed into a byte");
    i && (e |= 1 << 7 - r3);
  }
  return e;
}
function $u(t, e, r3) {
  let i = 0;
  for (; ; ) {
    let n = e + r3 * i;
    if (t[n].constructor === ki)
      if (n !== t.length - 1 && r3 === 1)
        i += 1;
      else if (n > 0 && r3 === -1)
        i += 1;
      else
        break;
    else {
      i -= 1;
      break;
    }
  }
  return i;
}
U();
U();
U();
var Di;
(function(t) {
  t.any = "txn", t.pay = "pay", t.keyreg = "keyreg", t.acfg = "acfg", t.axfer = "axfer", t.afrz = "afrz", t.appl = "appl";
})(Di || (Di = {}));
function cf(t) {
  return t === Di.any || t === Di.pay || t === Di.keyreg || t === Di.acfg || t === Di.axfer || t === Di.afrz || t === Di.appl;
}
function wg(t, e) {
  return t === Di.any ? true : e.type && e.type.toString() === t.toString();
}
U();
var Zi;
(function(t) {
  t.account = "account", t.application = "application", t.asset = "asset";
})(Zi || (Zi = {}));
function Wu(t) {
  return t === Zi.account || t === Zi.application || t === Zi.asset;
}
function zF(t) {
  let e = t.indexOf("(");
  if (e === -1)
    throw new Error(`Invalid method signature: ${t}`);
  let r3 = -1, i = 0;
  for (let n = e; n < t.length; n++) {
    let s = t[n];
    if (s === "(")
      i += 1;
    else if (s === ")") {
      if (i === 0)
        break;
      if (i -= 1, i === 0) {
        r3 = n;
        break;
      }
    }
  }
  if (r3 === -1)
    throw new Error(`Invalid method signature: ${t}`);
  return { name: t.slice(0, e), args: $r.parseTupleContent(t.slice(e + 1, r3)), returns: t.slice(r3 + 1) };
}
var Ji = class {
  constructor(e) {
    if (typeof e.name != "string" || typeof e.returns != "object" || !Array.isArray(e.args))
      throw new Error("Invalid ABIMethod parameters");
    this.name = e.name, this.description = e.desc, this.args = e.args.map(({ type: r3, name: i, desc: n }) => cf(r3) || Wu(r3) ? { type: r3, name: i, description: n } : { type: hr.from(r3), name: i, description: n }), this.returns = { type: e.returns.type === "void" ? e.returns.type : hr.from(e.returns.type), description: e.returns.desc };
  }
  getSignature() {
    let e = this.args.map((i) => i.type.toString()).join(","), r3 = this.returns.type.toString();
    return `${this.name}(${e})${r3}`;
  }
  getSelector() {
    let e = Rr(this.getSignature());
    return new Uint8Array(e.slice(0, 4));
  }
  txnCount() {
    let e = 1;
    for (let r3 of this.args)
      typeof r3.type == "string" && cf(r3.type) && (e += 1);
    return e;
  }
  toJSON() {
    return { name: this.name, desc: this.description, args: this.args.map(({ type: e, name: r3, description: i }) => ({ type: e.toString(), name: r3, desc: i })), returns: { type: this.returns.type.toString(), desc: this.returns.description } };
  }
  static fromSignature(e) {
    let { name: r3, args: i, returns: n } = zF(e);
    return new Ji({ name: r3, args: i.map((s) => ({ type: s })), returns: { type: n } });
  }
};
function Vu(t, e) {
  if (t === null || !Array.isArray(t) || !t.every((i) => i instanceof Ji))
    throw new Error("Methods list provided is null or not the correct type");
  let r3 = t.filter((i) => i.name === e);
  if (r3.length > 1)
    throw new Error(`found ${r3.length} methods with the same name ${r3.map((i) => i.getSignature()).join(",")}`);
  if (r3.length === 0)
    throw new Error(`found 0 methods with the name ${e}`);
  return r3[0];
}
var _g = class {
  constructor(e) {
    if (typeof e.name != "string" || !Array.isArray(e.methods) || e.networks && typeof e.networks != "object")
      throw new Error("Invalid ABIContract parameters");
    this.name = e.name, this.description = e.desc, this.networks = e.networks ? { ...e.networks } : {}, this.methods = e.methods.map((r3) => new Ji(r3));
  }
  toJSON() {
    return { name: this.name, desc: this.description, networks: this.networks, methods: this.methods.map((e) => e.toJSON()) };
  }
  getMethodByName(e) {
    return Vu(this.methods, e);
  }
};
U();
var Ag = class {
  constructor(e) {
    if (typeof e.name != "string" || !Array.isArray(e.methods))
      throw new Error("Invalid ABIInterface parameters");
    this.name = e.name, this.description = e.desc, this.methods = e.methods.map((r3) => new Ji(r3));
  }
  toJSON() {
    return { name: this.name, desc: this.description, methods: this.methods.map((e) => e.toJSON()) };
  }
  getMethodByName(e) {
    return Vu(this.methods, e);
  }
};
var HF = Mg.Buffer.from([21, 31, 124, 117]), Yu = 16, Br;
(function(t) {
  t[t.BUILDING = 0] = "BUILDING", t[t.BUILT = 1] = "BUILT", t[t.SIGNED = 2] = "SIGNED", t[t.SUBMITTED = 3] = "SUBMITTED", t[t.COMMITTED = 4] = "COMMITTED";
})(Br || (Br = {}));
function Eg(t, e, r3) {
  if (r3 != null && t === r3)
    return 0;
  let i = r3 == null ? 0 : 1;
  for (let n = 0; n < e.length; n++)
    if (t === e[n])
      return n + i;
  return e.push(t), e.length - 1 + i;
}
var Xi = class {
  constructor() {
    this.status = Br.BUILDING, this.transactions = [], this.methodCalls = /* @__PURE__ */ new Map(), this.signedTxns = [], this.txIDs = [];
  }
  getStatus() {
    return this.status;
  }
  count() {
    return this.transactions.length;
  }
  clone() {
    let e = new Xi();
    return e.transactions = this.transactions.map(({ txn: r3, signer: i }) => ({ txn: zt.from_obj_for_encoding({ ...r3.get_obj_for_encoding(), grp: void 0 }), signer: i })), e.methodCalls = new Map(this.methodCalls), e;
  }
  addTransaction(e) {
    if (this.status !== Br.BUILDING)
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    if (this.transactions.length === Xi.MAX_GROUP_SIZE)
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${Xi.MAX_GROUP_SIZE}`);
    if (e.txn.group && e.txn.group.some((r3) => r3 !== 0))
      throw new Error("Cannot add a transaction with nonzero group ID");
    this.transactions.push(e);
  }
  addMethodCall({ appID: e, method: r3, methodArgs: i, sender: n, suggestedParams: s, onComplete: o, approvalProgram: f2, clearProgram: l, numGlobalInts: g5, numGlobalByteSlices: _, numLocalInts: N2, numLocalByteSlices: U2, extraPages: V, appAccounts: G, appForeignApps: ee2, appForeignAssets: W5, boxes: Z, note: le, lease: be2, rekeyTo: Ae, signer: me }) {
    if (this.status !== Br.BUILDING)
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    if (this.transactions.length + r3.txnCount() > Xi.MAX_GROUP_SIZE)
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${Xi.MAX_GROUP_SIZE}`);
    if (e === 0) {
      if (f2 == null || l == null || g5 == null || _ == null || N2 == null || U2 == null)
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
    } else if (o === lr.UpdateApplicationOC) {
      if (f2 == null || l == null)
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      if (g5 != null || _ != null || N2 != null || U2 != null || V != null)
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    } else if (f2 != null || l != null || g5 != null || _ != null || N2 != null || U2 != null || V != null)
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    if (i == null && (i = []), i.length !== r3.args.length)
      throw new Error(`Incorrect number of method arguments. Expected ${r3.args.length}, got ${i.length}`);
    let H5 = [], ue = [], se2 = [], ne2 = [], E2 = [], c = /* @__PURE__ */ new Map(), m2 = Z || [];
    for (let d2 = 0; d2 < i.length; d2++) {
      let M = r3.args[d2].type, B2 = i[d2];
      if (cf(M)) {
        if (!Ch(B2) || !wg(M, B2.txn))
          throw new Error(`Expected ${M} transaction for argument at index ${d2}`);
        if (B2.txn.group && B2.txn.group.some((y2) => y2 !== 0))
          throw new Error("Cannot add a transaction with nonzero group ID");
        se2.push(B2);
        continue;
      }
      if (Ch(B2))
        throw new Error(`Expected non-transaction value for argument at index ${d2}`);
      if (Wu(M) && (c.set(ne2.length, H5.length), ne2.push(M), E2.push(B2), M = new Yi(8)), typeof M == "string")
        throw new Error(`Unknown ABI type: ${M}`);
      H5.push(M), ue.push(B2);
    }
    let h2 = [], a = G == null ? [] : G.slice(), u3 = ee2 == null ? [] : ee2.slice(), b2 = W5 == null ? [] : W5.slice();
    for (let d2 = 0; d2 < ne2.length; d2++) {
      let M = ne2[d2], B2 = E2[d2], y2 = 0;
      switch (M) {
        case Zi.account: {
          let I = new ts(), de = I.decode(I.encode(B2));
          y2 = Eg(de, a, n);
          break;
        }
        case Zi.application: {
          let I = new Yi(64), de = I.decode(I.encode(B2));
          if (de > Number.MAX_SAFE_INTEGER)
            throw new Error(`Expected safe integer for application value, got ${de}`);
          y2 = Eg(Number(de), u3, e);
          break;
        }
        case Zi.asset: {
          let I = new Yi(64), de = I.decode(I.encode(B2));
          if (de > Number.MAX_SAFE_INTEGER)
            throw new Error(`Expected safe integer for asset value, got ${de}`);
          y2 = Eg(Number(de), b2);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${M}`);
      }
      h2.push(y2);
    }
    for (let d2 = 0; d2 < h2.length; d2++) {
      let M = c.get(d2);
      ue[M] = h2[d2];
    }
    if (H5.length > Yu - 1) {
      let d2 = H5.slice(Yu - 2), M = ue.slice(Yu - 2);
      H5 = H5.slice(0, Yu - 2), ue = ue.slice(0, Yu - 2), H5.push(new $r(d2)), ue.push(M);
    }
    let A2 = [r3.getSelector()];
    for (let d2 = 0; d2 < H5.length; d2++)
      A2.push(H5[d2].encode(ue[d2]));
    let v2 = { txn: xg({ from: n, appIndex: e, appArgs: A2, accounts: a, foreignApps: u3, foreignAssets: b2, boxes: m2, onComplete: o ?? lr.NoOpOC, approvalProgram: f2, clearProgram: l, numGlobalInts: g5, numGlobalByteSlices: _, numLocalInts: N2, numLocalByteSlices: U2, extraPages: V, lease: be2, note: le, rekeyTo: Ae, suggestedParams: s }), signer: me };
    this.transactions.push(...se2, v2), this.methodCalls.set(this.transactions.length - 1, r3);
  }
  buildGroup() {
    if (this.status === Br.BUILDING) {
      if (this.transactions.length === 0)
        throw new Error("Cannot build a group with 0 transactions");
      this.transactions.length > 1 && Eh(this.transactions.map((e) => e.txn)), this.status = Br.BUILT;
    }
    return this.transactions;
  }
  async gatherSignatures() {
    if (this.status >= Br.SIGNED)
      return this.signedTxns;
    let e = this.buildGroup(), r3 = e.map((l) => l.txn), i = /* @__PURE__ */ new Map();
    for (let l = 0; l < e.length; l++) {
      let { signer: g5 } = e[l];
      i.has(g5) || i.set(g5, []), i.get(g5).push(l);
    }
    let n = Array.from(i), s = await Promise.all(n.map(([l, g5]) => l(r3, g5))), o = e.map(() => null);
    for (let l = 0; l < n.length; l++) {
      let g5 = n[l][1], _ = s[l];
      for (let N2 = 0; N2 < g5.length; N2++)
        o[g5[N2]] = _[N2];
    }
    if (!o.every((l) => l != null))
      throw new Error(`Missing signatures. Got ${o}`);
    let f2 = o.map((l, g5) => {
      try {
        return vn(l).txn.txID();
      } catch (_) {
        throw new Error(`Cannot decode signed transaction at index ${g5}. ${_}`);
      }
    });
    return this.signedTxns = o, this.txIDs = f2, this.status = Br.SIGNED, o;
  }
  async submit(e) {
    if (this.status > Br.SUBMITTED)
      throw new Error("Transaction group cannot be resubmitted");
    let r3 = await this.gatherSignatures();
    return await e.sendRawTransaction(r3).do(), this.status = Br.SUBMITTED, this.txIDs;
  }
  async execute(e, r3) {
    if (this.status === Br.COMMITTED)
      throw new Error("Transaction group has already been executed successfully");
    let i = await this.submit(e);
    this.status = Br.SUBMITTED;
    let n = this.transactions.findIndex((g5, _) => this.methodCalls.has(_)), o = await vh(e, i[n === -1 ? 0 : n], r3);
    this.status = Br.COMMITTED;
    let f2 = o["confirmed-round"], l = [];
    for (let [g5, _] of this.methodCalls) {
      let N2 = i[g5], U2 = { txID: N2, rawReturnValue: new Uint8Array(), method: _ };
      try {
        let V = g5 === n ? o : await e.pendingTransactionInformation(N2).do();
        if (U2.txInfo = V, _.returns.type !== "void") {
          let G = V.logs || [];
          if (G.length === 0)
            throw new Error("App call transaction did not log a return value");
          let ee2 = Mg.Buffer.from(G[G.length - 1], "base64");
          if (ee2.byteLength < 4 || !ee2.slice(0, 4).equals(HF))
            throw new Error("App call transaction did not log a return value");
          U2.rawReturnValue = new Uint8Array(ee2.slice(4)), U2.returnValue = _.returns.type.decode(U2.rawReturnValue);
        }
      } catch (V) {
        U2.decodeError = V;
      }
      l.push(U2);
    }
    return { confirmedRound: f2, txIDs: i, methodResults: l };
  }
};
Xi.MAX_GROUP_SIZE = 16;
U();
U();
U();
var w4 = Oh.Buffer.from([77, 88]), _4 = "The transaction sender address and multisig preimage do not match.";
function KF(t, e) {
  if (typeof t.from > "u") {
    let i = mn(e);
    t.from = Ue(i.publicKey);
  }
  let r3 = ci(t);
  return { txID: r3.txID().toString(), blob: r3.signTxn(e) };
}
function GF(t, e) {
  return new pc(t).signBid(e);
}
function $F(t, e) {
  let r3 = Oh.Buffer.from($t(w4, t));
  return yn(r3, e);
}
function WF(t, e, r3) {
  let i = Oh.Buffer.from($t(w4, t)), n = ct(r3).publicKey;
  return zs(i, e, n);
}
function VF(t) {
  return new Uint8Array(nr(t));
}
function Cr(t) {
  return sr(t);
}
var YF = new Error(_4), ZF = new Error(gc);
var A4 = Sg;
U();
U();
U();
U();
function Ig(t, e) {
  let r3 = /* @__PURE__ */ Object.create(null), i = t.split(",");
  for (let n = 0; n < i.length; n++)
    r3[i[n]] = true;
  return e ? (n) => !!r3[n.toLowerCase()] : (n) => !!r3[n];
}
var JF = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
Ig(JF + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");
W.default.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
W.default.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
var jh = () => {
};
var E4 = Object.assign;
var XF = Object.prototype.hasOwnProperty, Zu = (t, e) => XF.call(t, e), li = Array.isArray, uf = (t) => S4(t) === "[object Map]";
var Tn = (t) => typeof t == "function", QF = (t) => typeof t == "string", Lh = (t) => typeof t == "symbol", rs = (t) => t !== null && typeof t == "object", M4 = (t) => rs(t) && Tn(t.then) && Tn(t.catch), eR = Object.prototype.toString, S4 = (t) => eR.call(t), Tg = (t) => S4(t).slice(8, -1);
var qh = (t) => QF(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t;
var Ph = (t) => {
  let e = /* @__PURE__ */ Object.create(null);
  return (r3) => e[r3] || (e[r3] = t(r3));
}, Fg = Ph((t) => t.charAt(0).toUpperCase() + t.slice(1)), df = (t, e) => !Object.is(t, e);
var I4 = (t, e, r3) => {
  Object.defineProperty(t, e, { configurable: true, enumerable: false, value: r3 });
};
function T4(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
var iR;
function nR(t, e = iR) {
  e && e.active && e.effects.push(t);
}
var Xu = (t) => {
  let e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, O4 = (t) => (t.w & os) > 0, j4 = (t) => (t.n & os) > 0, sR = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= os;
}, oR = (t) => {
  let { deps: e } = t;
  if (e.length) {
    let r3 = 0;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      O4(n) && !j4(n) ? n.delete(t) : e[r3++] = n, n.w &= ~os, n.n &= ~os;
    }
    e.length = r3;
  }
}, Rg = /* @__PURE__ */ new WeakMap(), Ju = 0, os = 1, kg = 30, Or, bo = Symbol(W.default.env.NODE_ENV !== "production" ? "iterate" : ""), Dg = Symbol(W.default.env.NODE_ENV !== "production" ? "Map key iterate" : ""), Qu = class {
  constructor(e, r3 = null, i) {
    this.fn = e, this.scheduler = r3, this.active = true, this.deps = [], this.parent = void 0, nR(this, i);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = Or, r3 = ss;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = Or, Or = this, ss = true, os = 1 << ++Ju, Ju <= kg ? sR(this) : F4(this), this.fn();
    } finally {
      Ju <= kg && oR(this), os = 1 << --Ju, Or = this.parent, ss = r3, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Or === this ? this.deferStop = true : this.active && (F4(this), this.onStop && this.onStop(), this.active = false);
  }
};
function F4(t) {
  let { deps: e } = t;
  if (e.length) {
    for (let r3 = 0; r3 < e.length; r3++)
      e[r3].delete(t);
    e.length = 0;
  }
}
var ss = true, L4 = [];
function aR() {
  L4.push(ss), ss = false;
}
function fR() {
  let t = L4.pop();
  ss = t === void 0 ? true : t;
}
function hi(t, e, r3) {
  if (ss && Or) {
    let i = Rg.get(t);
    i || Rg.set(t, i = /* @__PURE__ */ new Map());
    let n = i.get(r3);
    n || i.set(r3, n = Xu());
    let s = W.default.env.NODE_ENV !== "production" ? { effect: Or, target: t, type: e, key: r3 } : void 0;
    Ng(n, s);
  }
}
function Ng(t, e) {
  let r3 = false;
  Ju <= kg ? j4(t) || (t.n |= os, r3 = !O4(t)) : r3 = !t.has(Or), r3 && (t.add(Or), Or.deps.push(t), W.default.env.NODE_ENV !== "production" && Or.onTrack && Or.onTrack(Object.assign({ effect: Or }, e)));
}
function as(t, e, r3, i, n, s) {
  let o = Rg.get(t);
  if (!o)
    return;
  let f2 = [];
  if (e === "clear")
    f2 = [...o.values()];
  else if (r3 === "length" && li(t)) {
    let g5 = Number(i);
    o.forEach((_, N2) => {
      (N2 === "length" || N2 >= g5) && f2.push(_);
    });
  } else
    switch (r3 !== void 0 && f2.push(o.get(r3)), e) {
      case "add":
        li(t) ? qh(r3) && f2.push(o.get("length")) : (f2.push(o.get(bo)), uf(t) && f2.push(o.get(Dg)));
        break;
      case "delete":
        li(t) || (f2.push(o.get(bo)), uf(t) && f2.push(o.get(Dg)));
        break;
      case "set":
        uf(t) && f2.push(o.get(bo));
        break;
    }
  let l = W.default.env.NODE_ENV !== "production" ? { target: t, type: e, key: r3, newValue: i, oldValue: n, oldTarget: s } : void 0;
  if (f2.length === 1)
    f2[0] && (W.default.env.NODE_ENV !== "production" ? lf(f2[0], l) : lf(f2[0]));
  else {
    let g5 = [];
    for (let _ of f2)
      _ && g5.push(..._);
    W.default.env.NODE_ENV !== "production" ? lf(Xu(g5), l) : lf(Xu(g5));
  }
}
function lf(t, e) {
  let r3 = li(t) ? t : [...t];
  for (let i of r3)
    i.computed && R4(i, e);
  for (let i of r3)
    i.computed || R4(i, e);
}
function R4(t, e) {
  (t !== Or || t.allowRecurse) && (W.default.env.NODE_ENV !== "production" && t.onTrigger && t.onTrigger(E4({ effect: t }, e)), t.scheduler ? t.scheduler() : t.run());
}
var cR = Ig("__proto__,__v_isRef,__isVue"), q4 = new Set(Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(Lh)), uR = P4();
var dR = P4(true);
var k4 = lR();
function lR() {
  let t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...r3) {
      let i = Wt(this);
      for (let s = 0, o = this.length; s < o; s++)
        hi(i, "get", s + "");
      let n = i[e](...r3);
      return n === -1 || n === false ? i[e](...r3.map(Wt)) : n;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...r3) {
      aR();
      let i = Wt(this)[e].apply(this, r3);
      return fR(), i;
    };
  }), t;
}
function hR(t) {
  let e = Wt(this);
  return hi(e, "has", t), e.hasOwnProperty(t);
}
function P4(t = false, e = false) {
  return function(i, n, s) {
    if (n === "__v_isReactive")
      return !t;
    if (n === "__v_isReadonly")
      return t;
    if (n === "__v_isShallow")
      return e;
    if (n === "__v_raw" && s === (t ? e ? FR : K4 : e ? TR : H4).get(i))
      return i;
    let o = li(i);
    if (!t) {
      if (o && Zu(k4, n))
        return Reflect.get(k4, n, s);
      if (n === "hasOwnProperty")
        return hR;
    }
    let f2 = Reflect.get(i, n, s);
    return (Lh(n) ? q4.has(n) : cR(n)) || (t || hi(i, "get", n), e) ? f2 : ns(f2) ? o && qh(n) ? f2 : f2.value : rs(f2) ? t ? Qi(f2) : hf(f2) : f2;
  };
}
var pR = gR();
function gR(t = false) {
  return function(r3, i, n, s) {
    let o = r3[i];
    if ($h(o) && ns(o) && !ns(n))
      return false;
    if (!t && (!Og(n) && !$h(n) && (o = Wt(o), n = Wt(n)), !li(r3) && ns(o) && !ns(n)))
      return o.value = n, true;
    let f2 = li(r3) && qh(i) ? Number(i) < r3.length : Zu(r3, i), l = Reflect.set(r3, i, n, s);
    return r3 === Wt(s) && (f2 ? df(n, o) && as(r3, "set", i, n, o) : as(r3, "add", i, n)), l;
  };
}
function mR(t, e) {
  let r3 = Zu(t, e), i = t[e], n = Reflect.deleteProperty(t, e);
  return n && r3 && as(t, "delete", e, void 0, i), n;
}
function yR(t, e) {
  let r3 = Reflect.has(t, e);
  return (!Lh(e) || !q4.has(e)) && hi(t, "has", e), r3;
}
function bR(t) {
  return hi(t, "iterate", li(t) ? "length" : bo), Reflect.ownKeys(t);
}
var vR = { get: uR, set: pR, deleteProperty: mR, has: yR, ownKeys: bR }, xR = { get: dR, set(t, e) {
  return W.default.env.NODE_ENV !== "production" && T4(`Set operation on key "${String(e)}" failed: target is readonly.`, t), true;
}, deleteProperty(t, e) {
  return W.default.env.NODE_ENV !== "production" && T4(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), true;
} };
var Cg = (t) => t, Wh = (t) => Reflect.getPrototypeOf(t);
function Uh(t, e, r3 = false, i = false) {
  t = t.__v_raw;
  let n = Wt(t), s = Wt(e);
  r3 || (e !== s && hi(n, "get", e), hi(n, "get", s));
  let { has: o } = Wh(n), f2 = i ? Cg : r3 ? Lg : jg;
  if (o.call(n, e))
    return f2(t.get(e));
  if (o.call(n, s))
    return f2(t.get(s));
  t !== n && t.get(e);
}
function zh(t, e = false) {
  let r3 = this.__v_raw, i = Wt(r3), n = Wt(t);
  return e || (t !== n && hi(i, "has", t), hi(i, "has", n)), t === n ? r3.has(t) : r3.has(t) || r3.has(n);
}
function Hh(t, e = false) {
  return t = t.__v_raw, !e && hi(Wt(t), "iterate", bo), Reflect.get(t, "size", t);
}
function D4(t) {
  t = Wt(t);
  let e = Wt(this);
  return Wh(e).has.call(e, t) || (e.add(t), as(e, "add", t, t)), this;
}
function N4(t, e) {
  e = Wt(e);
  let r3 = Wt(this), { has: i, get: n } = Wh(r3), s = i.call(r3, t);
  s ? W.default.env.NODE_ENV !== "production" && z4(r3, i, t) : (t = Wt(t), s = i.call(r3, t));
  let o = n.call(r3, t);
  return r3.set(t, e), s ? df(e, o) && as(r3, "set", t, e, o) : as(r3, "add", t, e), this;
}
function B4(t) {
  let e = Wt(this), { has: r3, get: i } = Wh(e), n = r3.call(e, t);
  n ? W.default.env.NODE_ENV !== "production" && z4(e, r3, t) : (t = Wt(t), n = r3.call(e, t));
  let s = i ? i.call(e, t) : void 0, o = e.delete(t);
  return n && as(e, "delete", t, void 0, s), o;
}
function C4() {
  let t = Wt(this), e = t.size !== 0, r3 = W.default.env.NODE_ENV !== "production" ? uf(t) ? new Map(t) : new Set(t) : void 0, i = t.clear();
  return e && as(t, "clear", void 0, void 0, r3), i;
}
function Kh(t, e) {
  return function(i, n) {
    let s = this, o = s.__v_raw, f2 = Wt(o), l = e ? Cg : t ? Lg : jg;
    return !t && hi(f2, "iterate", bo), o.forEach((g5, _) => i.call(n, l(g5), l(_), s));
  };
}
function Gh(t, e, r3) {
  return function(...i) {
    let n = this.__v_raw, s = Wt(n), o = uf(s), f2 = t === "entries" || t === Symbol.iterator && o, l = t === "keys" && o, g5 = n[t](...i), _ = r3 ? Cg : e ? Lg : jg;
    return !e && hi(s, "iterate", l ? Dg : bo), { next() {
      let { value: N2, done: U2 } = g5.next();
      return U2 ? { value: N2, done: U2 } : { value: f2 ? [_(N2[0]), _(N2[1])] : _(N2), done: U2 };
    }, [Symbol.iterator]() {
      return this;
    } };
  };
}
function is(t) {
  return function(...e) {
    if (W.default.env.NODE_ENV !== "production") {
      let r3 = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${Fg(t)} operation ${r3}failed: target is readonly.`, Wt(this));
    }
    return t === "delete" ? false : this;
  };
}
function wR() {
  let t = { get(s) {
    return Uh(this, s);
  }, get size() {
    return Hh(this);
  }, has: zh, add: D4, set: N4, delete: B4, clear: C4, forEach: Kh(false, false) }, e = { get(s) {
    return Uh(this, s, false, true);
  }, get size() {
    return Hh(this);
  }, has: zh, add: D4, set: N4, delete: B4, clear: C4, forEach: Kh(false, true) }, r3 = { get(s) {
    return Uh(this, s, true);
  }, get size() {
    return Hh(this, true);
  }, has(s) {
    return zh.call(this, s, true);
  }, add: is("add"), set: is("set"), delete: is("delete"), clear: is("clear"), forEach: Kh(true, false) }, i = { get(s) {
    return Uh(this, s, true, true);
  }, get size() {
    return Hh(this, true);
  }, has(s) {
    return zh.call(this, s, true);
  }, add: is("add"), set: is("set"), delete: is("delete"), clear: is("clear"), forEach: Kh(true, true) };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    t[s] = Gh(s, false, false), r3[s] = Gh(s, true, false), e[s] = Gh(s, false, true), i[s] = Gh(s, true, true);
  }), [t, r3, e, i];
}
var [_R, AR, ER, MR] = wR();
function U4(t, e) {
  let r3 = e ? t ? MR : ER : t ? AR : _R;
  return (i, n, s) => n === "__v_isReactive" ? !t : n === "__v_isReadonly" ? t : n === "__v_raw" ? i : Reflect.get(Zu(r3, n) && n in i ? r3 : i, n, s);
}
var SR = { get: U4(false, false) };
var IR = { get: U4(true, false) };
function z4(t, e, r3) {
  let i = Wt(r3);
  if (i !== r3 && e.call(t, i)) {
    let n = Tg(t);
    console.warn(`Reactive ${n} contains both the raw and reactive versions of the same object${n === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var H4 = /* @__PURE__ */ new WeakMap(), TR = /* @__PURE__ */ new WeakMap(), K4 = /* @__PURE__ */ new WeakMap(), FR = /* @__PURE__ */ new WeakMap();
function RR(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function kR(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : RR(Tg(t));
}
function hf(t) {
  return $h(t) ? t : G4(t, false, vR, SR, H4);
}
function Qi(t) {
  return G4(t, true, xR, IR, K4);
}
function G4(t, e, r3, i, n) {
  if (!rs(t))
    return W.default.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(t)}`), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  let s = n.get(t);
  if (s)
    return s;
  let o = kR(t);
  if (o === 0)
    return t;
  let f2 = new Proxy(t, o === 2 ? i : r3);
  return n.set(t, f2), f2;
}
function ed(t) {
  return $h(t) ? ed(t.__v_raw) : !!(t && t.__v_isReactive);
}
function $h(t) {
  return !!(t && t.__v_isReadonly);
}
function Og(t) {
  return !!(t && t.__v_isShallow);
}
function Wt(t) {
  let e = t && t.__v_raw;
  return e ? Wt(e) : t;
}
function Vh(t) {
  return I4(t, "__v_skip", true), t;
}
var jg = (t) => rs(t) ? hf(t) : t, Lg = (t) => rs(t) ? Qi(t) : t;
function DR(t) {
  ss && Or && (t = Wt(t), W.default.env.NODE_ENV !== "production" ? Ng(t.dep || (t.dep = Xu()), { target: t, type: "get", key: "value" }) : Ng(t.dep || (t.dep = Xu())));
}
function NR(t, e) {
  t = Wt(t);
  let r3 = t.dep;
  r3 && (W.default.env.NODE_ENV !== "production" ? lf(r3, { target: t, type: "set", key: "value", newValue: e }) : lf(r3));
}
function ns(t) {
  return !!(t && t.__v_isRef === true);
}
var $4, Bg = class {
  constructor(e, r3, i, n) {
    this._setter = r3, this.dep = void 0, this.__v_isRef = true, this[$4] = false, this._dirty = true, this.effect = new Qu(e, () => {
      this._dirty || (this._dirty = true, NR(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !n, this.__v_isReadonly = i;
  }
  get value() {
    let e = Wt(this);
    return DR(e), (e._dirty || !e._cacheable) && (e._dirty = false, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
};
$4 = "__v_isReadonly";
function Fn(t, e, r3 = false) {
  let i, n, s = Tn(t);
  s ? (i = t, n = W.default.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : jh) : (i = t.get, n = t.set);
  let o = new Bg(i, n, s || !n, r3);
  return W.default.env.NODE_ENV !== "production" && e && !r3 && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;
}
U();
function Yh(t, e, r3) {
  let i;
  try {
    i = r3 ? t(...r3) : t();
  } catch (n) {
    V4(n, e);
  }
  return i;
}
function qg(t, e, r3) {
  if (Tn(t)) {
    let n = Yh(t, e, r3);
    return n && M4(n) && n.catch((s) => {
      V4(s, e);
    }), n;
  }
  let i = [];
  for (let n = 0; n < t.length; n++)
    i.push(qg(t[n], e, r3));
  return i;
}
function V4(t, e) {
  console.error(new Error(`[@vue-reactivity/watch]: ${e}`)), console.error(t);
}
function CR(t) {
  console.warn(OR(t));
}
function OR(t) {
  return new Error(`[reactivue]: ${t}`);
}
var W4 = {};
function td(t, e, r3) {
  return jR(t, e, r3);
}
function jR(t, e, { immediate: r3, deep: i, flush: n } = {}) {
  let s, o = false, f2 = false;
  if (ns(t) ? (s = () => t.value, o = Og(t)) : ed(t) ? (s = () => t, i = true) : li(t) ? (f2 = true, o = t.some(ed), s = () => t.map((G) => ns(G) ? G.value : ed(G) ? pf(G) : Tn(G) ? Yh(G, "watch getter") : CR("invalid source"))) : Tn(t) ? e ? s = () => Yh(t, "watch getter") : s = () => (l && l(), qg(t, "watch callback", [g5])) : s = jh, e && i) {
    let G = s;
    s = () => pf(G());
  }
  let l, g5 = (G) => {
    l = V.onStop = () => {
      Yh(G, "watch cleanup");
    };
  }, _ = f2 ? [] : W4, N2 = () => {
    if (!!V.active)
      if (e) {
        let G = V.run();
        (i || o || (f2 ? G.some((ee2, W5) => df(ee2, _[W5])) : df(G, _))) && (l && l(), qg(e, "watch value", [G, _ === W4 ? void 0 : _, g5]), _ = G);
      } else
        V.run();
  };
  N2.allowRecurse = !!e;
  let U2;
  n === "sync" ? U2 = N2 : U2 = () => {
    N2();
  };
  let V = new Qu(s, U2);
  return e ? r3 ? N2() : _ = V.run() : V.run(), () => V.stop();
}
function pf(t, e = /* @__PURE__ */ new Set()) {
  if (!rs(t) || e.has(t))
    return t;
  if (e.add(t), li(t))
    for (let r3 = 0; r3 < t.length; r3++)
      pf(t[r3], e);
  else if (t instanceof Map)
    t.forEach((r3, i) => {
      pf(t.get(i), e);
    });
  else if (t instanceof Set)
    t.forEach((r3) => {
      pf(r3, e);
    });
  else
    for (let r3 of Object.keys(t))
      pf(t[r3], e);
  return t;
}
var r8 = rr(or(), 1);
var X4 = Object.defineProperty, LR = (t, e, r3) => e in t ? X4(t, e, { enumerable: true, configurable: true, writable: true, value: r3 }) : t[e] = r3, Xt = (t, e) => X4(t, "name", { value: e, configurable: true }), Rn = (t, e, r3) => (LR(t, typeof e != "symbol" ? e + "" : e, r3), r3);
function Jh() {
  let t = false;
  return typeof window !== void 0 && typeof window == "object" && "document" in window && typeof window.document == "object" && (t = true), t;
}
Xt(Jh, "isBrowser");
var yf = { changedState: (t) => {
}, changedAccount: (t) => {
} }, Y4 = "AnyWallet", qR = Xt(() => {
  if (!Jh()) {
    console.warn("not in browser...");
    return;
  }
  Xt(() => {
    try {
      let t = localStorage.getItem(Y4);
      if (t)
        try {
          let e = JSON.parse(t);
          mt.stored = e;
        } catch {
          console.warn("bad sLocalStorage parse");
        }
    } catch {
      console.warn("could not access localstorage");
    }
  }, "initLocalStorage")(), td(() => mt.stored, () => {
    try {
      localStorage.setItem(Y4, JSON.stringify(mt.stored));
    } catch {
      console.warn("could not save to localstorage");
    }
  }, { deep: true }), td(mt, (t) => {
    yf.changedState(t);
  }, { deep: true }), td(() => mt.stored.activeAccount, (t) => {
    yf.changedAccount(t);
  }, { deep: true });
}, "startWatchers");
Xt((t, e = true) => {
  yf.changedState = t, e && yf.changedState(mt);
}, "setChangedStateHandler");
Xt((t, e = true) => {
  yf.changedAccount = t, e && yf.changedAccount(mt.stored.activeAccount);
}, "setChangedAccountHandler");
var en = class {
  constructor(t) {
  }
};
Xt(en, "BaseClient"), Rn(en, "metadata"), Rn(en, "init");
var PR = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzcgMTg3Ij48cmVjdCB4PSItMTEuMzgiIHk9Ii0yNS45NyIgd2lkdGg9IjIwMC4wMiIgaGVpZ2h0PSIyMzEuNTMiIHN0eWxlPSJmaWxsOiNmZTU7Ii8+PHBhdGggZD0iTTk0LjA1LDU5LjYxYzIuMDUsOC40OCwxLjM2LDE1Ljk0LTEuNTUsMTYuNjYtMi45LC43Mi02LjkxLTUuNTctOC45Ni0xNC4wNS0yLjA1LTguNDgtMS4zNi0xNS45NCwxLjU1LTE2LjY2LDIuOS0uNzIsNi45MSw1LjU3LDguOTYsMTQuMDVaIiBzdHlsZT0iZmlsbDojMWMxYzFjOyIvPjxwYXRoIGQ9Ik0xMjcuODUsNjYuOWMtNC41My00LjgxLTEzLjU1LTMuNS0yMC4xNSwyLjkxLTYuNTksNi40MS04LjI2LDE1LjUtMy43MywyMC4zMSw0LjUzLDQuOCwxMy41NSwzLjUsMjAuMTUtMi45MXM4LjI2LTE1LjUsMy43My0yMC4zMVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTkxLjc5LDE0MC40N2MyLjktLjcyLDMuNDktOC42LDEuMzItMTcuNjEtMi4xNy05LTYuMjktMTUuNzEtOS4xOS0xNC45OS0yLjksLjcyLTMuNDksOC42LTEuMzIsMTcuNjEsMi4xNyw5LDYuMjksMTUuNzEsOS4xOSwxNC45OVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTYyLjIyLDcxLjNjOC4zNywyLjQ3LDE0LjQ4LDYuOCwxMy42Niw5LjY3LS44MywyLjg3LTguMjgsMy4yLTE2LjY1LC43My04LjM3LTIuNDctMTQuNDgtNi44LTEzLjY2LTkuNjcsLjgzLTIuODcsOC4yOC0zLjIsMTYuNjUtLjczWiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48cGF0aCBkPSJNMTE2LjU0LDEwMy43NGM4Ljg4LDIuNjIsMTUuNDEsNy4wNywxNC41OSw5Ljk0LS44MywyLjg3LTguNywzLjA4LTE3LjU4LC40Ni04Ljg4LTIuNjItMTUuNDEtNy4wNy0xNC41OS05Ljk0LC44My0yLjg3LDguNy0zLjA4LDE3LjU4LS40NloiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTcxLjY0LDk3LjcxYy0yLjA4LTIuMTUtOC44OCwuOTgtMTUuMiw2Ljk5LTYuMzIsNi4wMS05Ljc2LDEyLjYzLTcuNjksMTQuNzgsMi4wOCwyLjE1LDguODgtLjk4LDE1LjItNi45OSw2LjMyLTYuMDEsOS43Ni0xMi42Myw3LjY5LTE0Ljc4WiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48L3N2Zz4=", xo = { id: "pera", chain: "algorand", name: "Pera Wallet", icon: PR, pkg: "@perawallet/connect" }, Q4 = class extends en {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r3, i = { shouldShowSignTxnToast: false };
        r3 = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./index-c551dac6.js").then((n2) => n2.i), true ? ["assets/index-c551dac6.js","assets/qr-code-styling-5f5f0e1c.js","assets/index-56481aea.js"] : void 0), s = n.PeraWalletConnect || n.default.PeraWalletConnect;
        e = new s(r3);
      }
      return e = Vh(e), new Q4({ sdk: e });
    } catch (e) {
      return console.error(`[${xo.id}] Error initializing...`, e), null;
    }
  }
  async connect(t) {
    var _a2;
    let e = await this.sdk.connect();
    if ((_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e.length === 0)
      throw new Error(`No accounts found for ${xo.id}`);
    let r3 = e.map((i, n) => ({ name: `Pera Wallet ${n + 1}`, address: i, walletId: xo.id }));
    return { ...xo, accounts: r3 };
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? { ...xo, accounts: e.map((r3, i) => ({ name: `Pera Wallet ${i + 1}`, address: r3, walletId: xo.id })) } : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let r3 = e.map((s) => Cr(s)), i = r3.reduce((s, o, f2) => (!("txn" in o) && t.includes(Ue(o.snd)) ? s.push({ txn: $s(e[f2]) }) : s.push({ txn: vn(e[f2]).txn, signers: [] }), s), []), n = await this.sdk.signTransaction([i]);
    return r3.reduce((s, o, f2) => {
      if ("txn" in o)
        s.push(e[f2]);
      else {
        let l = n.shift();
        l && s.push(l);
      }
      return s;
    }, []);
  }
}, Pg = Q4;
Xt(Pg, "PeraClient"), Rn(Pg, "metadata", xo);
var UR = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA2MDAgNjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6IzE5MTkxOTt9Cgkuc3Qxe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxnPgoJPHBhdGggY2xhc3M9InN0MCIgZD0iTTQ2MCwwSDE0MEM2Mi43LDAsMCw2Mi43LDAsMTQwdjMyMGMwLDc3LjMsNjIuNywxNDAsMTQwLDE0MGg0Ny45TDMwMCw0ODcuOUw0MTIuMSw2MDBINDYwCgkJYzc3LjMsMCwxNDAtNjIuNywxNDAtMTQwVjE0MEM2MDAsNjIuNyw1MzcuMywwLDQ2MCwweiIvPgo8L2c+CjxnPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTc3LjEsMjM0Ljl2MTE0LjZINDEuNlYyMzQuOUg3Ny4xeiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTIwNi4yLDIzNC45djExNC42aC0zOC45bC0zMS4zLTU2LjhsLTcuMy0xNS41aC0wLjNsMC43LDIyLjZ2NDkuN0g5OC4yVjIzNC45SDEzN2wzMS4zLDU2LjhsNy41LDE1LjVoMC4yCgkJbC0wLjctMjIuNnYtNDkuN0gyMDYuMnoiLz4KCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMjk5LDM0OS41IDMzOS4xLDM0OS41IDI5OS41LDI4MC45IDMzNi4zLDIzNC45IDI5Ny45LDIzNC45IDI2Mi44LDI4MS43IDI2Mi44LDIzNC45IDIyNy40LDIzNC45IAoJCTIyNy40LDM0OS41IDI2Mi44LDM0OS41IDI2Mi44LDMxOC42IDI3NC41LDMwMy41IAkiLz4KCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0zNTAsMzQ5LjVWMjM0LjloOTIuNHYyNi42aC01Ni45VjI4MGg0NS41djI0LjdoLTQ1LjV2MTguMmg1OS4ydjI2LjZIMzUweiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTU2NiwyMzQuOWwtNDAuMSw3NHY0MC42aC0zNS42di00MC42bC00MC4zLTc0SDQ4NmwxMy45LDI4LjZsOC41LDIwbDguMy0yMGwxNC4xLTI4LjZINTY2eiIvPgo8L2c+Cjwvc3ZnPgo=", rd = { id: "inkey", chain: "algorand", name: "Inkey Microwallet", icon: UR, pkg: "@thencc/inkey-client-js" }, zR = Xt((t) => {
  if (typeof window == null)
    throw new Error("[inkey] cannot access window");
  for (var e = "", r3 = new Uint8Array(t), i = r3.byteLength, n = 0; n < i; n++)
    e += String.fromCharCode(r3[n]);
  return window.btoa(e);
}, "arrayBufferToBase64"), e8 = class extends en {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r3, i = { src: "https://inkey-staging.web.app", align: "center" };
        r3 = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./index.esm-c3f74de7.js"), true ? [] : void 0);
        e = await (n.createClient || n.default.createClient)(r3);
      }
      return new e8({ sdk: e });
    } catch (e) {
      return console.warn(`[${rd.id}] Error initializing...`, e), null;
    }
  }
  async connect() {
    let t = await this.sdk.connect();
    if (!t)
      throw new Error("no inkeyAccounts");
    let e = t.map((i) => ({ address: i.address, name: i.username }));
    if (e.length === 0)
      throw new Error(`No accounts found for ${rd.id}`);
    let r3 = e.map((i) => ({ name: i.name, address: i.address, walletId: rd.id }));
    return { ...rd, accounts: r3 };
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let r3 = e.map((o) => Cr(o)), i = r3.reduce((o, f2, l) => (!("txn" in f2) && t.includes(Ue(f2.snd)) && o.push(e[l]), o), []).map((o) => zR(o)), n = await this.sdk.signTxns(i);
    if (!n.success)
      throw new Error("Error signing transactions");
    let s = n.signedTxns;
    return r3.reduce((o, f2, l) => {
      if ("txn" in f2)
        o.push(e[l]);
      else {
        let g5 = s.shift();
        g5 && o.push(g5);
      }
      return o;
    }, []);
  }
}, Ug = e8;
Xt(Ug, "InkeyClient"), Rn(Ug, "metadata", rd);
var HR = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHBhdGggZmlsbD0iIzI0NUVDNiIgZD0iTTE2LDMyYy0zLjIsMC02LjItMC45LTguOS0yLjdjLTIuNi0xLjgtNC43LTQuMy01LjktNy4yQzAsMTkuMi0wLjMsMTYsMC4zLDEyLjlDMC45LDkuOCwyLjQsNyw0LjcsNC43IEM2LjIsMy4yLDcuOSwyLDkuOSwxLjJDMTEuOCwwLjQsMTMuOSwwLDE2LDBzNC4yLDAuNCw2LjEsMS4yYzEuOSwwLjgsMy43LDIsNS4yLDMuNXMyLjcsMy4zLDMuNSw1LjJjMC44LDEuOSwxLjIsNCwxLjIsNi4xIHMtMC40LDQuMi0xLjIsNi4xYy0wLjgsMS45LTIsMy43LTMuNSw1LjJjLTEuNSwxLjUtMy4yLDIuNy01LjIsMy41QzIwLjIsMzEuNiwxOC4xLDMyLDE2LDMyTDE2LDMyeiBNMjAuMiwxMS4ybDAuMSwwLjVsMi42LDkuNWgyLjEgTDIxLjUsOC45bC0wLjEtMC4zaC0xLjlsMCwwLjFsLTEuNywzLjFMMTYsMTQuOWwwLDAuMWwwLTAuMWwtMC4yLTAuOGwtMC42LTIuNGwtMC4xLTAuMmwtMC43LTIuNmwtMC4xLTAuM2gtMS45bDAsMC4xbC0xLjcsMy4xIGwtMS44LDMuMkw3LjEsMThsLTEuOCwzLjJoMi4xTDkuMiwxOGwxLjgtMy4ybDEuOC0zLjJsMC4zLTAuNWwwLjEsMC41bDAuNSwyLjFsMC43LDIuNmwwLjIsMC45TDE0LjIsMThsLTEuOCwzLjJoMi4xbDAuOC0xLjMgbDEuMy0yLjNsMS41LTIuN2wxLjgtMy4yTDIwLjIsMTEuMkwyMC4yLDExLjJ6Ii8+Cjwvc3ZnPgo=", id = { id: "myalgo", chain: "algorand", name: "MyAlgo", icon: HR, pkg: "@randlabs/myalgo-connect" }, t8 = class extends en {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r3, i = { disableLedgerNano: false };
        r3 = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./buffer-DEE2PWSU-67624f80.js"), true ? [] : void 0);
        window.Buffer || (window.Buffer = n.Buffer || n.default.Buffer);
        let s = (await __vitePreload(() => import("./index-c31e7e70.js").then((n2) => n2.i), true ? [] : void 0)).default;
        e = new s(r3);
      }
      return e = Vh(e), new t8({ sdk: e });
    } catch (e) {
      return console.error(`[${id.id}] Error initializing...`, e), null;
    }
  }
  async connect() {
    let t = await this.sdk.connect();
    if (t.length === 0)
      throw new Error(`No accounts found for ${id.id}`);
    let e = t.map((r3) => ({ ...r3, walletId: id.id }));
    return { ...id, accounts: e };
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let r3 = e.map((s) => Cr(s)), i = r3.reduce((s, o, f2) => (!("txn" in o) && t.includes(Ue(o.snd)) && s.push(e[f2]), s), []), n = await this.sdk.signTransaction(i);
    return r3.reduce((s, o, f2) => {
      var _a2;
      if ("txn" in o)
        s.push(e[f2]);
      else {
        let l = (_a2 = n.shift()) == null ? void 0 : _a2.blob;
        l && s.push(l);
      }
      return s;
    }, []);
  }
}, zg = t8;
Xt(zg, "MyAlgoClient"), Rn(zg, "metadata", id);
var KR = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjM4IiBoZWlnaHQ9IjIzOCIgdmlld0JveD0iMCAwIDIzOCAyMzgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01MS43MDUgMTQ1LjA0MkgxMTYuNzA1TDEwNy43MDUgMTU1LjA0Mkg1MS43MDVWMTQ1LjA0MloiIGZpbGw9IiNENjQ1MDAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNDcuNTE5IDE5MS41NTdMMTI5LjU3NyAxNDQuMzk0TDE0Mi40MDQgMTI3LjExMkwxNjcuODc1IDE5MS41NTdIMTQ3LjUxOVpNMTEwLjkzNiA5NS4zOTMyTDEyMC42MTMgMTIwLjgzMUwxMzMuMzU5IDEwNC4yMjhMMTE3LjQ3NSA2NC4wNDIyQzExNS45MjggNjAuMTI4IDExMi4xNDYgNTcuNTU2NSAxMDcuOTM4IDU3LjU1NjVDMTAzLjcyOSA1Ny41NTY1IDk5Ljk0NzQgNjAuMTI4IDk4LjQwMDMgNjQuMDQyMkw2Ny45NjU5IDE0MS4wNDJIODcuNzgwN0M5NS40MTUzIDEyMS4wMTEgMTAyLjg5MyAxMDEuMzk5IDEwNS4xOTggOTUuMzU0MUMxMDUuNjQxIDk0LjE5MTIgMTA2Ljc0MyA5My40NTk5IDEwNy45ODcgOTMuNDU5OUgxMDguMTMyQzEwOS4zNzggOTMuNDU5OSAxMTAuNDkzIDk0LjIyOTMgMTEwLjkzNiA5NS4zOTMyWk04MC45MjEgMTU5LjA0MkM3NC45Mjg5IDE3NC43NjggNjkuODY2MSAxODguMDYzIDY4LjU0NDcgMTkxLjU1N0g0OEw2MC44NTE0IDE1OS4wNDJIODAuOTIxWiIgZmlsbD0iIzIyMkI2MCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3Ni4wMjYgNTQuNzUwOUMxNzcuOTk3IDUyLjA4NzIgMTgxLjc1NCA1MS41MjU3IDE4NC40MTggNTMuNDk2N0MxODcuMDgyIDU1LjQ2NzggMTg3LjY0MyA1OS4yMjUxIDE4NS42NzIgNjEuODg4OEwxMzAuMDEzIDEzNy4xMDdDMTI5LjcxNCAxMzcuNTEyIDEyOS4zNDEgMTM3Ljg1NyAxMjguOTEzIDEzOC4xMjNMMTE3Ljg1NiAxNDUuMDEzQzExNy4wODcgMTQ1LjQ5MyAxMTYuMTI4IDE0NC43ODMgMTE2LjM2MSAxNDMuOTA3TDExOS43MTggMTMxLjMxOEMxMTkuODQ3IDEzMC44MzIgMTIwLjA2OCAxMzAuMzc0IDEyMC4zNjcgMTI5Ljk3TDE3MC42NyA2MS45ODlMMTY5LjkyOSA2MS40NDA1QzE2OS40ODUgNjEuMTEyIDE2OC44NTkgNjEuMjA1NiAxNjguNTMgNjEuNjQ5NkwxNTIuMzExIDgzLjU2ODhDMTUyLjU4NiA4NC4yMDIzIDE1Mi41MjQgODQuOTYxMiAxNTIuMDg0IDg1LjU1NjJMMTQ5LjExIDg5LjU3NTVDMTQ4LjQ1MyA5MC40NjM0IDE0Ny4yMDEgOTAuNjUwNiAxNDYuMzEzIDg5Ljk5MzZDMTQ1LjQyNSA4OS4zMzY2IDE0NS4yMzggODguMDg0MSAxNDUuODk1IDg3LjE5NjJMMTQ3LjY3OSA4NC43ODQ3TDE0OC44NjkgODMuMTc2OUwxNjcuMzA4IDU4LjI1NzRDMTY4LjYyMiA1Ni40ODE1IDE3MS4xMjcgNTYuMTA3MiAxNzIuOTAzIDU3LjQyMTJMMTczLjY0NCA1Ny45Njk3TDE3Ni4wMjYgNTQuNzUwOVoiIGZpbGw9IiNENjQ1MDAiLz4KPC9zdmc+Cg==", nd = { id: "algosigner", chain: "algorand", name: "AlgoSigner", icon: KR, pkg: "" }, GR = Xt((t) => t === "betanet" ? "BetaNet" : t === "testnet" ? "TestNet" : t === "mainnet" ? "MainNet" : t, "getNetwork"), i8 = class extends en {
  constructor({ sdk: t, network: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "network");
    this.sdk = t, this.network = e;
  }
  static async init(t) {
    var _a2;
    try {
      if (typeof window > "u" || window.AlgoSigner === void 0)
        throw new Error("AlgoSigner is not available.");
      let e = window.AlgoSigner, r3 = "mainnet";
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.network) && (t.config.network == "mainnet" || t.config.network == "testnet" || t.config.network == "betanet" ? r3 = t.config.network : console.warn(`invalid network in ${nd.id} config`)), new i8({ sdk: e, network: r3 });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    await this.sdk.connect();
    let t = await this.sdk.accounts({ ledger: GR(this.network) });
    if (t.length === 0)
      throw new Error(`No accounts found for ${nd.id}`);
    let e = t.map(({ address: r3 }, i) => ({ name: `AlgoSigner ${i + 1}`, address: r3, walletId: nd.id }));
    return { ...nd, accounts: e };
  }
  async reconnect(t) {
    return (window === void 0 || window.AlgoSigner === void 0) && t(), null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let r3 = e.map((i) => Cr(i)).reduce((i, n, s) => {
      let o = { txn: this.sdk.encoding.msgpackToBase64(e[s]) };
      return ("txn" in n || !t.includes(Ue(n.snd))) && (o.txn = this.sdk.encoding.msgpackToBase64(vn(e[s]).txn.toByte()), o.signers = []), i.push(o), i;
    }, []);
    return (await this.sdk.signTxn(r3)).reduce((i, n, s) => (n ? i.push(new Uint8Array(r8.Buffer.from(n.blob, "base64"))) : i.push(e[s]), i), []);
  }
}, Hg = i8;
Xt(Hg, "AlgoSignerClient"), Rn(Hg, "metadata", nd);
var $R = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMDAgMzAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMDAgMzAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6dXJsKCNTVkdJRF8xXyk7fQoJLnN0MXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNDM0MjYxNjcxNDAxMDY1ODIyNzAwMDAwMDIxMzA3Njg5MDYwNzMxMTM0ODRfKTt9Cgkuc3Qye2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEwMjUxOTMxNjAxNTI3NjU4MTY0MDAwMDAxNjI3NDExMjM4MzE3NTY0MTc1OV8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTt9Cgkuc3Qze2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEzODU2MzM4MjQ2MjA4NjAyMDM1MDAwMDAxNDg3ODQ5MDI3MDc4MjA3MTIwN18pO30KCS5zdDR7bWFzazp1cmwoI21hc2swXzE2NjFfMjk1XzAwMDAwMDg4MTMyMjUxNTk3NDQxNTczNDkwMDAwMDExNjkzNjEyMDE4NTA2NjgxNDgxXyk7fQoJLnN0NXtmaWxsOnVybCgjU1ZHSURfMDAwMDAxMDYxMjA2MzI0NjE3OTI4NzExNjAwMDAwMDc0MzM5MTMwMzgzMzc3NjY1NzZfKTt9Cjwvc3R5bGU+CjxnPgoJCgkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDYuNjAzIiB5MT0iOS4yMjEyIiB4Mj0iMTc0LjE1OCIgeTI9IjMwOC41NDI2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xCgkJTDI3NC43LDkzLjl6Ii8+CgkKCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMjkuMzUxNiIgeTE9Ii0xOS4xNTczIiB4Mj0iNTYuOTA2NiIgeTI9IjI4MC4xNjQxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1Xyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCWw2OS4yLTQ1LjFWMjNMMjUuMyw5My45TDQzLDE1MC4xbC0xNy43LDU2LjJMMTMzLjcsMjc3di0zOS42bC02OS40LTQ1LjFMNzIuNSwxNjYuNHoiLz4KCTxkZWZzPgoJCTxmaWx0ZXIgaWQ9IkFkb2JlX09wYWNpdHlNYXNrRmlsdGVyIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ij4KCQkJPGZlQ29sb3JNYXRyaXggIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIxIDAgMCAwIDAgIDAgMSAwIDAgMCAgMCAwIDEgMCAwICAwIDAgMCAxIDAiLz4KCQk8L2ZpbHRlcj4KCTwvZGVmcz4KCQoJCTxtYXNrIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0IiBpZD0ibWFzazBfMTY2MV8yOTVfMDAwMDAwODgxMzIyNTE1OTc0NDE1NzM0OTAwMDAwMTE2OTM2MTIwMTg1MDY2ODE0ODFfIj4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjQ2LjYwMzgiIHkxPSI5LjIyMTQiIHgyPSIxNzQuMTU4OCIgeTI9IjMwOC41NDI4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwQjQ2RjkiLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JCRkJFMCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJPHBhdGggc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTsiIGQ9IgoJCQlNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xTDI3NC43LDkzLjl6Ii8+CgkJCgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMTk4MTE3MDc2MjE0NzI4MTQyNzAwMDAwMTA4Mjk2NTkzODM4NTEyMDI0OTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyOS4zNTIxIiB5MT0iLTE5LjE1NzEiIHgyPSI1Ni45MDcxIiB5Mj0iMjgwLjE2NDIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAzMDIpIj4KCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQkJGQkUwIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCQk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTE5ODExNzA3NjIxNDcyODE0MjcwMDAwMDEwODI5NjU5MzgzODUxMjAyNDkxXyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCQlsNjkuMi00NS4xVjIzTDI1LjMsOTMuOUw0MywxNTAuMWwtMTcuNyw1Ni4yTDEzMy43LDI3N3YtMzkuNmwtNjkuNC00NS4xTDcyLjUsMTY2LjR6Ii8+Cgk8L21hc2s+Cgk8ZyBjbGFzcz0ic3Q0Ij4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDEwOTAxOTkxODU1Nzc3MzA1MzQyMDAwMDAxNzYwMjQwNTkwODA2NzEyMDMwMF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDYuNDY2MiIgeTE9IjIyOC43NTU0IiB4Mj0iMTcxLjg2MzgiIHkyPSIxMzUuMTAzOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDMwMikiPgoJCQk8c3RvcCAgb2Zmc2V0PSIwLjExOTgiIHN0eWxlPSJzdG9wLWNvbG9yOiM4OTUyRkY7c3RvcC1vcGFjaXR5OjAuODciLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0RBQkRGRjtzdG9wLW9wYWNpdHk6MCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJCgkJCTxyZWN0IHg9IjI1LjQiIHk9IjIzIiBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTA5MDE5OTE4NTU3NzczMDUzNDIwMDAwMDE3NjAyNDA1OTA4MDY3MTIwMzAwXyk7IiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ii8+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", Zh = { id: "exodus", chain: "algorand", name: "Exodus", icon: $R, pkg: "" }, n8 = class extends en {
  constructor({ sdk: t, onlyIfTrusted: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "onlyIfTrusted");
    this.sdk = t, this.onlyIfTrusted = e;
  }
  static async init(t) {
    var _a2, _b;
    try {
      if (typeof window > "u" || window.exodus === void 0)
        throw new Error("Exodus is not available. Do you have the browser extension installed?");
      let e = window.exodus.algorand, r3 = false;
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.onlyIfTrusted) && (r3 = (_b = t == null ? void 0 : t.config) == null ? void 0 : _b.onlyIfTrusted), new n8({ sdk: e, onlyIfTrusted: r3 });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    let t = "";
    try {
      let { address: r3 } = await window.exodus.algorand.connect({ onlyIfTrusted: this.onlyIfTrusted });
      t = r3;
    } catch (r3) {
      throw console.warn("err w exodus connect"), r3;
    }
    if (!t)
      throw new Error(`No accounts found for ${Zh.id}`);
    let e = [{ name: "Exodus 1", address: t, walletId: Zh.id }];
    return { ...Zh, accounts: e };
  }
  async reconnect(t) {
    return (window === void 0 || window.exodus === void 0 || window.exodus.algorand.isConnected !== true) && t(), null;
  }
  async disconnect() {
    window.exodus.algorand.disconnect();
  }
  async signTransactions(t, e, r3, i = true) {
    let n = e.map((l) => Cr(l)), s = [], o = n.reduce((l, g5, _) => {
      let N2 = "txn" in g5;
      return (r3 && r3.length && r3.includes(_) || !N2 && t.includes(Ue(g5.snd))) && (s.push(_), l.push(e[_])), l;
    }, []), f2 = await window.exodus.algorand.signTransaction(o);
    return e.reduce((l, g5, _) => {
      if (s.includes(_)) {
        let N2 = f2.shift();
        N2 && l.push(N2);
      } else
        i && l.push(e[_]);
      return l;
    }, []);
  }
}, Kg = n8;
Xt(Kg, "ExodusClient"), Rn(Kg, "metadata", Zh);
var WR = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiLz4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNjgyMDksMCwwLDEuNjgyMDksMjI2LjM2OCwyMTIuODE4KSI+CiAgICAgICAgPHBhdGggZD0iTTMyNy4wNDksMjgwLjE5MkwxNjkuNTI0LDEzTDEyLDI4MC4xOTJMMTY5LjUyNCwxODkuMDg0TDMyNy4wNDksMjgwLjE5MloiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvOyIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS42ODIwOSwwLDAsMS42ODIwOSwyMjYuMzY4LDIxMi44MTgpIj4KICAgICAgICA8cGF0aCBkPSJNMjk5LjU0NiwzMDdMMTY5LjUyNSwyMzguNDczTDM5LjUwNCwzMDdMMTY5LjUyNSwyNjQuNjdMMjk5LjU0NiwzMDdaIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybzsiLz4KICAgIDwvZz4KPC9zdmc+Cg==", gf = { id: "defly", chain: "algorand", name: "Defly", icon: WR, pkg: "@blockshake/defly-connect" }, s8 = class extends en {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r3, i = { shouldShowSignTxnToast: false };
        r3 = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./index-eef8d67d.js").then((n2) => n2.i), true ? ["assets/index-eef8d67d.js","assets/qr-code-styling-5f5f0e1c.js","assets/lottie-3dd57f71.js"] : void 0), s = n.DeflyWalletConnect || n.default.DeflyWalletConnect;
        e = new s(r3);
      }
      return new s8({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect(t) {
    let e = await this.sdk.connect().catch(console.info);
    if (this.sdk.connector.on("disconnect", t), !e || e.length === 0)
      throw new Error(`No accounts found for ${gf.id}`);
    let r3 = e.map((i, n) => ({ name: `Defly Wallet ${n + 1}`, address: i, walletId: gf.id }));
    return { ...gf, accounts: r3 };
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? { ...gf, accounts: e.map((r3, i) => ({ name: `Defly Wallet ${i + 1}`, address: r3, walletId: gf.id })) } : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let r3 = e.map((s) => Cr(s)), i = r3.reduce((s, o, f2) => (!("txn" in o) && t.includes(Ue(o.snd)) ? s.push({ txn: $s(e[f2]) }) : s.push({ txn: vn(e[f2]).txn, signers: [] }), s), []), n = await this.sdk.signTransaction([i]);
    return r3.reduce((s, o, f2) => {
      if ("txn" in o)
        s.push(e[f2]);
      else {
        let l = n.shift();
        l && s.push(l);
      }
      return s;
    }, []);
  }
}, Gg = s8;
Xt(Gg, "DeflyClient"), Rn(Gg, "metadata", gf);
var VR = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e %3c!-- Generated by Pixelmator Pro 3.2.2 --%3e %3csvg width='409' height='210' viewBox='0 0 409 210' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctext id='MNEMONIC' xml:space='preserve' x='0' y='129' font-family='Helvetica' font-size='72' fill='black'%3eMNEMONIC%3c/text%3e%3c/svg%3e", $g = { id: "mnemonic", name: "Mnemonic", icon: VR, chain: "algorand", pkg: "" }, o8 = class extends en {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else if (t && t.config && t.config.mnemonic) {
        let r3 = t.config.mnemonic;
        e = go(r3);
      }
      return new o8({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    if (this.sdk == null) {
      let t = await this.requestMnemonic();
      if (!t)
        throw this.sdk = void 0, new Error("Mnemonic passphrase is required");
      let e = go(t);
      this.sdk = e;
    }
    return { ...$g, accounts: [{ name: "Mnemonic Wallet 1", address: this.sdk.addr, walletId: $g.id }] };
  }
  async disconnect() {
    this.sdk = void 0;
  }
  async reconnect() {
    return null;
  }
  async requestMnemonic() {
    if (Jh())
      return prompt("Enter mnemonic passphrase (25 words)") || "";
    throw new Error("Not used in a browser");
  }
  signTransactions(t, e, r3, i = true) {
    if (!this.sdk)
      throw new Error("Client has no account");
    let n = e.map((g5) => Cr(g5)), s = [], o = [];
    for (let g5 in n) {
      let _ = n[g5], N2 = "txn" in _;
      if (s.push(e[g5]), N2 || r3 && r3.length && !r3.includes(Number(g5)) || !t.includes(Ue(_.snd)))
        continue;
      s[g5] = new Uint8Array();
      let U2 = zt.from_obj_for_encoding(_).signTxn(this.sdk.sk);
      o.push(U2);
    }
    let f2 = 0, l = s.reduce((g5, _, N2) => (_.length === 0 ? (g5.push(o[f2]), f2 += 1) : i && g5.push(_), g5), []);
    return Promise.resolve(l);
  }
}, Wg = o8;
Xt(Wg, "MnemonicClient"), Rn(Wg, "metadata", $g);
var mf = { pera: { client: Pg }, inkey: { client: Ug }, myalgo: { client: zg }, algosigner: { client: Hg }, exodus: { client: Kg }, defly: { client: Gg }, mnemonic: { client: Wg } };
Object.values(mf).map((t) => t.client.metadata.id);
Object.values(mf).map((t) => t.client.metadata.pkg).filter((t) => t !== "");
Xt((t) => {
  let e = [];
  for (let r3 of t)
    e.push(mf[r3].client.metadata.pkg);
  return e;
}, "excludeClients");
var vo = Xt((t, e = true) => {
  let r3 = hf({ id: t, metadata: mf[t].client.metadata, client: null, initParams: e, inited: false, initing: false, signing: false, connecting: false, isReady: async () => (r3.inited || (r3.initing = true, typeof r3.initParams == "object" && (r3.initParams.config || r3.initParams.sdk) ? r3.client = await mf[t].client.init(r3.initParams) : e == true ? r3.client = await mf[t].client.init() : console.warn("bad/incomplete init params for wallet:", t), r3.initing = false, r3.inited = true), true), connect: async () => {
    r3.connecting = true;
    try {
      await r3.isReady();
      let { accounts: i } = await r3.client.connect(() => {
      });
      return YR(i), ZR(i[0]), i;
    } catch (i) {
      throw i;
    } finally {
      r3.connecting = false;
    }
  }, disconnect: async () => {
    J4(t), await r3.isReady();
    try {
      await r3.client.disconnect();
    } catch (i) {
      console.warn(i);
    }
  }, reconnect: async () => {
    await r3.isReady(), await r3.client.reconnect(() => {
    });
  }, setAsActiveWallet: () => {
    let i = Z4(t);
    if (i)
      mt.stored.activeAccount = i[0];
    else
      throw new Error("No accounts for this provider to set as active");
  }, removeAccounts: () => {
    J4(t);
  }, signTransactions: async (i) => {
    await r3.isReady();
    let n = r3.accounts.map((s) => s.address);
    n.length || (n = (await r3.connect()).map((s) => s.address), await new Promise((s) => setTimeout(s, 1e3))), r3.signing = true;
    try {
      return await r3.client.signTransactions(n, i);
    } catch (s) {
      throw s;
    } finally {
      r3.signing = false;
    }
  }, get accounts() {
    return Qi(Fn(() => Z4(t)));
  }, get isActive() {
    return Fn(() => {
      var _a2;
      return ((_a2 = mt.stored.activeAccount) == null ? void 0 : _a2.walletId) === t;
    });
  }, get isConnected() {
    return Qi(Fn(() => mt.stored.connectedAccounts.some((i) => i.walletId === t)));
  } });
  return r3;
}, "createWallet"), a8 = Xt((t = XR) => {
  var _a2, _b;
  mt.enabledWallets == null && (mt.enabledWallets = {});
  for (let [r3, i] of Object.entries(t)) {
    let n = r3;
    mt.allWallets[n].initParams = i, mt.enabledWallets[n] = mt.allWallets[n];
  }
  let e = (_a2 = mt.stored.activeAccount) == null ? void 0 : _a2.walletId;
  return e && (new Set(Object.keys(t)).has(e) || ((_b = mt.allWallets[e]) == null ? void 0 : _b.disconnect())), mt.enabledWallets;
}, "enableWallets"), Z4 = Xt((t) => mt.stored.connectedAccounts.filter((e) => e.walletId === t), "getAccountsByWalletId"), J4 = Xt((t) => {
  if (mt.stored.activeAccount) {
    let r3 = mt.stored.connectedAccounts.filter((i) => i.walletId == t);
    for (let i of r3)
      if (i.address == mt.stored.activeAccount.address && i.walletId == mt.stored.activeAccount.walletId) {
        mt.stored.activeAccount = null;
        break;
      }
  }
  let e = mt.stored.connectedAccounts.filter((r3) => r3.walletId !== t);
  mt.stored.connectedAccounts = e;
}, "removeAccountsByWalletId"), YR = Xt((t) => {
  for (let e of t) {
    let r3 = false;
    for (let i of mt.stored.connectedAccounts)
      e.walletId == i.walletId && e.address == i.address && (r3 = true);
    r3 || mt.stored.connectedAccounts.push(e);
  }
}, "addConnectedAccounts"), ZR = Xt((t) => {
  mt.stored.activeAccount = t;
}, "setAsActiveAccount"), f8 = Xt(async (t) => {
  if (!mt.enabledWallets)
    throw new Error("No wallets enabled, call enableWallets() first");
  let e = Object.keys(mt.enabledWallets), r3 = mt.activeWalletId;
  if (e.length == 1 && (r3 = e[0]), !r3)
    throw new Error("No active wallet id");
  let i = mt.enabledWallets[r3];
  if (!i)
    throw new Error("No active wallet... how'd you get here.");
  return await i.signTransactions(t);
}, "signTransactions"), JR = ((t) => (t.PERA = "pera", t.INKEY = "inkey", t.MYALGO = "myalgo", t.ALGOSIGNER = "algosigner", t.EXODUS = "exodus", t.DEFLY = "defly", t.MNEMONIC = "mnemonic", t))(JR || {}), XR = { pera: true, inkey: true, myalgo: true, algosigner: true, exodus: true, defly: true }, QR = { pera: vo("pera"), inkey: vo("inkey"), myalgo: vo("myalgo"), algosigner: vo("algosigner"), exodus: vo("exodus"), defly: vo("defly"), mnemonic: vo("mnemonic") }, mt = hf({ allWallets: QR, enabledWallets: null, stored: { version: 0, connectedAccounts: [], activeAccount: null }, activeAddress: Qi(Fn(() => {
  let t = "";
  return mt.stored.activeAccount && (t = mt.stored.activeAccount.address), t;
})), activeWalletId: Qi(Fn(() => {
  let t = null;
  return mt.stored.activeAccount && (t = mt.stored.activeAccount.walletId), t;
})), activeWallet: Qi(Fn(() => {
  let t;
  return mt.activeWalletId !== null && mt.enabledWallets !== null && (t = mt.enabledWallets[mt.activeWalletId]), t;
})), isSigning: Qi(Fn(() => {
  let t = false;
  if (mt.enabledWallets) {
    for (let [e, r3] of Object.entries(mt.enabledWallets))
      if (r3.signing) {
        t = true;
        break;
      }
  }
  return t;
})) });
Jh() && qR();
U();
var ek = { LEDGER: "testnet", BASE_SERVER: "https://testnet-api.algonode.cloud", INDEX_SERVER: "", API_TOKEN: "", PORT: "" };
var Vg = ek;
U();
var Yg = { disableLogs: false };
U();
var pi = { enabled: false, log(...t) {
  !this.enabled || console.log(...t);
}, debug(...t) {
  !this.enabled || console.debug(...t);
} };
var Zg = class {
  constructor(e) {
    __publicField(this, "algodClient");
    __publicField(this, "indexerClient");
    __publicField(this, "nodeConfig", Vg);
    __publicField(this, "libConfig", Yg);
    __publicField(this, "sdk", A4);
    __publicField(this, "AnyWalletState", mt);
    this.setNodeConfig(e == null ? void 0 : e.nodeConfig), this.initAnyWallet(e == null ? void 0 : e.anyWalletConfig), this.setLibConfig(e == null ? void 0 : e.libConfig);
  }
  initAnyWallet(e) {
    let r3 = { inkey: true }, i = (e == null ? void 0 : e.walletInitParams) || r3;
    a8(i);
  }
  setLibConfig(e) {
    e == null && (e = Yg), e !== void 0 && "disableLogs" in e && typeof e.disableLogs == "boolean" && (pi.enabled = !e.disableLogs);
  }
  isValidNodeConfig(e) {
    let r3 = true;
    return (e == null || !e.BASE_SERVER) && (r3 = false), r3;
  }
  setNodeConfig(e) {
    if (e == null && (e = Vg), !this.isValidNodeConfig(e))
      throw new Error("bad node config!");
    this.nodeConfig = e, this.algodClient = new ro(e.API_TOKEN, e.BASE_SERVER, e.PORT), e.INDEX_SERVER ? this.indexerClient = new po(e.API_TOKEN, e.INDEX_SERVER, e.PORT) : console.warn("No indexer configured because INDEX_SERVER was not provided.");
  }
  getNodeConfig() {
    return this.nodeConfig ? this.nodeConfig : false;
  }
  async checkStatus() {
    if (!this.getNodeConfig())
      throw new Error("No node configuration set.");
    let e = await this.algodClient.status().do();
    return pi.log("Algorand network status: %o", e), e;
  }
  authWithMnemonic(e) {
    if (!e)
      throw new Error("algonaut.authWithMnemonic: No mnemonic provided.");
    let r3 = Ni.recoverAccount(e);
    return this.initAnyWallet({ walletInitParams: { mnemonic: { config: { mnemonic: e } } } }), this.AnyWalletState.enabledWallets && this.AnyWalletState.enabledWallets.mnemonic && this.AnyWalletState.enabledWallets.mnemonic.setAsActiveWallet(), r3;
  }
  async waitForConfirmation(e, r3, i = false) {
    var _a2;
    if (!e)
      throw new Error("waitForConfirmation: No transaction ID provided.");
    let n = (await this.algodClient.status().do())["last-round"], s = n + (r3 || 50), o = { status: "fail", message: "" };
    for (; n < s; ) {
      let f2 = "";
      try {
        f2 = await this.algodClient.pendingTransactionInformation(e).do(), i && pi.log("waiting for confirmation");
      } catch (l) {
        console.error((_a2 = l.response) == null ? void 0 : _a2.text);
      }
      if (f2["confirmed-round"] !== null && f2["confirmed-round"] > 0) {
        i && pi.log("Transaction confirmed in round " + f2["confirmed-round"]), o.txId = e, o.status = "success", o.message = "Transaction confirmed in round " + f2["confirmed-round"];
        break;
      }
      n = (await this.algodClient.status().do())["last-round"];
    }
    return o;
  }
  generateLogicSig(e) {
    if (!e)
      throw new Error("No program string provided.");
    return Ni.generateLogicSig(e);
  }
  async atomicOptInAsset(e, r3) {
    if (!this.AnyWalletState.activeAddress)
      throw new Error("No account set in Algonaut.");
    if (!e)
      throw new Error("No asset index provided.");
    let i = (r3 == null ? void 0 : r3.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Ku({ from: this.AnyWalletState.activeAddress, to: this.AnyWalletState.activeAddress, assetIndex: e, amount: 0, suggestedParams: i }), transactionSigner: void 0, isLogigSig: false };
  }
  async optInAsset(e, r3, i) {
    if (!this.AnyWalletState.activeAddress)
      throw new Error("There was no account!");
    if (!e)
      throw new Error("No asset index provided.");
    let { transaction: n } = await this.atomicOptInAsset(e, i);
    return await this.sendTransaction(n, r3);
  }
  async isOptedIntoAsset(e) {
    if (!e.account)
      throw new Error("No account provided.");
    if (!e.assetId)
      throw new Error("No asset ID provided.");
    let r3 = false;
    return (await this.getAccountInfo(e.account)).assets.forEach((n) => {
      n["asset-id"] == e.assetId && (r3 = true);
    }), r3;
  }
  encodeArguments(e) {
    return Ni.encodeArguments(e);
  }
  async atomicCreateAsset(e) {
    var _a2;
    if (!e.assetName)
      throw new Error("args.assetName not provided.");
    if (!e.symbol)
      throw new Error("args.symbol not provided");
    if (typeof e.decimals > "u")
      throw new Error("args.decimals not provided.");
    if (!e.amount)
      throw new Error("args.amount not provided.");
    let r3 = e.from || this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    e.metaBlock || (e.metaBlock = " "), e.defaultFrozen || (e.defaultFrozen = false), e.assetURL || (e.assetURL = void 0);
    let i = e.metaBlock.length;
    if (i > 1023)
      throw console.error("meta block is " + i), new Error("drat! this meta block is too long!");
    let s = new TextEncoder().encode(e.metaBlock), o = e.amount, f2 = e.manager && e.manager.length > 0 ? e.manager : r3, l = e.reserve && e.reserve.length > 0 ? e.reserve : r3, g5 = e.freeze && e.freeze.length > 0 ? e.freeze : r3, _ = e.clawback && e.clawback.length > 0 ? e.clawback : r3, N2 = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Rh(r3, s, o, e.decimals, e.defaultFrozen, f2, l, g5, _, e.symbol, e.assetName, e.assetURL, e.assetMetadataHash, N2), transactionSigner: void 0, isLogigSig: false };
  }
  async createAsset(e, r3) {
    let n = (await this.atomicCreateAsset(e)).transaction;
    try {
      let o = await this.sendTransaction(n, r3), f2 = await this.algodClient.pendingTransactionInformation(n.txID().toString()).do();
      return o.createdIndex = f2["asset-index"], o;
    } catch (s) {
      throw pi.log("transaction error"), pi.log(s), new Error(s);
    }
  }
  async atomicDeleteAsset(e, r3) {
    if (!this.AnyWalletState.activeAddress)
      throw new Error("there was no account!");
    if (!e)
      throw new Error("No assetId provided!");
    let i = new TextEncoder(), n = (r3 == null ? void 0 : r3.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: kh(this.AnyWalletState.activeAddress, i.encode("doh!"), e, n), transactionSigner: void 0, isLogigSig: false };
  }
  async deleteAsset(e, r3, i) {
    if (!e)
      throw new Error("No asset ID provided!");
    let { transaction: n } = await this.atomicDeleteAsset(e, i);
    return await this.sendTransaction(n, r3);
  }
  async atomicSendAsset(e) {
    var _a2;
    if (!e.to)
      throw new Error("No to address provided");
    if (!e.assetIndex)
      throw new Error("No asset index provided");
    if (!e.amount)
      throw new Error("No amount provided");
    let r3 = e.from || this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Ku({ from: r3, to: e.to, amount: e.amount, assetIndex: e.assetIndex, suggestedParams: i }), transactionSigner: void 0, isLogigSig: false };
  }
  async sendAsset(e, r3) {
    if (!(e.from || this.AnyWalletState.activeAddress))
      throw new Error("there is no fromAddr");
    let { transaction: n } = await this.atomicSendAsset(e);
    return await this.sendTransaction(n, r3);
  }
  async getAssetInfo(e) {
    if (!e)
      throw new Error("No asset ID provided");
    return await this.algodClient.getAssetByID(e).do();
  }
  async atomicOptInApp(e) {
    var _a2, _b, _c2, _d, _e, _f, _g2;
    if (!e.appIndex)
      throw new Error("No app ID provided");
    let r3 = this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: bg({ from: r3, appIndex: e.appIndex, suggestedParams: i, appArgs: e.appArgs ? this.encodeArguments(e.appArgs) : void 0, accounts: ((_b = e.optionalFields) == null ? void 0 : _b.accounts) ? (_c2 = e.optionalFields) == null ? void 0 : _c2.accounts : void 0, foreignApps: ((_d = e.optionalFields) == null ? void 0 : _d.applications) ? (_e = e.optionalFields) == null ? void 0 : _e.applications : void 0, foreignAssets: ((_f = e.optionalFields) == null ? void 0 : _f.assets) ? (_g2 = e.optionalFields) == null ? void 0 : _g2.assets : void 0 }), transactionSigner: void 0, isLogigSig: false };
  }
  async optInApp(e, r3) {
    let { transaction: i } = await this.atomicOptInApp(e);
    return await this.sendTransaction(i, r3);
  }
  async atomicDeleteApp(e, r3) {
    if (!e)
      throw new Error("No app ID provided");
    let i = this.AnyWalletState.activeAddress;
    if (!i)
      throw new Error("there is no fromAddr");
    let n = (r3 == null ? void 0 : r3.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Nh(i, n, e), transactionSigner: void 0, isLogigSig: false };
  }
  async deleteApp(e, r3, i) {
    var _a2;
    try {
      let { transaction: n } = await this.atomicDeleteApp(e, i), s = n.txID().toString(), o = await this.sendTransaction(n, r3), l = (await this.algodClient.pendingTransactionInformation(s).do()).txn.txn.apid;
      return { status: "success", message: "deleted app index " + l, txId: s };
    } catch (n) {
      throw pi.log(n), new Error((_a2 = n.response) == null ? void 0 : _a2.text);
    }
  }
  async atomicCallApp(e) {
    var _a2, _b, _c2, _d, _e;
    let r3 = (e == null ? void 0 : e.from) || this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    if (!e.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    let i = this.encodeArguments(e.appArgs), n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Bh({ from: r3, suggestedParams: n, appIndex: e.appIndex, appArgs: i, accounts: ((_b = e.optionalFields) == null ? void 0 : _b.accounts) || void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) || void 0, foreignAssets: ((_d = e.optionalFields) == null ? void 0 : _d.assets) || void 0, note: ((_e = e.optionalFields) == null ? void 0 : _e.note) ? this.to8Arr(e.optionalFields.note) : void 0 }), transactionSigner: void 0, isLogigSig: false };
  }
  async callApp(e, r3) {
    let { transaction: i } = await this.atomicCallApp(e);
    return await this.sendTransaction(i, r3);
  }
  async atomicCallAppWithLSig(e) {
    var _a2, _b, _c2, _d;
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    if (!e.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    let r3 = this.encodeArguments(e.appArgs), i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Bh({ from: e.lsig.address(), suggestedParams: i, appIndex: e.appIndex, appArgs: r3, accounts: ((_b = e.optionalFields) == null ? void 0 : _b.accounts) || void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) || void 0, foreignAssets: ((_d = e.optionalFields) == null ? void 0 : _d.assets) || void 0 }), transactionSigner: e.lsig, isLogigSig: true };
  }
  async atomicCloseOutApp(e) {
    var _a2, _b, _c2, _d;
    let r3 = (e == null ? void 0 : e.from) || this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    try {
      let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), n = this.encodeArguments(e.appArgs);
      return { transaction: vg({ from: r3, suggestedParams: i, appIndex: e.appIndex, appArgs: n, accounts: ((_b = e.optionalFields) == null ? void 0 : _b.accounts) || void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) || void 0, foreignAssets: ((_d = e.optionalFields) == null ? void 0 : _d.assets) || void 0 }), transactionSigner: void 0, isLogigSig: false };
    } catch (i) {
      throw new Error(i);
    }
  }
  async closeOutApp(e, r3) {
    let { transaction: i } = await this.atomicCloseOutApp(e);
    return await this.sendTransaction(i, r3);
  }
  getAppEscrowAccount(e) {
    if (!e)
      throw new Error("No appId provided");
    return Ni.getAppEscrowAccount(e);
  }
  async getAppInfo(e) {
    if (!e)
      throw new Error("No appId provided");
    let r3 = [this.algodClient.getApplicationByID(e).do()];
    this.AnyWalletState.activeAddress && r3.push(this.getAppLocalState(e));
    let n = await Promise.all(r3), s = n[0], o = n[1], f2 = { hasState: true, globals: [], locals: (o == null ? void 0 : o.locals) || [], creatorAddress: s.params.creator, index: e };
    return s.params["global-state"] && (f2.globals = this.decodeStateArray(s.params["global-state"])), f2;
  }
  async createApp(e, r3) {
    var _a2, _b, _c2, _d, _e;
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw console.warn("drat! your note is too long!"), new Error("Your note is too long");
    let i = this.AnyWalletState.activeAddress;
    if (!i)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (!e.schema)
      throw new Error("No schema provided");
    try {
      let n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), s = new Uint8Array(), o = new Uint8Array();
      if (s = await this.compileProgram(e.tealApprovalCode), o = await this.compileProgram(e.tealClearCode), s && o) {
        let f2 = yg({ from: i, suggestedParams: n, onComplete: lr.NoOpOC, approvalProgram: s, clearProgram: o, numLocalInts: e.schema.localInts, numLocalByteSlices: e.schema.localBytes, numGlobalInts: e.schema.globalInts, numGlobalByteSlices: e.schema.globalBytes, appArgs: this.encodeArguments(e.appArgs), accounts: ((_b = e.optionalFields) == null ? void 0 : _b.accounts) ? e.optionalFields.accounts : void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) ? e.optionalFields.applications : void 0, foreignAssets: ((_d = e.optionalFields) == null ? void 0 : _d.assets) ? e.optionalFields.assets : void 0, note: ((_e = e.optionalFields) == null ? void 0 : _e.note) ? this.to8Arr(e.optionalFields.note) : void 0 }), l = f2.txID().toString(), g5 = await this.sendTransaction(f2, r3), _ = await this.algodClient.pendingTransactionInformation(l).do();
        return g5.message = "Created App ID: " + _["application-index"], g5.createdIndex = _["application-index"], g5.meta = _, g5.txId = l, g5;
      } else
        throw new Error("could not compile teal code");
    } catch (n) {
      throw new Error(n.message);
    }
  }
  async atomicCreateApp(e) {
    var _a2, _b, _c2, _d, _e;
    let r3 = this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (!e.schema)
      throw new Error("No schema provided");
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    if (r3)
      try {
        let i = lr.NoOpOC, n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), s = new Uint8Array(), o = new Uint8Array();
        if (s = await this.compileProgram(e.tealApprovalCode), o = await this.compileProgram(e.tealClearCode), !s || !o)
          throw new Error("Error: you must provide an approval program and a clear state program.");
        return { transaction: Gu(r3, n, i, s, o, e.schema.localInts, e.schema.localBytes, e.schema.globalInts, e.schema.globalBytes, this.encodeArguments(e.appArgs), ((_b = e.optionalFields) == null ? void 0 : _b.accounts) ? e.optionalFields.accounts : void 0, ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) ? e.optionalFields.applications : void 0, ((_d = e.optionalFields) == null ? void 0 : _d.assets) ? e.optionalFields.assets : void 0, ((_e = e.optionalFields) == null ? void 0 : _e.note) ? this.to8Arr(e.optionalFields.note) : void 0), transactionSigner: void 0, isLogigSig: false };
      } catch {
        throw new Error("There was an error creating the transaction");
      }
    else
      throw new Error("Algonaut.js has no account loaded!");
  }
  async deployTealWithLSig(e) {
    var _a2, _b;
    if (e.noteText && e.noteText.length > 511)
      throw new Error("Your note is too long");
    let r3 = [];
    e.appArgs && e.appArgs.length && (r3 = this.encodeArguments(e.appArgs));
    let i = e.lsig.address(), n = lr.NoOpOC, s = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), o = new Uint8Array(), f2 = new Uint8Array();
    try {
      if (o = await this.compileProgram(e.tealApprovalCode), f2 = await this.compileProgram(e.tealClearCode), o && f2) {
        let l = Gu(i, s, n, o, f2, e.schema.localInts, e.schema.localBytes, e.schema.globalInts, e.schema.globalBytes, r3, ((_b = e.optionalFields) == null ? void 0 : _b.accounts) || void 0), g5 = l.txID().toString(), _ = mo(l, e.lsig);
        await this.algodClient.sendRawTransaction(_.blob).do();
        let N2 = await this.waitForConfirmation(g5), V = (await this.algodClient.pendingTransactionInformation(g5).do())["application-index"];
        return { status: "success", message: "created new app with id: " + V, txId: g5 };
      } else
        throw new Error("Error compiling programs.");
    } catch (l) {
      throw console.error("Error deploying contract:"), new Error(l);
    }
  }
  async atomicUpdateApp(e) {
    var _a2, _b, _c2, _d, _e;
    let r3 = this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    try {
      let i = lr.NoOpOC, n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), s = new Uint8Array(), o = new Uint8Array();
      if (s = await this.compileProgram(e.tealApprovalCode), o = await this.compileProgram(e.tealClearCode), !s || !o)
        throw new Error("Error: you must provide an approval program and a clear state program.");
      return { transaction: Dh(r3, n, e.appIndex, s, o, this.encodeArguments(e.appArgs), ((_b = e.optionalFields) == null ? void 0 : _b.accounts) ? e.optionalFields.accounts : void 0, ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) ? e.optionalFields.applications : void 0, ((_d = e.optionalFields) == null ? void 0 : _d.assets) ? e.optionalFields.assets : void 0, ((_e = e.optionalFields) == null ? void 0 : _e.note) ? this.to8Arr(e.optionalFields.note) : void 0), transactionSigner: void 0, isLogigSig: false };
    } catch {
      throw new Error("There was an error creating the transaction");
    }
  }
  async updateApp(e, r3) {
    let { transaction: i } = await this.atomicUpdateApp(e);
    return await this.sendTransaction(i, r3);
  }
  async compileProgram(e) {
    let i = new TextEncoder().encode(e), n = await this.algodClient.compile(i).do();
    return new Uint8Array(Ur.Buffer.from(n.result, "base64"));
  }
  async atomicSendAlgo(e) {
    var _a2, _b;
    if (!e.amount)
      throw new Error("You did not specify an amount!");
    if (!e.to)
      throw new Error("You did not specify a to address");
    let r3 = e.from || this.AnyWalletState.activeAddress;
    if (!r3)
      throw new Error("there is no fromAddr");
    if (r3) {
      let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.note) ? this.to8Arr(e.optionalFields.note) : new Uint8Array(), n = ((_b = e.optionalFields) == null ? void 0 : _b.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: Fh({ from: r3, to: e.to, amount: e.amount, note: i, suggestedParams: n }), transactionSigner: void 0, isLogigSig: false };
    } else
      throw new Error("there is no fromAddr");
  }
  async sendAlgo(e, r3) {
    let { transaction: i } = await this.atomicSendAlgo(e);
    return await this.sendTransaction(i, r3);
  }
  async getAccountInfo(e) {
    if (!e)
      throw new Error("No address provided");
    return await this.algodClient.accountInformation(e).do();
  }
  async getAlgoBalance(e) {
    if (!e)
      throw new Error("No address provided");
    return (await this.algodClient.accountInformation(e).do()).amount;
  }
  async getTokenBalance(e, r3) {
    if (!e)
      throw new Error("No address provided");
    if (!r3)
      throw new Error("No asset index provided");
    let i = await this.algodClient.accountInformation(e).do(), n = 0;
    return i.assets.forEach((s) => {
      s["asset-id"] == r3 && (n = s.amount);
    }), n;
  }
  async accountHasTokens(e, r3) {
    return "this is not done yet";
  }
  async getAppGlobalState(e) {
    if (!e)
      throw new Error("No application ID provided");
    let r3 = await this.getAppInfo(e);
    return r3.hasState ? this.stateArrayToObject(r3.globals) : {};
  }
  async getAppLocalState(e, r3) {
    if (!e)
      throw new Error("No application ID provided");
    let i = { hasState: false, globals: [], locals: [], creatorAddress: "", index: e };
    if (this.AnyWalletState.activeAddress && !r3 && (r3 = this.AnyWalletState.activeAddress), r3) {
      let n = await this.algodClient.accountInformation(r3).do();
      for (let s = 0; s < n["apps-local-state"].length; s++)
        if (n["apps-local-state"][s].id == e) {
          i.hasState = true;
          for (let o = 0; o < n["apps-local-state"][s]["key-value"].length; o++) {
            let f2 = n["apps-local-state"][s]["key-value"][o], l = Ur.Buffer.from(f2.key, "base64").toString(), g5 = f2.value.type, _, N2 = "";
            g5 == 1 ? (_ = Ur.Buffer.from(f2.value.bytes, "base64").toString(), N2 = Ue(Ur.Buffer.from(f2.value.bytes, "base64"))) : f2.value.type == 2 && (_ = f2.value.uint), i.locals.push({ key: l, value: _ || "", address: N2 });
          }
        }
      return i;
    } else
      console.warn("Algonaut used in non-authd state, not getting local vars");
  }
  async atomicAssetTransferWithLSig(e) {
    var _a2;
    if (e.lsig) {
      let r3 = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: Ku({ from: e.lsig.address(), to: e.to, amount: e.amount, assetIndex: e.assetIndex, suggestedParams: r3 }), transactionSigner: e.lsig, isLogigSig: true };
    } else
      throw new Error("there is no logic sig object!");
  }
  async atomicPaymentWithLSig(e) {
    var _a2;
    if (e.lsig) {
      let r3 = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: Fh({ from: e.lsig.address(), to: e.to, amount: e.amount, suggestedParams: r3 }), transactionSigner: e.lsig, isLogigSig: true };
    } else
      throw new Error("there is no account!");
  }
  normalizeTxns(e) {
    pi.log("normalizeTxns", e);
    let r3 = [];
    Array.isArray(e) ? r3 = e : r3 = [e];
    let i = [];
    return i = r3.map((s) => {
      let o = s.transaction;
      return o == null && (o = s), o;
    }), i.map((s) => s.toByte());
  }
  async sendTransaction(e, r3) {
    let i = this.normalizeTxns(e);
    pi.log("awTxnsToSign", i);
    let n;
    try {
      n = await f8(i), pi.log("awTxnsSigned", n);
    } catch (l) {
      return console.warn("err signing txns..."), pi.log(l), { status: "rejected", message: "User rejected the message.", txId: "" };
    }
    (r3 == null ? void 0 : r3.onSign) && r3.onSign(n);
    let s = await this.algodClient.sendRawTransaction(n).do();
    (r3 == null ? void 0 : r3.onSend) && r3.onSend(s);
    let o = await this.waitForConfirmation(s.txId), f2 = await this.algodClient.pendingTransactionInformation(s.txId).do();
    return o.meta = f2, (r3 == null ? void 0 : r3.onConfirm) && r3.onConfirm(o), o;
  }
  to8Arr(e, r3 = "utf8") {
    return Ni.to8Arr(e, r3);
  }
  stateArrayToObject(e) {
    return Ni.stateArrayToObject(e);
  }
  fromBase64(e) {
    return Ni.fromBase64(e);
  }
  valueAsAddr(e) {
    return Ni.valueAsAddr(e);
  }
  decodeStateArray(e) {
    return Ni.decodeStateArray(e);
  }
  decodeBase64UnsignedTransaction(e) {
    return Ni.decodeBase64UnsignedTransaction(e);
  }
  txnSummary(e) {
    return Ni.txnSummary(e);
  }
}, Ni = { createWallet() {
  let t = Hu();
  if (t) {
    let e = Ah(t.sk);
    return { address: t.addr, mnemonic: e };
  } else
    throw new Error("There was no account: could not create algonaut wallet!");
}, recoverAccount(t) {
  if (!t)
    throw new Error("utils.recoverAccount: No mnemonic provided.");
  try {
    let e = go(t);
    if (aa(e == null ? void 0 : e.addr))
      return e;
    throw new Error("Not a valid mnemonic.");
  } catch (e) {
    throw console.error(e), new Error("Could not recover account from mnemonic.");
  }
}, generateLogicSig(t) {
  if (!t)
    throw new Error("No program string provided.");
  let e = new Uint8Array(Ur.Buffer.from(t, "base64"));
  return new Vi(e);
}, encodeArguments(t) {
  let e = [];
  return t.forEach((r3) => {
    typeof r3 == "number" ? e.push(Ks(r3)) : typeof r3 == "bigint" ? e.push(Ks(r3)) : typeof r3 == "string" && e.push(new Uint8Array(Ur.Buffer.from(r3)));
  }), e;
}, getAppEscrowAccount(t) {
  if (!t)
    throw new Error("No appId provided");
  return Gs(t);
}, to8Arr(t, e = "utf8") {
  return new Uint8Array(Ur.Buffer.from(t, e));
}, stateArrayToObject(t) {
  let e = {};
  return t.forEach((r3) => {
    r3.key && (e[r3.key] = r3.value || null);
  }), e;
}, fromBase64(t) {
  return Ur.Buffer.from(t, "base64").toString();
}, valueAsAddr(t) {
  return Ue(Ur.Buffer.from(t, "base64"));
}, decodeStateArray(t) {
  let e = [];
  for (let r3 = 0; r3 < t.length; r3++) {
    let i = t[r3], n = this.fromBase64(i.key), s = i.value.type, o, f2 = "";
    s == 1 ? (o = this.fromBase64(i.value.bytes), f2 = this.valueAsAddr(i.value.bytes)) : i.value.type == 2 && (o = i.value.uint), e.push({ key: n, value: o || "", address: f2 });
  }
  return e;
}, decodeBase64UnsignedTransaction(t) {
  return $s(Ur.Buffer.from(t, "base64"));
}, txnB64ToTxnBuff(t) {
  return Ur.Buffer.from(t, "base64");
}, txnToStr(t) {
  return Ur.Buffer.from(t.toByte()).toString("base64");
}, txnSummary(t) {
  if (t.type) {
    let e = t.to ? Ue(t.to.publicKey) : "", r3 = t.from ? Ue(t.from.publicKey) : "";
    if (t.type === "pay")
      return t.amount ? `Send ${gh(t.amount)} ALGO to ${e}` : `Send 0 ALGO to ${e}`;
    if (t.type === "axfer")
      return !t.amount && e === r3 ? `Opt-in to asset ID ${t.assetIndex}` : `Transfer ${t.amount ? t.amount : 0} of asset ID ${t.assetIndex} to ${e}`;
    if (t.type === "acfg")
      return t.assetUnitName ? `Create asset ${t.assetName}, symbol ${t.assetUnitName}` : `Configure asset ${t.assetIndex}`;
    if (t.type === "afrz")
      return `Freeze asset ${t.assetIndex}`;
    if (t.type === "appl")
      switch (t.appOnComplete) {
        case 0:
          return `Call to application ID ${t.appIndex}`;
        case 1:
          return `Opt-in to application ID ${t.appIndex}`;
        case 2:
          return `Close out application ID ${t.appIndex}`;
        case 3:
          return `Execute clear state program of application ID ${t.appIndex}`;
        case 4:
          return `Update application ID ${t.appIndex}`;
        case 5:
          return `Delete application ID ${t.appIndex}`;
        default:
          return `Call to application ID ${t.appIndex}`;
      }
    else
      return `Transaction of type ${t.type} to ${e}`;
  } else
    return t.toString();
} };
Ur.Buffer;
/*
* [hi-base32]{@link https://github.com/emn178/hi-base32}
*
* @version 0.5.0
* @author Chen, Yi-Cyuan [emn178@gmail.com]
* @copyright Chen, Yi-Cyuan 2015-2018
* @license MIT
*/
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const algonaut = new Zg();
const _sfc_main$1 = defineComponent({
  data() {
    return {
      walletListOpen: false,
      AnyWalletState: r,
      selectedAddrFromDropdown: r.stored.activeAccount
    };
  },
  mounted() {
    yn$1({
      [D.INKEY]: true,
      [D.PERA]: true,
      [D.MYALGO]: true,
      [D.ALGOSIGNER]: true,
      [D.EXODUS]: true,
      [D.DEFLY]: true,
      [D.MNEMONIC]: true
    });
    Xe(
      (acct) => {
        this.selectedAddrFromDropdown = acct;
        this.$forceUpdate();
      }
    );
    Ve(
      () => this.$forceUpdate()
    );
  },
  methods: {
    getAddrFromAccount(a) {
      return a.address;
    },
    activeAddrChanged(x2) {
      r.stored.activeAccount = x2;
    },
    async doTxnSimpleAlgJs() {
      console.log("doTxnSimpleAlgJs");
      let addr = r.activeAddress;
      if (!addr) {
        alert("no .to address provided");
        return;
      }
      const txn = await algonaut.atomicSendAlgo({
        amount: 1e3,
        to: addr,
        from: addr
        // .from needed IF algonaut doesnt have this.account populated
      });
      console.log("txn", txn);
      const txnArr = txn.transaction.toByte();
      try {
        let res = await An$1([txnArr]);
        console.log("res", res);
      } catch (e) {
        console.warn(e);
      }
    }
  }
});
const Demo_vue_vue_type_style_index_0_scoped_83b2570a_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _withScopeId = (n) => (pushScopeId("data-v-83b2570a"), n = n(), popScopeId(), n);
const _hoisted_1 = { class: "auth-test-container" };
const _hoisted_2 = { style: { "color": "red" } };
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { key: 1 };
const _hoisted_5 = {
  key: 0,
  class: "wallet-list"
};
const _hoisted_6 = {
  key: 0,
  class: "active-account-details"
};
const _hoisted_7 = { style: { "font-weight": "bold" } };
const _hoisted_8 = { style: { "font-family": "monospace", "word-break": "break-all" } };
const _hoisted_9 = { class: "wallet-list-item" };
const _hoisted_10 = ["src"];
const _hoisted_11 = { style: { "padding": "0 1em" } };
const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { style: { "flex-grow": "1" } }, null, -1));
const _hoisted_13 = ["name"];
const _hoisted_14 = ["value"];
const _hoisted_15 = ["onClick", "disabled"];
const _hoisted_16 = ["onClick", "disabled"];
const _hoisted_17 = ["onClick", "disabled"];
const _hoisted_18 = ["disabled"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createBaseVNode("header", null, [
      createBaseVNode("span", _hoisted_2, toDisplayString(_ctx.AnyWalletState.isSigning ? "(signing)" : ""), 1),
      createBaseVNode("button", {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.walletListOpen = !_ctx.walletListOpen)
      }, [
        _ctx.AnyWalletState.activeAddress ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(`${_ctx.AnyWalletState.activeAddress.substring(0, 6)}...${_ctx.AnyWalletState.activeAddress.substring(_ctx.AnyWalletState.activeAddress.length - 3)}`) + " (" + toDisplayString(_ctx.AnyWalletState.activeWalletId) + ") ", 1)) : (openBlock(), createElementBlock("span", _hoisted_4, " Connect Wallet "))
      ])
    ]),
    _ctx.walletListOpen ? (openBlock(), createElementBlock("div", _hoisted_5, [
      _ctx.AnyWalletState.stored.activeAccount ? (openBlock(), createElementBlock("div", _hoisted_6, [
        createBaseVNode("span", _hoisted_7, toDisplayString(_ctx.AnyWalletState.stored.activeAccount.name), 1),
        createBaseVNode("span", null, "(" + toDisplayString(_ctx.AnyWalletState.stored.activeAccount.walletId) + ")", 1),
        createBaseVNode("div", _hoisted_8, toDisplayString(_ctx.AnyWalletState.activeAddress), 1)
      ])) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.AnyWalletState.enabledWallets, (p2, key) => {
        return openBlock(), createElementBlock("div", _hoisted_9, [
          p2 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("img", {
              src: p2.metadata.icon,
              alt: "",
              style: { "width": "40px", "height": "40px" }
            }, null, 8, _hoisted_10),
            createBaseVNode("span", _hoisted_11, toDisplayString(p2.metadata.name), 1),
            _hoisted_12,
            createBaseVNode("span", null, toDisplayString(p2.initing ? "(loading)" : ""), 1),
            createBaseVNode("span", null, toDisplayString(p2.connecting ? "(connecting)" : ""), 1),
            createBaseVNode("span", null, toDisplayString(p2.signing ? "(signing)" : ""), 1),
            p2.isActive ? withDirectives((openBlock(), createElementBlock("select", {
              key: 0,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedAddrFromDropdown = $event),
              style: { "width": "100px" },
              name: `w_${key}_select`,
              id: "",
              onChange: _cache[2] || (_cache[2] = ($event) => _ctx.activeAddrChanged(_ctx.selectedAddrFromDropdown))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(p2.accounts, (a) => {
                return openBlock(), createElementBlock("option", { value: a }, toDisplayString(_ctx.getAddrFromAccount(a)), 9, _hoisted_14);
              }), 256))
            ], 40, _hoisted_13)), [
              [vModelSelect, _ctx.selectedAddrFromDropdown]
            ]) : createCommentVNode("", true),
            p2.isConnected && !p2.isActive ? (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: ($event) => p2.setAsActiveWallet(),
              disabled: !(p2.isConnected && !p2.isActive)
            }, "set as active", 8, _hoisted_15)) : p2.isConnected ? (openBlock(), createElementBlock("button", {
              key: 2,
              onClick: ($event) => p2.disconnect(),
              disabled: !p2.isConnected
            }, "disconnect", 8, _hoisted_16)) : (openBlock(), createElementBlock("button", {
              key: 3,
              onClick: ($event) => p2.connect(),
              disabled: !!p2.isConnected
            }, "connect", 8, _hoisted_17))
          ], 64)) : createCommentVNode("", true)
        ]);
      }), 256))
    ])) : createCommentVNode("", true),
    _ctx.AnyWalletState.enabledWallets !== null ? (openBlock(), createElementBlock("button", {
      key: 1,
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.doTxnSimpleAlgJs && _ctx.doTxnSimpleAlgJs(...args)),
      disabled: !(_ctx.AnyWalletState.enabledWallets !== null)
    }, " sign transaction test ", 8, _hoisted_18)) : createCommentVNode("", true)
  ]);
}
const Demo = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-83b2570a"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Demo);
    };
  }
});
const App_vue_vue_type_style_index_0_scoped_7fbb6b6c_lang = "";
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-7fbb6b6c"]]);
const style = "";
const app = createApp(App);
app.mount("#app");
export {
  createDryrun as $,
  ABIAddressType as A,
  IntDecoding$1 as B,
  LogicSig as C,
  DryrunResult as D,
  ERROR_INVALID_MICROALGOS as E,
  LogicSigAccount as F,
  MULTISIG_BAD_SENDER_ERROR_MSG as G,
  SINGLE_BYTE_SIZE as H,
  INVALID_MICROALGOS_ERROR_MSG as I,
  SourceMap as J,
  Kmd as K,
  LENGTH_ENCODE_BYTE_SIZE as L,
  MAX_LEN as M,
  TransactionType as N,
  OnApplicationComplete as O,
  abiCheckTransactionType as P,
  abiTypeIsReference as Q,
  abiTypeIsTransaction as R,
  SINGLE_BOOL_SIZE as S,
  Transaction$1 as T,
  algosToMicroalgos as U,
  appendSignMultisigTransaction as V,
  appendSignRawMultisigSignature as W,
  assignGroupID as X,
  bigIntToBytes as Y,
  bytesToBigInt as Z,
  computeGroupID as _,
  algosdk as a,
  signLogicSigTransactionObject as a$,
  createMultisigTransaction as a0,
  decodeAddress as a1,
  decodeObj as a2,
  decodeSignedTransaction as a3,
  decodeUint64 as a4,
  decodeUnsignedTransaction as a5,
  encodeAddress as a6,
  encodeObj as a7,
  encodeUint64 as a8,
  encodeUnsignedTransaction as a9,
  makeAssetCreateTxnWithSuggestedParamsFromObject as aA,
  makeAssetDestroyTxnWithSuggestedParams as aB,
  makeAssetDestroyTxnWithSuggestedParamsFromObject as aC,
  makeAssetFreezeTxnWithSuggestedParams as aD,
  makeAssetFreezeTxnWithSuggestedParamsFromObject as aE,
  makeAssetTransferTxnWithSuggestedParams as aF,
  makeAssetTransferTxnWithSuggestedParamsFromObject as aG,
  makeBasicAccountTransactionSigner as aH,
  makeKeyRegistrationTxnWithSuggestedParams as aI,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject as aJ,
  makeLogicSigAccountTransactionSigner as aK,
  makeMultiSigAccountTransactionSigner as aL,
  makePaymentTxnWithSuggestedParams as aM,
  makePaymentTxnWithSuggestedParamsFromObject as aN,
  masterDerivationKeyToMnemonic as aO,
  mergeMultisigTransactions as aP,
  microalgosToAlgos as aQ,
  mnemonicFromSeed as aR,
  mnemonicToMasterDerivationKey as aS,
  mnemonicToSecretKey as aT,
  types$1 as aU,
  multisigAddress as aV,
  secretKeyToMnemonic as aW,
  seedFromMnemonic as aX,
  signBid as aY,
  signBytes as aZ,
  signLogicSigTransaction as a_,
  generateAccount as aa,
  getApplicationAddress as ab,
  getMethodByName as ac,
  types as ad,
  instantiateTxnIfNeeded as ae,
  isTransactionWithSigner as af,
  isValidAddress as ag,
  logicSigFromByte as ah,
  makeApplicationCallTxnFromObject as ai,
  makeApplicationClearStateTxn as aj,
  makeApplicationClearStateTxnFromObject as ak,
  makeApplicationCloseOutTxn as al,
  makeApplicationCloseOutTxnFromObject as am,
  makeApplicationCreateTxn as an,
  makeApplicationCreateTxnFromObject as ao,
  makeApplicationDeleteTxn as ap,
  makeApplicationDeleteTxnFromObject as aq,
  makeApplicationNoOpTxn as ar,
  makeApplicationNoOpTxnFromObject as as,
  makeApplicationOptInTxn as at,
  makeApplicationOptInTxnFromObject as au,
  makeApplicationUpdateTxn as av,
  makeApplicationUpdateTxnFromObject as aw,
  makeAssetConfigTxnWithSuggestedParams as ax,
  makeAssetConfigTxnWithSuggestedParamsFromObject as ay,
  makeAssetCreateTxnWithSuggestedParams as az,
  buffer as b,
  signMultisigTransaction as b0,
  signTransaction as b1,
  tealSign as b2,
  tealSignFromProgram as b3,
  verifyBytes as b4,
  verifyMultisig as b5,
  verifyTealSign as b6,
  waitForConfirmation as b7,
  require$$0 as b8,
  getAugmentedNamespace as b9,
  commonjsGlobal as c,
  ABIArrayDynamicType as d,
  ABIArrayStaticType as e,
  ABIBoolType as f,
  getDefaultExportFromCjs as g,
  ABIByteType as h,
  ABIContract as i,
  ABIInterface as j,
  ABIMethod as k,
  ABIReferenceType as l,
  ABIStringType as m,
  ABITransactionType as n,
  or as o,
  ABITupleType as p,
  ABIType as q,
  ABIUfixedType as r,
  ABIUintType as s,
  ADDR_BYTE_SIZE as t,
  ALGORAND_MIN_TX_FEE as u,
  AlgodClient as v,
  AtomicTransactionComposer as w,
  AtomicTransactionComposerStatus as x,
  ERROR_MULTISIG_BAD_SENDER as y,
  IndexerClient as z
};
