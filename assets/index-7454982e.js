var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a, _b, _c, _d, _e, _f, _g, _h;
function _mergeNamespaces(n, m3) {
  for (var i = 0; i < m3.length; i++) {
    const e = m3[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k2 in e) {
        if (k2 !== "default" && !(k2 in n)) {
          const d2 = Object.getOwnPropertyDescriptor(e, k2);
          if (d2) {
            Object.defineProperty(n, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str) => str ? `on${capitalize(str)}` : ``
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b2) {
  if (a.length !== b2.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b2[i]);
  }
  return equal;
}
function looseEqual(a, b2) {
  if (a === b2)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b2);
  if (aValidType || bValidType) {
    return a === b2;
  }
  aValidType = isArray(a);
  bValidType = isArray(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b2) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn$1(msg, ...args) {
  return;
}
function callWithErrorHandling$1(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError$1(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling$1(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling$1(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError$1(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling$1(fn[i], instance, type, args));
  }
  return values;
}
function handleError$1(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling$1(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b2) => getId(a) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b2) => {
  const diff = getId(a) - getId(b2);
  if (diff === 0) {
    if (a.pre && !b2.pre)
      return -1;
    if (b2.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling$1(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling$1(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling$1(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError$1(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const INITIAL_WATCHER_VALUE$1 = {};
function watch$1(source, cb, options) {
  return doWatch$1(source, cb, options);
}
function doWatch$1(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a2;
  const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse$1(s2);
      } else if (isFunction(s2)) {
        return callWithErrorHandling$1(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling$1(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling$1(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse$1(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling$1(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling$1(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE$1) : INITIAL_WATCHER_VALUE$1;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v, i) => hasChanged(v, oldValue[i])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling$1(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE$1 ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE$1 ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    );
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch$1(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse$1(value, seen2) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse$1(value.value, seen2);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse$1(value[i], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse$1(v, seen2);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse$1(value[key], seen2);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse$1(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling$1(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling$1(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling$1(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch$1(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch$1(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch$1(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m3) => mergeOptions(resolved, m3, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to2, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m3) => mergeOptions(to2, m3, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from[key]) : from[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from) {
  if (!from) {
    return to2;
  }
  if (!to2) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to2) ? to2.call(this, this) : to2,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to2, from) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
  return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
}
function mergeEmitsOrPropsOptions(to2, from) {
  if (to2) {
    if (isArray(to2) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to2, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to2),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to2, from) {
  if (!to2)
    return from;
  if (!from)
    return to2;
  const merged = extend(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from) {
    merged[key] = mergeAsArray(to2[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b2) {
  return getType(a) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref)) {
    callWithErrorHandling$1(ref, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (hasOwn(setupState, ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (hasOwn(setupState, ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n12 === n2) {
      return;
    }
    if (n12 && !isSameVNodeType(n12, n2)) {
      anchor = getNextHostNode(n12);
      unmount(n12, parentComponent, parentSuspense, true);
      n12 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n12, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n12, n2, container, anchor);
        break;
      case Static:
        if (n12 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n12,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n12,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n12,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n12,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n12,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
    }
  };
  const processText = (n12, n2, container, anchor) => {
    if (n12 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n12.el;
      if (n2.children !== n12.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n12, n2, container, anchor) => {
    if (n12 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n12.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n12 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n12,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n12, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n12.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n12.patchFlag & 16;
    const oldProps = n12.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n12.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n12,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n12.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n12.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n12 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n12.dynamicChildren) {
        patchBlockChildren(
          n12.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n12,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n12,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n12 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n12, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n12, n2, optimized) => {
    const instance = n2.component = n12.component;
    if (shouldUpdateComponent(n12, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n12.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm: bm2, m: m3, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm2) {
          invokeArrayFns(bm2);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m3) {
          queuePostRenderEffect(m3, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu: bu2, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu2) {
          invokeArrayFns(bu2);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n12 && n12.children;
    const prevShapeFlag = n12 ? n12.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n12 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n12, n2)) {
        patch(
          n12,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n12 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n12, n2)) {
        patch(
          n12,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j3;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j3 = s2; j3 <= e2; j3++) {
            if (newIndexToOldIndexMap[j3 - s2] === 0 && isSameVNodeType(prevChild, c2[j3])) {
              newIndex = j3;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j3 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j3 < 0 || i !== increasingNewIndexSequence[j3]) {
            move(nextChild, container, anchor, 2);
          } else {
            j3--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um: um2 } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um2) {
      queuePostRenderEffect(um2, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n12, n2, shallow = false) {
  const ch1 = n12.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j3, u, v, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j3 = result[result.length - 1];
      if (arr[j3] < arrI) {
        p2[i] = j3;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c2 = u + v >> 1;
        if (arr[result[c2]] < arrI) {
          u = c2 + 1;
        } else {
          v = c2;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n12, n2) {
  return n12.type === n2.type && n12.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style2)) {
      if (isProxy(style2) && !isArray(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling$1(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s2) => s2(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling$1(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError$1(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is2, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style2, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m3;
    while (m3 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m3[0].length);
      options[m3[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling$1(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el._assign(
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link2 = links[i];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
function callWithErrorHandling(fn, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++)
    values.push(callWithAsyncErrorHandling(fn[i], type, args));
  return values;
}
function handleError(err, type) {
  console.error(new Error(`[@vue-reactivity/watch]: ${type}`));
  console.error(err);
}
function warn(message) {
  console.warn(createError(message));
}
function createError(message) {
  return new Error(`[reactivue]: ${message}`);
}
var INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush } = {}) {
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);
    getter = () => source.map((s2) => {
      if (isRef(s2))
        return s2.value;
      else if (isReactive(s2))
        return traverse(s2);
      else if (isFunction(s2))
        return callWithErrorHandling(s2, "watch getter");
      else
        return warn("invalid source");
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, "watch getter");
    } else {
      getter = () => {
        if (cleanup)
          cleanup();
        return callWithAsyncErrorHandling(source, "watch callback", [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, "watch cleanup");
    };
  };
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active)
      return;
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup)
          cleanup();
        callWithAsyncErrorHandling(cb, "watch value", [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else {
    scheduler = () => {
      job();
    };
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate)
      job();
    else
      oldValue = effect.run();
  } else {
    effect.run();
  }
  return () => effect.stop();
}
function traverse(value, seen2 = /* @__PURE__ */ new Set()) {
  if (!isObject(value) || seen2.has(value))
    return value;
  seen2.add(value);
  if (isArray(value)) {
    for (let i = 0; i < value.length; i++)
      traverse(value[i], seen2);
  } else if (value instanceof Map) {
    value.forEach((_2, key) => {
      traverse(value.get(key), seen2);
    });
  } else if (value instanceof Set) {
    value.forEach((v) => {
      traverse(v, seen2);
    });
  } else {
    for (const key of Object.keys(value))
      traverse(value[key], seen2);
  }
  return value;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a;
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i];
  i += d2;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m3 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m3 = m3 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m3 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m3 = m3 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m3 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m3, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m3 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m3 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m3 = (value * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m3 & 255, i += d2, m3 /= 256, mLen -= 8) {
  }
  e = e << mLen | m3;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2)
      return 0;
    let x = a.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n, m3) {
    const i = b2[n];
    b2[n] = b2[m3];
    b2[m3] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j3 = 0; j3 < valLength; j3++) {
          if (read(arr, i + j3) !== read(val, j3)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 6] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 5] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 4] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo2;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i);
      hi2 = c2 >> 8;
      lo2 = c2 % 256;
      byteArray.push(lo2);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j3 = 0; j3 < 16; ++j3) {
        table[i16 + j3] = alphabet[i] + alphabet[j3];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const index = /* @__PURE__ */ getDefaultExportFromCjs(buffer);
const index$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [buffer]);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module) {
  (function(nacl2) {
    var gf2 = function(init) {
      var i, r = new Float64Array(16);
      if (init)
        for (i = 0; i < init.length; i++)
          r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _02 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf2(), gf1 = gf2([1]), _121665 = gf2([56129, 1]), D2 = gf2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h2, l) {
      x[i] = h2 >> 24 & 255;
      x[i + 1] = h2 >> 16 & 255;
      x[i + 2] = h2 >> 8 & 255;
      x[i + 3] = h2 & 255;
      x[i + 4] = l >> 24 & 255;
      x[i + 5] = l >> 16 & 255;
      x[i + 6] = l >> 8 & 255;
      x[i + 7] = l & 255;
    }
    function vn2(x, xi, y2, yi2, n) {
      var i, d2 = 0;
      for (i = 0; i < n; i++)
        d2 |= x[xi + i] ^ y2[yi2 + i];
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y2, yi2) {
      return vn2(x, xi, y2, yi2, 16);
    }
    function crypto_verify_32(x, xi, y2, yi2) {
      return vn2(x, xi, y2, yi2, 32);
    }
    function core_salsa20(o, p2, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j12 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j22 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j42 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j82 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j122 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x02 = j0, x1 = j12, x2 = j22, x3 = j3, x42 = j42, x5 = j5, x6 = j6, x7 = j7, x82 = j82, x9 = j9, x10 = j10, x11 = j11, x12 = j122, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x02 + x12 | 0;
        x42 ^= u << 7 | u >>> 32 - 7;
        u = x42 + x02 | 0;
        x82 ^= u << 9 | u >>> 32 - 9;
        u = x82 + x42 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x82 | 0;
        x02 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x02 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x02 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x02 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x42 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x42 ^= u << 13 | u >>> 32 - 13;
        u = x42 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x82 ^= u << 9 | u >>> 32 - 9;
        u = x82 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x82 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x02 = x02 + j0 | 0;
      x1 = x1 + j12 | 0;
      x2 = x2 + j22 | 0;
      x3 = x3 + j3 | 0;
      x42 = x42 + j42 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x82 = x82 + j82 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j122 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x02 >>> 0 & 255;
      o[1] = x02 >>> 8 & 255;
      o[2] = x02 >>> 16 & 255;
      o[3] = x02 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x42 >>> 0 & 255;
      o[17] = x42 >>> 8 & 255;
      o[18] = x42 >>> 16 & 255;
      o[19] = x42 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x82 >>> 0 & 255;
      o[33] = x82 >>> 8 & 255;
      o[34] = x82 >>> 16 & 255;
      o[35] = x82 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p2, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j12 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j22 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j42 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j82 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j122 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x02 = j0, x1 = j12, x2 = j22, x3 = j3, x42 = j42, x5 = j5, x6 = j6, x7 = j7, x82 = j82, x9 = j9, x10 = j10, x11 = j11, x12 = j122, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x02 + x12 | 0;
        x42 ^= u << 7 | u >>> 32 - 7;
        u = x42 + x02 | 0;
        x82 ^= u << 9 | u >>> 32 - 9;
        u = x82 + x42 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x82 | 0;
        x02 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x02 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x02 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x02 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x42 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x42 ^= u << 13 | u >>> 32 - 13;
        u = x42 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x82 ^= u << 9 | u >>> 32 - 9;
        u = x82 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x82 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x02 >>> 0 & 255;
      o[1] = x02 >>> 8 & 255;
      o[2] = x02 >>> 16 & 255;
      o[3] = x02 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x82 >>> 0 & 255;
      o[25] = x82 >>> 8 & 255;
      o[26] = x82 >>> 16 & 255;
      o[27] = x82 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c2) {
      core_salsa20(out, inp, k2, c2);
    }
    function crypto_core_hsalsa20(out, inp, k2, c2) {
      core_hsalsa20(out, inp, k2, c2);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c2, cpos, m3, mpos, b2, n, k2) {
      var z3 = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++)
        z3[i] = 0;
      for (i = 0; i < 8; i++)
        z3[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x, z3, k2, sigma);
        for (i = 0; i < 64; i++)
          c2[cpos + i] = m3[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z3[i] & 255) | 0;
          z3[i] = u & 255;
          u >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x, z3, k2, sigma);
        for (i = 0; i < b2; i++)
          c2[cpos + i] = m3[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c2, cpos, b2, n, k2) {
      var z3 = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++)
        z3[i] = 0;
      for (i = 0; i < 8; i++)
        z3[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x, z3, k2, sigma);
        for (i = 0; i < 64; i++)
          c2[cpos + i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z3[i] & 255) | 0;
          z3[i] = u & 255;
          u >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x, z3, k2, sigma);
        for (i = 0; i < b2; i++)
          c2[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c2, cpos, d2, n, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c2, cpos, d2, sn, s2);
    }
    function crypto_stream_xor(c2, cpos, m3, mpos, d2, n, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c2, cpos, m3, mpos, d2, sn, s2);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t02, t12, t22, t3, t42, t5, t62, t7;
      t02 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t02 & 8191;
      t12 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t02 >>> 13 | t12 << 3) & 8191;
      t22 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t12 >>> 10 | t22 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t22 >>> 7 | t3 << 9) & 8191;
      t42 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t42 << 12) & 255;
      this.r[5] = t42 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t42 >>> 14 | t5 << 2) & 8191;
      t62 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t62 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t62 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m3, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t02, t12, t22, t3, t42, t5, t62, t7, c2;
      var d02, d1, d2, d32, d42, d5, d6, d7, d82, d9;
      var h02 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h82 = this.h[8], h9 = this.h[9];
      var r02 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r42 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r82 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t02 = m3[mpos + 0] & 255 | (m3[mpos + 1] & 255) << 8;
        h02 += t02 & 8191;
        t12 = m3[mpos + 2] & 255 | (m3[mpos + 3] & 255) << 8;
        h1 += (t02 >>> 13 | t12 << 3) & 8191;
        t22 = m3[mpos + 4] & 255 | (m3[mpos + 5] & 255) << 8;
        h2 += (t12 >>> 10 | t22 << 6) & 8191;
        t3 = m3[mpos + 6] & 255 | (m3[mpos + 7] & 255) << 8;
        h3 += (t22 >>> 7 | t3 << 9) & 8191;
        t42 = m3[mpos + 8] & 255 | (m3[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t42 << 12) & 8191;
        h5 += t42 >>> 1 & 8191;
        t5 = m3[mpos + 10] & 255 | (m3[mpos + 11] & 255) << 8;
        h6 += (t42 >>> 14 | t5 << 2) & 8191;
        t62 = m3[mpos + 12] & 255 | (m3[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t62 << 5) & 8191;
        t7 = m3[mpos + 14] & 255 | (m3[mpos + 15] & 255) << 8;
        h82 += (t62 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c2 = 0;
        d02 = c2;
        d02 += h02 * r02;
        d02 += h1 * (5 * r9);
        d02 += h2 * (5 * r82);
        d02 += h3 * (5 * r7);
        d02 += h4 * (5 * r6);
        c2 = d02 >>> 13;
        d02 &= 8191;
        d02 += h5 * (5 * r5);
        d02 += h6 * (5 * r42);
        d02 += h7 * (5 * r3);
        d02 += h82 * (5 * r2);
        d02 += h9 * (5 * r1);
        c2 += d02 >>> 13;
        d02 &= 8191;
        d1 = c2;
        d1 += h02 * r1;
        d1 += h1 * r02;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r82);
        d1 += h4 * (5 * r7);
        c2 = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r42);
        d1 += h82 * (5 * r3);
        d1 += h9 * (5 * r2);
        c2 += d1 >>> 13;
        d1 &= 8191;
        d2 = c2;
        d2 += h02 * r2;
        d2 += h1 * r1;
        d2 += h2 * r02;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r82);
        c2 = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h82 * (5 * r42);
        d2 += h9 * (5 * r3);
        c2 += d2 >>> 13;
        d2 &= 8191;
        d32 = c2;
        d32 += h02 * r3;
        d32 += h1 * r2;
        d32 += h2 * r1;
        d32 += h3 * r02;
        d32 += h4 * (5 * r9);
        c2 = d32 >>> 13;
        d32 &= 8191;
        d32 += h5 * (5 * r82);
        d32 += h6 * (5 * r7);
        d32 += h7 * (5 * r6);
        d32 += h82 * (5 * r5);
        d32 += h9 * (5 * r42);
        c2 += d32 >>> 13;
        d32 &= 8191;
        d42 = c2;
        d42 += h02 * r42;
        d42 += h1 * r3;
        d42 += h2 * r2;
        d42 += h3 * r1;
        d42 += h4 * r02;
        c2 = d42 >>> 13;
        d42 &= 8191;
        d42 += h5 * (5 * r9);
        d42 += h6 * (5 * r82);
        d42 += h7 * (5 * r7);
        d42 += h82 * (5 * r6);
        d42 += h9 * (5 * r5);
        c2 += d42 >>> 13;
        d42 &= 8191;
        d5 = c2;
        d5 += h02 * r5;
        d5 += h1 * r42;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c2 = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r02;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r82);
        d5 += h82 * (5 * r7);
        d5 += h9 * (5 * r6);
        c2 += d5 >>> 13;
        d5 &= 8191;
        d6 = c2;
        d6 += h02 * r6;
        d6 += h1 * r5;
        d6 += h2 * r42;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c2 = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r02;
        d6 += h7 * (5 * r9);
        d6 += h82 * (5 * r82);
        d6 += h9 * (5 * r7);
        c2 += d6 >>> 13;
        d6 &= 8191;
        d7 = c2;
        d7 += h02 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r42;
        d7 += h4 * r3;
        c2 = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r02;
        d7 += h82 * (5 * r9);
        d7 += h9 * (5 * r82);
        c2 += d7 >>> 13;
        d7 &= 8191;
        d82 = c2;
        d82 += h02 * r82;
        d82 += h1 * r7;
        d82 += h2 * r6;
        d82 += h3 * r5;
        d82 += h4 * r42;
        c2 = d82 >>> 13;
        d82 &= 8191;
        d82 += h5 * r3;
        d82 += h6 * r2;
        d82 += h7 * r1;
        d82 += h82 * r02;
        d82 += h9 * (5 * r9);
        c2 += d82 >>> 13;
        d82 &= 8191;
        d9 = c2;
        d9 += h02 * r9;
        d9 += h1 * r82;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c2 = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r42;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h82 * r1;
        d9 += h9 * r02;
        c2 += d9 >>> 13;
        d9 &= 8191;
        c2 = (c2 << 2) + c2 | 0;
        c2 = c2 + d02 | 0;
        d02 = c2 & 8191;
        c2 = c2 >>> 13;
        d1 += c2;
        h02 = d02;
        h1 = d1;
        h2 = d2;
        h3 = d32;
        h4 = d42;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h82 = d82;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h02;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h82;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c2, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c2;
        c2 = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c2 * 5;
      c2 = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c2;
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c2;
      g[0] = this.h[0] + 5;
      c2 = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c2;
        c2 = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c2 ^ 1) - 1;
      for (i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1; i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m3, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m3[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m3, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m3[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m3, mpos, n, k2) {
      var s2 = new poly1305(k2);
      s2.update(m3, mpos, n);
      s2.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m3, mpos, n, k2) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m3, mpos, n, k2);
      return crypto_verify_16(h2, hpos, x, 0);
    }
    function crypto_secretbox(c2, m3, d2, n, k2) {
      var i;
      if (d2 < 32)
        return -1;
      crypto_stream_xor(c2, 0, m3, 0, d2, n, k2);
      crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
      for (i = 0; i < 16; i++)
        c2[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m3, c2, d2, n, k2) {
      var i;
      var x = new Uint8Array(32);
      if (d2 < 32)
        return -1;
      crypto_stream(x, 0, 32, n, k2);
      if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m3, 0, c2, 0, d2, n, k2);
      for (i = 0; i < 32; i++)
        m3[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c2 = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c2 + 65535;
        c2 = Math.floor(v / 65536);
        o[i] = v - c2 * 65536;
      }
      o[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q2, b2) {
      var t, c2 = ~(b2 - 1);
      for (var i = 0; i < 16; i++) {
        t = c2 & (p2[i] ^ q2[i]);
        p2[i] ^= t;
        q2[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j3, b2;
      var m3 = gf2(), t = gf2();
      for (i = 0; i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j3 = 0; j3 < 2; j3++) {
        m3[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m3[i] = t[i] - 65535 - (m3[i - 1] >> 16 & 1);
          m3[i - 1] &= 65535;
        }
        m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
        b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t, m3, 1 - b2);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b2) {
      var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
      pack25519(c2, a);
      pack25519(d2, b2);
      return crypto_verify_32(c2, 0, d2, 0);
    }
    function par25519(a) {
      var d2 = new Uint8Array(32);
      pack25519(d2, a);
      return d2[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A2(o, a, b2) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] + b2[i];
    }
    function Z2(o, a, b2) {
      for (var i = 0; i < 16; i++)
        o[i] = a[i] - b2[i];
    }
    function M(o, a, b2) {
      var v, c2, t02 = 0, t12 = 0, t22 = 0, t3 = 0, t42 = 0, t5 = 0, t62 = 0, t7 = 0, t82 = 0, t9 = 0, t10 = 0, t11 = 0, t122 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b02 = b2[0], b12 = b2[1], b22 = b2[2], b3 = b2[3], b42 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b82 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b122 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v = a[0];
      t02 += v * b02;
      t12 += v * b12;
      t22 += v * b22;
      t3 += v * b3;
      t42 += v * b42;
      t5 += v * b5;
      t62 += v * b6;
      t7 += v * b7;
      t82 += v * b82;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t122 += v * b122;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t12 += v * b02;
      t22 += v * b12;
      t3 += v * b22;
      t42 += v * b3;
      t5 += v * b42;
      t62 += v * b5;
      t7 += v * b6;
      t82 += v * b7;
      t9 += v * b82;
      t10 += v * b9;
      t11 += v * b10;
      t122 += v * b11;
      t13 += v * b122;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t22 += v * b02;
      t3 += v * b12;
      t42 += v * b22;
      t5 += v * b3;
      t62 += v * b42;
      t7 += v * b5;
      t82 += v * b6;
      t9 += v * b7;
      t10 += v * b82;
      t11 += v * b9;
      t122 += v * b10;
      t13 += v * b11;
      t14 += v * b122;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b02;
      t42 += v * b12;
      t5 += v * b22;
      t62 += v * b3;
      t7 += v * b42;
      t82 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b82;
      t122 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b122;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t42 += v * b02;
      t5 += v * b12;
      t62 += v * b22;
      t7 += v * b3;
      t82 += v * b42;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t122 += v * b82;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b122;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b02;
      t62 += v * b12;
      t7 += v * b22;
      t82 += v * b3;
      t9 += v * b42;
      t10 += v * b5;
      t11 += v * b6;
      t122 += v * b7;
      t13 += v * b82;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b122;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t62 += v * b02;
      t7 += v * b12;
      t82 += v * b22;
      t9 += v * b3;
      t10 += v * b42;
      t11 += v * b5;
      t122 += v * b6;
      t13 += v * b7;
      t14 += v * b82;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b122;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b02;
      t82 += v * b12;
      t9 += v * b22;
      t10 += v * b3;
      t11 += v * b42;
      t122 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b82;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b122;
      t20 += v * b13;
      t21 += v * b14;
      t222 += v * b15;
      v = a[8];
      t82 += v * b02;
      t9 += v * b12;
      t10 += v * b22;
      t11 += v * b3;
      t122 += v * b42;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b82;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b122;
      t21 += v * b13;
      t222 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b02;
      t10 += v * b12;
      t11 += v * b22;
      t122 += v * b3;
      t13 += v * b42;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b82;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b122;
      t222 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b02;
      t11 += v * b12;
      t122 += v * b22;
      t13 += v * b3;
      t14 += v * b42;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b82;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t222 += v * b122;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b02;
      t122 += v * b12;
      t13 += v * b22;
      t14 += v * b3;
      t15 += v * b42;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b82;
      t20 += v * b9;
      t21 += v * b10;
      t222 += v * b11;
      t23 += v * b122;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t122 += v * b02;
      t13 += v * b12;
      t14 += v * b22;
      t15 += v * b3;
      t16 += v * b42;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b82;
      t21 += v * b9;
      t222 += v * b10;
      t23 += v * b11;
      t24 += v * b122;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b02;
      t14 += v * b12;
      t15 += v * b22;
      t16 += v * b3;
      t17 += v * b42;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b82;
      t222 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b122;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b02;
      t15 += v * b12;
      t16 += v * b22;
      t17 += v * b3;
      t18 += v * b42;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t222 += v * b82;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b122;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b02;
      t16 += v * b12;
      t17 += v * b22;
      t18 += v * b3;
      t19 += v * b42;
      t20 += v * b5;
      t21 += v * b6;
      t222 += v * b7;
      t23 += v * b82;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b122;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t02 += 38 * t16;
      t12 += 38 * t17;
      t22 += 38 * t18;
      t3 += 38 * t19;
      t42 += 38 * t20;
      t5 += 38 * t21;
      t62 += 38 * t222;
      t7 += 38 * t23;
      t82 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t122 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v = t02 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t02 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t22 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t22 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t42 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t42 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t62 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t62 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t82 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t82 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t122 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t122 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v = t02 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t02 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t22 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t22 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t42 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t42 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t62 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t62 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t82 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t82 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t122 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t122 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      o[0] = t02;
      o[1] = t12;
      o[2] = t22;
      o[3] = t3;
      o[4] = t42;
      o[5] = t5;
      o[6] = t62;
      o[7] = t7;
      o[8] = t82;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t122;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S2(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c2 = gf2();
      var a;
      for (a = 0; a < 16; a++)
        c2[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S2(c2, c2);
        if (a !== 2 && a !== 4)
          M(c2, c2, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c2[a];
    }
    function pow2523(o, i) {
      var c2 = gf2();
      var a;
      for (a = 0; a < 16; a++)
        c2[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S2(c2, c2);
        if (a !== 1)
          M(c2, c2, i);
      }
      for (a = 0; a < 16; a++)
        o[a] = c2[a];
    }
    function crypto_scalarmult(q2, n, p2) {
      var z3 = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e = gf2(), f = gf2();
      for (i = 0; i < 31; i++)
        z3[i] = n[i];
      z3[31] = n[31] & 127 | 64;
      z3[0] &= 248;
      unpack25519(x, p2);
      for (i = 0; i < 16; i++) {
        b2[i] = x[i];
        d2[i] = a[i] = c2[i] = 0;
      }
      a[0] = d2[0] = 1;
      for (i = 254; i >= 0; --i) {
        r = z3[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b2, r);
        sel25519(c2, d2, r);
        A2(e, a, c2);
        Z2(a, a, c2);
        A2(c2, b2, d2);
        Z2(b2, b2, d2);
        S2(d2, e);
        S2(f, a);
        M(a, c2, a);
        M(c2, b2, e);
        A2(e, a, c2);
        Z2(a, a, c2);
        S2(b2, a);
        Z2(c2, d2, f);
        M(a, c2, _121665);
        A2(a, a, d2);
        M(c2, c2, a);
        M(a, d2, f);
        M(d2, b2, x);
        S2(b2, e);
        sel25519(a, b2, r);
        sel25519(c2, d2, r);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c2[i];
        x[i + 48] = b2[i];
        x[i + 64] = d2[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y2, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y2, x);
    }
    function crypto_box_beforenm(k2, y2, x) {
      var s2 = new Uint8Array(32);
      crypto_scalarmult(s2, x, y2);
      return crypto_core_hsalsa20(k2, _02, s2, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c2, m3, d2, n, y2, x) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x);
      return crypto_box_afternm(c2, m3, d2, n, k2);
    }
    function crypto_box_open(m3, c2, d2, n, y2, x) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x);
      return crypto_box_open_afternm(m3, c2, d2, n, k2);
    }
    var K5 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m3, n) {
      var wh2 = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j3, h2, l, a, b2, c2, d2;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j3 = 8 * i + pos;
          wh2[i] = m3[j3 + 0] << 24 | m3[j3 + 1] << 16 | m3[j3 + 2] << 8 | m3[j3 + 3];
          wl[i] = m3[j3 + 4] << 24 | m3[j3 + 5] << 16 | m3[j3 + 6] << 8 | m3[j3 + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l = al7;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = K5[i * 2];
          l = K5[i * 2 + 1];
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = wh2[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          th = c2 & 65535 | d2 << 16;
          tl = a & 65535 | b2 << 16;
          h2 = th;
          l = tl;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          bh7 = c2 & 65535 | d2 << 16;
          bl7 = a & 65535 | b2 << 16;
          h2 = bh3;
          l = bl3;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = th;
          l = tl;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          bh3 = c2 & 65535 | d2 << 16;
          bl3 = a & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j3 = 0; j3 < 16; j3++) {
              h2 = wh2[j3];
              l = wl[j3];
              a = l & 65535;
              b2 = l >>> 16;
              c2 = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = wh2[(j3 + 9) % 16];
              l = wl[(j3 + 9) % 16];
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              th = wh2[(j3 + 1) % 16];
              tl = wl[(j3 + 1) % 16];
              h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              th = wh2[(j3 + 14) % 16];
              tl = wl[(j3 + 14) % 16];
              h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a >>> 16;
              c2 += b2 >>> 16;
              d2 += c2 >>> 16;
              wh2[j3] = c2 & 65535 | d2 << 16;
              wl[j3] = a & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l = al0;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[0];
        l = hl[0];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[0] = ah0 = c2 & 65535 | d2 << 16;
        hl[0] = al0 = a & 65535 | b2 << 16;
        h2 = ah1;
        l = al1;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[1];
        l = hl[1];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[1] = ah1 = c2 & 65535 | d2 << 16;
        hl[1] = al1 = a & 65535 | b2 << 16;
        h2 = ah2;
        l = al2;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[2];
        l = hl[2];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[2] = ah2 = c2 & 65535 | d2 << 16;
        hl[2] = al2 = a & 65535 | b2 << 16;
        h2 = ah3;
        l = al3;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[3];
        l = hl[3];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[3] = ah3 = c2 & 65535 | d2 << 16;
        hl[3] = al3 = a & 65535 | b2 << 16;
        h2 = ah4;
        l = al4;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[4];
        l = hl[4];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[4] = ah4 = c2 & 65535 | d2 << 16;
        hl[4] = al4 = a & 65535 | b2 << 16;
        h2 = ah5;
        l = al5;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[5];
        l = hl[5];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[5] = ah5 = c2 & 65535 | d2 << 16;
        hl[5] = al5 = a & 65535 | b2 << 16;
        h2 = ah6;
        l = al6;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[6];
        l = hl[6];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[6] = ah6 = c2 & 65535 | d2 << 16;
        hl[6] = al6 = a & 65535 | b2 << 16;
        h2 = ah7;
        l = al7;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh[7];
        l = hl[7];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh[7] = ah7 = c2 & 65535 | d2 << 16;
        hl[7] = al7 = a & 65535 | b2 << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m3, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b2 = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m3, n);
      n %= 128;
      for (i = 0; i < n; i++)
        x[i] = m3[b2 - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add2(p2, q2) {
      var a = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e = gf2(), f = gf2(), g = gf2(), h2 = gf2(), t = gf2();
      Z2(a, p2[1], p2[0]);
      Z2(t, q2[1], q2[0]);
      M(a, a, t);
      A2(b2, p2[0], p2[1]);
      A2(t, q2[0], q2[1]);
      M(b2, b2, t);
      M(c2, p2[3], q2[3]);
      M(c2, c2, D22);
      M(d2, p2[2], q2[2]);
      A2(d2, d2, d2);
      Z2(e, b2, a);
      Z2(f, d2, c2);
      A2(g, d2, c2);
      A2(h2, b2, a);
      M(p2[0], e, f);
      M(p2[1], h2, g);
      M(p2[2], g, f);
      M(p2[3], e, h2);
    }
    function cswap(p2, q2, b2) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p2[i], q2[i], b2);
      }
    }
    function pack(r, p2) {
      var tx = gf2(), ty2 = gf2(), zi = gf2();
      inv25519(zi, p2[2]);
      M(tx, p2[0], zi);
      M(ty2, p2[1], zi);
      pack25519(r, ty2);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p2, q2, s2) {
      var b2, i;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i = 255; i >= 0; --i) {
        b2 = s2[i / 8 | 0] >> (i & 7) & 1;
        cswap(p2, q2, b2);
        add2(q2, p2);
        add2(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s2) {
      var q2 = [gf2(), gf2(), gf2(), gf2()];
      set25519(q2[0], X2);
      set25519(q2[1], Y);
      set25519(q2[2], gf1);
      M(q2[3], X2, Y);
      scalarmult(p2, q2, s2);
    }
    function crypto_sign_keypair(pk2, sk2, seeded) {
      var d2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var i;
      if (!seeded)
        randombytes(sk2, 32);
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk2, p2);
      for (i = 0; i < 32; i++)
        sk2[i + 32] = pk2[i];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x) {
      var carry, i, j3, k2;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j3 = i - 32, k2 = i - 12; j3 < k2; ++j3) {
          x[j3] += carry - 16 * x[i] * L2[j3 - (i - 32)];
          carry = Math.floor((x[j3] + 128) / 256);
          x[j3] -= carry * 256;
        }
        x[j3] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j3 = 0; j3 < 32; j3++) {
        x[j3] += carry - (x[31] >> 4) * L2[j3];
        carry = x[j3] >> 8;
        x[j3] &= 255;
      }
      for (j3 = 0; j3 < 32; j3++)
        x[j3] -= carry * L2[j3];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++)
        x[i] = r[i];
      for (i = 0; i < 64; i++)
        r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm2, m3, n, sk2) {
      var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
      var i, j3, x = new Float64Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++)
        sm2[64 + i] = m3[i];
      for (i = 0; i < 32; i++)
        sm2[32 + i] = d2[32 + i];
      crypto_hash(r, sm2.subarray(32), n + 32);
      reduce(r);
      scalarbase(p2, r);
      pack(sm2, p2);
      for (i = 32; i < 64; i++)
        sm2[i] = sk2[i];
      crypto_hash(h2, sm2, n + 64);
      reduce(h2);
      for (i = 0; i < 64; i++)
        x[i] = 0;
      for (i = 0; i < 32; i++)
        x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j3 = 0; j3 < 32; j3++) {
          x[i + j3] += h2[i] * d2[j3];
        }
      }
      modL(sm2.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p2) {
      var t = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r[2], gf1);
      unpack25519(r[1], p2);
      S2(num, r[1]);
      M(den, num, D2);
      Z2(num, num, r[2]);
      A2(den, r[2], den);
      S2(den2, den);
      S2(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S2(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r[0], r[0], I);
      S2(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p2[31] >> 7)
        Z2(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m3, sm2, n, pk2) {
      var i;
      var t = new Uint8Array(32), h2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()], q2 = [gf2(), gf2(), gf2(), gf2()];
      if (n < 64)
        return -1;
      if (unpackneg(q2, pk2))
        return -1;
      for (i = 0; i < n; i++)
        m3[i] = sm2[i];
      for (i = 0; i < 32; i++)
        m3[i + 32] = pk2[i];
      crypto_hash(h2, m3, n);
      reduce(h2);
      scalarmult(p2, q2, h2);
      scalarbase(q2, sm2.subarray(32));
      add2(p2, q2);
      pack(t, p2);
      n -= 64;
      if (crypto_verify_32(sm2, 0, t, 0)) {
        for (i = 0; i < n; i++)
          m3[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++)
        m3[i] = sm2[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl2.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf: gf2,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M,
      A: A2,
      S: S2,
      Z: Z2,
      pow2523,
      add: add2,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk2, sk2) {
      if (pk2.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk2.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++)
        arr[i] = 0;
    }
    nacl2.randomBytes = function(n) {
      var b2 = new Uint8Array(n);
      randombytes(b2, n);
      return b2;
    };
    nacl2.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m3 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c2 = new Uint8Array(m3.length);
      for (var i = 0; i < msg.length; i++)
        m3[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c2, m3, m3.length, nonce, key);
      return c2.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl2.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m3 = new Uint8Array(c2.length);
      for (var i = 0; i < box.length; i++)
        c2[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c2.length < 32)
        return null;
      if (crypto_secretbox_open(m3, c2, c2.length, nonce, key) !== 0)
        return null;
      return m3.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl2.scalarMult = function(n, p2) {
      checkArrayTypes(n, p2);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p2.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p2);
      return q2;
    };
    nacl2.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl2.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl2.box.before(publicKey, secretKey);
      return nacl2.secretbox(msg, nonce, k2);
    };
    nacl2.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl2.box.after = nacl2.secretbox;
    nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl2.box.before(publicKey, secretKey);
      return nacl2.secretbox.open(msg, nonce, k2);
    };
    nacl2.box.open.after = nacl2.secretbox.open;
    nacl2.box.keyPair = function() {
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl2.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk2, secretKey);
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl2.box.nonceLength = crypto_box_NONCEBYTES;
    nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
    nacl2.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl2.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m3 = new Uint8Array(mlen);
      for (var i = 0; i < m3.length; i++)
        m3[i] = tmp[i];
      return m3;
    };
    nacl2.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl2.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl2.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm2 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++)
        sm2[i] = sig[i];
      for (i = 0; i < msg.length; i++)
        sm2[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m3, sm2, sm2.length, publicKey) >= 0;
    };
    nacl2.sign.keyPair = function() {
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk2.length; i++)
        pk2[i] = secretKey[32 + i];
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl2.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++)
        sk2[i] = seed[i];
      crypto_sign_keypair(pk2, sk2, true);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl2.sign.signatureLength = crypto_sign_BYTES;
    nacl2.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl2.hash.hashLength = crypto_hash_BYTES;
    nacl2.verify = function(x, y2) {
      checkArrayTypes(x, y2);
      if (x.length === 0 || y2.length === 0)
        return false;
      if (x.length !== y2.length)
        return false;
      return vn2(x, 0, y2, 0, x.length) === 0 ? true : false;
    };
    nacl2.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl2.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++)
            x[i] = v[i];
          cleanup(v);
        });
      } else if (typeof commonjsRequire !== "undefined") {
        crypto2 = require$$0;
        if (crypto2 && crypto2.randomBytes) {
          nacl2.setPRNG(function(x, n) {
            var i, v = crypto2.randomBytes(n);
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(module.exports ? module.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
const nacl = /* @__PURE__ */ getDefaultExportFromCjs(naclFastExports);
var sha512$1 = { exports: {} };
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA512_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K5 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, bits) {
      return function(message) {
        return new Sha512(bits, true).update(message)[outputType]();
      };
    };
    var createMethod = function(bits) {
      var method = createOutputMethod("hex", bits);
      method.create = function() {
        return new Sha512(bits);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type, bits);
      }
      return method;
    };
    var createHmacOutputMethod = function(outputType, bits) {
      return function(key, message) {
        return new HmacSha512(key, bits, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(bits) {
      var method = createHmacOutputMethod("hex", bits);
      method.create = function(key) {
        return new HmacSha512(key, bits);
      };
      method.update = function(key, message) {
        return method.create(key).update(message);
      };
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createHmacOutputMethod(type, bits);
      }
      return method;
    };
    function Sha512(bits, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (bits == 384) {
        this.h0h = 3418070365;
        this.h0l = 3238371032;
        this.h1h = 1654270250;
        this.h1l = 914150663;
        this.h2h = 2438529370;
        this.h2l = 812702999;
        this.h3h = 355462360;
        this.h3l = 4144912697;
        this.h4h = 1731405415;
        this.h4l = 4290775857;
        this.h5h = 2394180231;
        this.h5l = 1750603025;
        this.h6h = 3675008525;
        this.h6l = 1694076839;
        this.h7h = 1203062813;
        this.h7l = 3204075428;
      } else if (bits == 256) {
        this.h0h = 573645204;
        this.h0l = 4230739756;
        this.h1h = 2673172387;
        this.h1l = 3360449730;
        this.h2h = 596883563;
        this.h2l = 1867755857;
        this.h3h = 2520282905;
        this.h3l = 1497426621;
        this.h4h = 2519219938;
        this.h4l = 2827943907;
        this.h5h = 3193839141;
        this.h5l = 1401305490;
        this.h6h = 721525244;
        this.h6l = 746961066;
        this.h7h = 246885852;
        this.h7l = 2177182882;
      } else if (bits == 224) {
        this.h0h = 2352822216;
        this.h0l = 424955298;
        this.h1h = 1944164710;
        this.h1l = 2312950998;
        this.h2h = 502970286;
        this.h2l = 855612546;
        this.h3h = 1738396948;
        this.h3l = 1479516111;
        this.h4h = 258812777;
        this.h4l = 2077511080;
        this.h5h = 2011393907;
        this.h5l = 79989058;
        this.h6h = 1067287976;
        this.h6l = 1780299464;
        this.h7h = 286451373;
        this.h7l = 2446758561;
      } else {
        this.h0h = 1779033703;
        this.h0l = 4089235720;
        this.h1h = 3144134277;
        this.h1l = 2227873595;
        this.h2h = 1013904242;
        this.h2l = 4271175723;
        this.h3h = 2773480762;
        this.h3l = 1595750129;
        this.h4h = 1359893119;
        this.h4l = 2917565137;
        this.h5h = 2600822924;
        this.h5l = 725511199;
        this.h6h = 528734635;
        this.h6l = 4215389547;
        this.h7h = 1541459225;
        this.h7l = 327033209;
      }
      this.bits = bits;
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
    }
    Sha512.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var code2, index2 = 0, i, length = message.length, blocks2 = this.blocks;
      while (index2 < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        if (notString) {
          for (i = this.start; index2 < length && i < 128; ++index2) {
            blocks2[i >> 2] |= message[index2] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start; index2 < length && i < 128; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks2[i >> 2] |= code2 << SHIFT[i++ & 3];
            } else if (code2 < 2048) {
              blocks2[i >> 2] |= (192 | code2 >> 6) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks2[i >> 2] |= (224 | code2 >> 12) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i >> 2] |= (240 | code2 >> 18) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 128) {
          this.block = blocks2[32];
          this.start = i - 128;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha512.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i = this.lastByteIndex;
      blocks2[32] = this.block;
      blocks2[i >> 2] |= EXTRA[i & 3];
      this.block = blocks2[32];
      if (i >= 112) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
      }
      blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[31] = this.bytes << 3;
      this.hash();
    };
    Sha512.prototype.hash = function() {
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j3, s0h, s0l, s1h, s1l, c1, c2, c32, c42, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
      for (j3 = 32; j3 < 160; j3 += 2) {
        t1h = blocks2[j3 - 30];
        t1l = blocks2[j3 - 29];
        s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
        s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
        t1h = blocks2[j3 - 4];
        t1l = blocks2[j3 - 3];
        s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
        s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
        t1h = blocks2[j3 - 32];
        t1l = blocks2[j3 - 31];
        t2h = blocks2[j3 - 14];
        t2l = blocks2[j3 - 13];
        c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c32 >>> 16);
        blocks2[j3] = c42 << 16 | c32 & 65535;
        blocks2[j3 + 1] = c2 << 16 | c1 & 65535;
      }
      var ah2 = h0h, al2 = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl2 = h3l, eh = h4h, el = h4l, fh2 = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
      bch = bh & ch;
      bcl = bl & cl;
      for (j3 = 0; j3 < 160; j3 += 8) {
        s0h = (ah2 >>> 28 | al2 << 4) ^ (al2 >>> 2 | ah2 << 30) ^ (al2 >>> 7 | ah2 << 25);
        s0l = (al2 >>> 28 | ah2 << 4) ^ (ah2 >>> 2 | al2 << 30) ^ (ah2 >>> 7 | al2 << 25);
        s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
        s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
        abh = ah2 & bh;
        abl = al2 & bl;
        majh = abh ^ ah2 & ch ^ bch;
        majl = abl ^ al2 & cl ^ bcl;
        chh = eh & fh2 ^ ~eh & gh;
        chl = el & fl ^ ~el & gl;
        t1h = blocks2[j3];
        t1l = blocks2[j3 + 1];
        t2h = K5[j3];
        t2l = K5[j3 + 1];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c32 >>> 16);
        t1h = c42 << 16 | c32 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c32 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c32 >>> 16);
        t2h = c42 << 16 | c32 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (dl2 & 65535) + (t1l & 65535);
        c2 = (dl2 >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (dh >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        hh = c42 << 16 | c32 & 65535;
        hl = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        dh = c42 << 16 | c32 & 65535;
        dl2 = c2 << 16 | c1 & 65535;
        s0h = (dh >>> 28 | dl2 << 4) ^ (dl2 >>> 2 | dh << 30) ^ (dl2 >>> 7 | dh << 25);
        s0l = (dl2 >>> 28 | dh << 4) ^ (dh >>> 2 | dl2 << 30) ^ (dh >>> 7 | dl2 << 25);
        s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
        s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
        dah = dh & ah2;
        dal = dl2 & al2;
        majh = dah ^ dh & bh ^ abh;
        majl = dal ^ dl2 & bl ^ abl;
        chh = hh & eh ^ ~hh & fh2;
        chl = hl & el ^ ~hl & fl;
        t1h = blocks2[j3 + 2];
        t1l = blocks2[j3 + 3];
        t2h = K5[j3 + 2];
        t2l = K5[j3 + 3];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c32 >>> 16);
        t1h = c42 << 16 | c32 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c32 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c32 >>> 16);
        t2h = c42 << 16 | c32 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (cl & 65535) + (t1l & 65535);
        c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (ch >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        gh = c42 << 16 | c32 & 65535;
        gl = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        ch = c42 << 16 | c32 & 65535;
        cl = c2 << 16 | c1 & 65535;
        s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
        s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
        s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
        s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
        cdh = ch & dh;
        cdl = cl & dl2;
        majh = cdh ^ ch & ah2 ^ dah;
        majl = cdl ^ cl & al2 ^ dal;
        chh = gh & hh ^ ~gh & eh;
        chl = gl & hl ^ ~gl & el;
        t1h = blocks2[j3 + 4];
        t1l = blocks2[j3 + 5];
        t2h = K5[j3 + 4];
        t2l = K5[j3 + 5];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh2 & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh2 >>> 16) + (c32 >>> 16);
        t1h = c42 << 16 | c32 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c32 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c32 >>> 16);
        t2h = c42 << 16 | c32 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (bl & 65535) + (t1l & 65535);
        c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (bh >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        fh2 = c42 << 16 | c32 & 65535;
        fl = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        bh = c42 << 16 | c32 & 65535;
        bl = c2 << 16 | c1 & 65535;
        s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
        s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
        s1h = (fh2 >>> 14 | fl << 18) ^ (fh2 >>> 18 | fl << 14) ^ (fl >>> 9 | fh2 << 23);
        s1l = (fl >>> 14 | fh2 << 18) ^ (fl >>> 18 | fh2 << 14) ^ (fh2 >>> 9 | fl << 23);
        bch = bh & ch;
        bcl = bl & cl;
        majh = bch ^ bh & dh ^ cdh;
        majl = bcl ^ bl & dl2 ^ cdl;
        chh = fh2 & gh ^ ~fh2 & hh;
        chl = fl & gl ^ ~fl & hl;
        t1h = blocks2[j3 + 6];
        t1l = blocks2[j3 + 7];
        t2h = K5[j3 + 6];
        t2l = K5[j3 + 7];
        c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c32 >>> 16);
        t1h = c42 << 16 | c32 & 65535;
        t1l = c2 << 16 | c1 & 65535;
        c1 = (majl & 65535) + (s0l & 65535);
        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
        c32 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
        c42 = (majh >>> 16) + (s0h >>> 16) + (c32 >>> 16);
        t2h = c42 << 16 | c32 & 65535;
        t2l = c2 << 16 | c1 & 65535;
        c1 = (al2 & 65535) + (t1l & 65535);
        c2 = (al2 >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (ah2 & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (ah2 >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        eh = c42 << 16 | c32 & 65535;
        el = c2 << 16 | c1 & 65535;
        c1 = (t2l & 65535) + (t1l & 65535);
        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
        c32 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
        c42 = (t2h >>> 16) + (t1h >>> 16) + (c32 >>> 16);
        ah2 = c42 << 16 | c32 & 65535;
        al2 = c2 << 16 | c1 & 65535;
      }
      c1 = (h0l & 65535) + (al2 & 65535);
      c2 = (h0l >>> 16) + (al2 >>> 16) + (c1 >>> 16);
      c32 = (h0h & 65535) + (ah2 & 65535) + (c2 >>> 16);
      c42 = (h0h >>> 16) + (ah2 >>> 16) + (c32 >>> 16);
      this.h0h = c42 << 16 | c32 & 65535;
      this.h0l = c2 << 16 | c1 & 65535;
      c1 = (h1l & 65535) + (bl & 65535);
      c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
      c32 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
      c42 = (h1h >>> 16) + (bh >>> 16) + (c32 >>> 16);
      this.h1h = c42 << 16 | c32 & 65535;
      this.h1l = c2 << 16 | c1 & 65535;
      c1 = (h2l & 65535) + (cl & 65535);
      c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
      c32 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
      c42 = (h2h >>> 16) + (ch >>> 16) + (c32 >>> 16);
      this.h2h = c42 << 16 | c32 & 65535;
      this.h2l = c2 << 16 | c1 & 65535;
      c1 = (h3l & 65535) + (dl2 & 65535);
      c2 = (h3l >>> 16) + (dl2 >>> 16) + (c1 >>> 16);
      c32 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
      c42 = (h3h >>> 16) + (dh >>> 16) + (c32 >>> 16);
      this.h3h = c42 << 16 | c32 & 65535;
      this.h3l = c2 << 16 | c1 & 65535;
      c1 = (h4l & 65535) + (el & 65535);
      c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
      c32 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
      c42 = (h4h >>> 16) + (eh >>> 16) + (c32 >>> 16);
      this.h4h = c42 << 16 | c32 & 65535;
      this.h4l = c2 << 16 | c1 & 65535;
      c1 = (h5l & 65535) + (fl & 65535);
      c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
      c32 = (h5h & 65535) + (fh2 & 65535) + (c2 >>> 16);
      c42 = (h5h >>> 16) + (fh2 >>> 16) + (c32 >>> 16);
      this.h5h = c42 << 16 | c32 & 65535;
      this.h5l = c2 << 16 | c1 & 65535;
      c1 = (h6l & 65535) + (gl & 65535);
      c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
      c32 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
      c42 = (h6h >>> 16) + (gh >>> 16) + (c32 >>> 16);
      this.h6h = c42 << 16 | c32 & 65535;
      this.h6l = c2 << 16 | c1 & 65535;
      c1 = (h7l & 65535) + (hl & 65535);
      c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
      c32 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
      c42 = (h7h >>> 16) + (hh >>> 16) + (c32 >>> 16);
      this.h7h = c42 << 16 | c32 & 65535;
      this.h7l = c2 << 16 | c1 & 65535;
    };
    Sha512.prototype.hex = function() {
      this.finalize();
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
      var hex = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
      if (bits >= 256) {
        hex += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
      }
      if (bits >= 384) {
        hex += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
      }
      if (bits == 512) {
        hex += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
      }
      return hex;
    };
    Sha512.prototype.toString = Sha512.prototype.hex;
    Sha512.prototype.digest = function() {
      this.finalize();
      var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
      var arr = [
        h0h >> 24 & 255,
        h0h >> 16 & 255,
        h0h >> 8 & 255,
        h0h & 255,
        h0l >> 24 & 255,
        h0l >> 16 & 255,
        h0l >> 8 & 255,
        h0l & 255,
        h1h >> 24 & 255,
        h1h >> 16 & 255,
        h1h >> 8 & 255,
        h1h & 255,
        h1l >> 24 & 255,
        h1l >> 16 & 255,
        h1l >> 8 & 255,
        h1l & 255,
        h2h >> 24 & 255,
        h2h >> 16 & 255,
        h2h >> 8 & 255,
        h2h & 255,
        h2l >> 24 & 255,
        h2l >> 16 & 255,
        h2l >> 8 & 255,
        h2l & 255,
        h3h >> 24 & 255,
        h3h >> 16 & 255,
        h3h >> 8 & 255,
        h3h & 255
      ];
      if (bits >= 256) {
        arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
      }
      if (bits >= 384) {
        arr.push(
          h4h >> 24 & 255,
          h4h >> 16 & 255,
          h4h >> 8 & 255,
          h4h & 255,
          h4l >> 24 & 255,
          h4l >> 16 & 255,
          h4l >> 8 & 255,
          h4l & 255,
          h5h >> 24 & 255,
          h5h >> 16 & 255,
          h5h >> 8 & 255,
          h5h & 255,
          h5l >> 24 & 255,
          h5l >> 16 & 255,
          h5l >> 8 & 255,
          h5l & 255
        );
      }
      if (bits == 512) {
        arr.push(
          h6h >> 24 & 255,
          h6h >> 16 & 255,
          h6h >> 8 & 255,
          h6h & 255,
          h6l >> 24 & 255,
          h6l >> 16 & 255,
          h6l >> 8 & 255,
          h6l & 255,
          h7h >> 24 & 255,
          h7h >> 16 & 255,
          h7h >> 8 & 255,
          h7h & 255,
          h7l >> 24 & 255,
          h7l >> 16 & 255,
          h7l >> 8 & 255,
          h7l & 255
        );
      }
      return arr;
    };
    Sha512.prototype.array = Sha512.prototype.digest;
    Sha512.prototype.arrayBuffer = function() {
      this.finalize();
      var bits = this.bits;
      var buffer2 = new ArrayBuffer(bits / 8);
      var dataView = new DataView(buffer2);
      dataView.setUint32(0, this.h0h);
      dataView.setUint32(4, this.h0l);
      dataView.setUint32(8, this.h1h);
      dataView.setUint32(12, this.h1l);
      dataView.setUint32(16, this.h2h);
      dataView.setUint32(20, this.h2l);
      dataView.setUint32(24, this.h3h);
      if (bits >= 256) {
        dataView.setUint32(28, this.h3l);
      }
      if (bits >= 384) {
        dataView.setUint32(32, this.h4h);
        dataView.setUint32(36, this.h4l);
        dataView.setUint32(40, this.h5h);
        dataView.setUint32(44, this.h5l);
      }
      if (bits == 512) {
        dataView.setUint32(48, this.h6h);
        dataView.setUint32(52, this.h6l);
        dataView.setUint32(56, this.h7h);
        dataView.setUint32(60, this.h7l);
      }
      return buffer2;
    };
    Sha512.prototype.clone = function() {
      var hash = new Sha512(this.bits, false);
      this.copyTo(hash);
      return hash;
    };
    Sha512.prototype.copyTo = function(hash) {
      var i = 0, attrs = [
        "h0h",
        "h0l",
        "h1h",
        "h1l",
        "h2h",
        "h2l",
        "h3h",
        "h3l",
        "h4h",
        "h4l",
        "h5h",
        "h5l",
        "h6h",
        "h6l",
        "h7h",
        "h7l",
        "start",
        "bytes",
        "hBytes",
        "finalized",
        "hashed",
        "lastByteIndex"
      ];
      for (i = 0; i < attrs.length; ++i) {
        hash[attrs[i]] = this[attrs[i]];
      }
      for (i = 0; i < this.blocks.length; ++i) {
        hash.blocks[i] = this.blocks[i];
      }
    };
    function HmacSha512(key, bits, sharedMemory) {
      var notString, type = typeof key;
      if (type !== "string") {
        if (type === "object") {
          if (key === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
            key = new Uint8Array(key);
          } else if (!Array.isArray(key)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var length = key.length;
      if (!notString) {
        var bytes = [], length = key.length, index2 = 0, code2;
        for (var i = 0; i < length; ++i) {
          code2 = key.charCodeAt(i);
          if (code2 < 128) {
            bytes[index2++] = code2;
          } else if (code2 < 2048) {
            bytes[index2++] = 192 | code2 >> 6;
            bytes[index2++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes[index2++] = 224 | code2 >> 12;
            bytes[index2++] = 128 | code2 >> 6 & 63;
            bytes[index2++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i) & 1023);
            bytes[index2++] = 240 | code2 >> 18;
            bytes[index2++] = 128 | code2 >> 12 & 63;
            bytes[index2++] = 128 | code2 >> 6 & 63;
            bytes[index2++] = 128 | code2 & 63;
          }
        }
        key = bytes;
      }
      if (key.length > 128) {
        key = new Sha512(bits, true).update(key).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (var i = 0; i < 128; ++i) {
        var b2 = key[i] || 0;
        oKeyPad[i] = 92 ^ b2;
        iKeyPad[i] = 54 ^ b2;
      }
      Sha512.call(this, bits, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha512.prototype = new Sha512();
    HmacSha512.prototype.finalize = function() {
      Sha512.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha512.call(this, this.bits, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha512.prototype.finalize.call(this);
      }
    };
    HmacSha512.prototype.clone = function() {
      var hash = new HmacSha512([], this.bits, false);
      this.copyTo(hash);
      hash.inner = this.inner;
      for (var i = 0; i < this.oKeyPad.length; ++i) {
        hash.oKeyPad[i] = this.oKeyPad[i];
      }
      return hash;
    };
    var exports = createMethod(512);
    exports.sha512 = exports;
    exports.sha384 = createMethod(384);
    exports.sha512_256 = createMethod(256);
    exports.sha512_224 = createMethod(224);
    exports.sha512.hmac = createHmacMethod(512);
    exports.sha384.hmac = createHmacMethod(384);
    exports.sha512_256.hmac = createHmacMethod(256);
    exports.sha512_224.hmac = createHmacMethod(224);
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.sha512 = exports.sha512;
      root.sha384 = exports.sha384;
      root.sha512_256 = exports.sha512_256;
      root.sha512_224 = exports.sha512_224;
    }
  })();
})(sha512$1);
var sha512Exports = sha512$1.exports;
const sha512 = /* @__PURE__ */ getDefaultExportFromCjs(sha512Exports);
function genericHash(arr) {
  return sha512.sha512_256.array(arr);
}
function keyPairFromSeed(seed) {
  return nacl.sign.keyPair.fromSeed(seed);
}
function isValidSignatureLength(len) {
  return len === nacl.sign.signatureLength;
}
function keyPairFromSecretKey(sk2) {
  return nacl.sign.keyPair.fromSecretKey(sk2);
}
function sign(msg, secretKey) {
  return nacl.sign.detached(msg, secretKey);
}
const PUBLIC_KEY_LENGTH = nacl.sign.publicKeyLength;
nacl.sign.secretKeyLength;
const HASH_BYTES_LENGTH = 32;
var base32$1 = { exports: {} };
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var root = typeof window === "object" ? window : {};
    var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    }
    var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && true && module.exports;
    var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
    var BASE32_DECODE_CHAR = {
      "A": 0,
      "B": 1,
      "C": 2,
      "D": 3,
      "E": 4,
      "F": 5,
      "G": 6,
      "H": 7,
      "I": 8,
      "J": 9,
      "K": 10,
      "L": 11,
      "M": 12,
      "N": 13,
      "O": 14,
      "P": 15,
      "Q": 16,
      "R": 17,
      "S": 18,
      "T": 19,
      "U": 20,
      "V": 21,
      "W": 22,
      "X": 23,
      "Y": 24,
      "Z": 25,
      "2": 26,
      "3": 27,
      "4": 28,
      "5": 29,
      "6": 30,
      "7": 31
    };
    var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
    var throwInvalidUtf8 = function(position, partial) {
      if (partial.length > 10) {
        partial = "..." + partial.substr(-10);
      }
      var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
      err.position = position;
      throw err;
    };
    var toUtf8String = function(bytes) {
      var str = "", length = bytes.length, i = 0, followingChars = 0, b2, c2;
      while (i < length) {
        b2 = bytes[i++];
        if (b2 <= 127) {
          str += String.fromCharCode(b2);
          continue;
        } else if (b2 > 191 && b2 <= 223) {
          c2 = b2 & 31;
          followingChars = 1;
        } else if (b2 <= 239) {
          c2 = b2 & 15;
          followingChars = 2;
        } else if (b2 <= 247) {
          c2 = b2 & 7;
          followingChars = 3;
        } else {
          throwInvalidUtf8(i, str);
        }
        for (var j3 = 0; j3 < followingChars; ++j3) {
          b2 = bytes[i++];
          if (b2 < 128 || b2 > 191) {
            throwInvalidUtf8(i, str);
          }
          c2 <<= 6;
          c2 += b2 & 63;
        }
        if (c2 >= 55296 && c2 <= 57343) {
          throwInvalidUtf8(i, str);
        }
        if (c2 > 1114111) {
          throwInvalidUtf8(i, str);
        }
        if (c2 <= 65535) {
          str += String.fromCharCode(c2);
        } else {
          c2 -= 65536;
          str += String.fromCharCode((c2 >> 10) + 55296);
          str += String.fromCharCode((c2 & 1023) + 56320);
        }
      }
      return str;
    };
    var decodeAsBytes = function(base32Str) {
      if (base32Str === "") {
        return [];
      } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
        throw new Error("Invalid base32 characters");
      }
      base32Str = base32Str.replace(/=/g, "");
      var v12, v2, v32, v42, v5, v62, v7, v82, bytes = [], index2 = 0, length = base32Str.length;
      for (var i = 0, count = length >> 3 << 3; i < count; ) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v82 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v12 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
        bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
        bytes[index2++] = (v5 << 7 | v62 << 2 | v7 >>> 3) & 255;
        bytes[index2++] = (v7 << 5 | v82) & 255;
      }
      var remain = length - count;
      if (remain === 2) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v12 << 3 | v2 >>> 2) & 255;
      } else if (remain === 4) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v12 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
      } else if (remain === 5) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v12 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
        bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
      } else if (remain === 7) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        bytes[index2++] = (v12 << 3 | v2 >>> 2) & 255;
        bytes[index2++] = (v2 << 6 | v32 << 1 | v42 >>> 4) & 255;
        bytes[index2++] = (v42 << 4 | v5 >>> 1) & 255;
        bytes[index2++] = (v5 << 7 | v62 << 2 | v7 >>> 3) & 255;
      }
      return bytes;
    };
    var encodeAscii = function(str) {
      var v12, v2, v32, v42, v5, base32Str = "", length = str.length;
      for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
        v12 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v32 = str.charCodeAt(i++);
        v42 = str.charCodeAt(i++);
        v5 = str.charCodeAt(i++);
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
      }
      var remain = length - count;
      if (remain === 1) {
        v12 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[v12 << 2 & 31] + "======";
      } else if (remain === 2) {
        v12 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
      } else if (remain === 3) {
        v12 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v32 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
      } else if (remain === 4) {
        v12 = str.charCodeAt(i++);
        v2 = str.charCodeAt(i++);
        v32 = str.charCodeAt(i++);
        v42 = str.charCodeAt(i);
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
      }
      return base32Str;
    };
    var encodeUtf8 = function(str) {
      var v12, v2, v32, v42, v5, code2, end = false, base32Str = "", index2 = 0, i, start = 0, length = str.length;
      if (str === "") {
        return base32Str;
      }
      do {
        blocks[0] = blocks[5];
        blocks[1] = blocks[6];
        blocks[2] = blocks[7];
        for (i = start; index2 < length && i < 5; ++index2) {
          code2 = str.charCodeAt(index2);
          if (code2 < 128) {
            blocks[i++] = code2;
          } else if (code2 < 2048) {
            blocks[i++] = 192 | code2 >> 6;
            blocks[i++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            blocks[i++] = 224 | code2 >> 12;
            blocks[i++] = 128 | code2 >> 6 & 63;
            blocks[i++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++index2) & 1023);
            blocks[i++] = 240 | code2 >> 18;
            blocks[i++] = 128 | code2 >> 12 & 63;
            blocks[i++] = 128 | code2 >> 6 & 63;
            blocks[i++] = 128 | code2 & 63;
          }
        }
        start = i - 5;
        if (index2 === length) {
          ++index2;
        }
        if (index2 > length && i < 6) {
          end = true;
        }
        v12 = blocks[0];
        if (i > 4) {
          v2 = blocks[1];
          v32 = blocks[2];
          v42 = blocks[3];
          v5 = blocks[4];
          base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        } else if (i === 1) {
          base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[v12 << 2 & 31] + "======";
        } else if (i === 2) {
          v2 = blocks[1];
          base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (i === 3) {
          v2 = blocks[1];
          v32 = blocks[2];
          base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
        } else {
          v2 = blocks[1];
          v32 = blocks[2];
          v42 = blocks[3];
          base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
        }
      } while (!end);
      return base32Str;
    };
    var encodeBytes = function(bytes) {
      var v12, v2, v32, v42, v5, base32Str = "", length = bytes.length;
      for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
        v12 = bytes[i++];
        v2 = bytes[i++];
        v32 = bytes[i++];
        v42 = bytes[i++];
        v5 = bytes[i++];
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v42 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
      }
      var remain = length - count;
      if (remain === 1) {
        v12 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[v12 << 2 & 31] + "======";
      } else if (remain === 2) {
        v12 = bytes[i++];
        v2 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
      } else if (remain === 3) {
        v12 = bytes[i++];
        v2 = bytes[i++];
        v32 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[v32 << 1 & 31] + "===";
      } else if (remain === 4) {
        v12 = bytes[i++];
        v2 = bytes[i++];
        v32 = bytes[i++];
        v42 = bytes[i];
        base32Str += BASE32_ENCODE_CHAR[v12 >>> 3] + BASE32_ENCODE_CHAR[(v12 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v32 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v32 << 1 | v42 >>> 7) & 31] + BASE32_ENCODE_CHAR[v42 >>> 2 & 31] + BASE32_ENCODE_CHAR[v42 << 3 & 31] + "=";
      }
      return base32Str;
    };
    var encode2 = function(input, asciiOnly) {
      var notString = typeof input !== "string";
      if (notString && input.constructor === ArrayBuffer) {
        input = new Uint8Array(input);
      }
      if (notString) {
        return encodeBytes(input);
      } else if (asciiOnly) {
        return encodeAscii(input);
      } else {
        return encodeUtf8(input);
      }
    };
    var decode2 = function(base32Str, asciiOnly) {
      if (!asciiOnly) {
        return toUtf8String(decodeAsBytes(base32Str));
      }
      if (base32Str === "") {
        return "";
      } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
        throw new Error("Invalid base32 characters");
      }
      var v12, v2, v32, v42, v5, v62, v7, v82, str = "", length = base32Str.indexOf("=");
      if (length === -1) {
        length = base32Str.length;
      }
      for (var i = 0, count = length >> 3 << 3; i < count; ) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v82 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v12 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v62 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v82) & 255);
      }
      var remain = length - count;
      if (remain === 2) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v12 << 3 | v2 >>> 2) & 255);
      } else if (remain === 4) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v12 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255);
      } else if (remain === 5) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v12 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255);
      } else if (remain === 7) {
        v12 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v32 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v42 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v62 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
        str += String.fromCharCode((v12 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v32 << 1 | v42 >>> 4) & 255) + String.fromCharCode((v42 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v62 << 2 | v7 >>> 3) & 255);
      }
      return str;
    };
    var exports = {
      encode: encode2,
      decode: decode2
    };
    decode2.asBytes = decodeAsBytes;
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.base32 = exports;
    }
  })();
})(base32$1);
var base32Exports = base32$1.exports;
const base32 = /* @__PURE__ */ getDefaultExportFromCjs(base32Exports);
var jsonBigint = { exports: {} };
var stringify = { exports: {} };
var bignumber = { exports: {} };
(function(module) {
  (function(globalObject) {
    var BigNumber2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P5 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber3(v, b2) {
        var alphabet, c2, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber3))
          return new BigNumber3(v, b2);
        if (b2 == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b2, 2, ALPHABET.length, "Base");
          if (b2 == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber3(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b2);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b2);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet.indexOf(c2 = str.charAt(i)) < 0) {
              if (c2 == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b2);
            }
          }
          isNum = false;
          str = convertBase(str, b2, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber3.clone = clone;
      BigNumber3.ROUND_UP = 0;
      BigNumber3.ROUND_DOWN = 1;
      BigNumber3.ROUND_CEIL = 2;
      BigNumber3.ROUND_FLOOR = 3;
      BigNumber3.ROUND_HALF_UP = 4;
      BigNumber3.ROUND_HALF_DOWN = 5;
      BigNumber3.ROUND_HALF_EVEN = 6;
      BigNumber3.ROUND_HALF_CEIL = 7;
      BigNumber3.ROUND_HALF_FLOOR = 8;
      BigNumber3.EUCLID = 9;
      BigNumber3.config = BigNumber3.set = function(obj) {
        var p2, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
              v = obj[p2];
              intCheck(v, 0, MAX, p2);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
              v = obj[p2];
              intCheck(v, 0, 8, p2);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
              v = obj[p2];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p2);
                intCheck(v[1], 0, MAX, p2);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p2);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p2 = "RANGE")) {
              v = obj[p2];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p2);
                intCheck(v[1], 1, MAX, p2);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p2);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p2 + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p2 = "CRYPTO")) {
              v = obj[p2];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p2 + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
              v = obj[p2];
              intCheck(v, 0, 9, p2);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
              v = obj[p2];
              intCheck(v, 0, MAX, p2);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p2 = "FORMAT")) {
              v = obj[p2];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p2 + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p2 = "ALPHABET")) {
              v = obj[p2];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p2 + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber3.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber3.DEBUG)
          return true;
        var i, n, c2 = v.c, e = v.e, s2 = v.s;
        out:
          if ({}.toString.call(c2) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c2[0] === 0) {
                if (e === 0 && c2.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c2[0]).length == i) {
                for (i = 0; i < c2.length; i++) {
                  n = c2[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c2 === null && e === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber3.maximum = BigNumber3.max = function() {
        return maxOrMin(arguments, P5.lt);
      };
      BigNumber3.minimum = BigNumber3.min = function() {
        return maxOrMin(arguments, P5.gt);
      };
      BigNumber3.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b2, e, k2, v, i = 0, c2 = [], rand = new BigNumber3(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k2 = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k2 *= 2));
              for (; i < k2; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9e15) {
                  b2 = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b2[0];
                  a[i + 1] = b2[1];
                } else {
                  c2.push(v % 1e14);
                  i += 2;
                }
              }
              i = k2 / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k2 *= 7);
              for (; i < k2; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c2.push(v % 1e14);
                  i += 7;
                }
              }
              i = k2 / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k2; ) {
              v = random53bitInt();
              if (v < 9e15)
                c2[i++] = v % 1e14;
            }
          }
          k2 = c2[--i];
          dp %= LOG_BASE;
          if (k2 && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c2[i] = mathfloor(k2 / v) * v;
          }
          for (; c2[i] === 0; c2.pop(), i--)
            ;
          if (i < 0) {
            c2 = [e = 0];
          } else {
            for (e = -1; c2[0] === 0; c2.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c2[0]; v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c2;
          return rand;
        };
      }();
      BigNumber3.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber3(args[0]);
        for (; i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j3, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j3 = 0; j3 < arr.length; j3++) {
              if (arr[j3] > baseOut - 1) {
                if (arr[j3 + 1] == null)
                  arr[j3 + 1] = 0;
                arr[j3 + 1] += arr[j3] / baseOut | 0;
                arr[j3] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign2, callerIsToString) {
          var alphabet, d2, e, k2, r, x, xc, y2, i = str.indexOf("."), dp = DECIMAL_PLACES, rm2 = ROUNDING_MODE;
          if (i >= 0) {
            k2 = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y2 = new BigNumber3(baseIn);
            x = y2.pow(str.length - i);
            POW_PRECISION = k2;
            y2.c = toBaseOut(
              toFixedPoint(coeffToString(x.c), x.e, "0"),
              10,
              baseOut,
              decimal
            );
            y2.e = y2.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k2 = xc.length;
          for (; xc[--k2] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign2;
            x = div(x, y2, dp, rm2, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d2 = e + dp + 1;
          i = xc[d2];
          k2 = baseOut / 2;
          r = r || d2 < 0 || xc[d2 + 1] != null;
          r = rm2 < 4 ? (i != null || r) && (rm2 == 0 || rm2 == (x.s < 0 ? 3 : 2)) : i > k2 || i == k2 && (rm2 == 4 || r || rm2 == 6 && xc[d2 - 1] & 1 || rm2 == (x.s < 0 ? 8 : 7));
          if (d2 < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc.length = d2;
            if (r) {
              for (--baseOut; ++xc[--d2] > baseOut; ) {
                xc[d2] = 0;
                if (!d2) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k2 = xc.length; !xc[--k2]; )
              ;
            for (i = 0, str = ""; i <= k2; str += alphabet.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x, k2, base) {
          var m3, temp, xlo, xhi, carry = 0, i = x.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
          for (x = x.slice(); i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m3 = khi * xlo + xhi * klo;
            temp = klo * xlo + m3 % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m3 / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare2(a, b2, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b2[i]) {
                cmp = a[i] > b2[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b2, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b2[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b2[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y2, dp, rm2, base) {
          var cmp, e, i, more, n, prod, prodL, q2, qc2, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x.s == y2.s ? 1 : -1, xc = x.c, yc = y2.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber3(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
              )
            );
          }
          q2 = new BigNumber3(s2);
          qc2 = q2.c = [];
          e = x.e - y2.e;
          s2 = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
            s2 = s2 / LOG_BASE | 0;
          }
          for (i = 0; yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s2 < 0) {
            qc2.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s2 += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base);
              xc = multiply(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare2(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc2[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s2--);
            more = rem[0] != null;
            if (!qc2[0])
              qc2.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s2 = qc2[0]; s2 >= 10; s2 /= 10, i++)
              ;
            round(q2, dp + (q2.e = i + e * LOG_BASE - 1) + 1, rm2, more);
          } else {
            q2.e = e;
            q2.r = +more;
          }
          return q2;
        };
      }();
      function format(n, i, rm2, id2) {
        var c02, e, ne, len, str;
        if (rm2 == null)
          rm2 = ROUNDING_MODE;
        else
          intCheck(rm2, 0, 8);
        if (!n.c)
          return n.toString();
        c02 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id2 == 1 || id2 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber3(n), i, rm2);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id2 == 1 || id2 == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += "."; i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (; i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c02 ? "-" + str : str;
      }
      function maxOrMin(args, method) {
        var n, i = 1, m3 = new BigNumber3(args[0]);
        for (; i < args.length; i++) {
          n = new BigNumber3(args[i]);
          if (!n.s) {
            m3 = n;
            break;
          } else if (method.call(m3, n)) {
            m3 = n;
          }
        }
        return m3;
      }
      function normalise(n, c2, e) {
        var i = 1, j3 = c2.length;
        for (; !c2[--j3]; c2.pop())
          ;
        for (j3 = c2[0]; j3 >= 10; j3 /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c2;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b2) {
          var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s2)) {
            x.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s2 = s2.replace(basePrefix, function(m3, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b2 || b2 == base ? p1 : m3;
              });
              if (b2) {
                base = b2;
                s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s2)
                return new BigNumber3(s2, base);
            }
            if (BigNumber3.DEBUG) {
              throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd2, rm2, r) {
        var d2, i, j3, k2, n, ni, rd2, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d2 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d2++)
              ;
            i = sd2 - d2;
            if (i < 0) {
              i += LOG_BASE;
              j3 = sd2;
              n = xc[ni = 0];
              rd2 = n / pows10[d2 - j3 - 1] % 10 | 0;
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (; xc.length <= ni; xc.push(0))
                    ;
                  n = rd2 = 0;
                  d2 = 1;
                  i %= LOG_BASE;
                  j3 = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k2 = xc[ni];
                for (d2 = 1; k2 >= 10; k2 /= 10, d2++)
                  ;
                i %= LOG_BASE;
                j3 = i - LOG_BASE + d2;
                rd2 = j3 < 0 ? 0 : n / pows10[d2 - j3 - 1] % 10 | 0;
              }
            }
            r = r || sd2 < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            xc[ni + 1] != null || (j3 < 0 ? n : n % pows10[d2 - j3 - 1]);
            r = rm2 < 4 ? (rd2 || r) && (rm2 == 0 || rm2 == (x.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm2 == 4 || r || rm2 == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j3 > 0 ? n / pows10[d2 - j3] : 0 : xc[ni - 1]) % 10 & 1 || rm2 == (x.s < 0 ? 8 : 7));
            if (sd2 < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd2 -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd2 % LOG_BASE) % LOG_BASE];
                x.e = -sd2 || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k2 = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k2 = pows10[LOG_BASE - i];
              xc[ni] = j3 > 0 ? mathfloor(n / pows10[d2 - j3] % pows10[j3]) * k2 : 0;
            }
            if (r) {
              for (; ; ) {
                if (ni == 0) {
                  for (i = 1, j3 = xc[0]; j3 >= 10; j3 /= 10, i++)
                    ;
                  j3 = xc[0] += k2;
                  for (k2 = 1; j3 >= 10; j3 /= 10, k2++)
                    ;
                  if (i != k2) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k2;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k2 = 1;
                }
              }
            }
            for (i = xc.length; xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P5.absoluteValue = P5.abs = function() {
        var x = new BigNumber3(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P5.comparedTo = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2));
      };
      P5.decimalPlaces = P5.dp = function(dp, rm2) {
        var c2, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm2 == null)
            rm2 = ROUNDING_MODE;
          else
            intCheck(rm2, 0, 8);
          return round(new BigNumber3(x), dp + x.e + 1, rm2);
        }
        if (!(c2 = x.c))
          return null;
        n = ((v = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c2[v])
          for (; v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P5.dividedBy = P5.div = function(y2, b2) {
        return div(this, new BigNumber3(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P5.dividedToIntegerBy = P5.idiv = function(y2, b2) {
        return div(this, new BigNumber3(y2, b2), 0, 1);
      };
      P5.exponentiatedBy = P5.pow = function(n, m3) {
        var half, isModExp, i, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x = this;
        n = new BigNumber3(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m3 != null)
          m3 = new BigNumber3(m3);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y2 = new BigNumber3(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m3 ? y2.mod(m3) : y2;
        }
        nIsNeg = n.s < 0;
        if (m3) {
          if (m3.c ? !m3.c[0] : !m3.s)
            return new BigNumber3(NaN);
          isModExp = !nIsNeg && x.isInteger() && m3.isInteger();
          if (isModExp)
            x = x.mod(m3);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
          k2 = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k2 = 1 / k2;
          return new BigNumber3(nIsNeg ? 1 / k2 : k2);
        } else if (POW_PRECISION) {
          k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber3(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y2 = new BigNumber3(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y2 = y2.times(x);
            if (!y2.c)
              break;
            if (k2) {
              if (y2.c.length > k2)
                y2.c.length = k2;
            } else if (isModExp) {
              y2 = y2.mod(m3);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k2) {
            if (x.c && x.c.length > k2)
              x.c.length = k2;
          } else if (isModExp) {
            x = x.mod(m3);
          }
        }
        if (isModExp)
          return y2;
        if (nIsNeg)
          y2 = ONE.div(y2);
        return m3 ? y2.mod(m3) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
      };
      P5.integerValue = function(rm2) {
        var n = new BigNumber3(this);
        if (rm2 == null)
          rm2 = ROUNDING_MODE;
        else
          intCheck(rm2, 0, 8);
        return round(n, n.e + 1, rm2);
      };
      P5.isEqualTo = P5.eq = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) === 0;
      };
      P5.isFinite = function() {
        return !!this.c;
      };
      P5.isGreaterThan = P5.gt = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) > 0;
      };
      P5.isGreaterThanOrEqualTo = P5.gte = function(y2, b2) {
        return (b2 = compare(this, new BigNumber3(y2, b2))) === 1 || b2 === 0;
      };
      P5.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P5.isLessThan = P5.lt = function(y2, b2) {
        return compare(this, new BigNumber3(y2, b2)) < 0;
      };
      P5.isLessThanOrEqualTo = P5.lte = function(y2, b2) {
        return (b2 = compare(this, new BigNumber3(y2, b2))) === -1 || b2 === 0;
      };
      P5.isNaN = function() {
        return !this.s;
      };
      P5.isNegative = function() {
        return this.s < 0;
      };
      P5.isPositive = function() {
        return this.s > 0;
      };
      P5.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P5.minus = function(y2, b2) {
        var i, j3, t, xLTy, x = this, a = x.s;
        y2 = new BigNumber3(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber3(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x.plus(y2);
        }
        var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y2.s = -b2, y2) : new BigNumber3(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y2.s = -b2, y2) : new BigNumber3(xc[0] ? x : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0
            ));
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b2 = a; b2--; t.push(0))
            ;
          t.reverse();
        } else {
          j3 = (xLTy = (a = xc.length) < (b2 = yc.length)) ? a : b2;
          for (a = b2 = 0; b2 < j3; b2++) {
            if (xc[b2] != yc[b2]) {
              xLTy = xc[b2] < yc[b2];
              break;
            }
          }
        }
        if (xLTy) {
          t = xc;
          xc = yc;
          yc = t;
          y2.s = -y2.s;
        }
        b2 = (j3 = yc.length) - (i = xc.length);
        if (b2 > 0)
          for (; b2--; xc[i++] = 0)
            ;
        b2 = BASE - 1;
        for (; j3 > a; ) {
          if (xc[--j3] < yc[j3]) {
            for (i = j3; i && !xc[--i]; xc[i] = b2)
              ;
            --xc[i];
            xc[j3] += BASE;
          }
          xc[j3] -= yc[j3];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y2.s = ROUNDING_MODE == 3 ? -1 : 1;
          y2.c = [y2.e = 0];
          return y2;
        }
        return normalise(y2, xc, ye);
      };
      P5.modulo = P5.mod = function(y2, b2) {
        var q2, s2, x = this;
        y2 = new BigNumber3(y2, b2);
        if (!x.c || !y2.s || y2.c && !y2.c[0]) {
          return new BigNumber3(NaN);
        } else if (!y2.c || x.c && !x.c[0]) {
          return new BigNumber3(x);
        }
        if (MODULO_MODE == 9) {
          s2 = y2.s;
          y2.s = 1;
          q2 = div(x, y2, 0, 3);
          y2.s = s2;
          q2.s *= s2;
        } else {
          q2 = div(x, y2, 0, MODULO_MODE);
        }
        y2 = x.minus(q2.times(y2));
        if (!y2.c[0] && MODULO_MODE == 1)
          y2.s = x.s;
        return y2;
      };
      P5.multipliedBy = P5.times = function(y2, b2) {
        var c2, e, i, j3, k2, m3, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base, sqrtBase, x = this, xc = x.c, yc = (y2 = new BigNumber3(y2, b2)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y2.c = y2.e = y2.s = null;
          } else {
            y2.s *= x.s;
            if (!xc || !yc) {
              y2.c = y2.e = null;
            } else {
              y2.c = [0];
              y2.e = 0;
            }
          }
          return y2;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
        y2.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc2 = xc;
          xc = yc;
          yc = zc2;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc2 = []; i--; zc2.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c2 = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k2 = xcL, j3 = i + k2; j3 > i; ) {
            xlo = xc[--k2] % sqrtBase;
            xhi = xc[k2] / sqrtBase | 0;
            m3 = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m3 % sqrtBase * sqrtBase + zc2[j3] + c2;
            c2 = (xlo / base | 0) + (m3 / sqrtBase | 0) + yhi * xhi;
            zc2[j3--] = xlo % base;
          }
          zc2[j3] = c2;
        }
        if (c2) {
          ++e;
        } else {
          zc2.splice(0, 1);
        }
        return normalise(y2, zc2, e);
      };
      P5.negated = function() {
        var x = new BigNumber3(this);
        x.s = -x.s || null;
        return x;
      };
      P5.plus = function(y2, b2) {
        var t, x = this, a = x.s;
        y2 = new BigNumber3(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber3(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x.minus(y2);
        }
        var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber3(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y2 : new BigNumber3(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (; a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc.length;
        b2 = yc.length;
        if (a - b2 < 0) {
          t = yc;
          yc = xc;
          xc = t;
          b2 = a;
        }
        for (a = 0; b2; ) {
          a = (xc[--b2] = xc[b2] + yc[b2] + a) / BASE | 0;
          xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y2, xc, ye);
      };
      P5.precision = P5.sd = function(sd2, rm2) {
        var c2, n, v, x = this;
        if (sd2 != null && sd2 !== !!sd2) {
          intCheck(sd2, 1, MAX);
          if (rm2 == null)
            rm2 = ROUNDING_MODE;
          else
            intCheck(rm2, 0, 8);
          return round(new BigNumber3(x), sd2, rm2);
        }
        if (!(c2 = x.c))
          return null;
        v = c2.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c2[v]) {
          for (; v % 10 == 0; v /= 10, n--)
            ;
          for (v = c2[0]; v >= 10; v /= 10, n++)
            ;
        }
        if (sd2 && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P5.shiftedBy = function(k2) {
        intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k2);
      };
      P5.squareRoot = P5.sqrt = function() {
        var m3, n, r, rep, t, x = this, c2 = x.c, s2 = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
        if (s2 !== 1 || !c2 || !c2[0]) {
          return new BigNumber3(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x : 1 / 0);
        }
        s2 = Math.sqrt(+valueOf(x));
        if (s2 == 0 || s2 == 1 / 0) {
          n = coeffToString(c2);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s2 = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s2 == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s2.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber3(n);
        } else {
          r = new BigNumber3(s2 + "");
        }
        if (r.c[0]) {
          e = r.e;
          s2 = e + dp;
          if (s2 < 3)
            s2 = 0;
          for (; ; ) {
            t = r;
            r = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s2) === (n = coeffToString(r.c)).slice(0, s2)) {
              if (r.e < e)
                --s2;
              n = n.slice(s2 - 3, s2 + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                dp += 4;
                s2 += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m3 = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m3);
      };
      P5.toExponential = function(dp, rm2) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm2, 1);
      };
      P5.toFixed = function(dp, rm2) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm2);
      };
      P5.toFormat = function(dp, rm2, format2) {
        var str, x = this;
        if (format2 == null) {
          if (dp != null && rm2 && typeof rm2 == "object") {
            format2 = rm2;
            rm2 = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm2 = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x.toFixed(dp, rm2);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
            new RegExp("\\d{" + g2 + "}\\B", "g"),
            "$&" + (format2.fractionGroupSeparator || "")
          ) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P5.toFraction = function(md2) {
        var d2, d02, d1, d22, e, exp, n, n02, n12, q2, r, s2, x = this, xc = x.c;
        if (md2 != null) {
          n = new BigNumber3(md2);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber3(x);
        d2 = new BigNumber3(ONE);
        n12 = d02 = new BigNumber3(ONE);
        d1 = n02 = new BigNumber3(ONE);
        s2 = coeffToString(xc);
        e = d2.e = s2.length - x.e - 1;
        d2.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md2 = !md2 || n.comparedTo(d2) > 0 ? e > 0 ? d2 : n12 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber3(s2);
        n02.c[0] = 0;
        for (; ; ) {
          q2 = div(n, d2, 0, 1);
          d22 = d02.plus(q2.times(d1));
          if (d22.comparedTo(md2) == 1)
            break;
          d02 = d1;
          d1 = d22;
          n12 = n02.plus(q2.times(d22 = n12));
          n02 = d22;
          d2 = n.minus(q2.times(d22 = d2));
          n = d22;
        }
        d22 = div(md2.minus(d02), d1, 0, 1);
        n02 = n02.plus(d22.times(n12));
        d02 = d02.plus(d22.times(d1));
        n02.s = n12.s = x.s;
        e = e * 2;
        r = div(n12, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n02, d02, e, ROUNDING_MODE).minus(x).abs()
        ) < 1 ? [n12, d1] : [n02, d02];
        MAX_EXP = exp;
        return r;
      };
      P5.toNumber = function() {
        return +valueOf(this);
      };
      P5.toPrecision = function(sd2, rm2) {
        if (sd2 != null)
          intCheck(sd2, 1, MAX);
        return format(this, sd2, rm2, 2);
      };
      P5.toString = function(b2) {
        var str, n = this, s2 = n.s, e = n.e;
        if (e === null) {
          if (s2) {
            str = "Infinity";
            if (s2 < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b2 == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b2, s2, true);
          }
          if (s2 < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P5.valueOf = P5.toJSON = function() {
        return valueOf(this);
      };
      P5._isBigNumber = true;
      if (configObject != null)
        BigNumber3.set(configObject);
      return BigNumber3;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s2, z3, i = 1, j3 = a.length, r = a[0] + "";
      for (; i < j3; ) {
        s2 = a[i++] + "";
        z3 = LOG_BASE - s2.length;
        for (; z3--; s2 = "0" + s2)
          ;
        r += s2;
      }
      for (j3 = r.length; r.charCodeAt(--j3) === 48; )
        ;
      return r.slice(0, j3 + 1 || 1);
    }
    function compare(x, y2) {
      var a, b2, xc = x.c, yc = y2.c, i = x.s, j3 = y2.s, k2 = x.e, l = y2.e;
      if (!i || !j3)
        return null;
      a = xc && !xc[0];
      b2 = yc && !yc[0];
      if (a || b2)
        return a ? b2 ? 0 : -j3 : i;
      if (i != j3)
        return i;
      a = i < 0;
      b2 = k2 == l;
      if (!xc || !yc)
        return b2 ? 0 : !xc ^ a ? 1 : -1;
      if (!b2)
        return k2 > l ^ a ? 1 : -1;
      j3 = (k2 = xc.length) < (l = yc.length) ? k2 : l;
      for (i = 0; i < j3; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k2 == l ? 0 : k2 > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k2 = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k2 && n.c[k2] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z3) {
      var len, zs;
      if (e < 0) {
        for (zs = z3 + "."; ++e; zs += z3)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z3, e -= len; --e; zs += z3)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber2 = clone();
    BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
    if (module.exports) {
      module.exports = BigNumber2;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber2;
    }
  })(commonjsGlobal);
})(bignumber);
var bignumberExports = bignumber.exports;
(function(module) {
  var BigNumber2 = bignumberExports;
  var JSON2 = module.exports;
  (function() {
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c2 = meta[a];
        return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i, k2, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber2 || BigNumber2.isBigNumber(value));
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          if (isBigNumber) {
            return value;
          } else {
            return quote(value);
          }
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              if (typeof rep[i] === "string") {
                k2 = rep[i];
                v = str(k2, value);
                if (v) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            Object.keys(value).forEach(function(k3) {
              var v2 = str(k3, value);
              if (v2) {
                partial.push(quote(k3) + (gap ? ": " : ":") + v2);
              }
            });
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
      }
    }
    if (typeof JSON2.stringify !== "function") {
      JSON2.stringify = function(value, replacer2, space) {
        var i;
        gap = "";
        indent = "";
        if (typeof space === "number") {
          for (i = 0; i < space; i += 1) {
            indent += " ";
          }
        } else if (typeof space === "string") {
          indent = space;
        }
        rep = replacer2;
        if (replacer2 && typeof replacer2 !== "function" && (typeof replacer2 !== "object" || typeof replacer2.length !== "number")) {
          throw new Error("JSON.stringify");
        }
        return str("", { "": value });
      };
    }
  })();
})(stringify);
var stringifyExports = stringify.exports;
var BigNumber = null;
const suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
const suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
var json_parse$1 = function(options) {
  var _options = {
    strict: false,
    // not being strict means do not generate syntax errors for "duplicate key"
    storeAsString: false,
    // toggles whether the values should be stored as BigNumber (default) or a string
    alwaysParseAsBig: false,
    // toggles whether all numbers should be Big
    useNativeBigInt: false,
    // toggles whether to use native BigInt instead of bignumber.js
    protoAction: "error",
    constructorAction: "error"
  };
  if (options !== void 0 && options !== null) {
    if (options.strict === true) {
      _options.strict = true;
    }
    if (options.storeAsString === true) {
      _options.storeAsString = true;
    }
    _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
    _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
    if (typeof options.constructorAction !== "undefined") {
      if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
        _options.constructorAction = options.constructorAction;
      } else {
        throw new Error(
          `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
        );
      }
    }
    if (typeof options.protoAction !== "undefined") {
      if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
        _options.protoAction = options.protoAction;
      } else {
        throw new Error(
          `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
        );
      }
    }
  }
  var at, ch, escapee = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	"
  }, text, error = function(m3) {
    throw {
      name: "SyntaxError",
      message: m3,
      at,
      text
    };
  }, next = function(c2) {
    if (c2 && c2 !== ch) {
      error("Expected '" + c2 + "' instead of '" + ch + "'");
    }
    ch = text.charAt(at);
    at += 1;
    return ch;
  }, number = function() {
    var number2, string2 = "";
    if (ch === "-") {
      string2 = "-";
      next("-");
    }
    while (ch >= "0" && ch <= "9") {
      string2 += ch;
      next();
    }
    if (ch === ".") {
      string2 += ".";
      while (next() && ch >= "0" && ch <= "9") {
        string2 += ch;
      }
    }
    if (ch === "e" || ch === "E") {
      string2 += ch;
      next();
      if (ch === "-" || ch === "+") {
        string2 += ch;
        next();
      }
      while (ch >= "0" && ch <= "9") {
        string2 += ch;
        next();
      }
    }
    number2 = +string2;
    if (!isFinite(number2)) {
      error("Bad number");
    } else {
      if (BigNumber == null)
        BigNumber = bignumberExports;
      if (string2.length > 15)
        return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
      else
        return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
    }
  }, string = function() {
    var hex, i, string2 = "", uffff;
    if (ch === '"') {
      var startAt = at;
      while (next()) {
        if (ch === '"') {
          if (at - 1 > startAt)
            string2 += text.substring(startAt, at - 1);
          next();
          return string2;
        }
        if (ch === "\\") {
          if (at - 1 > startAt)
            string2 += text.substring(startAt, at - 1);
          next();
          if (ch === "u") {
            uffff = 0;
            for (i = 0; i < 4; i += 1) {
              hex = parseInt(next(), 16);
              if (!isFinite(hex)) {
                break;
              }
              uffff = uffff * 16 + hex;
            }
            string2 += String.fromCharCode(uffff);
          } else if (typeof escapee[ch] === "string") {
            string2 += escapee[ch];
          } else {
            break;
          }
          startAt = at;
        }
      }
    }
    error("Bad string");
  }, white = function() {
    while (ch && ch <= " ") {
      next();
    }
  }, word = function() {
    switch (ch) {
      case "t":
        next("t");
        next("r");
        next("u");
        next("e");
        return true;
      case "f":
        next("f");
        next("a");
        next("l");
        next("s");
        next("e");
        return false;
      case "n":
        next("n");
        next("u");
        next("l");
        next("l");
        return null;
    }
    error("Unexpected '" + ch + "'");
  }, value, array = function() {
    var array2 = [];
    if (ch === "[") {
      next("[");
      white();
      if (ch === "]") {
        next("]");
        return array2;
      }
      while (ch) {
        array2.push(value());
        white();
        if (ch === "]") {
          next("]");
          return array2;
        }
        next(",");
        white();
      }
    }
    error("Bad array");
  }, object = function() {
    var key, object2 = /* @__PURE__ */ Object.create(null);
    if (ch === "{") {
      next("{");
      white();
      if (ch === "}") {
        next("}");
        return object2;
      }
      while (ch) {
        key = string();
        white();
        next(":");
        if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
          error('Duplicate key "' + key + '"');
        }
        if (suspectProtoRx.test(key) === true) {
          if (_options.protoAction === "error") {
            error("Object contains forbidden prototype property");
          } else if (_options.protoAction === "ignore") {
            value();
          } else {
            object2[key] = value();
          }
        } else if (suspectConstructorRx.test(key) === true) {
          if (_options.constructorAction === "error") {
            error("Object contains forbidden constructor property");
          } else if (_options.constructorAction === "ignore") {
            value();
          } else {
            object2[key] = value();
          }
        } else {
          object2[key] = value();
        }
        white();
        if (ch === "}") {
          next("}");
          return object2;
        }
        next(",");
        white();
      }
    }
    error("Bad object");
  };
  value = function() {
    white();
    switch (ch) {
      case "{":
        return object();
      case "[":
        return array();
      case '"':
        return string();
      case "-":
        return number();
      default:
        return ch >= "0" && ch <= "9" ? number() : word();
    }
  };
  return function(source, reviver) {
    var result;
    text = source + "";
    at = 0;
    ch = " ";
    result = value();
    white();
    if (ch) {
      error("Syntax error");
    }
    return typeof reviver === "function" ? function walk(holder, key) {
      var v, value2 = holder[key];
      if (value2 && typeof value2 === "object") {
        Object.keys(value2).forEach(function(k2) {
          v = walk(value2, k2);
          if (v !== void 0) {
            value2[k2] = v;
          } else {
            delete value2[k2];
          }
        });
      }
      return reviver.call(holder, key, value2);
    }({ "": result }, "") : result;
  };
};
var parse = json_parse$1;
var json_stringify = stringifyExports.stringify;
var json_parse = parse;
jsonBigint.exports = function(options) {
  return {
    parse: json_parse(options),
    stringify: json_stringify
  };
};
jsonBigint.exports.parse = json_parse();
jsonBigint.exports.stringify = json_stringify;
var jsonBigintExports = jsonBigint.exports;
const JSONbigWithoutConfig = /* @__PURE__ */ getDefaultExportFromCjs(jsonBigintExports);
var IntDecoding;
(function(IntDecoding2) {
  IntDecoding2["DEFAULT"] = "default";
  IntDecoding2["SAFE"] = "safe";
  IntDecoding2["MIXED"] = "mixed";
  IntDecoding2["BIGINT"] = "bigint";
})(IntDecoding || (IntDecoding = {}));
JSONbigWithoutConfig({ useNativeBigInt: true, strict: true });
function arrayEqual(a, b2) {
  if (a.length !== b2.length) {
    return false;
  }
  return Array.from(a).every((val, i) => val === b2[i]);
}
function concatArrays(...arrs) {
  const size2 = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c2 = new Uint8Array(size2);
  let offset = 0;
  for (let i = 0; i < arrs.length; i++) {
    c2.set(arrs[i], offset);
    offset += arrs[i].length;
  }
  return c2;
}
function removeUndefinedProperties(obj) {
  const mutableCopy = { ...obj };
  Object.keys(mutableCopy).forEach((key) => {
    if (typeof mutableCopy[key] === "undefined")
      delete mutableCopy[key];
  });
  return mutableCopy;
}
const ALGORAND_ADDRESS_BYTE_LENGTH = 36;
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_ADDRESS_LENGTH = 58;
const ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
buffer.Buffer.from("appID");
const MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
const CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
function decodeAddress(address) {
  if (typeof address !== "string" || address.length !== ALGORAND_ADDRESS_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const decoded = base32.decode.asBytes(address.toString());
  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);
  const pk2 = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  const cs2 = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
  const checksum = genericHash(pk2).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH);
  if (!arrayEqual(checksum, cs2))
    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
  return { publicKey: pk2, checksum: cs2 };
}
function encodeAddress(address) {
  const checksum = genericHash(address).slice(PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, PUBLIC_KEY_LENGTH);
  const addr = base32.encode(concatArrays(address, checksum));
  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH);
}
var msgpack_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    return function(t) {
      var e = {};
      function r(n) {
        if (e[n])
          return e[n].exports;
        var i = e[n] = { i: n, l: false, exports: {} };
        return t[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
      }
      return r.m = t, r.c = e, r.d = function(t3, e2, n) {
        r.o(t3, e2) || Object.defineProperty(t3, e2, { enumerable: true, get: n });
      }, r.r = function(t3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
      }, r.t = function(t3, e2) {
        if (1 & e2 && (t3 = r(t3)), 8 & e2)
          return t3;
        if (4 & e2 && "object" == typeof t3 && t3 && t3.__esModule)
          return t3;
        var n = /* @__PURE__ */ Object.create(null);
        if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t3 }), 2 & e2 && "string" != typeof t3)
          for (var i in t3)
            r.d(n, i, function(e3) {
              return t3[e3];
            }.bind(null, i));
        return n;
      }, r.n = function(t3) {
        var e2 = t3 && t3.__esModule ? function() {
          return t3.default;
        } : function() {
          return t3;
        };
        return r.d(e2, "a", e2), e2;
      }, r.o = function(t3, e2) {
        return Object.prototype.hasOwnProperty.call(t3, e2);
      }, r.p = "", r(r.s = 0);
    }([function(t, e, r) {
      r.r(e), r.d(e, "encode", function() {
        return T2;
      }), r.d(e, "decode", function() {
        return V;
      }), r.d(e, "decodeAsync", function() {
        return Y;
      }), r.d(e, "decodeArrayStream", function() {
        return Z2;
      }), r.d(e, "decodeStream", function() {
        return $;
      }), r.d(e, "Decoder", function() {
        return O2;
      }), r.d(e, "Encoder", function() {
        return I;
      }), r.d(e, "ExtensionCodec", function() {
        return S2;
      }), r.d(e, "ExtData", function() {
        return p2;
      }), r.d(e, "EXT_TIMESTAMP", function() {
        return w;
      }), r.d(e, "encodeDateToTimeSpec", function() {
        return g;
      }), r.d(e, "encodeTimeSpecToTimestamp", function() {
        return v;
      }), r.d(e, "decodeTimestampToTimeSpec", function() {
        return U2;
      }), r.d(e, "encodeTimestampExtension", function() {
        return b2;
      }), r.d(e, "decodeTimestampExtension", function() {
        return m3;
      });
      var n = function(t3, e2) {
        var r2 = "function" == typeof Symbol && t3[Symbol.iterator];
        if (!r2)
          return t3;
        var n2, i2, o2 = r2.call(t3), s3 = [];
        try {
          for (; (void 0 === e2 || e2-- > 0) && !(n2 = o2.next()).done; )
            s3.push(n2.value);
        } catch (t5) {
          i2 = { error: t5 };
        } finally {
          try {
            n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
          } finally {
            if (i2)
              throw i2.error;
          }
        }
        return s3;
      }, i = function() {
        for (var t3 = [], e2 = 0; e2 < arguments.length; e2++)
          t3 = t3.concat(n(arguments[e2]));
        return t3;
      }, o = "undefined" != typeof process && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
      function s2(t3) {
        for (var e2 = t3.length, r2 = 0, n2 = 0; n2 < e2; ) {
          var i2 = t3.charCodeAt(n2++);
          if (0 != (4294967168 & i2))
            if (0 == (4294965248 & i2))
              r2 += 2;
            else {
              if (i2 >= 55296 && i2 <= 56319 && n2 < e2) {
                var o2 = t3.charCodeAt(n2);
                56320 == (64512 & o2) && (++n2, i2 = ((1023 & i2) << 10) + (1023 & o2) + 65536);
              }
              r2 += 0 == (4294901760 & i2) ? 3 : 4;
            }
          else
            r2++;
        }
        return r2;
      }
      var a = o ? new TextEncoder() : void 0, h2 = "undefined" != typeof process ? 200 : 0;
      var u = (null == a ? void 0 : a.encodeInto) ? function(t3, e2, r2) {
        a.encodeInto(t3, e2.subarray(r2));
      } : function(t3, e2, r2) {
        e2.set(a.encode(t3), r2);
      };
      function c2(t3, e2, r2) {
        for (var n2 = e2, o2 = n2 + r2, s3 = [], a2 = ""; n2 < o2; ) {
          var h3 = t3[n2++];
          if (0 == (128 & h3))
            s3.push(h3);
          else if (192 == (224 & h3)) {
            var u2 = 63 & t3[n2++];
            s3.push((31 & h3) << 6 | u2);
          } else if (224 == (240 & h3)) {
            u2 = 63 & t3[n2++];
            var c5 = 63 & t3[n2++];
            s3.push((31 & h3) << 12 | u2 << 6 | c5);
          } else if (240 == (248 & h3)) {
            var f2 = (7 & h3) << 18 | (u2 = 63 & t3[n2++]) << 12 | (c5 = 63 & t3[n2++]) << 6 | 63 & t3[n2++];
            f2 > 65535 && (f2 -= 65536, s3.push(f2 >>> 10 & 1023 | 55296), f2 = 56320 | 1023 & f2), s3.push(f2);
          } else
            s3.push(h3);
          s3.length >= 4096 && (a2 += String.fromCharCode.apply(String, i(s3)), s3.length = 0);
        }
        return s3.length > 0 && (a2 += String.fromCharCode.apply(String, i(s3))), a2;
      }
      var f = o ? new TextDecoder() : null, l = "undefined" != typeof process ? 200 : 0;
      var p2 = function(t3, e2) {
        this.type = t3, this.data = e2;
      };
      function d2(t3, e2, r2) {
        var n2 = Math.floor(r2 / 4294967296), i2 = r2;
        t3.setUint32(e2, n2), t3.setUint32(e2 + 4, i2);
      }
      function y2(t3, e2) {
        var r2 = t3.getInt32(e2), n2 = t3.getUint32(e2 + 4), i2 = r2 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r2 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && 0 === n2, o2 = r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        return i2 || o2 ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2;
      }
      var w = -1;
      function v(t3) {
        var e2 = t3.sec, r2 = t3.nsec;
        if (e2 >= 0 && r2 >= 0 && e2 <= 17179869183) {
          if (0 === r2 && e2 <= 4294967295) {
            var n2 = new Uint8Array(4);
            return (s3 = new DataView(n2.buffer)).setUint32(0, e2), n2;
          }
          var i2 = e2 / 4294967296, o2 = 4294967295 & e2;
          n2 = new Uint8Array(8);
          return (s3 = new DataView(n2.buffer)).setUint32(0, r2 << 2 | 3 & i2), s3.setUint32(4, o2), n2;
        }
        var s3;
        n2 = new Uint8Array(12);
        return (s3 = new DataView(n2.buffer)).setUint32(0, r2), d2(s3, 4, e2), n2;
      }
      function g(t3) {
        var e2 = t3.getTime(), r2 = Math.floor(e2 / 1e3), n2 = 1e6 * (e2 - 1e3 * r2), i2 = Math.floor(n2 / 1e9);
        return { sec: r2 + i2, nsec: n2 - 1e9 * i2 };
      }
      function b2(t3) {
        return t3 instanceof Date ? v(g(t3)) : null;
      }
      function U2(t3) {
        var e2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
        switch (t3.byteLength) {
          case 4:
            return { sec: e2.getUint32(0), nsec: 0 };
          case 8:
            var r2 = e2.getUint32(0);
            return { sec: 4294967296 * (3 & r2) + e2.getUint32(4), nsec: r2 >>> 2 };
          case 12:
            return { sec: y2(e2, 4), nsec: e2.getUint32(0) };
          default:
            throw new Error("Unrecognized data size for timestamp: " + t3.length);
        }
      }
      function m3(t3) {
        var e2 = U2(t3);
        return new Date(1e3 * e2.sec + e2.nsec / 1e6);
      }
      var x = { type: w, encode: b2, decode: m3 }, S2 = function() {
        function t3() {
          this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x);
        }
        return t3.prototype.register = function(t5) {
          var e2 = t5.type, r2 = t5.encode, n2 = t5.decode;
          if (e2 >= 0)
            this.encoders[e2] = r2, this.decoders[e2] = n2;
          else {
            var i2 = 1 + e2;
            this.builtInEncoders[i2] = r2, this.builtInDecoders[i2] = n2;
          }
        }, t3.prototype.tryToEncode = function(t5, e2) {
          for (var r2 = 0; r2 < this.builtInEncoders.length; r2++) {
            if (null != (n2 = this.builtInEncoders[r2])) {
              if (null != (i2 = n2(t5, e2)))
                return new p2(-1 - r2, i2);
            }
          }
          for (r2 = 0; r2 < this.encoders.length; r2++) {
            var n2, i2;
            if (null != (n2 = this.encoders[r2])) {
              if (null != (i2 = n2(t5, e2)))
                return new p2(r2, i2);
            }
          }
          return t5 instanceof p2 ? t5 : null;
        }, t3.prototype.decode = function(t5, e2, r2) {
          var n2 = e2 < 0 ? this.builtInDecoders[-1 - e2] : this.decoders[e2];
          return n2 ? n2(t5, e2, r2) : new p2(e2, t5);
        }, t3.defaultCodec = new t3(), t3;
      }();
      function B(t3) {
        return t3 instanceof Uint8Array ? t3 : ArrayBuffer.isView(t3) ? new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength) : t3 instanceof ArrayBuffer ? new Uint8Array(t3) : Uint8Array.from(t3);
      }
      var E2 = function(t3) {
        var e2 = "function" == typeof Symbol && Symbol.iterator, r2 = e2 && t3[e2], n2 = 0;
        if (r2)
          return r2.call(t3);
        if (t3 && "number" == typeof t3.length)
          return { next: function() {
            return t3 && n2 >= t3.length && (t3 = void 0), { value: t3 && t3[n2++], done: !t3 };
          } };
        throw new TypeError(e2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, I = function() {
        function t3(t5, e2, r2, n2, i2, o2, s3, a2) {
          void 0 === t5 && (t5 = S2.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 100), void 0 === n2 && (n2 = 2048), void 0 === i2 && (i2 = false), void 0 === o2 && (o2 = false), void 0 === s3 && (s3 = false), void 0 === a2 && (a2 = false), this.extensionCodec = t5, this.context = e2, this.maxDepth = r2, this.initialBufferSize = n2, this.sortKeys = i2, this.forceFloat32 = o2, this.ignoreUndefined = s3, this.forceIntegerToFloat = a2, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
        }
        return t3.prototype.getUint8Array = function() {
          return this.bytes.subarray(0, this.pos);
        }, t3.prototype.reinitializeState = function() {
          this.pos = 0;
        }, t3.prototype.encode = function(t5) {
          return this.reinitializeState(), this.doEncode(t5, 1), this.getUint8Array();
        }, t3.prototype.doEncode = function(t5, e2) {
          if (e2 > this.maxDepth)
            throw new Error("Too deep objects in depth " + e2);
          null == t5 ? this.encodeNil() : "boolean" == typeof t5 ? this.encodeBoolean(t5) : "number" == typeof t5 ? this.encodeNumber(t5) : "string" == typeof t5 ? this.encodeString(t5) : "bigint" == typeof t5 ? this.encodebigint(t5) : this.encodeObject(t5, e2);
        }, t3.prototype.ensureBufferSizeToWrite = function(t5) {
          var e2 = this.pos + t5;
          this.view.byteLength < e2 && this.resizeBuffer(2 * e2);
        }, t3.prototype.resizeBuffer = function(t5) {
          var e2 = new ArrayBuffer(t5), r2 = new Uint8Array(e2), n2 = new DataView(e2);
          r2.set(this.bytes), this.view = n2, this.bytes = r2;
        }, t3.prototype.encodeNil = function() {
          this.writeU8(192);
        }, t3.prototype.encodeBoolean = function(t5) {
          false === t5 ? this.writeU8(194) : this.writeU8(195);
        }, t3.prototype.encodeNumber = function(t5) {
          Number.isSafeInteger(t5) && !this.forceIntegerToFloat ? t5 >= 0 ? t5 < 128 ? this.writeU8(t5) : t5 < 256 ? (this.writeU8(204), this.writeU8(t5)) : t5 < 65536 ? (this.writeU8(205), this.writeU16(t5)) : t5 < 4294967296 ? (this.writeU8(206), this.writeU32(t5)) : (this.writeU8(207), this.writeU64(t5)) : t5 >= -32 ? this.writeU8(224 | t5 + 32) : t5 >= -128 ? (this.writeU8(208), this.writeI8(t5)) : t5 >= -32768 ? (this.writeU8(209), this.writeI16(t5)) : t5 >= -2147483648 ? (this.writeU8(210), this.writeI32(t5)) : (this.writeU8(211), this.writeI64(t5)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t5)) : (this.writeU8(203), this.writeF64(t5));
        }, t3.prototype.encodebigint = function(t5) {
          t5 >= BigInt(0) ? t5 < BigInt(128) ? this.writeU8(Number(t5)) : t5 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(t5))) : t5 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(t5))) : t5 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(t5))) : (this.writeU8(207), this.writeBig64(t5)) : t5 >= BigInt(-32) ? this.writeU8(224 | Number(t5) + 32) : t5 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(t5))) : t5 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(t5))) : t5 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(t5))) : (this.writeU8(211), this.writeBig64(t5));
        }, t3.prototype.writeStringHeader = function(t5) {
          if (t5 < 32)
            this.writeU8(160 + t5);
          else if (t5 < 256)
            this.writeU8(217), this.writeU8(t5);
          else if (t5 < 65536)
            this.writeU8(218), this.writeU16(t5);
          else {
            if (!(t5 < 4294967296))
              throw new Error("Too long string: " + t5 + " bytes in UTF-8");
            this.writeU8(219), this.writeU32(t5);
          }
        }, t3.prototype.encodeString = function(t5) {
          var e2 = t5.length;
          if (o && e2 > h2) {
            var r2 = s2(t5);
            this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), u(t5, this.bytes, this.pos), this.pos += r2;
          } else {
            r2 = s2(t5);
            this.ensureBufferSizeToWrite(5 + r2), this.writeStringHeader(r2), function(t7, e3, r3) {
              for (var n2 = t7.length, i2 = r3, o2 = 0; o2 < n2; ) {
                var s3 = t7.charCodeAt(o2++);
                if (0 != (4294967168 & s3)) {
                  if (0 == (4294965248 & s3))
                    e3[i2++] = s3 >> 6 & 31 | 192;
                  else {
                    if (s3 >= 55296 && s3 <= 56319 && o2 < n2) {
                      var a2 = t7.charCodeAt(o2);
                      56320 == (64512 & a2) && (++o2, s3 = ((1023 & s3) << 10) + (1023 & a2) + 65536);
                    }
                    0 == (4294901760 & s3) ? (e3[i2++] = s3 >> 12 & 15 | 224, e3[i2++] = s3 >> 6 & 63 | 128) : (e3[i2++] = s3 >> 18 & 7 | 240, e3[i2++] = s3 >> 12 & 63 | 128, e3[i2++] = s3 >> 6 & 63 | 128);
                  }
                  e3[i2++] = 63 & s3 | 128;
                } else
                  e3[i2++] = s3;
              }
            }(t5, this.bytes, this.pos), this.pos += r2;
          }
        }, t3.prototype.encodeObject = function(t5, e2) {
          var r2 = this.extensionCodec.tryToEncode(t5, this.context);
          if (null != r2)
            this.encodeExtension(r2);
          else if (Array.isArray(t5))
            this.encodeArray(t5, e2);
          else if (ArrayBuffer.isView(t5))
            this.encodeBinary(t5);
          else {
            if ("object" != typeof t5)
              throw new Error("Unrecognized object: " + Object.prototype.toString.apply(t5));
            this.encodeMap(t5, e2);
          }
        }, t3.prototype.encodeBinary = function(t5) {
          var e2 = t5.byteLength;
          if (e2 < 256)
            this.writeU8(196), this.writeU8(e2);
          else if (e2 < 65536)
            this.writeU8(197), this.writeU16(e2);
          else {
            if (!(e2 < 4294967296))
              throw new Error("Too large binary: " + e2);
            this.writeU8(198), this.writeU32(e2);
          }
          var r2 = B(t5);
          this.writeU8a(r2);
        }, t3.prototype.encodeArray = function(t5, e2) {
          var r2, n2, i2 = t5.length;
          if (i2 < 16)
            this.writeU8(144 + i2);
          else if (i2 < 65536)
            this.writeU8(220), this.writeU16(i2);
          else {
            if (!(i2 < 4294967296))
              throw new Error("Too large array: " + i2);
            this.writeU8(221), this.writeU32(i2);
          }
          try {
            for (var o2 = E2(t5), s3 = o2.next(); !s3.done; s3 = o2.next()) {
              var a2 = s3.value;
              this.doEncode(a2, e2 + 1);
            }
          } catch (t7) {
            r2 = { error: t7 };
          } finally {
            try {
              s3 && !s3.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
        }, t3.prototype.countWithoutUndefined = function(t5, e2) {
          var r2, n2, i2 = 0;
          try {
            for (var o2 = E2(e2), s3 = o2.next(); !s3.done; s3 = o2.next()) {
              void 0 !== t5[s3.value] && i2++;
            }
          } catch (t7) {
            r2 = { error: t7 };
          } finally {
            try {
              s3 && !s3.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return i2;
        }, t3.prototype.encodeMap = function(t5, e2) {
          var r2, n2, i2 = Object.keys(t5);
          this.sortKeys && i2.sort();
          var o2 = this.ignoreUndefined ? this.countWithoutUndefined(t5, i2) : i2.length;
          if (o2 < 16)
            this.writeU8(128 + o2);
          else if (o2 < 65536)
            this.writeU8(222), this.writeU16(o2);
          else {
            if (!(o2 < 4294967296))
              throw new Error("Too large map object: " + o2);
            this.writeU8(223), this.writeU32(o2);
          }
          try {
            for (var s3 = E2(i2), a2 = s3.next(); !a2.done; a2 = s3.next()) {
              var h3 = a2.value, u2 = t5[h3];
              this.ignoreUndefined && void 0 === u2 || (this.encodeString(h3), this.doEncode(u2, e2 + 1));
            }
          } catch (t7) {
            r2 = { error: t7 };
          } finally {
            try {
              a2 && !a2.done && (n2 = s3.return) && n2.call(s3);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
        }, t3.prototype.encodeExtension = function(t5) {
          var e2 = t5.data.length;
          if (1 === e2)
            this.writeU8(212);
          else if (2 === e2)
            this.writeU8(213);
          else if (4 === e2)
            this.writeU8(214);
          else if (8 === e2)
            this.writeU8(215);
          else if (16 === e2)
            this.writeU8(216);
          else if (e2 < 256)
            this.writeU8(199), this.writeU8(e2);
          else if (e2 < 65536)
            this.writeU8(200), this.writeU16(e2);
          else {
            if (!(e2 < 4294967296))
              throw new Error("Too large extension object: " + e2);
            this.writeU8(201), this.writeU32(e2);
          }
          this.writeI8(t5.type), this.writeU8a(t5.data);
        }, t3.prototype.writeU8 = function(t5) {
          this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t5), this.pos++;
        }, t3.prototype.writeU8a = function(t5) {
          var e2 = t5.length;
          this.ensureBufferSizeToWrite(e2), this.bytes.set(t5, this.pos), this.pos += e2;
        }, t3.prototype.writeI8 = function(t5) {
          this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t5), this.pos++;
        }, t3.prototype.writeU16 = function(t5) {
          this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t5), this.pos += 2;
        }, t3.prototype.writeI16 = function(t5) {
          this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t5), this.pos += 2;
        }, t3.prototype.writeU32 = function(t5) {
          this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t5), this.pos += 4;
        }, t3.prototype.writeI32 = function(t5) {
          this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t5), this.pos += 4;
        }, t3.prototype.writeF32 = function(t5) {
          this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t5), this.pos += 4;
        }, t3.prototype.writeF64 = function(t5) {
          this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t5), this.pos += 8;
        }, t3.prototype.writeU64 = function(t5) {
          this.ensureBufferSizeToWrite(8), function(t7, e2, r2) {
            var n2 = r2 / 4294967296, i2 = r2;
            t7.setUint32(e2, n2), t7.setUint32(e2 + 4, i2);
          }(this.view, this.pos, t5), this.pos += 8;
        }, t3.prototype.writeI64 = function(t5) {
          this.ensureBufferSizeToWrite(8), d2(this.view, this.pos, t5), this.pos += 8;
        }, t3.prototype.writeBig64 = function(t5) {
          this.ensureBufferSizeToWrite(8), function(t7, e2, r2) {
            var n2 = Number(r2 / BigInt(4294967296)), i2 = Number(r2 % BigInt(4294967296));
            n2 < 0 && 0 !== i2 && (n2 -= 1), t7.setUint32(e2, n2), t7.setUint32(e2 + 4, i2);
          }(this.view, this.pos, t5), this.pos += 8;
        }, t3;
      }(), A2 = {};
      function T2(t3, e2) {
        return void 0 === e2 && (e2 = A2), new I(e2.extensionCodec, e2.context, e2.maxDepth, e2.initialBufferSize, e2.sortKeys, e2.forceFloat32, e2.ignoreUndefined, e2.forceIntegerToFloat).encode(t3);
      }
      function L2(t3) {
        return (t3 < 0 ? "-" : "") + "0x" + Math.abs(t3).toString(16).padStart(2, "0");
      }
      var M = function() {
        function t3(t5, e2) {
          void 0 === t5 && (t5 = 16), void 0 === e2 && (e2 = 16), this.maxKeyLength = t5, this.maxLengthPerKey = e2, this.hit = 0, this.miss = 0, this.caches = [];
          for (var r2 = 0; r2 < this.maxKeyLength; r2++)
            this.caches.push([]);
        }
        return t3.prototype.canBeCached = function(t5) {
          return t5 > 0 && t5 <= this.maxKeyLength;
        }, t3.prototype.get = function(t5, e2, r2) {
          var n2 = this.caches[r2 - 1], i2 = n2.length;
          t:
            for (var o2 = 0; o2 < i2; o2++) {
              for (var s3 = n2[o2], a2 = s3.bytes, h3 = 0; h3 < r2; h3++)
                if (a2[h3] !== t5[e2 + h3])
                  continue t;
              return s3.value;
            }
          return null;
        }, t3.prototype.store = function(t5, e2) {
          var r2 = this.caches[t5.length - 1], n2 = { bytes: t5, value: e2 };
          r2.length >= this.maxLengthPerKey ? r2[Math.random() * r2.length | 0] = n2 : r2.push(n2);
        }, t3.prototype.decode = function(t5, e2, r2) {
          var n2 = this.get(t5, e2, r2);
          if (null != n2)
            return this.hit++, n2;
          this.miss++;
          var i2 = c2(t5, e2, r2), o2 = Uint8Array.prototype.slice.call(t5, e2, e2 + r2);
          return this.store(o2, i2), i2;
        }, t3;
      }(), k2 = function(t3, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, o2) {
          function s3(t5) {
            try {
              h3(n2.next(t5));
            } catch (t7) {
              o2(t7);
            }
          }
          function a2(t5) {
            try {
              h3(n2.throw(t5));
            } catch (t7) {
              o2(t7);
            }
          }
          function h3(t5) {
            var e3;
            t5.done ? i2(t5.value) : (e3 = t5.value, e3 instanceof r2 ? e3 : new r2(function(t7) {
              t7(e3);
            })).then(s3, a2);
          }
          h3((n2 = n2.apply(t3, e2 || [])).next());
        });
      }, z3 = function(t3, e2) {
        var r2, n2, i2, o2, s3 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o5) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (r2 = 1, n2 && (i2 = 2 & o5[0] ? n2.return : o5[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o5[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o5 = [2 & o5[0], i2.value]), o5[0]) {
                    case 0:
                    case 1:
                      i2 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, n2 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s3.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!i2 || o5[1] > i2[0] && o5[1] < i2[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < i2[1]) {
                        s3.label = i2[1], i2 = o5;
                        break;
                      }
                      if (i2 && s3.label < i2[2]) {
                        s3.label = i2[2], s3.ops.push(o5);
                        break;
                      }
                      i2[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = e2.call(t3, s3);
                } catch (t5) {
                  o5 = [6, t5], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }, D2 = function(t3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var e2, r2 = t3[Symbol.asyncIterator];
        return r2 ? r2.call(t3) : (t3 = "function" == typeof __values ? __values(t3) : t3[Symbol.iterator](), e2 = {}, n2("next"), n2("throw"), n2("return"), e2[Symbol.asyncIterator] = function() {
          return this;
        }, e2);
        function n2(r3) {
          e2[r3] = t3[r3] && function(e3) {
            return new Promise(function(n3, i2) {
              (function(t5, e5, r5, n5) {
                Promise.resolve(n5).then(function(e6) {
                  t5({ value: e6, done: r5 });
                }, e5);
              })(n3, i2, (e3 = t3[r3](e3)).done, e3.value);
            });
          };
        }
      }, N3 = function(t3) {
        return this instanceof N3 ? (this.v = t3, this) : new N3(t3);
      }, C2 = function(t3, e2, r2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var n2, i2 = r2.apply(t3, e2 || []), o2 = [];
        return n2 = {}, s3("next"), s3("throw"), s3("return"), n2[Symbol.asyncIterator] = function() {
          return this;
        }, n2;
        function s3(t5) {
          i2[t5] && (n2[t5] = function(e3) {
            return new Promise(function(r3, n3) {
              o2.push([t5, e3, r3, n3]) > 1 || a2(t5, e3);
            });
          });
        }
        function a2(t5, e3) {
          try {
            (r3 = i2[t5](e3)).value instanceof N3 ? Promise.resolve(r3.value.v).then(h3, u2) : c5(o2[0][2], r3);
          } catch (t7) {
            c5(o2[0][3], t7);
          }
          var r3;
        }
        function h3(t5) {
          a2("next", t5);
        }
        function u2(t5) {
          a2("throw", t5);
        }
        function c5(t5, e3) {
          t5(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
        }
      }, P5 = new DataView(new ArrayBuffer(0)), F3 = new Uint8Array(P5.buffer), j3 = function() {
        try {
          P5.getInt8(0);
        } catch (t3) {
          return t3.constructor;
        }
        throw new Error("never reached");
      }(), _2 = new j3("Insufficient data"), W2 = new M(), O2 = function() {
        function t3(t5, e2, r2, n2, i2, o2, s3, a2) {
          void 0 === t5 && (t5 = S2.defaultCodec), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = 4294967295), void 0 === n2 && (n2 = 4294967295), void 0 === i2 && (i2 = 4294967295), void 0 === o2 && (o2 = 4294967295), void 0 === s3 && (s3 = 4294967295), void 0 === a2 && (a2 = W2), this.extensionCodec = t5, this.context = e2, this.maxStrLength = r2, this.maxBinLength = n2, this.maxArrayLength = i2, this.maxMapLength = o2, this.maxExtLength = s3, this.keyDecoder = a2, this.totalPos = 0, this.pos = 0, this.view = P5, this.bytes = F3, this.headByte = -1, this.stack = [];
        }
        return t3.prototype.reinitializeState = function() {
          this.totalPos = 0, this.headByte = -1;
        }, t3.prototype.setBuffer = function(t5) {
          this.bytes = B(t5), this.view = function(t7) {
            if (t7 instanceof ArrayBuffer)
              return new DataView(t7);
            var e2 = B(t7);
            return new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
          }(this.bytes), this.pos = 0;
        }, t3.prototype.appendBuffer = function(t5) {
          if (-1 !== this.headByte || this.hasRemaining()) {
            var e2 = this.bytes.subarray(this.pos), r2 = B(t5), n2 = new Uint8Array(e2.length + r2.length);
            n2.set(e2), n2.set(r2, e2.length), this.setBuffer(n2);
          } else
            this.setBuffer(t5);
        }, t3.prototype.hasRemaining = function(t5) {
          return void 0 === t5 && (t5 = 1), this.view.byteLength - this.pos >= t5;
        }, t3.prototype.createNoExtraBytesError = function(t5) {
          var e2 = this.view, r2 = this.pos;
          return new RangeError("Extra " + (e2.byteLength - r2) + " of " + e2.byteLength + " byte(s) found at buffer[" + t5 + "]");
        }, t3.prototype.decode = function(t5) {
          return this.reinitializeState(), this.setBuffer(t5), this.doDecodeSingleSync();
        }, t3.prototype.doDecodeSingleSync = function() {
          var t5 = this.doDecodeSync();
          if (this.hasRemaining())
            throw this.createNoExtraBytesError(this.pos);
          return t5;
        }, t3.prototype.decodeAsync = function(t5) {
          var e2, r2, n2, i2;
          return k2(this, void 0, void 0, function() {
            var o2, s3, a2, h3, u2, c5, f2, l2;
            return z3(this, function(p3) {
              switch (p3.label) {
                case 0:
                  o2 = false, p3.label = 1;
                case 1:
                  p3.trys.push([1, 6, 7, 12]), e2 = D2(t5), p3.label = 2;
                case 2:
                  return [4, e2.next()];
                case 3:
                  if ((r2 = p3.sent()).done)
                    return [3, 5];
                  if (a2 = r2.value, o2)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(a2);
                  try {
                    s3 = this.doDecodeSync(), o2 = true;
                  } catch (t7) {
                    if (!(t7 instanceof j3))
                      throw t7;
                  }
                  this.totalPos += this.pos, p3.label = 4;
                case 4:
                  return [3, 2];
                case 5:
                  return [3, 12];
                case 6:
                  return h3 = p3.sent(), n2 = { error: h3 }, [3, 12];
                case 7:
                  return p3.trys.push([7, , 10, 11]), r2 && !r2.done && (i2 = e2.return) ? [4, i2.call(e2)] : [3, 9];
                case 8:
                  p3.sent(), p3.label = 9;
                case 9:
                  return [3, 11];
                case 10:
                  if (n2)
                    throw n2.error;
                  return [7];
                case 11:
                  return [7];
                case 12:
                  if (o2) {
                    if (this.hasRemaining())
                      throw this.createNoExtraBytesError(this.totalPos);
                    return [2, s3];
                  }
                  throw c5 = (u2 = this).headByte, f2 = u2.pos, l2 = u2.totalPos, new RangeError("Insufficient data in parcing " + L2(c5) + " at " + l2 + " (" + f2 + " in the current buffer)");
              }
            });
          });
        }, t3.prototype.decodeArrayStream = function(t5) {
          return this.decodeMultiAsync(t5, true);
        }, t3.prototype.decodeStream = function(t5) {
          return this.decodeMultiAsync(t5, false);
        }, t3.prototype.decodeMultiAsync = function(t5, e2) {
          return C2(this, arguments, function() {
            var r2, n2, i2, o2, s3, a2, h3, u2, c5;
            return z3(this, function(f2) {
              switch (f2.label) {
                case 0:
                  r2 = e2, n2 = -1, f2.label = 1;
                case 1:
                  f2.trys.push([1, 13, 14, 19]), i2 = D2(t5), f2.label = 2;
                case 2:
                  return [4, N3(i2.next())];
                case 3:
                  if ((o2 = f2.sent()).done)
                    return [3, 12];
                  if (s3 = o2.value, e2 && 0 === n2)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(s3), r2 && (n2 = this.readArraySize(), r2 = false, this.complete()), f2.label = 4;
                case 4:
                  f2.trys.push([4, 9, , 10]), f2.label = 5;
                case 5:
                  return [4, N3(this.doDecodeSync())];
                case 6:
                  return [4, f2.sent()];
                case 7:
                  return f2.sent(), 0 == --n2 ? [3, 8] : [3, 5];
                case 8:
                  return [3, 10];
                case 9:
                  if (!((a2 = f2.sent()) instanceof j3))
                    throw a2;
                  return [3, 10];
                case 10:
                  this.totalPos += this.pos, f2.label = 11;
                case 11:
                  return [3, 2];
                case 12:
                  return [3, 19];
                case 13:
                  return h3 = f2.sent(), u2 = { error: h3 }, [3, 19];
                case 14:
                  return f2.trys.push([14, , 17, 18]), o2 && !o2.done && (c5 = i2.return) ? [4, N3(c5.call(i2))] : [3, 16];
                case 15:
                  f2.sent(), f2.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  if (u2)
                    throw u2.error;
                  return [7];
                case 18:
                  return [7];
                case 19:
                  return [2];
              }
            });
          });
        }, t3.prototype.doDecodeSync = function() {
          t:
            for (; ; ) {
              var t5 = this.readHeadByte(), e2 = void 0;
              if (t5 >= 224)
                e2 = t5 - 256;
              else if (t5 < 192)
                if (t5 < 128)
                  e2 = t5;
                else if (t5 < 144) {
                  if (0 !== (n2 = t5 - 128)) {
                    this.pushMapState(n2), this.complete();
                    continue t;
                  }
                  e2 = {};
                } else if (t5 < 160) {
                  if (0 !== (n2 = t5 - 144)) {
                    this.pushArrayState(n2), this.complete();
                    continue t;
                  }
                  e2 = [];
                } else {
                  var r2 = t5 - 160;
                  e2 = this.decodeUtf8String(r2, 0);
                }
              else if (192 === t5)
                e2 = null;
              else if (194 === t5)
                e2 = false;
              else if (195 === t5)
                e2 = true;
              else if (202 === t5)
                e2 = this.readF32();
              else if (203 === t5)
                e2 = this.readF64();
              else if (204 === t5)
                e2 = this.readU8();
              else if (205 === t5)
                e2 = this.readU16();
              else if (206 === t5)
                e2 = this.readU32();
              else if (207 === t5)
                e2 = this.readU64();
              else if (208 === t5)
                e2 = this.readI8();
              else if (209 === t5)
                e2 = this.readI16();
              else if (210 === t5)
                e2 = this.readI32();
              else if (211 === t5)
                e2 = this.readI64();
              else if (217 === t5) {
                r2 = this.lookU8();
                e2 = this.decodeUtf8String(r2, 1);
              } else if (218 === t5) {
                r2 = this.lookU16();
                e2 = this.decodeUtf8String(r2, 2);
              } else if (219 === t5) {
                r2 = this.lookU32();
                e2 = this.decodeUtf8String(r2, 4);
              } else if (220 === t5) {
                if (0 !== (n2 = this.readU16())) {
                  this.pushArrayState(n2), this.complete();
                  continue t;
                }
                e2 = [];
              } else if (221 === t5) {
                if (0 !== (n2 = this.readU32())) {
                  this.pushArrayState(n2), this.complete();
                  continue t;
                }
                e2 = [];
              } else if (222 === t5) {
                if (0 !== (n2 = this.readU16())) {
                  this.pushMapState(n2), this.complete();
                  continue t;
                }
                e2 = {};
              } else if (223 === t5) {
                if (0 !== (n2 = this.readU32())) {
                  this.pushMapState(n2), this.complete();
                  continue t;
                }
                e2 = {};
              } else if (196 === t5) {
                var n2 = this.lookU8();
                e2 = this.decodeBinary(n2, 1);
              } else if (197 === t5) {
                n2 = this.lookU16();
                e2 = this.decodeBinary(n2, 2);
              } else if (198 === t5) {
                n2 = this.lookU32();
                e2 = this.decodeBinary(n2, 4);
              } else if (212 === t5)
                e2 = this.decodeExtension(1, 0);
              else if (213 === t5)
                e2 = this.decodeExtension(2, 0);
              else if (214 === t5)
                e2 = this.decodeExtension(4, 0);
              else if (215 === t5)
                e2 = this.decodeExtension(8, 0);
              else if (216 === t5)
                e2 = this.decodeExtension(16, 0);
              else if (199 === t5) {
                n2 = this.lookU8();
                e2 = this.decodeExtension(n2, 1);
              } else if (200 === t5) {
                n2 = this.lookU16();
                e2 = this.decodeExtension(n2, 2);
              } else {
                if (201 !== t5)
                  throw new Error("Unrecognized type byte: " + L2(t5));
                n2 = this.lookU32();
                e2 = this.decodeExtension(n2, 4);
              }
              this.complete();
              for (var i2 = this.stack; i2.length > 0; ) {
                var o2 = i2[i2.length - 1];
                if (0 === o2.type) {
                  if (o2.array[o2.position] = e2, o2.position++, o2.position !== o2.size)
                    continue t;
                  i2.pop(), e2 = o2.array;
                } else {
                  if (1 === o2.type) {
                    if (s3 = void 0, "string" !== (s3 = typeof e2) && "number" !== s3)
                      throw new Error("The type of key must be string or number but " + typeof e2);
                    o2.key = e2, o2.type = 2;
                    continue t;
                  }
                  if (o2.map[o2.key] = e2, o2.readCount++, o2.readCount !== o2.size) {
                    o2.key = null, o2.type = 1;
                    continue t;
                  }
                  i2.pop(), e2 = o2.map;
                }
              }
              return e2;
            }
          var s3;
        }, t3.prototype.readHeadByte = function() {
          return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
        }, t3.prototype.complete = function() {
          this.headByte = -1;
        }, t3.prototype.readArraySize = function() {
          var t5 = this.readHeadByte();
          switch (t5) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default:
              if (t5 < 160)
                return t5 - 144;
              throw new Error("Unrecognized array type byte: " + L2(t5));
          }
        }, t3.prototype.pushMapState = function(t5) {
          if (t5 > this.maxMapLength)
            throw new Error("Max length exceeded: map length (" + t5 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
          this.stack.push({ type: 1, size: t5, key: null, readCount: 0, map: {} });
        }, t3.prototype.pushArrayState = function(t5) {
          if (t5 > this.maxArrayLength)
            throw new Error("Max length exceeded: array length (" + t5 + ") > maxArrayLength (" + this.maxArrayLength + ")");
          this.stack.push({ type: 0, size: t5, array: new Array(t5), position: 0 });
        }, t3.prototype.decodeUtf8String = function(t5, e2) {
          var r2;
          if (t5 > this.maxStrLength)
            throw new Error("Max length exceeded: UTF-8 byte length (" + t5 + ") > maxStrLength (" + this.maxStrLength + ")");
          if (this.bytes.byteLength < this.pos + e2 + t5)
            throw _2;
          var n2, i2 = this.pos + e2;
          return n2 = this.stateIsMapKey() && (null === (r2 = this.keyDecoder) || void 0 === r2 ? void 0 : r2.canBeCached(t5)) ? this.keyDecoder.decode(this.bytes, i2, t5) : o && t5 > l ? function(t7, e3, r3) {
            var n3 = t7.subarray(e3, e3 + r3);
            return f.decode(n3);
          }(this.bytes, i2, t5) : c2(this.bytes, i2, t5), this.pos += e2 + t5, n2;
        }, t3.prototype.stateIsMapKey = function() {
          return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
        }, t3.prototype.decodeBinary = function(t5, e2) {
          if (t5 > this.maxBinLength)
            throw new Error("Max length exceeded: bin length (" + t5 + ") > maxBinLength (" + this.maxBinLength + ")");
          if (!this.hasRemaining(t5 + e2))
            throw _2;
          var r2 = this.pos + e2, n2 = this.bytes.subarray(r2, r2 + t5);
          return this.pos += e2 + t5, n2;
        }, t3.prototype.decodeExtension = function(t5, e2) {
          if (t5 > this.maxExtLength)
            throw new Error("Max length exceeded: ext length (" + t5 + ") > maxExtLength (" + this.maxExtLength + ")");
          var r2 = this.view.getInt8(this.pos + e2), n2 = this.decodeBinary(t5, e2 + 1);
          return this.extensionCodec.decode(n2, r2, this.context);
        }, t3.prototype.lookU8 = function() {
          return this.view.getUint8(this.pos);
        }, t3.prototype.lookU16 = function() {
          return this.view.getUint16(this.pos);
        }, t3.prototype.lookU32 = function() {
          return this.view.getUint32(this.pos);
        }, t3.prototype.readU8 = function() {
          var t5 = this.view.getUint8(this.pos);
          return this.pos++, t5;
        }, t3.prototype.readI8 = function() {
          var t5 = this.view.getInt8(this.pos);
          return this.pos++, t5;
        }, t3.prototype.readU16 = function() {
          var t5 = this.view.getUint16(this.pos);
          return this.pos += 2, t5;
        }, t3.prototype.readI16 = function() {
          var t5 = this.view.getInt16(this.pos);
          return this.pos += 2, t5;
        }, t3.prototype.readU32 = function() {
          var t5 = this.view.getUint32(this.pos);
          return this.pos += 4, t5;
        }, t3.prototype.readI32 = function() {
          var t5 = this.view.getInt32(this.pos);
          return this.pos += 4, t5;
        }, t3.prototype.readU64 = function() {
          var t5, e2, r2, n2, i2 = (t5 = this.view, e2 = this.pos, r2 = t5.getUint32(e2), n2 = t5.getUint32(e2 + 4), r2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r2) * BigInt(4294967296) + BigInt(n2) : 4294967296 * r2 + n2);
          return this.pos += 8, i2;
        }, t3.prototype.readI64 = function() {
          var t5 = y2(this.view, this.pos);
          return this.pos += 8, t5;
        }, t3.prototype.readF32 = function() {
          var t5 = this.view.getFloat32(this.pos);
          return this.pos += 4, t5;
        }, t3.prototype.readF64 = function() {
          var t5 = this.view.getFloat64(this.pos);
          return this.pos += 8, t5;
        }, t3;
      }(), R3 = {};
      function V(t3, e2) {
        return void 0 === e2 && (e2 = R3), new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decode(t3);
      }
      var K5 = function(t3, e2) {
        var r2, n2, i2, o2, s3 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o5) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (r2 = 1, n2 && (i2 = 2 & o5[0] ? n2.return : o5[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o5[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o5 = [2 & o5[0], i2.value]), o5[0]) {
                    case 0:
                    case 1:
                      i2 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, n2 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s3.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!i2 || o5[1] > i2[0] && o5[1] < i2[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < i2[1]) {
                        s3.label = i2[1], i2 = o5;
                        break;
                      }
                      if (i2 && s3.label < i2[2]) {
                        s3.label = i2[2], s3.ops.push(o5);
                        break;
                      }
                      i2[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = e2.call(t3, s3);
                } catch (t5) {
                  o5 = [6, t5], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }, G2 = function(t3) {
        return this instanceof G2 ? (this.v = t3, this) : new G2(t3);
      }, H2 = function(t3, e2, r2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var n2, i2 = r2.apply(t3, e2 || []), o2 = [];
        return n2 = {}, s3("next"), s3("throw"), s3("return"), n2[Symbol.asyncIterator] = function() {
          return this;
        }, n2;
        function s3(t5) {
          i2[t5] && (n2[t5] = function(e3) {
            return new Promise(function(r3, n3) {
              o2.push([t5, e3, r3, n3]) > 1 || a2(t5, e3);
            });
          });
        }
        function a2(t5, e3) {
          try {
            (r3 = i2[t5](e3)).value instanceof G2 ? Promise.resolve(r3.value.v).then(h3, u2) : c5(o2[0][2], r3);
          } catch (t7) {
            c5(o2[0][3], t7);
          }
          var r3;
        }
        function h3(t5) {
          a2("next", t5);
        }
        function u2(t5) {
          a2("throw", t5);
        }
        function c5(t5, e3) {
          t5(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
        }
      };
      function X2(t3) {
        if (null == t3)
          throw new Error("Assertion Failure: value must not be null nor undefined");
      }
      function q2(t3) {
        return null != t3[Symbol.asyncIterator] ? t3 : function(t5) {
          return H2(this, arguments, function() {
            var e2, r2, n2, i2;
            return K5(this, function(o2) {
              switch (o2.label) {
                case 0:
                  e2 = t5.getReader(), o2.label = 1;
                case 1:
                  o2.trys.push([1, , 9, 10]), o2.label = 2;
                case 2:
                  return [4, G2(e2.read())];
                case 3:
                  return r2 = o2.sent(), n2 = r2.done, i2 = r2.value, n2 ? [4, G2(void 0)] : [3, 5];
                case 4:
                  return [2, o2.sent()];
                case 5:
                  return X2(i2), [4, G2(i2)];
                case 6:
                  return [4, o2.sent()];
                case 7:
                  return o2.sent(), [3, 2];
                case 8:
                  return [3, 10];
                case 9:
                  return e2.releaseLock(), [7];
                case 10:
                  return [2];
              }
            });
          });
        }(t3);
      }
      var J2 = function(t3, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, o2) {
          function s3(t5) {
            try {
              h3(n2.next(t5));
            } catch (t7) {
              o2(t7);
            }
          }
          function a2(t5) {
            try {
              h3(n2.throw(t5));
            } catch (t7) {
              o2(t7);
            }
          }
          function h3(t5) {
            var e3;
            t5.done ? i2(t5.value) : (e3 = t5.value, e3 instanceof r2 ? e3 : new r2(function(t7) {
              t7(e3);
            })).then(s3, a2);
          }
          h3((n2 = n2.apply(t3, e2 || [])).next());
        });
      }, Q = function(t3, e2) {
        var r2, n2, i2, o2, s3 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o5) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (r2 = 1, n2 && (i2 = 2 & o5[0] ? n2.return : o5[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o5[1])).done)
                    return i2;
                  switch (n2 = 0, i2 && (o5 = [2 & o5[0], i2.value]), o5[0]) {
                    case 0:
                    case 1:
                      i2 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, n2 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s3.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!i2 || o5[1] > i2[0] && o5[1] < i2[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < i2[1]) {
                        s3.label = i2[1], i2 = o5;
                        break;
                      }
                      if (i2 && s3.label < i2[2]) {
                        s3.label = i2[2], s3.ops.push(o5);
                        break;
                      }
                      i2[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = e2.call(t3, s3);
                } catch (t5) {
                  o5 = [6, t5], n2 = 0;
                } finally {
                  r2 = i2 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      };
      function Y(t3, e2) {
        return void 0 === e2 && (e2 = R3), J2(this, void 0, void 0, function() {
          var r2;
          return Q(this, function(n2) {
            return r2 = q2(t3), [2, new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeAsync(r2)];
          });
        });
      }
      function Z2(t3, e2) {
        void 0 === e2 && (e2 = R3);
        var r2 = q2(t3);
        return new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeArrayStream(r2);
      }
      function $(t3, e2) {
        void 0 === e2 && (e2 = R3);
        var r2 = q2(t3);
        return new O2(e2.extensionCodec, e2.context, e2.maxStrLength, e2.maxBinLength, e2.maxArrayLength, e2.maxMapLength, e2.maxExtLength).decodeStream(r2);
      }
    }]);
  });
})(msgpack_min);
var msgpack_minExports = msgpack_min.exports;
const ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function containsEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0) {
        return { containsEmpty: true, firstEmptyKey: key };
      }
    }
  }
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function rawEncode(obj) {
  const options = { sortKeys: true };
  return msgpack_minExports.encode(obj, options);
}
function encode(obj) {
  const emptyCheck = containsEmpty(obj);
  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  }
  return rawEncode(obj);
}
function decode(buffer2) {
  return msgpack_minExports.decode(buffer2);
}
function translateBoxReference(reference, foreignApps, appIndex) {
  const referenceId = reference.appIndex;
  const referenceName = reference.name;
  const isOwnReference = referenceId === 0 || referenceId === appIndex;
  let index2 = 0;
  if (foreignApps != null) {
    index2 = foreignApps.indexOf(referenceId) + 1;
  }
  if (index2 === 0 && !isOwnReference) {
    throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
  }
  return { i: index2, n: referenceName };
}
function translateBoxReferences(references, foreignApps, appIndex) {
  if (references == null)
    return [];
  return references.map((bx) => translateBoxReference(bx, foreignApps, appIndex));
}
var TransactionType;
(function(TransactionType2) {
  TransactionType2["pay"] = "pay";
  TransactionType2["keyreg"] = "keyreg";
  TransactionType2["acfg"] = "acfg";
  TransactionType2["axfer"] = "axfer";
  TransactionType2["afrz"] = "afrz";
  TransactionType2["appl"] = "appl";
  TransactionType2["stpf"] = "stpf";
})(TransactionType || (TransactionType = {}));
function isTransactionType(s2) {
  return s2 === TransactionType.pay || s2 === TransactionType.keyreg || s2 === TransactionType.acfg || s2 === TransactionType.axfer || s2 === TransactionType.afrz || s2 === TransactionType.appl || s2 === TransactionType.stpf;
}
var OnApplicationComplete;
(function(OnApplicationComplete2) {
  OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
  OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
  OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
  OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
  OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
  OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
})(OnApplicationComplete || (OnApplicationComplete = {}));
const ALGORAND_TRANSACTION_LENGTH = 52;
const ALGORAND_MIN_TX_FEE = 1e3;
const ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
const ALGORAND_MAX_ASSET_DECIMALS = 19;
const NUM_ADDL_BYTES_AFTER_SIGNING = 75;
const ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH = 5;
const ALGORAND_TRANSACTION_ADDRESS_LENGTH = 32;
const ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH = 5;
const ASSET_METADATA_HASH_LENGTH = 32;
const KEYREG_VOTE_KEY_LENGTH = 32;
const KEYREG_SELECTION_KEY_LENGTH = 32;
const KEYREG_STATE_PROOF_KEY_LENGTH = 64;
function getKeyregKey(input, inputName, length) {
  if (input == null) {
    return void 0;
  }
  let inputAsBuffer;
  if (typeof input === "string") {
    inputAsBuffer = buffer.Buffer.from(input, "base64");
  } else if (input.constructor === Uint8Array) {
    inputAsBuffer = buffer.Buffer.from(input);
  } else if (buffer.Buffer.isBuffer(input)) {
    inputAsBuffer = input;
  }
  if (inputAsBuffer == null || inputAsBuffer.byteLength !== length) {
    throw Error(`${inputName} must be a ${length} byte Uint8Array or Buffer or base64 string.`);
  }
  return inputAsBuffer;
}
class Transaction {
  constructor({ ...transaction }) {
    this.name = "Transaction";
    this.tag = buffer.Buffer.from("TX");
    const defaults = {
      type: TransactionType.pay,
      flatFee: false,
      nonParticipation: false
    };
    if (typeof transaction.type === "undefined") {
      transaction.type = defaults.type;
    }
    if (typeof transaction.flatFee === "undefined") {
      transaction.flatFee = defaults.flatFee;
    }
    if (transaction.type === TransactionType.keyreg && typeof transaction.voteKey !== "undefined" && typeof transaction.nonParticipation === "undefined") {
      transaction.nonParticipation = defaults.nonParticipation;
    }
    if (transaction.suggestedParams !== void 0) {
      const reference = transaction;
      reference.genesisHash = reference.suggestedParams.genesisHash;
      reference.fee = reference.suggestedParams.fee;
      if (reference.suggestedParams.flatFee !== void 0)
        reference.flatFee = reference.suggestedParams.flatFee;
      reference.firstRound = reference.suggestedParams.firstRound;
      reference.lastRound = reference.suggestedParams.lastRound;
      reference.genesisID = reference.suggestedParams.genesisID;
    }
    const txn = transaction;
    txn.from = decodeAddress(txn.from);
    if (txn.to !== void 0)
      txn.to = decodeAddress(txn.to);
    if (txn.closeRemainderTo !== void 0)
      txn.closeRemainderTo = decodeAddress(txn.closeRemainderTo);
    if (txn.assetManager !== void 0)
      txn.assetManager = decodeAddress(txn.assetManager);
    if (txn.assetReserve !== void 0)
      txn.assetReserve = decodeAddress(txn.assetReserve);
    if (txn.assetFreeze !== void 0)
      txn.assetFreeze = decodeAddress(txn.assetFreeze);
    if (txn.assetClawback !== void 0)
      txn.assetClawback = decodeAddress(txn.assetClawback);
    if (txn.assetRevocationTarget !== void 0)
      txn.assetRevocationTarget = decodeAddress(txn.assetRevocationTarget);
    if (txn.freezeAccount !== void 0)
      txn.freezeAccount = decodeAddress(txn.freezeAccount);
    if (txn.reKeyTo !== void 0)
      txn.reKeyTo = decodeAddress(txn.reKeyTo);
    if (txn.genesisHash === void 0)
      throw Error("genesis hash must be specified and in a base64 string.");
    txn.genesisHash = buffer.Buffer.from(txn.genesisHash, "base64");
    if (txn.amount !== void 0 && (!(Number.isSafeInteger(txn.amount) || typeof txn.amount === "bigint" && txn.amount <= BigInt("0xffffffffffffffff")) || txn.amount < 0))
      throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (!Number.isSafeInteger(txn.fee) || txn.fee < 0)
      throw Error("fee must be a positive number and smaller than 2^53-1");
    if (!Number.isSafeInteger(txn.firstRound) || txn.firstRound < 0)
      throw Error("firstRound must be a positive number");
    if (!Number.isSafeInteger(txn.lastRound) || txn.lastRound < 0)
      throw Error("lastRound must be a positive number");
    if (txn.extraPages !== void 0 && (!Number.isInteger(txn.extraPages) || txn.extraPages < 0 || txn.extraPages > 3))
      throw Error("extraPages must be an Integer between and including 0 to 3");
    if (txn.assetTotal !== void 0 && (!(Number.isSafeInteger(txn.assetTotal) || typeof txn.assetTotal === "bigint" && txn.assetTotal <= BigInt("0xffffffffffffffff")) || txn.assetTotal < 0))
      throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (txn.assetDecimals !== void 0 && (!Number.isSafeInteger(txn.assetDecimals) || txn.assetDecimals < 0 || txn.assetDecimals > ALGORAND_MAX_ASSET_DECIMALS))
      throw Error(`assetDecimals must be a positive number and smaller than ${ALGORAND_MAX_ASSET_DECIMALS.toString()}`);
    if (txn.assetIndex !== void 0 && (!Number.isSafeInteger(txn.assetIndex) || txn.assetIndex < 0))
      throw Error("Asset index must be a positive number and smaller than 2^53-1");
    if (txn.appIndex !== void 0 && (!Number.isSafeInteger(txn.appIndex) || txn.appIndex < 0))
      throw Error("Application index must be a positive number and smaller than 2^53-1");
    if (txn.appLocalInts !== void 0 && (!Number.isSafeInteger(txn.appLocalInts) || txn.appLocalInts < 0))
      throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
    if (txn.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appLocalByteSlices) || txn.appLocalByteSlices < 0))
      throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalInts !== void 0 && (!Number.isSafeInteger(txn.appGlobalInts) || txn.appGlobalInts < 0))
      throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
    if (txn.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appGlobalByteSlices) || txn.appGlobalByteSlices < 0))
      throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
    if (txn.appApprovalProgram !== void 0) {
      if (txn.appApprovalProgram.constructor !== Uint8Array)
        throw Error("appApprovalProgram must be a Uint8Array.");
    }
    if (txn.appClearProgram !== void 0) {
      if (txn.appClearProgram.constructor !== Uint8Array)
        throw Error("appClearProgram must be a Uint8Array.");
    }
    if (txn.appArgs !== void 0) {
      if (!Array.isArray(txn.appArgs))
        throw Error("appArgs must be an Array of Uint8Array.");
      txn.appArgs = txn.appArgs.slice();
      txn.appArgs.forEach((arg) => {
        if (arg.constructor !== Uint8Array)
          throw Error("each element of AppArgs must be a Uint8Array.");
      });
    } else {
      txn.appArgs = [];
    }
    if (txn.appAccounts !== void 0) {
      if (!Array.isArray(txn.appAccounts))
        throw Error("appAccounts must be an Array of addresses.");
      txn.appAccounts = txn.appAccounts.map((addressAsString) => decodeAddress(addressAsString));
    }
    if (txn.appForeignApps !== void 0) {
      if (!Array.isArray(txn.appForeignApps))
        throw Error("appForeignApps must be an Array of integers.");
      txn.appForeignApps = txn.appForeignApps.slice();
      txn.appForeignApps.forEach((foreignAppIndex) => {
        if (!Number.isSafeInteger(foreignAppIndex) || foreignAppIndex < 0)
          throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.appForeignAssets !== void 0) {
      if (!Array.isArray(txn.appForeignAssets))
        throw Error("appForeignAssets must be an Array of integers.");
      txn.appForeignAssets = txn.appForeignAssets.slice();
      txn.appForeignAssets.forEach((foreignAssetIndex) => {
        if (!Number.isSafeInteger(foreignAssetIndex) || foreignAssetIndex < 0)
          throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
      });
    }
    if (txn.boxes !== void 0) {
      if (!Array.isArray(txn.boxes))
        throw Error("boxes must be an Array of BoxReference.");
      txn.boxes = txn.boxes.slice();
      txn.boxes.forEach((box) => {
        if (!Number.isSafeInteger(box.appIndex) || box.name.constructor !== Uint8Array)
          throw Error("box app index must be a number and name must be an Uint8Array.");
      });
    }
    if (txn.assetMetadataHash !== void 0 && txn.assetMetadataHash.length !== 0) {
      if (typeof txn.assetMetadataHash === "string") {
        txn.assetMetadataHash = new Uint8Array(buffer.Buffer.from(txn.assetMetadataHash));
      }
      if (txn.assetMetadataHash.constructor !== Uint8Array || txn.assetMetadataHash.byteLength !== ASSET_METADATA_HASH_LENGTH) {
        throw Error(`assetMetadataHash must be a ${ASSET_METADATA_HASH_LENGTH} byte Uint8Array or string.`);
      }
      if (txn.assetMetadataHash.every((value) => value === 0)) {
        txn.assetMetadataHash = void 0;
      }
    } else {
      txn.assetMetadataHash = void 0;
    }
    if (txn.note !== void 0) {
      if (txn.note.constructor !== Uint8Array)
        throw Error("note must be a Uint8Array.");
    } else {
      txn.note = new Uint8Array(0);
    }
    if (txn.lease !== void 0) {
      if (txn.lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (txn.lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      if (txn.lease.every((value) => value === 0)) {
        txn.lease = new Uint8Array(0);
      }
    } else {
      txn.lease = new Uint8Array(0);
    }
    txn.voteKey = getKeyregKey(txn.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH);
    txn.selectionKey = getKeyregKey(txn.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH);
    txn.stateProofKey = getKeyregKey(txn.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH);
    if (txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.stateProofKey || txn.voteLast || txn.voteKeyDilution)) {
      throw new Error("nonParticipation is true but participation params are present.");
    }
    if (!txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.stateProofKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution) && !(txn.voteKey && txn.selectionKey && txn.voteFirst && txn.voteLast && txn.voteKeyDilution)) {
      throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
    }
    delete txn.suggestedParams;
    Object.assign(this, removeUndefinedProperties(txn));
    if (!txn.flatFee) {
      this.fee *= this.estimateSize();
      if (this.fee < ALGORAND_MIN_TX_FEE) {
        this.fee = ALGORAND_MIN_TX_FEE;
      }
    }
    this.group = void 0;
    if (txn.stateProofType !== void 0 && (!Number.isSafeInteger(txn.stateProofType) || txn.stateProofType < 0))
      throw Error("State Proof type must be a positive number and smaller than 2^53-1");
    if (txn.stateProofMessage !== void 0) {
      if (txn.stateProofMessage.constructor !== Uint8Array)
        throw Error("stateProofMessage must be a Uint8Array.");
    } else {
      txn.stateProofMessage = new Uint8Array(0);
    }
    if (txn.stateProof !== void 0) {
      if (txn.stateProof.constructor !== Uint8Array)
        throw Error("stateProof must be a Uint8Array.");
    } else {
      txn.stateProof = new Uint8Array(0);
    }
  }
  // eslint-disable-next-line camelcase
  get_obj_for_encoding() {
    if (this.type === "pay") {
      const txn = {
        amt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: "pay",
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group
      };
      if (this.closeRemainderTo !== void 0 && encodeAddress(this.closeRemainderTo.publicKey) !== ALGORAND_ZERO_ADDRESS_STRING) {
        txn.close = buffer.Buffer.from(this.closeRemainderTo.publicKey);
      }
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.to !== void 0)
        txn.rcv = buffer.Buffer.from(this.to.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.rekey)
        delete txn.rekey;
      return txn;
    }
    if (this.type === "keyreg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        votekey: this.voteKey,
        selkey: this.selectionKey,
        sprfkey: this.stateProofKey,
        votefst: this.voteFirst,
        votelst: this.voteLast,
        votekd: this.voteKeyDilution
      };
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.nonParticipation) {
        txn.nonpart = true;
      }
      if (!txn.selkey)
        delete txn.selkey;
      if (!txn.votekey)
        delete txn.votekey;
      if (!txn.sprfkey)
        delete txn.sprfkey;
      if (!txn.votefst)
        delete txn.votefst;
      if (!txn.votelst)
        delete txn.votelst;
      if (!txn.votekd)
        delete txn.votekd;
      return txn;
    }
    if (this.type === "acfg") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        caid: this.assetIndex,
        apar: {
          t: this.assetTotal,
          df: this.assetDefaultFrozen,
          dc: this.assetDecimals
        }
      };
      if (this.assetManager !== void 0)
        txn.apar.m = buffer.Buffer.from(this.assetManager.publicKey);
      if (this.assetReserve !== void 0)
        txn.apar.r = buffer.Buffer.from(this.assetReserve.publicKey);
      if (this.assetFreeze !== void 0)
        txn.apar.f = buffer.Buffer.from(this.assetFreeze.publicKey);
      if (this.assetClawback !== void 0)
        txn.apar.c = buffer.Buffer.from(this.assetClawback.publicKey);
      if (this.assetName !== void 0)
        txn.apar.an = this.assetName;
      if (this.assetUnitName !== void 0)
        txn.apar.un = this.assetUnitName;
      if (this.assetURL !== void 0)
        txn.apar.au = this.assetURL;
      if (this.assetMetadataHash !== void 0)
        txn.apar.am = buffer.Buffer.from(this.assetMetadataHash);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (!txn.caid)
        delete txn.caid;
      if (!txn.apar.t && !txn.apar.un && !txn.apar.an && !txn.apar.df && !txn.apar.m && !txn.apar.r && !txn.apar.f && !txn.apar.c && !txn.apar.au && !txn.apar.am && !txn.apar.dc) {
        delete txn.apar;
      } else {
        if (!txn.apar.t)
          delete txn.apar.t;
        if (!txn.apar.dc)
          delete txn.apar.dc;
        if (!txn.apar.un)
          delete txn.apar.un;
        if (!txn.apar.an)
          delete txn.apar.an;
        if (!txn.apar.df)
          delete txn.apar.df;
        if (!txn.apar.m)
          delete txn.apar.m;
        if (!txn.apar.r)
          delete txn.apar.r;
        if (!txn.apar.f)
          delete txn.apar.f;
        if (!txn.apar.c)
          delete txn.apar.c;
        if (!txn.apar.au)
          delete txn.apar.au;
        if (!txn.apar.am)
          delete txn.apar.am;
      }
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "axfer") {
      const txn = {
        aamt: this.amount,
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        arcv: buffer.Buffer.from(this.to.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        xaid: this.assetIndex
      };
      if (this.closeRemainderTo !== void 0)
        txn.aclose = buffer.Buffer.from(this.closeRemainderTo.publicKey);
      if (this.assetRevocationTarget !== void 0)
        txn.asnd = buffer.Buffer.from(this.assetRevocationTarget.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.aamt)
        delete txn.aamt;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (txn.grp === void 0)
        delete txn.grp;
      if (!txn.aclose)
        delete txn.aclose;
      if (!txn.asnd)
        delete txn.asnd;
      if (!txn.rekey)
        delete txn.rekey;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "afrz") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        faid: this.assetIndex,
        afrz: this.freezeState
      };
      if (this.freezeAccount !== void 0)
        txn.fadd = buffer.Buffer.from(this.freezeAccount.publicKey);
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.afrz)
        delete txn.afrz;
      if (txn.grp === void 0)
        delete txn.grp;
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      return txn;
    }
    if (this.type === "appl") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        grp: this.group,
        apid: this.appIndex,
        apan: this.appOnComplete,
        apls: {
          nui: this.appLocalInts,
          nbs: this.appLocalByteSlices
        },
        apgs: {
          nui: this.appGlobalInts,
          nbs: this.appGlobalByteSlices
        },
        apfa: this.appForeignApps,
        apas: this.appForeignAssets,
        apep: this.extraPages,
        apbx: translateBoxReferences(this.boxes, this.appForeignApps, this.appIndex)
      };
      if (this.reKeyTo !== void 0) {
        txn.rekey = buffer.Buffer.from(this.reKeyTo.publicKey);
      }
      if (this.appApprovalProgram !== void 0) {
        txn.apap = buffer.Buffer.from(this.appApprovalProgram);
      }
      if (this.appClearProgram !== void 0) {
        txn.apsu = buffer.Buffer.from(this.appClearProgram);
      }
      if (this.appArgs !== void 0) {
        txn.apaa = this.appArgs.map((arg) => buffer.Buffer.from(arg));
      }
      if (this.appAccounts !== void 0) {
        txn.apat = this.appAccounts.map((decodedAddress) => buffer.Buffer.from(decodedAddress.publicKey));
      }
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apls.nui)
        delete txn.apls.nui;
      if (!txn.apls.nbs)
        delete txn.apls.nbs;
      if (!txn.apls.nui && !txn.apls.nbs)
        delete txn.apls;
      if (!txn.apgs.nui)
        delete txn.apgs.nui;
      if (!txn.apgs.nbs)
        delete txn.apgs.nbs;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apgs.nui && !txn.apgs.nbs)
        delete txn.apgs;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      for (const box of txn.apbx) {
        if (!box.i)
          delete box.i;
        if (!box.n || !box.n.length)
          delete box.n;
      }
      if (!txn.apbx || !txn.apbx.length)
        delete txn.apbx;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    if (this.type === "stpf") {
      const txn = {
        fee: this.fee,
        fv: this.firstRound,
        lv: this.lastRound,
        note: buffer.Buffer.from(this.note),
        snd: buffer.Buffer.from(this.from.publicKey),
        type: this.type,
        gen: this.genesisID,
        gh: this.genesisHash,
        lx: buffer.Buffer.from(this.lease),
        sptype: this.stateProofType,
        spmsg: buffer.Buffer.from(this.stateProofMessage),
        sp: buffer.Buffer.from(this.stateProof)
      };
      if (!txn.sptype)
        delete txn.sptype;
      if (!txn.note.length)
        delete txn.note;
      if (!txn.lx.length)
        delete txn.lx;
      if (!txn.amt)
        delete txn.amt;
      if (!txn.fee)
        delete txn.fee;
      if (!txn.fv)
        delete txn.fv;
      if (!txn.gen)
        delete txn.gen;
      if (!txn.apid)
        delete txn.apid;
      if (!txn.apaa || !txn.apaa.length)
        delete txn.apaa;
      if (!txn.apap)
        delete txn.apap;
      if (!txn.apsu)
        delete txn.apsu;
      if (!txn.apan)
        delete txn.apan;
      if (!txn.apfa || !txn.apfa.length)
        delete txn.apfa;
      if (!txn.apas || !txn.apas.length)
        delete txn.apas;
      if (!txn.apat || !txn.apat.length)
        delete txn.apat;
      if (!txn.apep)
        delete txn.apep;
      if (txn.grp === void 0)
        delete txn.grp;
      return txn;
    }
    return void 0;
  }
  // eslint-disable-next-line camelcase
  static from_obj_for_encoding(txnForEnc) {
    const txn = Object.create(this.prototype);
    txn.name = "Transaction";
    txn.tag = buffer.Buffer.from("TX");
    txn.genesisID = txnForEnc.gen;
    txn.genesisHash = buffer.Buffer.from(txnForEnc.gh);
    if (!isTransactionType(txnForEnc.type)) {
      throw new Error(`Unrecognized transaction type: ${txnForEnc.type}`);
    }
    txn.type = txnForEnc.type;
    txn.fee = txnForEnc.fee;
    txn.firstRound = txnForEnc.fv;
    txn.lastRound = txnForEnc.lv;
    txn.note = new Uint8Array(txnForEnc.note);
    txn.lease = new Uint8Array(txnForEnc.lx);
    txn.from = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.snd)));
    if (txnForEnc.grp !== void 0)
      txn.group = buffer.Buffer.from(txnForEnc.grp);
    if (txnForEnc.rekey !== void 0)
      txn.reKeyTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rekey)));
    if (txnForEnc.type === "pay") {
      txn.amount = txnForEnc.amt;
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.rcv)));
      if (txnForEnc.close !== void 0)
        txn.closeRemainderTo = decodeAddress(encodeAddress(txnForEnc.close));
    } else if (txnForEnc.type === "keyreg") {
      if (txnForEnc.votekey !== void 0) {
        txn.voteKey = buffer.Buffer.from(txnForEnc.votekey);
      }
      if (txnForEnc.selkey !== void 0) {
        txn.selectionKey = buffer.Buffer.from(txnForEnc.selkey);
      }
      if (txnForEnc.sprfkey !== void 0) {
        txn.stateProofKey = buffer.Buffer.from(txnForEnc.sprfkey);
      }
      if (txnForEnc.votekd !== void 0) {
        txn.voteKeyDilution = txnForEnc.votekd;
      }
      if (txnForEnc.votefst !== void 0) {
        txn.voteFirst = txnForEnc.votefst;
      }
      if (txnForEnc.votelst !== void 0) {
        txn.voteLast = txnForEnc.votelst;
      }
      if (txnForEnc.nonpart !== void 0) {
        txn.nonParticipation = txnForEnc.nonpart;
      }
    } else if (txnForEnc.type === "acfg") {
      if (txnForEnc.caid !== void 0) {
        txn.assetIndex = txnForEnc.caid;
      }
      if (txnForEnc.apar !== void 0) {
        txn.assetTotal = txnForEnc.apar.t;
        txn.assetDefaultFrozen = txnForEnc.apar.df;
        if (txnForEnc.apar.dc !== void 0)
          txn.assetDecimals = txnForEnc.apar.dc;
        if (txnForEnc.apar.m !== void 0)
          txn.assetManager = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.m)));
        if (txnForEnc.apar.r !== void 0)
          txn.assetReserve = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.r)));
        if (txnForEnc.apar.f !== void 0)
          txn.assetFreeze = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.f)));
        if (txnForEnc.apar.c !== void 0)
          txn.assetClawback = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.apar.c)));
        if (txnForEnc.apar.un !== void 0)
          txn.assetUnitName = txnForEnc.apar.un;
        if (txnForEnc.apar.an !== void 0)
          txn.assetName = txnForEnc.apar.an;
        if (txnForEnc.apar.au !== void 0)
          txn.assetURL = txnForEnc.apar.au;
        if (txnForEnc.apar.am !== void 0)
          txn.assetMetadataHash = txnForEnc.apar.am;
      }
    } else if (txnForEnc.type === "axfer") {
      if (txnForEnc.xaid !== void 0) {
        txn.assetIndex = txnForEnc.xaid;
      }
      if (txnForEnc.aamt !== void 0)
        txn.amount = txnForEnc.aamt;
      if (txnForEnc.aclose !== void 0) {
        txn.closeRemainderTo = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.aclose)));
      }
      if (txnForEnc.asnd !== void 0) {
        txn.assetRevocationTarget = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.asnd)));
      }
      txn.to = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.arcv)));
    } else if (txnForEnc.type === "afrz") {
      if (txnForEnc.afrz !== void 0) {
        txn.freezeState = txnForEnc.afrz;
      }
      if (txnForEnc.faid !== void 0) {
        txn.assetIndex = txnForEnc.faid;
      }
      txn.freezeAccount = decodeAddress(encodeAddress(new Uint8Array(txnForEnc.fadd)));
    } else if (txnForEnc.type === "appl") {
      if (txnForEnc.apid !== void 0) {
        txn.appIndex = txnForEnc.apid;
      }
      if (txnForEnc.apan !== void 0) {
        txn.appOnComplete = txnForEnc.apan;
      }
      if (txnForEnc.apls !== void 0) {
        if (txnForEnc.apls.nui !== void 0)
          txn.appLocalInts = txnForEnc.apls.nui;
        if (txnForEnc.apls.nbs !== void 0)
          txn.appLocalByteSlices = txnForEnc.apls.nbs;
      }
      if (txnForEnc.apgs !== void 0) {
        if (txnForEnc.apgs.nui !== void 0)
          txn.appGlobalInts = txnForEnc.apgs.nui;
        if (txnForEnc.apgs.nbs !== void 0)
          txn.appGlobalByteSlices = txnForEnc.apgs.nbs;
      }
      if (txnForEnc.apep !== void 0) {
        txn.extraPages = txnForEnc.apep;
      }
      if (txnForEnc.apap !== void 0) {
        txn.appApprovalProgram = new Uint8Array(txnForEnc.apap);
      }
      if (txnForEnc.apsu !== void 0) {
        txn.appClearProgram = new Uint8Array(txnForEnc.apsu);
      }
      if (txnForEnc.apaa !== void 0) {
        txn.appArgs = txnForEnc.apaa.map((arg) => new Uint8Array(arg));
      }
      if (txnForEnc.apat !== void 0) {
        txn.appAccounts = txnForEnc.apat.map((addressBytes) => decodeAddress(encodeAddress(new Uint8Array(addressBytes))));
      }
      if (txnForEnc.apfa !== void 0) {
        txn.appForeignApps = txnForEnc.apfa;
      }
      if (txnForEnc.apas !== void 0) {
        txn.appForeignAssets = txnForEnc.apas;
      }
      if (txnForEnc.apbx !== void 0) {
        txn.boxes = txnForEnc.apbx.map((box) => ({
          // We return 0 for the app ID so that it's guaranteed translateBoxReferences will
          // translate the app index back to 0. If we instead returned the called app ID,
          // translateBoxReferences would translate the app index to a nonzero value if the called
          // app is also in the foreign app array.
          appIndex: box.i ? txn.appForeignApps[box.i - 1] : 0,
          name: box.n
        }));
      }
    } else if (txnForEnc.type === "stpf") {
      if (txnForEnc.sptype !== void 0) {
        txn.stateProofType = txnForEnc.sptype;
      }
      if (txnForEnc.sp !== void 0) {
        txn.stateProof = txnForEnc.sp;
      }
      if (txnForEnc.spmsg !== void 0) {
        txn.stateProofMessage = txnForEnc.spmsg;
      }
    }
    return txn;
  }
  estimateSize() {
    return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
  }
  bytesToSign() {
    const encodedMsg = this.toByte();
    return buffer.Buffer.from(concatArrays(this.tag, encodedMsg));
  }
  toByte() {
    return encode(this.get_obj_for_encoding());
  }
  // returns the raw signature
  rawSignTxn(sk2) {
    const toBeSigned = this.bytesToSign();
    const sig = sign(toBeSigned, sk2);
    return buffer.Buffer.from(sig);
  }
  signTxn(sk2) {
    const sTxn = {
      sig: this.rawSignTxn(sk2),
      txn: this.get_obj_for_encoding()
    };
    const keypair = keyPairFromSecretKey(sk2);
    const pubKeyFromSk = keypair.publicKey;
    if (encodeAddress(pubKeyFromSk) !== encodeAddress(this.from.publicKey)) {
      sTxn.sgnr = buffer.Buffer.from(pubKeyFromSk);
    }
    return new Uint8Array(encode(sTxn));
  }
  attachSignature(signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error("Invalid signature length");
    }
    const sTxn = {
      sig: buffer.Buffer.from(signature),
      txn: this.get_obj_for_encoding()
    };
    if (signerAddr !== encodeAddress(this.from.publicKey)) {
      const signerPublicKey = decodeAddress(signerAddr).publicKey;
      sTxn.sgnr = buffer.Buffer.from(signerPublicKey);
    }
    return new Uint8Array(encode(sTxn));
  }
  rawTxID() {
    const enMsg = this.toByte();
    const gh = buffer.Buffer.from(concatArrays(this.tag, enMsg));
    return buffer.Buffer.from(genericHash(gh));
  }
  txID() {
    const hash = this.rawTxID();
    return base32.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
  }
  // add a lease to a transaction not yet having
  // supply feePerByte to increment fee accordingly
  addLease(lease, feePerByte = 0) {
    let mutableLease;
    if (lease !== void 0) {
      if (lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
        throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
      mutableLease = new Uint8Array(lease);
    } else {
      mutableLease = new Uint8Array(0);
    }
    this.lease = mutableLease;
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH + ALGORAND_TRANSACTION_LEASE_LENGTH) * feePerByte;
    }
  }
  // add the rekey-to field to a transaction not yet having it
  // supply feePerByte to increment fee accordingly
  addRekey(reKeyTo, feePerByte = 0) {
    if (reKeyTo !== void 0) {
      this.reKeyTo = decodeAddress(reKeyTo);
    }
    if (feePerByte !== 0) {
      this.fee += (ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH + ALGORAND_TRANSACTION_ADDRESS_LENGTH) * feePerByte;
    }
  }
  // build display dict for prettyPrint and toString
  // eslint-disable-next-line no-underscore-dangle
  _getDictForDisplay() {
    const forPrinting = {
      ...this
    };
    forPrinting.tag = forPrinting.tag.toString();
    forPrinting.from = encodeAddress(forPrinting.from.publicKey);
    if (forPrinting.to !== void 0)
      forPrinting.to = encodeAddress(forPrinting.to.publicKey);
    if (forPrinting.freezeAccount !== void 0)
      forPrinting.freezeAccount = encodeAddress(forPrinting.freezeAccount.publicKey);
    if (forPrinting.closeRemainderTo !== void 0)
      forPrinting.closeRemainderTo = encodeAddress(forPrinting.closeRemainderTo.publicKey);
    if (forPrinting.assetManager !== void 0)
      forPrinting.assetManager = encodeAddress(forPrinting.assetManager.publicKey);
    if (forPrinting.assetReserve !== void 0)
      forPrinting.assetReserve = encodeAddress(forPrinting.assetReserve.publicKey);
    if (forPrinting.assetFreeze !== void 0)
      forPrinting.assetFreeze = encodeAddress(forPrinting.assetFreeze.publicKey);
    if (forPrinting.assetClawback !== void 0)
      forPrinting.assetClawback = encodeAddress(forPrinting.assetClawback.publicKey);
    if (forPrinting.assetRevocationTarget !== void 0)
      forPrinting.assetRevocationTarget = encodeAddress(forPrinting.assetRevocationTarget.publicKey);
    if (forPrinting.reKeyTo !== void 0)
      forPrinting.reKeyTo = encodeAddress(forPrinting.reKeyTo.publicKey);
    forPrinting.genesisHash = forPrinting.genesisHash.toString("base64");
    return forPrinting;
  }
  // pretty print the transaction to console
  prettyPrint() {
    console.log(this._getDictForDisplay());
  }
  // get string representation
  toString() {
    return JSON.stringify(this._getDictForDisplay());
  }
}
function decodeUnsignedTransaction(transactionBuffer) {
  const partlyDecodedObject = decode(transactionBuffer);
  return Transaction.from_obj_for_encoding(partlyDecodedObject);
}
function decodeSignedTransaction(transactionBuffer) {
  const stxnDecoded = decode(transactionBuffer);
  const stxn = {
    ...stxnDecoded,
    txn: Transaction.from_obj_for_encoding(stxnDecoded.txn)
  };
  return stxn;
}
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F3() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F3.prototype = global2;
    return new F3();
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports2.Headers = Headers;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
const english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
const FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
const NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
function toUint11Array(buffer8) {
  const buffer11 = [];
  let acc = 0;
  let accBits = 0;
  function add2(octet) {
    acc |= octet << accBits;
    accBits += 8;
    if (accBits >= 11) {
      buffer11.push(acc & 2047);
      acc >>= 11;
      accBits -= 11;
    }
  }
  function flush() {
    if (accBits) {
      buffer11.push(acc);
    }
  }
  buffer8.forEach(add2);
  flush();
  return buffer11;
}
function applyWords(nums) {
  return nums.map((n) => english[n]);
}
function computeChecksum(seed) {
  const hashBuffer = genericHash(seed);
  const uint11Hash = toUint11Array(hashBuffer);
  const words = applyWords(uint11Hash);
  return words[0];
}
function toUint8Array(buffer11) {
  const buffer8 = [];
  let acc = 0;
  let accBits = 0;
  function add2(ui11) {
    acc |= ui11 << accBits;
    accBits += 11;
    while (accBits >= 8) {
      buffer8.push(acc & 255);
      acc >>= 8;
      accBits -= 8;
    }
  }
  function flush() {
    if (accBits) {
      buffer8.push(acc);
    }
  }
  buffer11.forEach(add2);
  flush();
  return new Uint8Array(buffer8);
}
function seedFromMnemonic(mnemonic) {
  const words = mnemonic.split(" ");
  const key = words.slice(0, 24);
  for (const w of key) {
    if (english.indexOf(w) === -1)
      throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
  }
  const checksum = words[words.length - 1];
  const uint11Array = key.map((word) => english.indexOf(word));
  let uint8Array = toUint8Array(uint11Array);
  if (uint8Array.length !== 33)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  if (uint8Array[uint8Array.length - 1] !== 0)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  uint8Array = uint8Array.slice(0, uint8Array.length - 1);
  const cs2 = computeChecksum(uint8Array);
  if (cs2 === checksum)
    return uint8Array;
  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
}
function mnemonicToSecretKey(mn) {
  const seed = seedFromMnemonic(mn);
  const keys = keyPairFromSeed(seed);
  const encodedPk = encodeAddress(keys.publicKey);
  return { addr: encodedPk, sk: keys.secretKey };
}
buffer.Buffer.from("ProgData");
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i) {
});
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
buffer.Buffer.from([21, 31, 124, 117]);
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
buffer.Buffer.from([77, 88]);
function decodeObj(o) {
  return decode(o);
}
var q = Object.defineProperty;
var c = (n, t) => q(n, "name", { value: t, configurable: true });
function S() {
  let n = false;
  return typeof window !== void 0 && typeof window == "object" && "document" in window && typeof window.document == "object" && (n = true), n;
}
c(S, "isBrowser");
var R = c((n) => {
  if (typeof window == null)
    throw new Error("Cannot access window for simple btoa conversion.");
  for (var t = "", e = new Uint8Array(n), o = e.byteLength, i = 0; i < o; i++)
    t += String.fromCharCode(e[i]);
  return window.btoa(t);
}, "arrayBufferToBase64"), T = { enabled: false, log(...n) {
  this.enabled && console.log(...n);
}, warn(...n) {
  this.enabled && console.warn(...n);
}, debug(...n) {
  this.enabled && console.debug(...n);
} };
var m = { changedStateHandlers: [], changedAccountHandlers: [] }, P = "AW", H = c(() => {
  T.debug("startWatchers started"), watch(() => s.stored, () => {
    try {
      localStorage.setItem(P, JSON.stringify(s.stored));
    } catch {
      S() ? console.warn("could not save to localstorage") : T.log("no localstorage to save to in node env");
    }
  }, { deep: true }), watch(s, (n) => {
    m.changedStateHandlers.forEach((t) => t(n));
  }, { deep: true }), watch(() => s.stored.activeAccount, (n) => {
    m.changedAccountHandlers.forEach((t) => t(n));
  }, { deep: true });
}, "startWatchers"), Re$1 = c((n, t = { callOnSet: true }) => (m.changedStateHandlers.push(n), t.callOnSet && n(s), c(() => {
  let o = m.changedStateHandlers.indexOf(n);
  o !== -1 && m.changedStateHandlers.splice(o, 1);
}, "unsubscribe")), "subscribeToStateChanges"), He$1 = c((n, t = { callOnSet: true }) => (m.changedAccountHandlers.push(n), t.callOnSet && n(s.stored.activeAccount), c(() => {
  let o = m.changedAccountHandlers.indexOf(n);
  o !== -1 && m.changedAccountHandlers.splice(o, 1);
}, "unsubscribe")), "subscribeToAccountChanges");
var d = { PERA: "pera", INKEY: "inkey", MYALGO: "myalgo", ALGOSIGNER: "algosigner", EXODUS: "exodus", DEFLY: "defly", MNEMONIC: "mnemonic" };
var y = (_a = class {
  constructor(t) {
  }
}, (() => {
  c(_a, "BaseClient");
})(), __publicField(_a, "metadata"), __publicField(_a, "init"), _a);
var ee = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzcgMTg3Ij48cmVjdCB4PSItMTEuMzgiIHk9Ii0yNS45NyIgd2lkdGg9IjIwMC4wMiIgaGVpZ2h0PSIyMzEuNTMiIHN0eWxlPSJmaWxsOiNmZTU7Ii8+PHBhdGggZD0iTTk0LjA1LDU5LjYxYzIuMDUsOC40OCwxLjM2LDE1Ljk0LTEuNTUsMTYuNjYtMi45LC43Mi02LjkxLTUuNTctOC45Ni0xNC4wNS0yLjA1LTguNDgtMS4zNi0xNS45NCwxLjU1LTE2LjY2LDIuOS0uNzIsNi45MSw1LjU3LDguOTYsMTQuMDVaIiBzdHlsZT0iZmlsbDojMWMxYzFjOyIvPjxwYXRoIGQ9Ik0xMjcuODUsNjYuOWMtNC41My00LjgxLTEzLjU1LTMuNS0yMC4xNSwyLjkxLTYuNTksNi40MS04LjI2LDE1LjUtMy43MywyMC4zMSw0LjUzLDQuOCwxMy41NSwzLjUsMjAuMTUtMi45MXM4LjI2LTE1LjUsMy43My0yMC4zMVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTkxLjc5LDE0MC40N2MyLjktLjcyLDMuNDktOC42LDEuMzItMTcuNjEtMi4xNy05LTYuMjktMTUuNzEtOS4xOS0xNC45OS0yLjksLjcyLTMuNDksOC42LTEuMzIsMTcuNjEsMi4xNyw5LDYuMjksMTUuNzEsOS4xOSwxNC45OVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTYyLjIyLDcxLjNjOC4zNywyLjQ3LDE0LjQ4LDYuOCwxMy42Niw5LjY3LS44MywyLjg3LTguMjgsMy4yLTE2LjY1LC43My04LjM3LTIuNDctMTQuNDgtNi44LTEzLjY2LTkuNjcsLjgzLTIuODcsOC4yOC0zLjIsMTYuNjUtLjczWiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48cGF0aCBkPSJNMTE2LjU0LDEwMy43NGM4Ljg4LDIuNjIsMTUuNDEsNy4wNywxNC41OSw5Ljk0LS44MywyLjg3LTguNywzLjA4LTE3LjU4LC40Ni04Ljg4LTIuNjItMTUuNDEtNy4wNy0xNC41OS05Ljk0LC44My0yLjg3LDguNy0zLjA4LDE3LjU4LS40NloiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTcxLjY0LDk3LjcxYy0yLjA4LTIuMTUtOC44OCwuOTgtMTUuMiw2Ljk5LTYuMzIsNi4wMS05Ljc2LDEyLjYzLTcuNjksMTQuNzgsMi4wOCwyLjE1LDguODgtLjk4LDE1LjItNi45OSw2LjMyLTYuMDEsOS43Ni0xMi42Myw3LjY5LTE0Ljc4WiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48L3N2Zz4=", D = { id: d.PERA, chain: "algorand", name: "Pera Wallet", icon: ee, pkg: "@perawallet/connect" };
var z = (_b = class extends y {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let o, i = { shouldShowSignTxnToast: false };
        o = (t == null ? void 0 : t.config) || i;
        let M = await __vitePreload(() => import("./index-bb988554.js").then((n) => n.i), true ? ["./index-bb988554.js","./qr-code-styling-3c33b143.js","./algosdk.min-007f3efe.js","./index-f3593f61.js"] : void 0, import.meta.url), I = M.PeraWalletConnect || M.default.PeraWalletConnect;
        e = new I(o);
      }
      return e = markRaw(e), new _b({ sdk: e });
    } catch (e) {
      return console.error(`[${D.id}] Error initializing...`, e), null;
    }
  }
  async connect(t) {
    var _a2;
    let e = await this.sdk.connect();
    if ((_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e.length === 0)
      throw new Error(`No accounts found for ${D.id}`);
    return e.map((o, i) => ({ name: `Pera Account ${i + 1}`, address: o, walletId: D.id, chain: D.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? e.map((o, i) => ({ name: `Pera Account ${i + 1}`, address: o, walletId: D.id, chain: D.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() })) : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let o = e.map((r) => decodeObj(r)), i = o.reduce((r, u, l) => {
      let a = t.map((g) => g.address);
      return !("txn" in u) && a.includes(encodeAddress(u.snd)) ? r.push({ txn: decodeUnsignedTransaction(e[l]) }) : r.push({ txn: decodeSignedTransaction(e[l]).txn, signers: [] }), r;
    }, []), M = await this.sdk.signTransaction([i]);
    return o.reduce((r, u, l) => {
      if ("txn" in u)
        r.push(e[l]);
      else {
        let a = M.shift();
        a && r.push(a);
      }
      return r;
    }, []);
  }
}, (() => {
  c(_b, "PeraClient");
})(), __publicField(_b, "metadata", D), _b);
var ce = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTIiIGhlaWdodD0iNTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cmVjdCB3aWR0aD0iNTIiIGhlaWdodD0iNTIiIHJ4PSIxMiIgZmlsbD0iI2ZmZiIvPjxjaXJjbGUgY3g9IjI2LjI1MSIgY3k9IjE3Ljg5MSIgcj0iMTMuODkxIiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTkuNzc2IiBjeT0iMTcuODkxIiBmaWxsPSIjZmZmIiByPSIyLjY0MyIvPjxjaXJjbGUgY3g9IjMxLjYzOCIgY3k9IjE3Ljg5MSIgZmlsbD0iI2ZmZiIgcj0iMi42NDMiLz48cGF0aCBkPSJNMjEgMjQuMmMxLjAyIDQuNjU5LTIuNzUgMTQuNTg4LTkuNTE0IDE1LjI5OU0zMC43NCAyNi44MDFjMS43NjQgMS44MzcgMy44ODUgMTQuMzIxLTEuNTgyIDIwLjE5OU0yNS4zMjMgMjkuMDA0YzEuMDExIDQuNjYxIDEuNDA2IDEzLjYyMi04LjQ1IDE3LjgxNiIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjUuMzk5IiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48Y2lyY2xlIGN4PSIxOS43NzYiIGN5PSIxNy44ODciIHI9IjEuNDE2IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMzEuNjM4IiBjeT0iMTcuODg3IiByPSIxLjQxNiIgZmlsbD0iIzAwMCIvPjwvZz48ZGVmcz48Y2xpcFBhdGggaWQ9ImEiPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0wIDBoNTJ2NTJIMHoiLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4=", C = { id: d.INKEY, chain: "algorand", name: "Inkey Microwallet", icon: ce, pkg: "@thencc/inkey-client-js" };
var b$1 = (_c = class extends y {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let o, i = { src: "https://inkey.app", align: "center" };
        o = (t == null ? void 0 : t.config) || i;
        let M = await __vitePreload(() => import("./index.esm-2f1d95df.js"), true ? [] : void 0, import.meta.url);
        e = await (M.createClient || M.default.createClient)(o);
      }
      return await new Promise((o) => setTimeout(o, 600)), new _c({ sdk: e });
    } catch (e) {
      return console.warn(`[${C.id}] Error initializing...`, e), null;
    }
  }
  async connect(t) {
    let e = await this.sdk.connect(t);
    if (!e)
      throw new Error("no inkeyAccounts");
    if (e.length === 0)
      throw new Error(`No accounts found for ${C.id}`);
    return (t == null ? void 0 : t.onDisconnect) && this.sdk.frameBus.setOnDisconnect(t.onDisconnect), e.map((o) => ({ name: o.name, address: o.address, walletId: C.id, chain: C.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let o = e.map((l) => decodeObj(l)), M = o.reduce((l, a, g) => {
      let w = t.map((N3) => N3.address);
      return !("txn" in a) && w.includes(encodeAddress(a.snd)) && l.push(e[g]), l;
    }, []).map((l) => R(l)), I = await this.sdk.signTxns(M, t);
    if (!I.success)
      throw new Error("Error signing transactions");
    let r = I.signedTxns;
    return o.reduce((l, a, g) => {
      if ("txn" in a)
        l.push(e[g]);
      else {
        let w = r.shift();
        w && l.push(w);
      }
      return l;
    }, []);
  }
}, (() => {
  c(_c, "InkeyClient");
})(), __publicField(_c, "metadata", C), _c);
var de = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHBhdGggZmlsbD0iIzI0NUVDNiIgZD0iTTE2LDMyYy0zLjIsMC02LjItMC45LTguOS0yLjdjLTIuNi0xLjgtNC43LTQuMy01LjktNy4yQzAsMTkuMi0wLjMsMTYsMC4zLDEyLjlDMC45LDkuOCwyLjQsNyw0LjcsNC43IEM2LjIsMy4yLDcuOSwyLDkuOSwxLjJDMTEuOCwwLjQsMTMuOSwwLDE2LDBzNC4yLDAuNCw2LjEsMS4yYzEuOSwwLjgsMy43LDIsNS4yLDMuNXMyLjcsMy4zLDMuNSw1LjJjMC44LDEuOSwxLjIsNCwxLjIsNi4xIHMtMC40LDQuMi0xLjIsNi4xYy0wLjgsMS45LTIsMy43LTMuNSw1LjJjLTEuNSwxLjUtMy4yLDIuNy01LjIsMy41QzIwLjIsMzEuNiwxOC4xLDMyLDE2LDMyTDE2LDMyeiBNMjAuMiwxMS4ybDAuMSwwLjVsMi42LDkuNWgyLjEgTDIxLjUsOC45bC0wLjEtMC4zaC0xLjlsMCwwLjFsLTEuNywzLjFMMTYsMTQuOWwwLDAuMWwwLTAuMWwtMC4yLTAuOGwtMC42LTIuNGwtMC4xLTAuMmwtMC43LTIuNmwtMC4xLTAuM2gtMS45bDAsMC4xbC0xLjcsMy4xIGwtMS44LDMuMkw3LjEsMThsLTEuOCwzLjJoMi4xTDkuMiwxOGwxLjgtMy4ybDEuOC0zLjJsMC4zLTAuNWwwLjEsMC41bDAuNSwyLjFsMC43LDIuNmwwLjIsMC45TDE0LjIsMThsLTEuOCwzLjJoMi4xbDAuOC0xLjMgbDEuMy0yLjNsMS41LTIuN2wxLjgtMy4yTDIwLjIsMTEuMkwyMC4yLDExLjJ6Ii8+Cjwvc3ZnPgo=", p = { id: d.MYALGO, chain: "algorand", name: "MyAlgo", icon: de, pkg: "@randlabs/myalgo-connect" };
var O = (_d = class extends y {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let o, i = { disableLedgerNano: false };
        o = (t == null ? void 0 : t.config) || i;
        let M = await __vitePreload(() => Promise.resolve().then(() => index$1), true ? void 0 : void 0, import.meta.url);
        window.Buffer || (window.Buffer = M.Buffer || M.default.Buffer);
        let r = (await __vitePreload(() => import("./index-26152857.js").then((n) => n.i), true ? [] : void 0, import.meta.url)).default;
        e = new r(o);
      }
      return e = markRaw(e), new _d({ sdk: e });
    } catch (e) {
      return console.error(`[${p.id}] Error initializing...`, e), null;
    }
  }
  async connect() {
    let t = await this.sdk.connect();
    if (t.length === 0)
      throw new Error(`No accounts found for ${p.id}`);
    return t.map((e) => ({ ...e, walletId: p.id, chain: p.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let o = e.map((r) => decodeObj(r)), i = o.reduce((r, u, l) => {
      let a = t.map((g) => g.address);
      return !("txn" in u) && a.includes(encodeAddress(u.snd)) && r.push(e[l]), r;
    }, []), M = await this.sdk.signTransaction(i);
    return o.reduce((r, u, l) => {
      var _a2;
      if ("txn" in u)
        r.push(e[l]);
      else {
        let a = (_a2 = M.shift()) == null ? void 0 : _a2.blob;
        a && r.push(a);
      }
      return r;
    }, []);
  }
}, (() => {
  c(_d, "MyAlgoClient");
})(), __publicField(_d, "metadata", p), _d);
var Ie$1 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjM4IiBoZWlnaHQ9IjIzOCIgdmlld0JveD0iMCAwIDIzOCAyMzgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01MS43MDUgMTQ1LjA0MkgxMTYuNzA1TDEwNy43MDUgMTU1LjA0Mkg1MS43MDVWMTQ1LjA0MloiIGZpbGw9IiNENjQ1MDAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNDcuNTE5IDE5MS41NTdMMTI5LjU3NyAxNDQuMzk0TDE0Mi40MDQgMTI3LjExMkwxNjcuODc1IDE5MS41NTdIMTQ3LjUxOVpNMTEwLjkzNiA5NS4zOTMyTDEyMC42MTMgMTIwLjgzMUwxMzMuMzU5IDEwNC4yMjhMMTE3LjQ3NSA2NC4wNDIyQzExNS45MjggNjAuMTI4IDExMi4xNDYgNTcuNTU2NSAxMDcuOTM4IDU3LjU1NjVDMTAzLjcyOSA1Ny41NTY1IDk5Ljk0NzQgNjAuMTI4IDk4LjQwMDMgNjQuMDQyMkw2Ny45NjU5IDE0MS4wNDJIODcuNzgwN0M5NS40MTUzIDEyMS4wMTEgMTAyLjg5MyAxMDEuMzk5IDEwNS4xOTggOTUuMzU0MUMxMDUuNjQxIDk0LjE5MTIgMTA2Ljc0MyA5My40NTk5IDEwNy45ODcgOTMuNDU5OUgxMDguMTMyQzEwOS4zNzggOTMuNDU5OSAxMTAuNDkzIDk0LjIyOTMgMTEwLjkzNiA5NS4zOTMyWk04MC45MjEgMTU5LjA0MkM3NC45Mjg5IDE3NC43NjggNjkuODY2MSAxODguMDYzIDY4LjU0NDcgMTkxLjU1N0g0OEw2MC44NTE0IDE1OS4wNDJIODAuOTIxWiIgZmlsbD0iIzIyMkI2MCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3Ni4wMjYgNTQuNzUwOUMxNzcuOTk3IDUyLjA4NzIgMTgxLjc1NCA1MS41MjU3IDE4NC40MTggNTMuNDk2N0MxODcuMDgyIDU1LjQ2NzggMTg3LjY0MyA1OS4yMjUxIDE4NS42NzIgNjEuODg4OEwxMzAuMDEzIDEzNy4xMDdDMTI5LjcxNCAxMzcuNTEyIDEyOS4zNDEgMTM3Ljg1NyAxMjguOTEzIDEzOC4xMjNMMTE3Ljg1NiAxNDUuMDEzQzExNy4wODcgMTQ1LjQ5MyAxMTYuMTI4IDE0NC43ODMgMTE2LjM2MSAxNDMuOTA3TDExOS43MTggMTMxLjMxOEMxMTkuODQ3IDEzMC44MzIgMTIwLjA2OCAxMzAuMzc0IDEyMC4zNjcgMTI5Ljk3TDE3MC42NyA2MS45ODlMMTY5LjkyOSA2MS40NDA1QzE2OS40ODUgNjEuMTEyIDE2OC44NTkgNjEuMjA1NiAxNjguNTMgNjEuNjQ5NkwxNTIuMzExIDgzLjU2ODhDMTUyLjU4NiA4NC4yMDIzIDE1Mi41MjQgODQuOTYxMiAxNTIuMDg0IDg1LjU1NjJMMTQ5LjExIDg5LjU3NTVDMTQ4LjQ1MyA5MC40NjM0IDE0Ny4yMDEgOTAuNjUwNiAxNDYuMzEzIDg5Ljk5MzZDMTQ1LjQyNSA4OS4zMzY2IDE0NS4yMzggODguMDg0MSAxNDUuODk1IDg3LjE5NjJMMTQ3LjY3OSA4NC43ODQ3TDE0OC44NjkgODMuMTc2OUwxNjcuMzA4IDU4LjI1NzRDMTY4LjYyMiA1Ni40ODE1IDE3MS4xMjcgNTYuMTA3MiAxNzIuOTAzIDU3LjQyMTJMMTczLjY0NCA1Ny45Njk3TDE3Ni4wMjYgNTQuNzUwOVoiIGZpbGw9IiNENjQ1MDAiLz4KPC9zdmc+Cg==", k$1 = { id: d.ALGOSIGNER, chain: "algorand", name: "AlgoSigner", icon: Ie$1, pkg: "" };
var Ne = c((n) => n === "betanet" ? "BetaNet" : n === "testnet" ? "TestNet" : n === "mainnet" ? "MainNet" : n, "getNetwork"), W$1 = (_e = class extends y {
  constructor({ sdk: t, network: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "network");
    this.sdk = t, this.network = e;
  }
  static async init(t) {
    var _a2;
    try {
      if (typeof window > "u" || window.AlgoSigner === void 0)
        throw new Error("AlgoSigner is not available.");
      let e = window.AlgoSigner, o = "mainnet";
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.network) && (t.config.network == "mainnet" || t.config.network == "testnet" || t.config.network == "betanet" ? o = t.config.network : console.warn(`invalid network in ${k$1.id} config`)), new _e({ sdk: e, network: o });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    await this.sdk.connect();
    let t = await this.sdk.accounts({ ledger: Ne(this.network) });
    if (t.length === 0)
      throw new Error(`No accounts found for ${k$1.id}`);
    return t.map(({ address: o }, i) => ({ name: `AlgoSigner Account ${i + 1}`, address: o, walletId: k$1.id, chain: k$1.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(t) {
    return (window === void 0 || window.AlgoSigner === void 0) && t(), null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let i = e.map((r) => decodeObj(r)).reduce((r, u, l) => {
      let a = { txn: this.sdk.encoding.msgpackToBase64(e[l]) }, g = t.map((w) => w.address);
      return ("txn" in u || !g.includes(encodeAddress(u.snd))) && (a.txn = this.sdk.encoding.msgpackToBase64(decodeSignedTransaction(e[l]).txn.toByte()), a.signers = []), r.push(a), r;
    }, []);
    return (await this.sdk.signTxn(i)).reduce((r, u, l) => (u ? r.push(new Uint8Array(buffer.Buffer.from(u.blob, "base64"))) : r.push(e[l]), r), []);
  }
}, (() => {
  c(_e, "AlgoSignerClient");
})(), __publicField(_e, "metadata", k$1), _e);
var me = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMDAgMzAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMDAgMzAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6dXJsKCNTVkdJRF8xXyk7fQoJLnN0MXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNDM0MjYxNjcxNDAxMDY1ODIyNzAwMDAwMDIxMzA3Njg5MDYwNzMxMTM0ODRfKTt9Cgkuc3Qye2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEwMjUxOTMxNjAxNTI3NjU4MTY0MDAwMDAxNjI3NDExMjM4MzE3NTY0MTc1OV8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTt9Cgkuc3Qze2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEzODU2MzM4MjQ2MjA4NjAyMDM1MDAwMDAxNDg3ODQ5MDI3MDc4MjA3MTIwN18pO30KCS5zdDR7bWFzazp1cmwoI21hc2swXzE2NjFfMjk1XzAwMDAwMDg4MTMyMjUxNTk3NDQxNTczNDkwMDAwMDExNjkzNjEyMDE4NTA2NjgxNDgxXyk7fQoJLnN0NXtmaWxsOnVybCgjU1ZHSURfMDAwMDAxMDYxMjA2MzI0NjE3OTI4NzExNjAwMDAwMDc0MzM5MTMwMzgzMzc3NjY1NzZfKTt9Cjwvc3R5bGU+CjxnPgoJCgkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDYuNjAzIiB5MT0iOS4yMjEyIiB4Mj0iMTc0LjE1OCIgeTI9IjMwOC41NDI2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xCgkJTDI3NC43LDkzLjl6Ii8+CgkKCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMjkuMzUxNiIgeTE9Ii0xOS4xNTczIiB4Mj0iNTYuOTA2NiIgeTI9IjI4MC4xNjQxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1Xyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCWw2OS4yLTQ1LjFWMjNMMjUuMyw5My45TDQzLDE1MC4xbC0xNy43LDU2LjJMMTMzLjcsMjc3di0zOS42bC02OS40LTQ1LjFMNzIuNSwxNjYuNHoiLz4KCTxkZWZzPgoJCTxmaWx0ZXIgaWQ9IkFkb2JlX09wYWNpdHlNYXNrRmlsdGVyIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ij4KCQkJPGZlQ29sb3JNYXRyaXggIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIxIDAgMCAwIDAgIDAgMSAwIDAgMCAgMCAwIDEgMCAwICAwIDAgMCAxIDAiLz4KCQk8L2ZpbHRlcj4KCTwvZGVmcz4KCQoJCTxtYXNrIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0IiBpZD0ibWFzazBfMTY2MV8yOTVfMDAwMDAwODgxMzIyNTE1OTc0NDE1NzM0OTAwMDAwMTE2OTM2MTIwMTg1MDY2ODE0ODFfIj4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjQ2LjYwMzgiIHkxPSI5LjIyMTQiIHgyPSIxNzQuMTU4OCIgeTI9IjMwOC41NDI4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwQjQ2RjkiLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JCRkJFMCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJPHBhdGggc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTsiIGQ9IgoJCQlNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xTDI3NC43LDkzLjl6Ii8+CgkJCgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMTk4MTE3MDc2MjE0NzI4MTQyNzAwMDAwMTA4Mjk2NTkzODM4NTEyMDI0OTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyOS4zNTIxIiB5MT0iLTE5LjE1NzEiIHgyPSI1Ni45MDcxIiB5Mj0iMjgwLjE2NDIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAzMDIpIj4KCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQkJGQkUwIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCQk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTE5ODExNzA3NjIxNDcyODE0MjcwMDAwMDEwODI5NjU5MzgzODUxMjAyNDkxXyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCQlsNjkuMi00NS4xVjIzTDI1LjMsOTMuOUw0MywxNTAuMWwtMTcuNyw1Ni4yTDEzMy43LDI3N3YtMzkuNmwtNjkuNC00NS4xTDcyLjUsMTY2LjR6Ii8+Cgk8L21hc2s+Cgk8ZyBjbGFzcz0ic3Q0Ij4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDEwOTAxOTkxODU1Nzc3MzA1MzQyMDAwMDAxNzYwMjQwNTkwODA2NzEyMDMwMF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDYuNDY2MiIgeTE9IjIyOC43NTU0IiB4Mj0iMTcxLjg2MzgiIHkyPSIxMzUuMTAzOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDMwMikiPgoJCQk8c3RvcCAgb2Zmc2V0PSIwLjExOTgiIHN0eWxlPSJzdG9wLWNvbG9yOiM4OTUyRkY7c3RvcC1vcGFjaXR5OjAuODciLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0RBQkRGRjtzdG9wLW9wYWNpdHk6MCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJCgkJCTxyZWN0IHg9IjI1LjQiIHk9IjIzIiBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTA5MDE5OTE4NTU3NzczMDUzNDIwMDAwMDE3NjAyNDA1OTA4MDY3MTIwMzAwXyk7IiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ii8+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", E = { id: d.EXODUS, chain: "algorand", name: "Exodus", icon: me, pkg: "" };
var h = (_f = class extends y {
  constructor({ sdk: t, onlyIfTrusted: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "onlyIfTrusted");
    this.sdk = t, this.onlyIfTrusted = e;
  }
  static async init(t) {
    var _a2, _b2;
    try {
      if (typeof window > "u" || window.exodus === void 0)
        throw new Error("Exodus is not available. Do you have the browser extension installed?");
      let e = window.exodus.algorand, o = false;
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.onlyIfTrusted) && (o = (_b2 = t == null ? void 0 : t.config) == null ? void 0 : _b2.onlyIfTrusted), new _f({ sdk: e, onlyIfTrusted: o });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    let t = "";
    try {
      let { address: e } = await window.exodus.algorand.connect({ onlyIfTrusted: this.onlyIfTrusted });
      t = e;
    } catch (e) {
      throw console.warn("err w exodus connect"), e;
    }
    if (!t)
      throw new Error(`No accounts found for ${E.id}`);
    return [{ name: `Exodus Account ${(/* @__PURE__ */ new Date()).getTime()}`, address: t, walletId: E.id, chain: E.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }];
  }
  async reconnect(t) {
    return (window === void 0 || window.exodus === void 0 || window.exodus.algorand.isConnected !== true) && t(), null;
  }
  async disconnect() {
    window.exodus.algorand.disconnect();
  }
  async signTransactions(t, e, o, i = true) {
    let M = e.map((a) => decodeObj(a)), I = [], r = M.reduce((a, g, w) => {
      let N3 = "txn" in g, B = t.map((v) => v.address);
      return (o && o.length && o.includes(w) || !N3 && B.includes(encodeAddress(g.snd))) && (I.push(w), a.push(e[w])), a;
    }, []), u = await window.exodus.algorand.signTransaction(r);
    return e.reduce((a, g, w) => {
      if (I.includes(w)) {
        let N3 = u.shift();
        N3 && a.push(N3);
      } else
        i && a.push(e[w]);
      return a;
    }, []);
  }
}, (() => {
  c(_f, "ExodusClient");
})(), __publicField(_f, "metadata", E), _f);
var je = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiLz4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNjgyMDksMCwwLDEuNjgyMDksMjI2LjM2OCwyMTIuODE4KSI+CiAgICAgICAgPHBhdGggZD0iTTMyNy4wNDksMjgwLjE5MkwxNjkuNTI0LDEzTDEyLDI4MC4xOTJMMTY5LjUyNCwxODkuMDg0TDMyNy4wNDksMjgwLjE5MloiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvOyIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS42ODIwOSwwLDAsMS42ODIwOSwyMjYuMzY4LDIxMi44MTgpIj4KICAgICAgICA8cGF0aCBkPSJNMjk5LjU0NiwzMDdMMTY5LjUyNSwyMzguNDczTDM5LjUwNCwzMDdMMTY5LjUyNSwyNjQuNjdMMjk5LjU0NiwzMDdaIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybzsiLz4KICAgIDwvZz4KPC9zdmc+Cg==", L = { id: d.DEFLY, chain: "algorand", name: "Defly", icon: je, pkg: "@blockshake/defly-connect" };
var U$1 = (_g = class extends y {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let o, i = { shouldShowSignTxnToast: false };
        o = (t == null ? void 0 : t.config) || i;
        let M = await __vitePreload(() => import("./index-e341b181.js").then((n) => n.i), true ? ["./index-e341b181.js","./qr-code-styling-3c33b143.js","./algosdk.min-007f3efe.js","./lottie-f9918250.js"] : void 0, import.meta.url), I = M.DeflyWalletConnect || M.default.DeflyWalletConnect;
        e = new I(o);
      }
      return new _g({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect(t) {
    let e = await this.sdk.connect().catch(console.info);
    if (this.sdk.connector.on("disconnect", t), !e || e.length === 0)
      throw new Error(`No accounts found for ${L.id}`);
    return e.map((o, i) => ({ name: `Defly Account ${i + 1}`, address: o, walletId: L.id, chain: L.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }));
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? e.map((o, i) => ({ name: `Defly Account ${i + 1}`, address: o, walletId: L.id, chain: L.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() })) : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let o = e.map((r) => decodeObj(r)), i = o.reduce((r, u, l) => {
      let a = t.map((g) => g.address);
      return !("txn" in u) && a.includes(encodeAddress(u.snd)) ? r.push({ txn: decodeUnsignedTransaction(e[l]) }) : r.push({ txn: decodeSignedTransaction(e[l]).txn, signers: [] }), r;
    }, []), M = await this.sdk.signTransaction([i]);
    return o.reduce((r, u, l) => {
      if ("txn" in u)
        r.push(e[l]);
      else {
        let a = M.shift();
        a && r.push(a);
      }
      return r;
    }, []);
  }
}, (() => {
  c(_g, "DeflyClient");
})(), __publicField(_g, "metadata", L), _g);
var pe = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e %3c!-- Generated by Pixelmator Pro 3.2.2 --%3e %3csvg width='409' height='210' viewBox='0 0 409 210' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctext id='MNEMONIC' xml:space='preserve' x='0' y='129' font-family='Helvetica' font-size='72' fill='black'%3eMNEMONIC%3c/text%3e%3c/svg%3e", Z = { id: d.MNEMONIC, name: "Mnemonic", icon: pe, chain: "algorand", pkg: "" };
var G = (_h = class extends y {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t)
        if (typeof t == "string")
          e = mnemonicToSecretKey(t);
        else if (typeof t == "object") {
          if (t.sdk)
            e = t.sdk;
          else if (t.config && t.config.mnemonic) {
            let o = t.config.mnemonic;
            e = mnemonicToSecretKey(o);
          }
        } else
          throw new Error("bad initParams for mnemonic client");
      else
        console.error("mnemonic wallet needs to be inited w a mnemonic - none provided.");
      return new _h({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    var _a2;
    return this.sdk == null && console.warn("mnemonic client wasnt initialized properly... no mnemonic passed in so cannot connect."), [{ name: `Mnemonic Account ${(/* @__PURE__ */ new Date()).getTime()}`, address: ((_a2 = this.sdk) == null ? void 0 : _a2.addr) || "", walletId: Z.id, chain: Z.chain, active: false, dateConnected: (/* @__PURE__ */ new Date()).getTime() }];
  }
  async disconnect() {
    this.sdk = void 0;
  }
  async reconnect() {
    return null;
  }
  async signTransactions(t, e, o, i = true) {
    if (this.sdk || await this.connect(), !this.sdk)
      throw new Error("Client could not init");
    let M = e.map((a) => decodeObj(a)), I = [], r = [];
    for (let a in M) {
      let g = M[a], w = "txn" in g, N3 = t.map(($) => $.address);
      if (I.push(e[a]), w)
        continue;
      if (o && o.length && !o.includes(Number(a)))
        continue;
      if (!N3.includes(encodeAddress(g.snd)))
        continue;
      I[a] = new Uint8Array();
      let v = Transaction.from_obj_for_encoding(g).signTxn(this.sdk.sk);
      r.push(v);
    }
    let u = 0, l = I.reduce((a, g, w) => (g.length === 0 ? (a.push(r[u]), u += 1) : i && a.push(g), a), []);
    return Promise.resolve(l);
  }
}, (() => {
  c(_h, "MnemonicClient");
})(), __publicField(_h, "metadata", Z), _h);
var A = { [d.PERA]: { client: z }, [d.INKEY]: { client: b$1 }, [d.MYALGO]: { client: O }, [d.ALGOSIGNER]: { client: W$1 }, [d.EXODUS]: { client: h }, [d.DEFLY]: { client: U$1 }, [d.MNEMONIC]: { client: G } };
Object.values(A).map((n) => n.client.metadata.id);
Object.values(A).map((n) => n.client.metadata.pkg).filter((n) => n !== "");
c((n) => {
  let t = [];
  for (let e of n)
    t.push(A[e].client.metadata.pkg);
  return t;
}, "excludeClients");
function J(n) {
  let t = c((e) => Array.isArray(e) ? e.map((o) => t(o)) : isRef(e) || isReactive(e) || isProxy(e) ? t(toRaw(e)) : e && typeof e == "object" ? Object.keys(e).reduce((o, i) => (o[i] = t(e[i]), o), {}) : e, "objectIterator");
  return t(n);
}
c(J, "deepToRaw");
var j = c((n, t = true) => {
  let e = reactive({ id: n, metadata: A[n].client.metadata, client: null, initParams: t, inited: false, initing: false, signing: false, connecting: false, loadClient: async () => (T.debug("loadClient:", n), e.inited ? (T.debug("aw already inited client"), true) : (e.initing = true, typeof e.initParams == "string" ? e.client = await A[n].client.init(e.initParams) : typeof e.initParams == "object" && (e.initParams.config || e.initParams.sdk) ? e.client = await A[n].client.init(e.initParams) : t == true ? e.client = await A[n].client.init() : console.warn("Bad/incomplete init params for wallet:", n), e.initing = false, e.inited = true, true)), unloadClient: async () => {
    var _a2;
    await ((_a2 = e.client) == null ? void 0 : _a2.disconnect()), e.inited = false;
  }, connect: async (o) => {
    e.connecting = true;
    try {
      if (await e.loadClient(), e.accounts) {
        o == null && (o = {});
        let M = J(e.accounts);
        o.connectedAccounts = [...M];
      }
      let i = await e.client.connect(o);
      return Ze$1(i), K(i[0]), i;
    } catch (i) {
      throw i;
    } finally {
      e.connecting = false;
    }
  }, disconnect: async () => {
    await e.loadClient();
    try {
      await e.unloadClient(), e.removeAccounts();
    } catch (o) {
      console.warn(o);
    }
  }, reconnect: async () => {
    await e.loadClient(), await e.client.reconnect(() => {
    });
  }, setAsActiveWallet: () => {
    let o = F(n);
    if (o)
      K(o[0]);
    else
      throw new Error("No accounts for this provider to set as active");
  }, removeAccounts: () => {
    Ue$1(n);
  }, signTransactions: async (o) => {
    await e.loadClient();
    let i = J(e.accounts);
    i.length || (i = await e.connect(), await new Promise((I) => setTimeout(I, 1e3))), e.signing = true;
    try {
      return await e.client.signTransactions(i, o);
    } catch (M) {
      throw M;
    } finally {
      e.signing = false;
    }
  }, get accounts() {
    return readonly(computed$1(() => F(n)));
  }, get isConnected() {
    return readonly(computed$1(() => s.stored.connectedAccounts.some((o) => o.walletId === n)));
  }, get isActive() {
    return computed$1(() => {
      var _a2;
      return ((_a2 = s.stored.activeAccount) == null ? void 0 : _a2.walletId) === n;
    });
  } });
  return e;
}, "createWallet"), _ = c((n, t) => {
  let e = s.allWallets[n];
  if (!e)
    throw new Error(`Unknown wallet: ${n}`);
  return t !== void 0 ? e.initParams = t : T.log("didnt update wallet's init params... kept whatever existed before"), e;
}, "initWallet");
c((n) => {
  T.log("initWallets started", n);
  for (let [t, e] of Object.entries(n))
    _(t, e);
  return s.allWallets;
}, "initWallets");
var En$1 = c(async (n, t) => {
  t !== void 0 && _(n, t);
  let e = s.allWallets[n];
  if (!e)
    throw new Error(`Unknown wallet: ${n}`);
  return await e.connect();
}, "connectWallet"), F = c((n) => s.stored.connectedAccounts.filter((t) => t.walletId === n), "getAccountsByWalletId"), Ue$1 = c((n) => {
  if (s.stored.activeAccount) {
    let e = s.stored.connectedAccounts.filter((o) => o.walletId == n);
    for (let o of e)
      if (o.address == s.stored.activeAccount.address && o.walletId == s.stored.activeAccount.walletId) {
        s.stored.activeAccount = null;
        break;
      }
  }
  let t = s.stored.connectedAccounts.filter((e) => e.walletId !== n);
  s.stored.connectedAccounts = t;
}, "removeAccountsByWalletId");
c((n) => {
  if (s.stored.activeAccount) {
    let o = s.stored.connectedAccounts.filter((i) => i.walletId == n.walletId && i.name == n.name && i.address == n.address);
    for (let i of o)
      if (i.address == s.stored.activeAccount.address && i.walletId == s.stored.activeAccount.walletId) {
        s.stored.activeAccount = null;
        break;
      }
  }
  let t = s.stored.connectedAccounts, e = t.findIndex((o) => o.walletId == n.walletId && o.address == n.address && o.name == n.name);
  t.splice(e, 1), s.stored.connectedAccounts = t;
}, "removeAccount");
c(() => {
  s.stored.activeAccount = null, s.stored.connectedAccounts = [];
}, "removeAllAccounts");
var Ze$1 = c((n) => {
  for (let t of n) {
    let e = false;
    for (let o of s.stored.connectedAccounts)
      t.walletId == o.walletId && t.address == o.address && (e = true);
    e || s.stored.connectedAccounts.push(t);
  }
}, "addConnectedAccounts"), K = c((n) => {
  T.debug("setAsActiveAccount", n), n.active = true, n.dateLastActive = (/* @__PURE__ */ new Date()).getTime(), s.stored.activeAccount = n, s.stored.connectedAccounts.forEach((t) => {
    t.walletId == n.walletId && t.address == n.address && t.name == n.name ? t.active = true : t.active = false;
  });
}, "setAsActiveAccount"), bn$1 = c(async (n) => {
  T.log("signTransactions", n);
  let t = s.activeWallet;
  if (!t)
    throw new Error("No active wallet... how'd you get here.");
  return await t.signTransactions(n);
}, "signTransactions");
c((n) => {
  T.enabled = n;
}, "setLogsEnabled");
var s = reactive({ allWallets: { [d.PERA]: j(d.PERA), [d.INKEY]: j(d.INKEY), [d.MYALGO]: j(d.MYALGO), [d.ALGOSIGNER]: j(d.ALGOSIGNER), [d.EXODUS]: j(d.EXODUS), [d.DEFLY]: j(d.DEFLY), [d.MNEMONIC]: j(d.MNEMONIC) }, stored: { version: 0, connectedAccounts: [], activeAccount: null }, activeAddress: readonly(computed$1(() => {
  let n = "";
  return s.stored.activeAccount && (n = s.stored.activeAccount.address), n;
})), activeAccount: readonly(computed$1(() => {
  let n = null;
  return s.stored.activeAccount && (n = s.stored.activeAccount), n;
})), connectedAccounts: readonly(computed$1(() => {
  let n = [];
  return s.stored.connectedAccounts && (n = s.stored.connectedAccounts), n;
})), activeWalletId: readonly(computed$1(() => {
  let n = null;
  return s.stored.activeAccount && (n = s.stored.activeAccount.walletId), n;
})), activeWallet: readonly(computed$1(() => {
  let n;
  return s.activeWalletId !== null && (n = s.allWallets[s.activeWalletId]), n;
})), isSigning: readonly(computed$1(() => {
  let n = false;
  for (let [t, e] of Object.entries(s.allWallets))
    if (e.signing) {
      n = true;
      break;
    }
  return n;
})), isIniting: readonly(computed$1(() => {
  let n = false;
  for (let [t, e] of Object.entries(s.allWallets))
    if (e.initing) {
      n = true;
      break;
    }
  return n;
})) }), Jn = c(() => {
  T.log("recallState"), S() && c(() => {
    T.log("initLocalStorage");
    try {
      let t = localStorage.getItem(P);
      if (t)
        try {
          let e = JSON.parse(t);
          s.stored = e;
        } catch {
          console.warn("bad sLocalStorage parse");
        }
    } catch {
      console.warn("could not access localstorage");
    }
  }, "initLocalStorage")();
}, "recallState");
H();
var Ur = Object.create;
var X = Object.defineProperty;
var Tr = Object.getOwnPropertyDescriptor;
var Ir = Object.getOwnPropertyNames;
var dr = Object.getPrototypeOf, Cr = Object.prototype.hasOwnProperty;
var pt = ((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, { get: (r, t) => (typeof require != "undefined" ? require : r)[t] }) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var Lr$1 = (e, r) => () => (e && (r = e(e = 0)), r);
var k = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports), ct = (e, r) => {
  for (var t in r)
    X(e, t, { get: r[t], enumerable: true });
}, Sr = (e, r, t, i) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let n of Ir(r))
      !Cr.call(e, n) && n !== t && X(e, n, { get: () => r[n], enumerable: !(i = Tr(r, n)) || i.enumerable });
  return e;
};
var rr$1 = (e, r, t) => (t = e != null ? Ur(dr(e)) : {}, Sr(r || !e || !e.__esModule ? X(t, "default", { value: e, enumerable: true }) : t, e));
var ur = k((st, nr) => {
  U();
  var s2 = nr.exports = {}, F3, g;
  function G2() {
    throw new Error("setTimeout has not been defined");
  }
  function z3() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? F3 = setTimeout : F3 = G2;
    } catch {
      F3 = G2;
    }
    try {
      typeof clearTimeout == "function" ? g = clearTimeout : g = z3;
    } catch {
      g = z3;
    }
  })();
  function tr2(e) {
    if (F3 === setTimeout)
      return setTimeout(e, 0);
    if ((F3 === G2 || !F3) && setTimeout)
      return F3 = setTimeout, setTimeout(e, 0);
    try {
      return F3(e, 0);
    } catch {
      try {
        return F3.call(null, e, 0);
      } catch {
        return F3.call(this, e, 0);
      }
    }
  }
  function Rr(e) {
    if (g === clearTimeout)
      return clearTimeout(e);
    if ((g === z3 || !g) && clearTimeout)
      return g = clearTimeout, clearTimeout(e);
    try {
      return g(e);
    } catch {
      try {
        return g.call(null, e);
      } catch {
        return g.call(this, e);
      }
    }
  }
  var v = [], R3 = false, d2, D2 = -1;
  function _r() {
    !R3 || !d2 || (R3 = false, d2.length ? v = d2.concat(v) : D2 = -1, v.length && er());
  }
  function er() {
    if (!R3) {
      var e = tr2(_r);
      R3 = true;
      for (var r = v.length; r; ) {
        for (d2 = v, v = []; ++D2 < r; )
          d2 && d2[D2].run();
        D2 = -1, r = v.length;
      }
      d2 = null, R3 = false, Rr(e);
    }
  }
  s2.nextTick = function(e) {
    var r = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var t = 1; t < arguments.length; t++)
        r[t - 1] = arguments[t];
    v.push(new ir(e, r)), v.length === 1 && !R3 && tr2(er);
  };
  function ir(e, r) {
    this.fun = e, this.array = r;
  }
  ir.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  s2.title = "browser";
  s2.browser = true;
  s2.env = {};
  s2.argv = [];
  s2.version = "";
  s2.versions = {};
  function T2() {
  }
  s2.on = T2;
  s2.addListener = T2;
  s2.once = T2;
  s2.off = T2;
  s2.removeListener = T2;
  s2.removeAllListeners = T2;
  s2.emit = T2;
  s2.prependListener = T2;
  s2.prependOnceListener = T2;
  s2.listeners = function(e) {
    return [];
  };
  s2.binding = function(e) {
    throw new Error("process.binding is not supported");
  };
  s2.cwd = function() {
    return "/";
  };
  s2.chdir = function(e) {
    throw new Error("process.chdir is not supported");
  };
  s2.umask = function() {
    return 0;
  };
});
var b, W, Mr, N, U = Lr$1(() => {
  b = rr$1(or()), W = rr$1(ur()), Mr = function(e) {
    function r() {
      var i = this || self;
      return delete e.prototype.__magic__, i;
    }
    if (typeof globalThis == "object")
      return globalThis;
    if (this)
      return r();
    e.defineProperty(e.prototype, "__magic__", { configurable: true, get: r });
    var t = __magic__;
    return t;
  }(Object), N = Mr;
});
var fr = k((Y) => {
  U();
  Y.byteLength = Dr2;
  Y.toByteArray = Nr2;
  Y.fromByteArray = qr;
  var B = [], m3 = [], kr = typeof Uint8Array < "u" ? Uint8Array : Array, J2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (C2 = 0, ar = J2.length; C2 < ar; ++C2)
    B[C2] = J2[C2], m3[J2.charCodeAt(C2)] = C2;
  var C2, ar;
  m3["-".charCodeAt(0)] = 62;
  m3["_".charCodeAt(0)] = 63;
  function hr2(e) {
    var r = e.length;
    if (r % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t = e.indexOf("=");
    t === -1 && (t = r);
    var i = t === r ? 0 : 4 - t % 4;
    return [t, i];
  }
  function Dr2(e) {
    var r = hr2(e), t = r[0], i = r[1];
    return (t + i) * 3 / 4 - i;
  }
  function br(e, r, t) {
    return (r + t) * 3 / 4 - t;
  }
  function Nr2(e) {
    var r, t = hr2(e), i = t[0], n = t[1], u = new kr(br(e, i, n)), o = 0, h2 = n > 0 ? i - 4 : i, f;
    for (f = 0; f < h2; f += 4)
      r = m3[e.charCodeAt(f)] << 18 | m3[e.charCodeAt(f + 1)] << 12 | m3[e.charCodeAt(f + 2)] << 6 | m3[e.charCodeAt(f + 3)], u[o++] = r >> 16 & 255, u[o++] = r >> 8 & 255, u[o++] = r & 255;
    return n === 2 && (r = m3[e.charCodeAt(f)] << 2 | m3[e.charCodeAt(f + 1)] >> 4, u[o++] = r & 255), n === 1 && (r = m3[e.charCodeAt(f)] << 10 | m3[e.charCodeAt(f + 1)] << 4 | m3[e.charCodeAt(f + 2)] >> 2, u[o++] = r >> 8 & 255, u[o++] = r & 255), u;
  }
  function Wr(e) {
    return B[e >> 18 & 63] + B[e >> 12 & 63] + B[e >> 6 & 63] + B[e & 63];
  }
  function Yr2(e, r, t) {
    for (var i, n = [], u = r; u < t; u += 3)
      i = (e[u] << 16 & 16711680) + (e[u + 1] << 8 & 65280) + (e[u + 2] & 255), n.push(Wr(i));
    return n.join("");
  }
  function qr(e) {
    for (var r, t = e.length, i = t % 3, n = [], u = 16383, o = 0, h2 = t - i; o < h2; o += u)
      n.push(Yr2(e, o, o + u > h2 ? h2 : o + u));
    return i === 1 ? (r = e[t - 1], n.push(B[r >> 2] + B[r << 4 & 63] + "==")) : i === 2 && (r = (e[t - 2] << 8) + e[t - 1], n.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), n.join("");
  }
});
var pr$1 = k((Q) => {
  U();
  Q.read = function(e, r, t, i, n) {
    var u, o, h2 = n * 8 - i - 1, f = (1 << h2) - 1, c2 = f >> 1, l = -7, p2 = t ? n - 1 : 0, E2 = t ? -1 : 1, x = e[r + p2];
    for (p2 += E2, u = x & (1 << -l) - 1, x >>= -l, l += h2; l > 0; u = u * 256 + e[r + p2], p2 += E2, l -= 8)
      ;
    for (o = u & (1 << -l) - 1, u >>= -l, l += i; l > 0; o = o * 256 + e[r + p2], p2 += E2, l -= 8)
      ;
    if (u === 0)
      u = 1 - c2;
    else {
      if (u === f)
        return o ? NaN : (x ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, i), u = u - c2;
    }
    return (x ? -1 : 1) * o * Math.pow(2, u - i);
  };
  Q.write = function(e, r, t, i, n, u) {
    var o, h2, f, c2 = u * 8 - n - 1, l = (1 << c2) - 1, p2 = l >> 1, E2 = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = i ? 0 : u - 1, S2 = i ? 1 : -1, vr = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
    for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (h2 = isNaN(r) ? 1 : 0, o = l) : (o = Math.floor(Math.log(r) / Math.LN2), r * (f = Math.pow(2, -o)) < 1 && (o--, f *= 2), o + p2 >= 1 ? r += E2 / f : r += E2 * Math.pow(2, 1 - p2), r * f >= 2 && (o++, f /= 2), o + p2 >= l ? (h2 = 0, o = l) : o + p2 >= 1 ? (h2 = (r * f - 1) * Math.pow(2, n), o = o + p2) : (h2 = r * Math.pow(2, p2 - 1) * Math.pow(2, n), o = 0)); n >= 8; e[t + x] = h2 & 255, x += S2, h2 /= 256, n -= 8)
      ;
    for (o = o << n | h2, c2 += n; c2 > 0; e[t + x] = o & 255, x += S2, o /= 256, c2 -= 8)
      ;
    e[t + x - S2] |= vr * 128;
  };
});
var or = k((M) => {
  U();
  var V = fr(), _2 = pr$1(), cr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  M.Buffer = a;
  M.SlowBuffer = Qr;
  M.INSPECT_MAX_BYTES = 50;
  var q2 = 2147483647;
  M.kMaxLength = q2;
  a.TYPED_ARRAY_SUPPORT = Hr();
  !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Hr() {
    try {
      var e = new Uint8Array(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(e, r), e.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a.prototype, "parent", { enumerable: true, get: function() {
    if (!!a.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(a.prototype, "offset", { enumerable: true, get: function() {
    if (!!a.isBuffer(this))
      return this.byteOffset;
  } });
  function I(e) {
    if (e > q2)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
    var r = new Uint8Array(e);
    return Object.setPrototypeOf(r, a.prototype), r;
  }
  function a(e, r, t) {
    if (typeof e == "number") {
      if (typeof r == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return $(e);
    }
    return wr(e, r, t);
  }
  a.poolSize = 8192;
  function wr(e, r, t) {
    if (typeof e == "string")
      return Gr2(e, r);
    if (ArrayBuffer.isView(e))
      return zr(e);
    if (e == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    if (A2(e, ArrayBuffer) || e && A2(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (A2(e, SharedArrayBuffer) || e && A2(e.buffer, SharedArrayBuffer)))
      return O2(e, r, t);
    if (typeof e == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var i = e.valueOf && e.valueOf();
    if (i != null && i !== e)
      return a.from(i, r, t);
    var n = Jr2(e);
    if (n)
      return n;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
      return a.from(e[Symbol.toPrimitive]("string"), r, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
  }
  a.from = function(e, r, t) {
    return wr(e, r, t);
  };
  Object.setPrototypeOf(a.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(a, Uint8Array);
  function yr(e) {
    if (typeof e != "number")
      throw new TypeError('"size" argument must be of type number');
    if (e < 0)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
  }
  function Xr(e, r, t) {
    return yr(e), e <= 0 ? I(e) : r !== void 0 ? typeof t == "string" ? I(e).fill(r, t) : I(e).fill(r) : I(e);
  }
  a.alloc = function(e, r, t) {
    return Xr(e, r, t);
  };
  function $(e) {
    return yr(e), I(e < 0 ? 0 : P5(e) | 0);
  }
  a.allocUnsafe = function(e) {
    return $(e);
  };
  a.allocUnsafeSlow = function(e) {
    return $(e);
  };
  function Gr2(e, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !a.isEncoding(r))
      throw new TypeError("Unknown encoding: " + r);
    var t = xr(e, r) | 0, i = I(t), n = i.write(e, r);
    return n !== t && (i = i.slice(0, n)), i;
  }
  function K5(e) {
    for (var r = e.length < 0 ? 0 : P5(e.length) | 0, t = I(r), i = 0; i < r; i += 1)
      t[i] = e[i] & 255;
    return t;
  }
  function zr(e) {
    if (A2(e, Uint8Array)) {
      var r = new Uint8Array(e);
      return O2(r.buffer, r.byteOffset, r.byteLength);
    }
    return K5(e);
  }
  function O2(e, r, t) {
    if (r < 0 || e.byteLength < r)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (e.byteLength < r + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var i;
    return r === void 0 && t === void 0 ? i = new Uint8Array(e) : t === void 0 ? i = new Uint8Array(e, r) : i = new Uint8Array(e, r, t), Object.setPrototypeOf(i, a.prototype), i;
  }
  function Jr2(e) {
    if (a.isBuffer(e)) {
      var r = P5(e.length) | 0, t = I(r);
      return t.length === 0 || e.copy(t, 0, 0, r), t;
    }
    if (e.length !== void 0)
      return typeof e.length != "number" || j3(e.length) ? I(0) : K5(e);
    if (e.type === "Buffer" && Array.isArray(e.data))
      return K5(e.data);
  }
  function P5(e) {
    if (e >= q2)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + q2.toString(16) + " bytes");
    return e | 0;
  }
  function Qr(e) {
    return +e != e && (e = 0), a.alloc(+e);
  }
  a.isBuffer = function(r) {
    return r != null && r._isBuffer === true && r !== a.prototype;
  };
  a.compare = function(r, t) {
    if (A2(r, Uint8Array) && (r = a.from(r, r.offset, r.byteLength)), A2(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), !a.isBuffer(r) || !a.isBuffer(t))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (r === t)
      return 0;
    for (var i = r.length, n = t.length, u = 0, o = Math.min(i, n); u < o; ++u)
      if (r[u] !== t[u]) {
        i = r[u], n = t[u];
        break;
      }
    return i < n ? -1 : n < i ? 1 : 0;
  };
  a.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  a.concat = function(r, t) {
    if (!Array.isArray(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0)
      return a.alloc(0);
    var i;
    if (t === void 0)
      for (t = 0, i = 0; i < r.length; ++i)
        t += r[i].length;
    var n = a.allocUnsafe(t), u = 0;
    for (i = 0; i < r.length; ++i) {
      var o = r[i];
      if (A2(o, Uint8Array))
        u + o.length > n.length ? a.from(o).copy(n, u) : Uint8Array.prototype.set.call(n, o, u);
      else if (a.isBuffer(o))
        o.copy(n, u);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      u += o.length;
    }
    return n;
  };
  function xr(e, r) {
    if (a.isBuffer(e))
      return e.length;
    if (ArrayBuffer.isView(e) || A2(e, ArrayBuffer))
      return e.byteLength;
    if (typeof e != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
    var t = e.length, i = arguments.length > 2 && arguments[2] === true;
    if (!i && t === 0)
      return 0;
    for (var n = false; ; )
      switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return Z2(e).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return Ar(e).length;
        default:
          if (n)
            return i ? -1 : Z2(e).length;
          r = ("" + r).toLowerCase(), n = true;
      }
  }
  a.byteLength = xr;
  function Vr(e, r, t) {
    var i = false;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
      return "";
    for (e || (e = "utf8"); ; )
      switch (e) {
        case "hex":
          return it(this, r, t);
        case "utf8":
        case "utf-8":
          return Er(this, r, t);
        case "ascii":
          return tt(this, r, t);
        case "latin1":
        case "binary":
          return et(this, r, t);
        case "base64":
          return jr2(this, r, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return nt(this, r, t);
        default:
          if (i)
            throw new TypeError("Unknown encoding: " + e);
          e = (e + "").toLowerCase(), i = true;
      }
  }
  a.prototype._isBuffer = true;
  function L2(e, r, t) {
    var i = e[r];
    e[r] = e[t], e[t] = i;
  }
  a.prototype.swap16 = function() {
    var r = this.length;
    if (r % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t = 0; t < r; t += 2)
      L2(this, t, t + 1);
    return this;
  };
  a.prototype.swap32 = function() {
    var r = this.length;
    if (r % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t = 0; t < r; t += 4)
      L2(this, t, t + 3), L2(this, t + 1, t + 2);
    return this;
  };
  a.prototype.swap64 = function() {
    var r = this.length;
    if (r % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t = 0; t < r; t += 8)
      L2(this, t, t + 7), L2(this, t + 1, t + 6), L2(this, t + 2, t + 5), L2(this, t + 3, t + 4);
    return this;
  };
  a.prototype.toString = function() {
    var r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? Er(this, 0, r) : Vr.apply(this, arguments);
  };
  a.prototype.toLocaleString = a.prototype.toString;
  a.prototype.equals = function(r) {
    if (!a.isBuffer(r))
      throw new TypeError("Argument must be a Buffer");
    return this === r ? true : a.compare(this, r) === 0;
  };
  a.prototype.inspect = function() {
    var r = "", t = M.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
  };
  cr && (a.prototype[cr] = a.prototype.inspect);
  a.prototype.compare = function(r, t, i, n, u) {
    if (A2(r, Uint8Array) && (r = a.from(r, r.offset, r.byteLength)), !a.isBuffer(r))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
    if (t === void 0 && (t = 0), i === void 0 && (i = r ? r.length : 0), n === void 0 && (n = 0), u === void 0 && (u = this.length), t < 0 || i > r.length || n < 0 || u > this.length)
      throw new RangeError("out of range index");
    if (n >= u && t >= i)
      return 0;
    if (n >= u)
      return -1;
    if (t >= i)
      return 1;
    if (t >>>= 0, i >>>= 0, n >>>= 0, u >>>= 0, this === r)
      return 0;
    for (var o = u - n, h2 = i - t, f = Math.min(o, h2), c2 = this.slice(n, u), l = r.slice(t, i), p2 = 0; p2 < f; ++p2)
      if (c2[p2] !== l[p2]) {
        o = c2[p2], h2 = l[p2];
        break;
      }
    return o < h2 ? -1 : h2 < o ? 1 : 0;
  };
  function mr(e, r, t, i, n) {
    if (e.length === 0)
      return -1;
    if (typeof t == "string" ? (i = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, j3(t) && (t = n ? 0 : e.length - 1), t < 0 && (t = e.length + t), t >= e.length) {
      if (n)
        return -1;
      t = e.length - 1;
    } else if (t < 0)
      if (n)
        t = 0;
      else
        return -1;
    if (typeof r == "string" && (r = a.from(r, i)), a.isBuffer(r))
      return r.length === 0 ? -1 : lr2(e, r, t, i, n);
    if (typeof r == "number")
      return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(e, r, t) : Uint8Array.prototype.lastIndexOf.call(e, r, t) : lr2(e, [r], t, i, n);
    throw new TypeError("val must be string, number or Buffer");
  }
  function lr2(e, r, t, i, n) {
    var u = 1, o = e.length, h2 = r.length;
    if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
      if (e.length < 2 || r.length < 2)
        return -1;
      u = 2, o /= 2, h2 /= 2, t /= 2;
    }
    function f(x, S2) {
      return u === 1 ? x[S2] : x.readUInt16BE(S2 * u);
    }
    var c2;
    if (n) {
      var l = -1;
      for (c2 = t; c2 < o; c2++)
        if (f(e, c2) === f(r, l === -1 ? 0 : c2 - l)) {
          if (l === -1 && (l = c2), c2 - l + 1 === h2)
            return l * u;
        } else
          l !== -1 && (c2 -= c2 - l), l = -1;
    } else
      for (t + h2 > o && (t = o - h2), c2 = t; c2 >= 0; c2--) {
        for (var p2 = true, E2 = 0; E2 < h2; E2++)
          if (f(e, c2 + E2) !== f(r, E2)) {
            p2 = false;
            break;
          }
        if (p2)
          return c2;
      }
    return -1;
  }
  a.prototype.includes = function(r, t, i) {
    return this.indexOf(r, t, i) !== -1;
  };
  a.prototype.indexOf = function(r, t, i) {
    return mr(this, r, t, i, true);
  };
  a.prototype.lastIndexOf = function(r, t, i) {
    return mr(this, r, t, i, false);
  };
  function Kr2(e, r, t, i) {
    t = Number(t) || 0;
    var n = e.length - t;
    i ? (i = Number(i), i > n && (i = n)) : i = n;
    var u = r.length;
    i > u / 2 && (i = u / 2);
    for (var o = 0; o < i; ++o) {
      var h2 = parseInt(r.substr(o * 2, 2), 16);
      if (j3(h2))
        return o;
      e[t + o] = h2;
    }
    return o;
  }
  function Or2(e, r, t, i) {
    return H2(Z2(r, e.length - t), e, t, i);
  }
  function Zr(e, r, t, i) {
    return H2(at(r), e, t, i);
  }
  function $r2(e, r, t, i) {
    return H2(Ar(r), e, t, i);
  }
  function Pr(e, r, t, i) {
    return H2(ht(r, e.length - t), e, t, i);
  }
  a.prototype.write = function(r, t, i, n) {
    if (t === void 0)
      n = "utf8", i = this.length, t = 0;
    else if (i === void 0 && typeof t == "string")
      n = t, i = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(i) ? (i = i >>> 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var u = this.length - t;
    if ((i === void 0 || i > u) && (i = u), r.length > 0 && (i < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    n || (n = "utf8");
    for (var o = false; ; )
      switch (n) {
        case "hex":
          return Kr2(this, r, t, i);
        case "utf8":
        case "utf-8":
          return Or2(this, r, t, i);
        case "ascii":
        case "latin1":
        case "binary":
          return Zr(this, r, t, i);
        case "base64":
          return $r2(this, r, t, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Pr(this, r, t, i);
        default:
          if (o)
            throw new TypeError("Unknown encoding: " + n);
          n = ("" + n).toLowerCase(), o = true;
      }
  };
  a.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function jr2(e, r, t) {
    return r === 0 && t === e.length ? V.fromByteArray(e) : V.fromByteArray(e.slice(r, t));
  }
  function Er(e, r, t) {
    t = Math.min(e.length, t);
    for (var i = [], n = r; n < t; ) {
      var u = e[n], o = null, h2 = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
      if (n + h2 <= t) {
        var f, c2, l, p2;
        switch (h2) {
          case 1:
            u < 128 && (o = u);
            break;
          case 2:
            f = e[n + 1], (f & 192) === 128 && (p2 = (u & 31) << 6 | f & 63, p2 > 127 && (o = p2));
            break;
          case 3:
            f = e[n + 1], c2 = e[n + 2], (f & 192) === 128 && (c2 & 192) === 128 && (p2 = (u & 15) << 12 | (f & 63) << 6 | c2 & 63, p2 > 2047 && (p2 < 55296 || p2 > 57343) && (o = p2));
            break;
          case 4:
            f = e[n + 1], c2 = e[n + 2], l = e[n + 3], (f & 192) === 128 && (c2 & 192) === 128 && (l & 192) === 128 && (p2 = (u & 15) << 18 | (f & 63) << 12 | (c2 & 63) << 6 | l & 63, p2 > 65535 && p2 < 1114112 && (o = p2));
        }
      }
      o === null ? (o = 65533, h2 = 1) : o > 65535 && (o -= 65536, i.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), i.push(o), n += h2;
    }
    return rt(i);
  }
  var sr = 4096;
  function rt(e) {
    var r = e.length;
    if (r <= sr)
      return String.fromCharCode.apply(String, e);
    for (var t = "", i = 0; i < r; )
      t += String.fromCharCode.apply(String, e.slice(i, i += sr));
    return t;
  }
  function tt(e, r, t) {
    var i = "";
    t = Math.min(e.length, t);
    for (var n = r; n < t; ++n)
      i += String.fromCharCode(e[n] & 127);
    return i;
  }
  function et(e, r, t) {
    var i = "";
    t = Math.min(e.length, t);
    for (var n = r; n < t; ++n)
      i += String.fromCharCode(e[n]);
    return i;
  }
  function it(e, r, t) {
    var i = e.length;
    (!r || r < 0) && (r = 0), (!t || t < 0 || t > i) && (t = i);
    for (var n = "", u = r; u < t; ++u)
      n += ft[e[u]];
    return n;
  }
  function nt(e, r, t) {
    for (var i = e.slice(r, t), n = "", u = 0; u < i.length - 1; u += 2)
      n += String.fromCharCode(i[u] + i[u + 1] * 256);
    return n;
  }
  a.prototype.slice = function(r, t) {
    var i = this.length;
    r = ~~r, t = t === void 0 ? i : ~~t, r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), t < r && (t = r);
    var n = this.subarray(r, t);
    return Object.setPrototypeOf(n, a.prototype), n;
  };
  function w(e, r, t) {
    if (e % 1 !== 0 || e < 0)
      throw new RangeError("offset is not uint");
    if (e + r > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(r, t, i) {
    r = r >>> 0, t = t >>> 0, i || w(r, t, this.length);
    for (var n = this[r], u = 1, o = 0; ++o < t && (u *= 256); )
      n += this[r + o] * u;
    return n;
  };
  a.prototype.readUintBE = a.prototype.readUIntBE = function(r, t, i) {
    r = r >>> 0, t = t >>> 0, i || w(r, t, this.length);
    for (var n = this[r + --t], u = 1; t > 0 && (u *= 256); )
      n += this[r + --t] * u;
    return n;
  };
  a.prototype.readUint8 = a.prototype.readUInt8 = function(r, t) {
    return r = r >>> 0, t || w(r, 1, this.length), this[r];
  };
  a.prototype.readUint16LE = a.prototype.readUInt16LE = function(r, t) {
    return r = r >>> 0, t || w(r, 2, this.length), this[r] | this[r + 1] << 8;
  };
  a.prototype.readUint16BE = a.prototype.readUInt16BE = function(r, t) {
    return r = r >>> 0, t || w(r, 2, this.length), this[r] << 8 | this[r + 1];
  };
  a.prototype.readUint32LE = a.prototype.readUInt32LE = function(r, t) {
    return r = r >>> 0, t || w(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  };
  a.prototype.readUint32BE = a.prototype.readUInt32BE = function(r, t) {
    return r = r >>> 0, t || w(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  };
  a.prototype.readIntLE = function(r, t, i) {
    r = r >>> 0, t = t >>> 0, i || w(r, t, this.length);
    for (var n = this[r], u = 1, o = 0; ++o < t && (u *= 256); )
      n += this[r + o] * u;
    return u *= 128, n >= u && (n -= Math.pow(2, 8 * t)), n;
  };
  a.prototype.readIntBE = function(r, t, i) {
    r = r >>> 0, t = t >>> 0, i || w(r, t, this.length);
    for (var n = t, u = 1, o = this[r + --n]; n > 0 && (u *= 256); )
      o += this[r + --n] * u;
    return u *= 128, o >= u && (o -= Math.pow(2, 8 * t)), o;
  };
  a.prototype.readInt8 = function(r, t) {
    return r = r >>> 0, t || w(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  };
  a.prototype.readInt16LE = function(r, t) {
    r = r >>> 0, t || w(r, 2, this.length);
    var i = this[r] | this[r + 1] << 8;
    return i & 32768 ? i | 4294901760 : i;
  };
  a.prototype.readInt16BE = function(r, t) {
    r = r >>> 0, t || w(r, 2, this.length);
    var i = this[r + 1] | this[r] << 8;
    return i & 32768 ? i | 4294901760 : i;
  };
  a.prototype.readInt32LE = function(r, t) {
    return r = r >>> 0, t || w(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  };
  a.prototype.readInt32BE = function(r, t) {
    return r = r >>> 0, t || w(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  };
  a.prototype.readFloatLE = function(r, t) {
    return r = r >>> 0, t || w(r, 4, this.length), _2.read(this, r, true, 23, 4);
  };
  a.prototype.readFloatBE = function(r, t) {
    return r = r >>> 0, t || w(r, 4, this.length), _2.read(this, r, false, 23, 4);
  };
  a.prototype.readDoubleLE = function(r, t) {
    return r = r >>> 0, t || w(r, 8, this.length), _2.read(this, r, true, 52, 8);
  };
  a.prototype.readDoubleBE = function(r, t) {
    return r = r >>> 0, t || w(r, 8, this.length), _2.read(this, r, false, 52, 8);
  };
  function y2(e, r, t, i, n, u) {
    if (!a.isBuffer(e))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > n || r < u)
      throw new RangeError('"value" argument is out of bounds');
    if (t + i > e.length)
      throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(r, t, i, n) {
    if (r = +r, t = t >>> 0, i = i >>> 0, !n) {
      var u = Math.pow(2, 8 * i) - 1;
      y2(this, r, t, i, u, 0);
    }
    var o = 1, h2 = 0;
    for (this[t] = r & 255; ++h2 < i && (o *= 256); )
      this[t + h2] = r / o & 255;
    return t + i;
  };
  a.prototype.writeUintBE = a.prototype.writeUIntBE = function(r, t, i, n) {
    if (r = +r, t = t >>> 0, i = i >>> 0, !n) {
      var u = Math.pow(2, 8 * i) - 1;
      y2(this, r, t, i, u, 0);
    }
    var o = i - 1, h2 = 1;
    for (this[t + o] = r & 255; --o >= 0 && (h2 *= 256); )
      this[t + o] = r / h2 & 255;
    return t + i;
  };
  a.prototype.writeUint8 = a.prototype.writeUInt8 = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
  };
  a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
  };
  a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  a.prototype.writeIntLE = function(r, t, i, n) {
    if (r = +r, t = t >>> 0, !n) {
      var u = Math.pow(2, 8 * i - 1);
      y2(this, r, t, i, u - 1, -u);
    }
    var o = 0, h2 = 1, f = 0;
    for (this[t] = r & 255; ++o < i && (h2 *= 256); )
      r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / h2 >> 0) - f & 255;
    return t + i;
  };
  a.prototype.writeIntBE = function(r, t, i, n) {
    if (r = +r, t = t >>> 0, !n) {
      var u = Math.pow(2, 8 * i - 1);
      y2(this, r, t, i, u - 1, -u);
    }
    var o = i - 1, h2 = 1, f = 0;
    for (this[t + o] = r & 255; --o >= 0 && (h2 *= 256); )
      r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / h2 >> 0) - f & 255;
    return t + i;
  };
  a.prototype.writeInt8 = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
  };
  a.prototype.writeInt16LE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  a.prototype.writeInt16BE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  a.prototype.writeInt32LE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
  };
  a.prototype.writeInt32BE = function(r, t, i) {
    return r = +r, t = t >>> 0, i || y2(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  function Fr(e, r, t, i, n, u) {
    if (t + i > e.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function gr(e, r, t, i, n) {
    return r = +r, t = t >>> 0, n || Fr(e, r, t, 4), _2.write(e, r, t, i, 23, 4), t + 4;
  }
  a.prototype.writeFloatLE = function(r, t, i) {
    return gr(this, r, t, true, i);
  };
  a.prototype.writeFloatBE = function(r, t, i) {
    return gr(this, r, t, false, i);
  };
  function Br2(e, r, t, i, n) {
    return r = +r, t = t >>> 0, n || Fr(e, r, t, 8), _2.write(e, r, t, i, 52, 8), t + 8;
  }
  a.prototype.writeDoubleLE = function(r, t, i) {
    return Br2(this, r, t, true, i);
  };
  a.prototype.writeDoubleBE = function(r, t, i) {
    return Br2(this, r, t, false, i);
  };
  a.prototype.copy = function(r, t, i, n) {
    if (!a.isBuffer(r))
      throw new TypeError("argument should be a Buffer");
    if (i || (i = 0), !n && n !== 0 && (n = this.length), t >= r.length && (t = r.length), t || (t = 0), n > 0 && n < i && (n = i), n === i || r.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (i < 0 || i >= this.length)
      throw new RangeError("Index out of range");
    if (n < 0)
      throw new RangeError("sourceEnd out of bounds");
    n > this.length && (n = this.length), r.length - t < n - i && (n = r.length - t + i);
    var u = n - i;
    return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, i, n) : Uint8Array.prototype.set.call(r, this.subarray(i, n), t), u;
  };
  a.prototype.fill = function(r, t, i, n) {
    if (typeof r == "string") {
      if (typeof t == "string" ? (n = t, t = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== void 0 && typeof n != "string")
        throw new TypeError("encoding must be a string");
      if (typeof n == "string" && !a.isEncoding(n))
        throw new TypeError("Unknown encoding: " + n);
      if (r.length === 1) {
        var u = r.charCodeAt(0);
        (n === "utf8" && u < 128 || n === "latin1") && (r = u);
      }
    } else
      typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (t < 0 || this.length < t || this.length < i)
      throw new RangeError("Out of range index");
    if (i <= t)
      return this;
    t = t >>> 0, i = i === void 0 ? this.length : i >>> 0, r || (r = 0);
    var o;
    if (typeof r == "number")
      for (o = t; o < i; ++o)
        this[o] = r;
    else {
      var h2 = a.isBuffer(r) ? r : a.from(r, n), f = h2.length;
      if (f === 0)
        throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (o = 0; o < i - t; ++o)
        this[o + t] = h2[o % f];
    }
    return this;
  };
  var ut2 = /[^+/0-9A-Za-z-_]/g;
  function ot(e) {
    if (e = e.split("=")[0], e = e.trim().replace(ut2, ""), e.length < 2)
      return "";
    for (; e.length % 4 !== 0; )
      e = e + "=";
    return e;
  }
  function Z2(e, r) {
    r = r || 1 / 0;
    for (var t, i = e.length, n = null, u = [], o = 0; o < i; ++o) {
      if (t = e.charCodeAt(o), t > 55295 && t < 57344) {
        if (!n) {
          if (t > 56319) {
            (r -= 3) > -1 && u.push(239, 191, 189);
            continue;
          } else if (o + 1 === i) {
            (r -= 3) > -1 && u.push(239, 191, 189);
            continue;
          }
          n = t;
          continue;
        }
        if (t < 56320) {
          (r -= 3) > -1 && u.push(239, 191, 189), n = t;
          continue;
        }
        t = (n - 55296 << 10 | t - 56320) + 65536;
      } else
        n && (r -= 3) > -1 && u.push(239, 191, 189);
      if (n = null, t < 128) {
        if ((r -= 1) < 0)
          break;
        u.push(t);
      } else if (t < 2048) {
        if ((r -= 2) < 0)
          break;
        u.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((r -= 3) < 0)
          break;
        u.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((r -= 4) < 0)
          break;
        u.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return u;
  }
  function at(e) {
    for (var r = [], t = 0; t < e.length; ++t)
      r.push(e.charCodeAt(t) & 255);
    return r;
  }
  function ht(e, r) {
    for (var t, i, n, u = [], o = 0; o < e.length && !((r -= 2) < 0); ++o)
      t = e.charCodeAt(o), i = t >> 8, n = t % 256, u.push(n), u.push(i);
    return u;
  }
  function Ar(e) {
    return V.toByteArray(ot(e));
  }
  function H2(e, r, t, i) {
    for (var n = 0; n < i && !(n + t >= r.length || n >= e.length); ++n)
      r[n + t] = e[n];
    return n;
  }
  function A2(e, r) {
    return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
  }
  function j3(e) {
    return e !== e;
  }
  var ft = function() {
    for (var e = "0123456789abcdef", r = new Array(256), t = 0; t < 16; ++t)
      for (var i = t * 16, n = 0; n < 16; ++n)
        r[i + n] = e[t] + e[n];
    return r;
  }();
});
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var St = k((S0, Nm) => {
  U();
  var Fd = or(), ji = Fd.Buffer;
  function Bm(t, e) {
    for (var r in t)
      e[r] = t[r];
  }
  ji.from && ji.alloc && ji.allocUnsafe && ji.allocUnsafeSlow ? Nm.exports = Fd : (Bm(Fd, S0), S0.Buffer = ys);
  function ys(t, e, r) {
    return ji(t, e, r);
  }
  ys.prototype = Object.create(ji.prototype);
  Bm(ji, ys);
  ys.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError("Argument must not be a number");
    return ji(t, e, r);
  };
  ys.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    var i = ji(t);
    return e !== void 0 ? typeof r == "string" ? i.fill(e, r) : i.fill(e) : i.fill(0), i;
  };
  ys.allocUnsafe = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return ji(t);
  };
  ys.allocUnsafeSlow = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return Fd.SlowBuffer(t);
  };
});
var bs = k((Vk, I0) => {
  U();
  var M0 = 65536, J8 = 4294967295;
  function Z8() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var X8 = St().Buffer, Rd = N.crypto || N.msCrypto;
  Rd && Rd.getRandomValues ? I0.exports = Q8 : I0.exports = Z8;
  function Q8(t, e) {
    if (t > J8)
      throw new RangeError("requested too many random bytes");
    var r = X8.allocUnsafe(t);
    if (t > 0)
      if (t > M0)
        for (var i = 0; i < t; i += M0)
          Rd.getRandomValues(r.slice(i, i + M0));
      else
        Rd.getRandomValues(r);
    return typeof e == "function" ? W.default.nextTick(function() {
      e(null, r);
    }) : r;
  }
});
var At = k((Yk, T0) => {
  U();
  typeof Object.create == "function" ? T0.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : T0.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var i = function() {
      };
      i.prototype = r.prototype, e.prototype = new i(), e.prototype.constructor = e;
    }
  };
});
var Bd = k((Jk, F0) => {
  U();
  var No = typeof Reflect == "object" ? Reflect : null, Cm = No && typeof No.apply == "function" ? No.apply : function(e, r, i) {
    return Function.prototype.apply.call(e, r, i);
  }, kd;
  No && typeof No.ownKeys == "function" ? kd = No.ownKeys : Object.getOwnPropertySymbols ? kd = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : kd = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  function e5(t) {
    console && console.warn && console.warn(t);
  }
  var jm = Number.isNaN || function(e) {
    return e !== e;
  };
  function Vt() {
    Vt.init.call(this);
  }
  F0.exports = Vt;
  F0.exports.once = n5;
  Vt.EventEmitter = Vt;
  Vt.prototype._events = void 0;
  Vt.prototype._eventsCount = 0;
  Vt.prototype._maxListeners = void 0;
  var Om = 10;
  function Dd(t) {
    if (typeof t != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
  }
  Object.defineProperty(Vt, "defaultMaxListeners", { enumerable: true, get: function() {
    return Om;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || jm(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    Om = t;
  } });
  Vt.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  Vt.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || jm(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  function Lm(t) {
    return t._maxListeners === void 0 ? Vt.defaultMaxListeners : t._maxListeners;
  }
  Vt.prototype.getMaxListeners = function() {
    return Lm(this);
  };
  Vt.prototype.emit = function(e) {
    for (var r = [], i = 1; i < arguments.length; i++)
      r.push(arguments[i]);
    var n = e === "error", s2 = this._events;
    if (s2 !== void 0)
      n = n && s2.error === void 0;
    else if (!n)
      return false;
    if (n) {
      var o;
      if (r.length > 0 && (o = r[0]), o instanceof Error)
        throw o;
      var f = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
      throw f.context = o, f;
    }
    var l = s2[e];
    if (l === void 0)
      return false;
    if (typeof l == "function")
      Cm(l, this, r);
    else
      for (var m3 = l.length, A2 = Hm(l, m3), i = 0; i < m3; ++i)
        Cm(A2[i], this, r);
    return true;
  };
  function qm(t, e, r, i) {
    var n, s2, o;
    if (Dd(r), s2 = t._events, s2 === void 0 ? (s2 = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s2.newListener !== void 0 && (t.emit("newListener", e, r.listener ? r.listener : r), s2 = t._events), o = s2[e]), o === void 0)
      o = s2[e] = r, ++t._eventsCount;
    else if (typeof o == "function" ? o = s2[e] = i ? [r, o] : [o, r] : i ? o.unshift(r) : o.push(r), n = Lm(t), n > 0 && o.length > n && !o.warned) {
      o.warned = true;
      var f = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      f.name = "MaxListenersExceededWarning", f.emitter = t, f.type = e, f.count = o.length, e5(f);
    }
    return t;
  }
  Vt.prototype.addListener = function(e, r) {
    return qm(this, e, r, false);
  };
  Vt.prototype.on = Vt.prototype.addListener;
  Vt.prototype.prependListener = function(e, r) {
    return qm(this, e, r, true);
  };
  function t5() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function Pm(t, e, r) {
    var i = { fired: false, wrapFn: void 0, target: t, type: e, listener: r }, n = t5.bind(i);
    return n.listener = r, i.wrapFn = n, n;
  }
  Vt.prototype.once = function(e, r) {
    return Dd(r), this.on(e, Pm(this, e, r)), this;
  };
  Vt.prototype.prependOnceListener = function(e, r) {
    return Dd(r), this.prependListener(e, Pm(this, e, r)), this;
  };
  Vt.prototype.removeListener = function(e, r) {
    var i, n, s2, o, f;
    if (Dd(r), n = this._events, n === void 0)
      return this;
    if (i = n[e], i === void 0)
      return this;
    if (i === r || i.listener === r)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, i.listener || r));
    else if (typeof i != "function") {
      for (s2 = -1, o = i.length - 1; o >= 0; o--)
        if (i[o] === r || i[o].listener === r) {
          f = i[o].listener, s2 = o;
          break;
        }
      if (s2 < 0)
        return this;
      s2 === 0 ? i.shift() : r5(i, s2), i.length === 1 && (n[e] = i[0]), n.removeListener !== void 0 && this.emit("removeListener", e, f || r);
    }
    return this;
  };
  Vt.prototype.off = Vt.prototype.removeListener;
  Vt.prototype.removeAllListeners = function(e) {
    var r, i, n;
    if (i = this._events, i === void 0)
      return this;
    if (i.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[e]), this;
    if (arguments.length === 0) {
      var s2 = Object.keys(i), o;
      for (n = 0; n < s2.length; ++n)
        o = s2[n], o !== "removeListener" && this.removeAllListeners(o);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (r = i[e], typeof r == "function")
      this.removeListener(e, r);
    else if (r !== void 0)
      for (n = r.length - 1; n >= 0; n--)
        this.removeListener(e, r[n]);
    return this;
  };
  function Um(t, e, r) {
    var i = t._events;
    if (i === void 0)
      return [];
    var n = i[e];
    return n === void 0 ? [] : typeof n == "function" ? r ? [n.listener || n] : [n] : r ? i5(n) : Hm(n, n.length);
  }
  Vt.prototype.listeners = function(e) {
    return Um(this, e, true);
  };
  Vt.prototype.rawListeners = function(e) {
    return Um(this, e, false);
  };
  Vt.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : zm.call(t, e);
  };
  Vt.prototype.listenerCount = zm;
  function zm(t) {
    var e = this._events;
    if (e !== void 0) {
      var r = e[t];
      if (typeof r == "function")
        return 1;
      if (r !== void 0)
        return r.length;
    }
    return 0;
  }
  Vt.prototype.eventNames = function() {
    return this._eventsCount > 0 ? kd(this._events) : [];
  };
  function Hm(t, e) {
    for (var r = new Array(e), i = 0; i < e; ++i)
      r[i] = t[i];
    return r;
  }
  function r5(t, e) {
    for (; e + 1 < t.length; e++)
      t[e] = t[e + 1];
    t.pop();
  }
  function i5(t) {
    for (var e = new Array(t.length), r = 0; r < e.length; ++r)
      e[r] = t[r].listener || t[r];
    return e;
  }
  function n5(t, e) {
    return new Promise(function(r, i) {
      function n(o) {
        t.removeListener(e, s2), i(o);
      }
      function s2() {
        typeof t.removeListener == "function" && t.removeListener("error", n), r([].slice.call(arguments));
      }
      $m(t, e, s2, { once: true }), e !== "error" && s5(t, n, { once: true });
    });
  }
  function s5(t, e, r) {
    typeof t.on == "function" && $m(t, "error", e, r);
  }
  function $m(t, e, r, i) {
    if (typeof t.on == "function")
      i.once ? t.once(e, r) : t.on(e, r);
    else if (typeof t.addEventListener == "function")
      t.addEventListener(e, function n(s2) {
        i.once && t.removeEventListener(e, n), r(s2);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
  }
});
var R0 = k((Zk, Gm) => {
  U();
  Gm.exports = Bd().EventEmitter;
});
var k0 = k((Xk, Km) => {
  U();
  Km.exports = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return false;
    if (typeof Symbol.iterator == "symbol")
      return true;
    var e = {}, r = Symbol("test"), i = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
      return false;
    var n = 42;
    e[r] = n;
    for (r in e)
      return false;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return false;
    var s2 = Object.getOwnPropertySymbols(e);
    if (s2.length !== 1 || s2[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r))
      return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = Object.getOwnPropertyDescriptor(e, r);
      if (o.value !== n || o.enumerable !== true)
        return false;
    }
    return true;
  };
});
var Bf = k((Qk, Wm) => {
  U();
  var o5 = k0();
  Wm.exports = function() {
    return o5() && !!Symbol.toStringTag;
  };
});
var Jm = k((eD, Ym) => {
  U();
  var Vm = typeof Symbol < "u" && Symbol, a5 = k0();
  Ym.exports = function() {
    return typeof Vm != "function" || typeof Symbol != "function" || typeof Vm("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : a5();
  };
});
var Qm = k((tD, Xm) => {
  U();
  var Zm = { foo: {} }, f5 = Object;
  Xm.exports = function() {
    return { __proto__: Zm }.foo === Zm.foo && !({ __proto__: null } instanceof f5);
  };
});
var ty = k((rD, ey) => {
  U();
  var c5 = "Function.prototype.bind called on incompatible ", D0 = Array.prototype.slice, u5 = Object.prototype.toString, d5 = "[object Function]";
  ey.exports = function(e) {
    var r = this;
    if (typeof r != "function" || u5.call(r) !== d5)
      throw new TypeError(c5 + r);
    for (var i = D0.call(arguments, 1), n, s2 = function() {
      if (this instanceof n) {
        var A2 = r.apply(this, i.concat(D0.call(arguments)));
        return Object(A2) === A2 ? A2 : this;
      } else
        return r.apply(e, i.concat(D0.call(arguments)));
    }, o = Math.max(0, r.length - i.length), f = [], l = 0; l < o; l++)
      f.push("$" + l);
    if (n = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(s2), r.prototype) {
      var m3 = function() {
      };
      m3.prototype = r.prototype, n.prototype = new m3(), m3.prototype = null;
    }
    return n;
  };
});
var Nd = k((iD, ry) => {
  U();
  var l5 = ty();
  ry.exports = Function.prototype.bind || l5;
});
var ny = k((nD, iy) => {
  U();
  var h5 = Nd();
  iy.exports = h5.call(Function.call, Object.prototype.hasOwnProperty);
});
var jd = k((sD, cy) => {
  U();
  var Dt, Lo = SyntaxError, fy = Function, jo = TypeError, B0 = function(t) {
    try {
      return fy('"use strict"; return (' + t + ").constructor;")();
    } catch {
    }
  }, vs = Object.getOwnPropertyDescriptor;
  if (vs)
    try {
      vs({}, "");
    } catch {
      vs = null;
    }
  var N0 = function() {
    throw new jo();
  }, p5 = vs ? function() {
    try {
      return arguments.callee, N0;
    } catch {
      try {
        return vs(arguments, "callee").get;
      } catch {
        return N0;
      }
    }
  }() : N0, Co = Jm()(), g5 = Qm()(), gr = Object.getPrototypeOf || (g5 ? function(t) {
    return t.__proto__;
  } : null), Oo = {}, m5 = typeof Uint8Array > "u" || !gr ? Dt : gr(Uint8Array), ws = { "%AggregateError%": typeof AggregateError > "u" ? Dt : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Dt : ArrayBuffer, "%ArrayIteratorPrototype%": Co && gr ? gr([][Symbol.iterator]()) : Dt, "%AsyncFromSyncIteratorPrototype%": Dt, "%AsyncFunction%": Oo, "%AsyncGenerator%": Oo, "%AsyncGeneratorFunction%": Oo, "%AsyncIteratorPrototype%": Oo, "%Atomics%": typeof Atomics > "u" ? Dt : Atomics, "%BigInt%": typeof BigInt > "u" ? Dt : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? Dt : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? Dt : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? Dt : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? Dt : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? Dt : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Dt : FinalizationRegistry, "%Function%": fy, "%GeneratorFunction%": Oo, "%Int8Array%": typeof Int8Array > "u" ? Dt : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? Dt : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? Dt : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": Co && gr ? gr(gr([][Symbol.iterator]())) : Dt, "%JSON%": typeof JSON == "object" ? JSON : Dt, "%Map%": typeof Map > "u" ? Dt : Map, "%MapIteratorPrototype%": typeof Map > "u" || !Co || !gr ? Dt : gr((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? Dt : Promise, "%Proxy%": typeof Proxy > "u" ? Dt : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? Dt : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? Dt : Set, "%SetIteratorPrototype%": typeof Set > "u" || !Co || !gr ? Dt : gr((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Dt : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": Co && gr ? gr(""[Symbol.iterator]()) : Dt, "%Symbol%": Co ? Symbol : Dt, "%SyntaxError%": Lo, "%ThrowTypeError%": p5, "%TypedArray%": m5, "%TypeError%": jo, "%Uint8Array%": typeof Uint8Array > "u" ? Dt : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Dt : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? Dt : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? Dt : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? Dt : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? Dt : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? Dt : WeakSet };
  if (gr)
    try {
      null.error;
    } catch (t) {
      sy = gr(gr(t)), ws["%Error.prototype%"] = sy;
    }
  var sy, y5 = function t(e) {
    var r;
    if (e === "%AsyncFunction%")
      r = B0("async function () {}");
    else if (e === "%GeneratorFunction%")
      r = B0("function* () {}");
    else if (e === "%AsyncGeneratorFunction%")
      r = B0("async function* () {}");
    else if (e === "%AsyncGenerator%") {
      var i = t("%AsyncGeneratorFunction%");
      i && (r = i.prototype);
    } else if (e === "%AsyncIteratorPrototype%") {
      var n = t("%AsyncGenerator%");
      n && gr && (r = gr(n.prototype));
    }
    return ws[e] = r, r;
  }, oy = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, Nf = Nd(), Cd = ny(), b5 = Nf.call(Function.call, Array.prototype.concat), v5 = Nf.call(Function.apply, Array.prototype.splice), ay = Nf.call(Function.call, String.prototype.replace), Od = Nf.call(Function.call, String.prototype.slice), w5 = Nf.call(Function.call, RegExp.prototype.exec), x5 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, _5 = /\\(\\)?/g, A5 = function(e) {
    var r = Od(e, 0, 1), i = Od(e, -1);
    if (r === "%" && i !== "%")
      throw new Lo("invalid intrinsic syntax, expected closing `%`");
    if (i === "%" && r !== "%")
      throw new Lo("invalid intrinsic syntax, expected opening `%`");
    var n = [];
    return ay(e, x5, function(s2, o, f, l) {
      n[n.length] = f ? ay(l, _5, "$1") : o || s2;
    }), n;
  }, E5 = function(e, r) {
    var i = e, n;
    if (Cd(oy, i) && (n = oy[i], i = "%" + n[0] + "%"), Cd(ws, i)) {
      var s2 = ws[i];
      if (s2 === Oo && (s2 = y5(i)), typeof s2 > "u" && !r)
        throw new jo("intrinsic " + e + " exists, but is not available. Please file an issue!");
      return { alias: n, name: i, value: s2 };
    }
    throw new Lo("intrinsic " + e + " does not exist!");
  };
  cy.exports = function(e, r) {
    if (typeof e != "string" || e.length === 0)
      throw new jo("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof r != "boolean")
      throw new jo('"allowMissing" argument must be a boolean');
    if (w5(/^%?[^%]*%?$/, e) === null)
      throw new Lo("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var i = A5(e), n = i.length > 0 ? i[0] : "", s2 = E5("%" + n + "%", r), o = s2.name, f = s2.value, l = false, m3 = s2.alias;
    m3 && (n = m3[0], v5(i, b5([0, 1], m3)));
    for (var A2 = 1, F3 = true; A2 < i.length; A2 += 1) {
      var z3 = i[A2], V = Od(z3, 0, 1), $ = Od(z3, -1);
      if ((V === '"' || V === "'" || V === "`" || $ === '"' || $ === "'" || $ === "`") && V !== $)
        throw new Lo("property names with quotes must have matching quotes");
      if ((z3 === "constructor" || !F3) && (l = true), n += "." + z3, o = "%" + n + "%", Cd(ws, o))
        f = ws[o];
      else if (f != null) {
        if (!(z3 in f)) {
          if (!r)
            throw new jo("base intrinsic for " + e + " exists, but the property is not available.");
          return;
        }
        if (vs && A2 + 1 >= i.length) {
          var re = vs(f, z3);
          F3 = !!re, F3 && "get" in re && !("originalValue" in re.get) ? f = re.get : f = f[z3];
        } else
          F3 = Cd(f, z3), f = f[z3];
        F3 && !l && (ws[o] = f);
      }
    }
    return f;
  };
});
var gy = k((oD, Ld) => {
  U();
  var C0 = Nd(), qo = jd(), ly = qo("%Function.prototype.apply%"), hy = qo("%Function.prototype.call%"), py = qo("%Reflect.apply%", true) || C0.call(hy, ly), uy = qo("%Object.getOwnPropertyDescriptor%", true), xs = qo("%Object.defineProperty%", true), S5 = qo("%Math.max%");
  if (xs)
    try {
      xs({}, "a", { value: 1 });
    } catch {
      xs = null;
    }
  Ld.exports = function(e) {
    var r = py(C0, hy, arguments);
    if (uy && xs) {
      var i = uy(r, "length");
      i.configurable && xs(r, "length", { value: 1 + S5(0, e.length - (arguments.length - 1)) });
    }
    return r;
  };
  var dy = function() {
    return py(C0, ly, arguments);
  };
  xs ? xs(Ld.exports, "apply", { value: dy }) : Ld.exports.apply = dy;
});
var qd = k((aD, by) => {
  U();
  var my = jd(), yy = gy(), M5 = yy(my("String.prototype.indexOf"));
  by.exports = function(e, r) {
    var i = my(e, !!r);
    return typeof i == "function" && M5(e, ".prototype.") > -1 ? yy(i) : i;
  };
});
var xy = k((fD, wy) => {
  U();
  var I5 = Bf()(), T5 = qd(), O0 = T5("Object.prototype.toString"), Pd = function(e) {
    return I5 && e && typeof e == "object" && Symbol.toStringTag in e ? false : O0(e) === "[object Arguments]";
  }, vy = function(e) {
    return Pd(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && O0(e) !== "[object Array]" && O0(e.callee) === "[object Function]";
  }, F5 = function() {
    return Pd(arguments);
  }();
  Pd.isLegacyArguments = vy;
  wy.exports = F5 ? Pd : vy;
});
var Ey = k((cD, Ay) => {
  U();
  var R5 = Object.prototype.toString, k5 = Function.prototype.toString, D5 = /^\s*(?:function)?\*/, _y = Bf()(), j0 = Object.getPrototypeOf, B5 = function() {
    if (!_y)
      return false;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, L0;
  Ay.exports = function(e) {
    if (typeof e != "function")
      return false;
    if (D5.test(k5.call(e)))
      return true;
    if (!_y) {
      var r = R5.call(e);
      return r === "[object GeneratorFunction]";
    }
    if (!j0)
      return false;
    if (typeof L0 > "u") {
      var i = B5();
      L0 = i ? j0(i) : false;
    }
    return j0(e) === L0;
  };
});
var Ty = k((uD, Iy) => {
  U();
  var My = Function.prototype.toString, Po = typeof Reflect == "object" && Reflect !== null && Reflect.apply, P0, Ud;
  if (typeof Po == "function" && typeof Object.defineProperty == "function")
    try {
      P0 = Object.defineProperty({}, "length", { get: function() {
        throw Ud;
      } }), Ud = {}, Po(function() {
        throw 42;
      }, null, P0);
    } catch (t) {
      t !== Ud && (Po = null);
    }
  else
    Po = null;
  var N5 = /^\s*class\b/, U0 = function(e) {
    try {
      var r = My.call(e);
      return N5.test(r);
    } catch {
      return false;
    }
  }, q0 = function(e) {
    try {
      return U0(e) ? false : (My.call(e), true);
    } catch {
      return false;
    }
  }, zd = Object.prototype.toString, C5 = "[object Object]", O5 = "[object Function]", j5 = "[object GeneratorFunction]", L5 = "[object HTMLAllCollection]", q5 = "[object HTML document.all class]", P5 = "[object HTMLCollection]", U5 = typeof Symbol == "function" && !!Symbol.toStringTag, z5 = !(0 in [,]), z0 = function() {
    return false;
  };
  typeof document == "object" && (Sy = document.all, zd.call(Sy) === zd.call(document.all) && (z0 = function(e) {
    if ((z5 || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var r = zd.call(e);
        return (r === L5 || r === q5 || r === P5 || r === C5) && e("") == null;
      } catch {
      }
    return false;
  }));
  var Sy;
  Iy.exports = Po ? function(e) {
    if (z0(e))
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    try {
      Po(e, null, P0);
    } catch (r) {
      if (r !== Ud)
        return false;
    }
    return !U0(e) && q0(e);
  } : function(e) {
    if (z0(e))
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    if (U5)
      return q0(e);
    if (U0(e))
      return false;
    var r = zd.call(e);
    return r !== O5 && r !== j5 && !/^\[object HTML/.test(r) ? false : q0(e);
  };
});
var H0 = k((dD, Ry) => {
  U();
  var H5 = Ty(), $5 = Object.prototype.toString, Fy = Object.prototype.hasOwnProperty, G5 = function(e, r, i) {
    for (var n = 0, s2 = e.length; n < s2; n++)
      Fy.call(e, n) && (i == null ? r(e[n], n, e) : r.call(i, e[n], n, e));
  }, K5 = function(e, r, i) {
    for (var n = 0, s2 = e.length; n < s2; n++)
      i == null ? r(e.charAt(n), n, e) : r.call(i, e.charAt(n), n, e);
  }, W5 = function(e, r, i) {
    for (var n in e)
      Fy.call(e, n) && (i == null ? r(e[n], n, e) : r.call(i, e[n], n, e));
  }, V5 = function(e, r, i) {
    if (!H5(r))
      throw new TypeError("iterator must be a function");
    var n;
    arguments.length >= 3 && (n = i), $5.call(e) === "[object Array]" ? G5(e, r, n) : typeof e == "string" ? K5(e, r, n) : W5(e, r, n);
  };
  Ry.exports = V5;
});
var G0 = k((lD, ky) => {
  U();
  var $0 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], Y5 = typeof globalThis > "u" ? N : globalThis;
  ky.exports = function() {
    for (var e = [], r = 0; r < $0.length; r++)
      typeof Y5[$0[r]] == "function" && (e[e.length] = $0[r]);
    return e;
  };
});
var K0 = k((hD, Dy) => {
  U();
  var J5 = jd(), Hd = J5("%Object.getOwnPropertyDescriptor%", true);
  if (Hd)
    try {
      Hd([], "length");
    } catch {
      Hd = null;
    }
  Dy.exports = Hd;
});
var Y0 = k((pD, jy) => {
  U();
  var By = H0(), Z5 = G0(), V0 = qd(), X5 = V0("Object.prototype.toString"), Ny = Bf()(), $d = K0(), Q5 = typeof globalThis > "u" ? N : globalThis, Cy = Z5(), e_ = V0("Array.prototype.indexOf", true) || function(e, r) {
    for (var i = 0; i < e.length; i += 1)
      if (e[i] === r)
        return i;
    return -1;
  }, t_ = V0("String.prototype.slice"), Oy = {}, W0 = Object.getPrototypeOf;
  Ny && $d && W0 && By(Cy, function(t) {
    var e = new Q5[t]();
    if (Symbol.toStringTag in e) {
      var r = W0(e), i = $d(r, Symbol.toStringTag);
      if (!i) {
        var n = W0(r);
        i = $d(n, Symbol.toStringTag);
      }
      Oy[t] = i.get;
    }
  });
  var r_ = function(e) {
    var r = false;
    return By(Oy, function(i, n) {
      if (!r)
        try {
          r = i.call(e) === n;
        } catch {
        }
    }), r;
  };
  jy.exports = function(e) {
    if (!e || typeof e != "object")
      return false;
    if (!Ny || !(Symbol.toStringTag in e)) {
      var r = t_(X5(e), 8, -1);
      return e_(Cy, r) > -1;
    }
    return $d ? r_(e) : false;
  };
});
var $y = k((gD, Hy) => {
  U();
  var qy = H0(), i_ = G0(), Py = qd(), J0 = K0(), n_ = Py("Object.prototype.toString"), Uy = Bf()(), Ly = typeof globalThis > "u" ? N : globalThis, s_ = i_(), o_ = Py("String.prototype.slice"), zy = {}, Z0 = Object.getPrototypeOf;
  Uy && J0 && Z0 && qy(s_, function(t) {
    if (typeof Ly[t] == "function") {
      var e = new Ly[t]();
      if (Symbol.toStringTag in e) {
        var r = Z0(e), i = J0(r, Symbol.toStringTag);
        if (!i) {
          var n = Z0(r);
          i = J0(n, Symbol.toStringTag);
        }
        zy[t] = i.get;
      }
    }
  });
  var a_ = function(e) {
    var r = false;
    return qy(zy, function(i, n) {
      if (!r)
        try {
          var s2 = i.call(e);
          s2 === n && (r = s2);
        } catch {
        }
    }), r;
  }, f_ = Y0();
  Hy.exports = function(e) {
    return f_(e) ? !Uy || !(Symbol.toStringTag in e) ? o_(n_(e), 8, -1) : a_(e) : false;
  };
});
var nb = k((Rt) => {
  U();
  var c_ = xy(), u_ = Ey(), wi = $y(), Gy = Y0();
  function Uo(t) {
    return t.call.bind(t);
  }
  var Ky = typeof BigInt < "u", Wy = typeof Symbol < "u", Zr = Uo(Object.prototype.toString), d_ = Uo(Number.prototype.valueOf), l_ = Uo(String.prototype.valueOf), h_ = Uo(Boolean.prototype.valueOf);
  Ky && (Vy = Uo(BigInt.prototype.valueOf));
  var Vy;
  Wy && (Yy = Uo(Symbol.prototype.valueOf));
  var Yy;
  function Of(t, e) {
    if (typeof t != "object")
      return false;
    try {
      return e(t), true;
    } catch {
      return false;
    }
  }
  Rt.isArgumentsObject = c_;
  Rt.isGeneratorFunction = u_;
  Rt.isTypedArray = Gy;
  function p_(t) {
    return typeof Promise < "u" && t instanceof Promise || t !== null && typeof t == "object" && typeof t.then == "function" && typeof t.catch == "function";
  }
  Rt.isPromise = p_;
  function g_(t) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(t) : Gy(t) || Zy(t);
  }
  Rt.isArrayBufferView = g_;
  function m_(t) {
    return wi(t) === "Uint8Array";
  }
  Rt.isUint8Array = m_;
  function y_(t) {
    return wi(t) === "Uint8ClampedArray";
  }
  Rt.isUint8ClampedArray = y_;
  function b_(t) {
    return wi(t) === "Uint16Array";
  }
  Rt.isUint16Array = b_;
  function v_(t) {
    return wi(t) === "Uint32Array";
  }
  Rt.isUint32Array = v_;
  function w_(t) {
    return wi(t) === "Int8Array";
  }
  Rt.isInt8Array = w_;
  function x_(t) {
    return wi(t) === "Int16Array";
  }
  Rt.isInt16Array = x_;
  function __(t) {
    return wi(t) === "Int32Array";
  }
  Rt.isInt32Array = __;
  function A_(t) {
    return wi(t) === "Float32Array";
  }
  Rt.isFloat32Array = A_;
  function E_(t) {
    return wi(t) === "Float64Array";
  }
  Rt.isFloat64Array = E_;
  function S_(t) {
    return wi(t) === "BigInt64Array";
  }
  Rt.isBigInt64Array = S_;
  function M_(t) {
    return wi(t) === "BigUint64Array";
  }
  Rt.isBigUint64Array = M_;
  function Gd(t) {
    return Zr(t) === "[object Map]";
  }
  Gd.working = typeof Map < "u" && Gd(/* @__PURE__ */ new Map());
  function I_(t) {
    return typeof Map > "u" ? false : Gd.working ? Gd(t) : t instanceof Map;
  }
  Rt.isMap = I_;
  function Kd(t) {
    return Zr(t) === "[object Set]";
  }
  Kd.working = typeof Set < "u" && Kd(/* @__PURE__ */ new Set());
  function T_(t) {
    return typeof Set > "u" ? false : Kd.working ? Kd(t) : t instanceof Set;
  }
  Rt.isSet = T_;
  function Wd(t) {
    return Zr(t) === "[object WeakMap]";
  }
  Wd.working = typeof WeakMap < "u" && Wd(/* @__PURE__ */ new WeakMap());
  function F_(t) {
    return typeof WeakMap > "u" ? false : Wd.working ? Wd(t) : t instanceof WeakMap;
  }
  Rt.isWeakMap = F_;
  function Q0(t) {
    return Zr(t) === "[object WeakSet]";
  }
  Q0.working = typeof WeakSet < "u" && Q0(/* @__PURE__ */ new WeakSet());
  function R_(t) {
    return Q0(t);
  }
  Rt.isWeakSet = R_;
  function Vd(t) {
    return Zr(t) === "[object ArrayBuffer]";
  }
  Vd.working = typeof ArrayBuffer < "u" && Vd(new ArrayBuffer());
  function Jy(t) {
    return typeof ArrayBuffer > "u" ? false : Vd.working ? Vd(t) : t instanceof ArrayBuffer;
  }
  Rt.isArrayBuffer = Jy;
  function Yd(t) {
    return Zr(t) === "[object DataView]";
  }
  Yd.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Yd(new DataView(new ArrayBuffer(1), 0, 1));
  function Zy(t) {
    return typeof DataView > "u" ? false : Yd.working ? Yd(t) : t instanceof DataView;
  }
  Rt.isDataView = Zy;
  var X0 = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Cf(t) {
    return Zr(t) === "[object SharedArrayBuffer]";
  }
  function Xy(t) {
    return typeof X0 > "u" ? false : (typeof Cf.working > "u" && (Cf.working = Cf(new X0())), Cf.working ? Cf(t) : t instanceof X0);
  }
  Rt.isSharedArrayBuffer = Xy;
  function k_(t) {
    return Zr(t) === "[object AsyncFunction]";
  }
  Rt.isAsyncFunction = k_;
  function D_(t) {
    return Zr(t) === "[object Map Iterator]";
  }
  Rt.isMapIterator = D_;
  function B_(t) {
    return Zr(t) === "[object Set Iterator]";
  }
  Rt.isSetIterator = B_;
  function N_(t) {
    return Zr(t) === "[object Generator]";
  }
  Rt.isGeneratorObject = N_;
  function C_(t) {
    return Zr(t) === "[object WebAssembly.Module]";
  }
  Rt.isWebAssemblyCompiledModule = C_;
  function Qy(t) {
    return Of(t, d_);
  }
  Rt.isNumberObject = Qy;
  function eb(t) {
    return Of(t, l_);
  }
  Rt.isStringObject = eb;
  function tb(t) {
    return Of(t, h_);
  }
  Rt.isBooleanObject = tb;
  function rb(t) {
    return Ky && Of(t, Vy);
  }
  Rt.isBigIntObject = rb;
  function ib(t) {
    return Wy && Of(t, Yy);
  }
  Rt.isSymbolObject = ib;
  function O_(t) {
    return Qy(t) || eb(t) || tb(t) || rb(t) || ib(t);
  }
  Rt.isBoxedPrimitive = O_;
  function j_(t) {
    return typeof Uint8Array < "u" && (Jy(t) || Xy(t));
  }
  Rt.isAnyArrayBuffer = j_;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(t) {
    Object.defineProperty(Rt, t, { enumerable: false, value: function() {
      throw new Error(t + " is not supported in userland");
    } });
  });
});
var ob = k((yD, sb) => {
  U();
  sb.exports = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  };
});
var sp = k((kt) => {
  U();
  var ab = Object.getOwnPropertyDescriptors || function(e) {
    for (var r = Object.keys(e), i = {}, n = 0; n < r.length; n++)
      i[r[n]] = Object.getOwnPropertyDescriptor(e, r[n]);
    return i;
  }, L_ = /%[sdj%]/g;
  kt.format = function(t) {
    if (!rl(t)) {
      for (var e = [], r = 0; r < arguments.length; r++)
        e.push(Nn(arguments[r]));
      return e.join(" ");
    }
    for (var r = 1, i = arguments, n = i.length, s2 = String(t).replace(L_, function(f) {
      if (f === "%%")
        return "%";
      if (r >= n)
        return f;
      switch (f) {
        case "%s":
          return String(i[r++]);
        case "%d":
          return Number(i[r++]);
        case "%j":
          try {
            return JSON.stringify(i[r++]);
          } catch {
            return "[Circular]";
          }
        default:
          return f;
      }
    }), o = i[r]; r < n; o = i[++r])
      tl(o) || !zo(o) ? s2 += " " + o : s2 += " " + Nn(o);
    return s2;
  };
  kt.deprecate = function(t, e) {
    if (typeof W.default < "u" && W.default.noDeprecation === true)
      return t;
    if (typeof W.default > "u")
      return function() {
        return kt.deprecate(t, e).apply(this, arguments);
      };
    var r = false;
    function i() {
      if (!r) {
        if (W.default.throwDeprecation)
          throw new Error(e);
        W.default.traceDeprecation ? console.trace(e) : console.error(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return i;
  };
  var Jd = {}, fb = /^$/;
  W.default.env.NODE_DEBUG && (Zd = W.default.env.NODE_DEBUG, Zd = Zd.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), fb = new RegExp("^" + Zd + "$", "i"));
  var Zd;
  kt.debuglog = function(t) {
    if (t = t.toUpperCase(), !Jd[t])
      if (fb.test(t)) {
        var e = W.default.pid;
        Jd[t] = function() {
          var r = kt.format.apply(kt, arguments);
          console.error("%s %d: %s", t, e, r);
        };
      } else
        Jd[t] = function() {
        };
    return Jd[t];
  };
  function Nn(t, e) {
    var r = { seen: [], stylize: P_ };
    return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), ip(e) ? r.showHidden = e : e && kt._extend(r, e), As(r.showHidden) && (r.showHidden = false), As(r.depth) && (r.depth = 2), As(r.colors) && (r.colors = false), As(r.customInspect) && (r.customInspect = true), r.colors && (r.stylize = q_), Qd(r, t, r.depth);
  }
  kt.inspect = Nn;
  Nn.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
  Nn.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
  function q_(t, e) {
    var r = Nn.styles[e];
    return r ? "\x1B[" + Nn.colors[r][0] + "m" + t + "\x1B[" + Nn.colors[r][1] + "m" : t;
  }
  function P_(t, e) {
    return t;
  }
  function U_(t) {
    var e = {};
    return t.forEach(function(r, i) {
      e[r] = true;
    }), e;
  }
  function Qd(t, e, r) {
    if (t.customInspect && e && Xd(e.inspect) && e.inspect !== kt.inspect && !(e.constructor && e.constructor.prototype === e)) {
      var i = e.inspect(r, t);
      return rl(i) || (i = Qd(t, i, r)), i;
    }
    var n = z_(t, e);
    if (n)
      return n;
    var s2 = Object.keys(e), o = U_(s2);
    if (t.showHidden && (s2 = Object.getOwnPropertyNames(e)), Lf(e) && (s2.indexOf("message") >= 0 || s2.indexOf("description") >= 0))
      return ep(e);
    if (s2.length === 0) {
      if (Xd(e)) {
        var f = e.name ? ": " + e.name : "";
        return t.stylize("[Function" + f + "]", "special");
      }
      if (jf(e))
        return t.stylize(RegExp.prototype.toString.call(e), "regexp");
      if (el(e))
        return t.stylize(Date.prototype.toString.call(e), "date");
      if (Lf(e))
        return ep(e);
    }
    var l = "", m3 = false, A2 = ["{", "}"];
    if (cb(e) && (m3 = true, A2 = ["[", "]"]), Xd(e)) {
      var F3 = e.name ? ": " + e.name : "";
      l = " [Function" + F3 + "]";
    }
    if (jf(e) && (l = " " + RegExp.prototype.toString.call(e)), el(e) && (l = " " + Date.prototype.toUTCString.call(e)), Lf(e) && (l = " " + ep(e)), s2.length === 0 && (!m3 || e.length == 0))
      return A2[0] + l + A2[1];
    if (r < 0)
      return jf(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
    t.seen.push(e);
    var z3;
    return m3 ? z3 = H_(t, e, r, o, s2) : z3 = s2.map(function(V) {
      return rp(t, e, r, o, V, m3);
    }), t.seen.pop(), $_(z3, l, A2);
  }
  function z_(t, e) {
    if (As(e))
      return t.stylize("undefined", "undefined");
    if (rl(e)) {
      var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return t.stylize(r, "string");
    }
    if (ub(e))
      return t.stylize("" + e, "number");
    if (ip(e))
      return t.stylize("" + e, "boolean");
    if (tl(e))
      return t.stylize("null", "null");
  }
  function ep(t) {
    return "[" + Error.prototype.toString.call(t) + "]";
  }
  function H_(t, e, r, i, n) {
    for (var s2 = [], o = 0, f = e.length; o < f; ++o)
      db(e, String(o)) ? s2.push(rp(t, e, r, i, String(o), true)) : s2.push("");
    return n.forEach(function(l) {
      l.match(/^\d+$/) || s2.push(rp(t, e, r, i, l, true));
    }), s2;
  }
  function rp(t, e, r, i, n, s2) {
    var o, f, l;
    if (l = Object.getOwnPropertyDescriptor(e, n) || { value: e[n] }, l.get ? l.set ? f = t.stylize("[Getter/Setter]", "special") : f = t.stylize("[Getter]", "special") : l.set && (f = t.stylize("[Setter]", "special")), db(i, n) || (o = "[" + n + "]"), f || (t.seen.indexOf(l.value) < 0 ? (tl(r) ? f = Qd(t, l.value, null) : f = Qd(t, l.value, r - 1), f.indexOf(`
`) > -1 && (s2 ? f = f.split(`
`).map(function(m3) {
      return "  " + m3;
    }).join(`
`).slice(2) : f = `
` + f.split(`
`).map(function(m3) {
      return "   " + m3;
    }).join(`
`))) : f = t.stylize("[Circular]", "special")), As(o)) {
      if (s2 && n.match(/^\d+$/))
        return f;
      o = JSON.stringify("" + n), o.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.slice(1, -1), o = t.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = t.stylize(o, "string"));
    }
    return o + ": " + f;
  }
  function $_(t, e, r) {
    var i = 0, n = t.reduce(function(s2, o) {
      return i++, o.indexOf(`
`) >= 0 && i++, s2 + o.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return n > 60 ? r[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1];
  }
  kt.types = nb();
  function cb(t) {
    return Array.isArray(t);
  }
  kt.isArray = cb;
  function ip(t) {
    return typeof t == "boolean";
  }
  kt.isBoolean = ip;
  function tl(t) {
    return t === null;
  }
  kt.isNull = tl;
  function G_(t) {
    return t == null;
  }
  kt.isNullOrUndefined = G_;
  function ub(t) {
    return typeof t == "number";
  }
  kt.isNumber = ub;
  function rl(t) {
    return typeof t == "string";
  }
  kt.isString = rl;
  function K_(t) {
    return typeof t == "symbol";
  }
  kt.isSymbol = K_;
  function As(t) {
    return t === void 0;
  }
  kt.isUndefined = As;
  function jf(t) {
    return zo(t) && np(t) === "[object RegExp]";
  }
  kt.isRegExp = jf;
  kt.types.isRegExp = jf;
  function zo(t) {
    return typeof t == "object" && t !== null;
  }
  kt.isObject = zo;
  function el(t) {
    return zo(t) && np(t) === "[object Date]";
  }
  kt.isDate = el;
  kt.types.isDate = el;
  function Lf(t) {
    return zo(t) && (np(t) === "[object Error]" || t instanceof Error);
  }
  kt.isError = Lf;
  kt.types.isNativeError = Lf;
  function Xd(t) {
    return typeof t == "function";
  }
  kt.isFunction = Xd;
  function W_(t) {
    return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || typeof t > "u";
  }
  kt.isPrimitive = W_;
  kt.isBuffer = ob();
  function np(t) {
    return Object.prototype.toString.call(t);
  }
  function tp(t) {
    return t < 10 ? "0" + t.toString(10) : t.toString(10);
  }
  var V_ = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function Y_() {
    var t = /* @__PURE__ */ new Date(), e = [tp(t.getHours()), tp(t.getMinutes()), tp(t.getSeconds())].join(":");
    return [t.getDate(), V_[t.getMonth()], e].join(" ");
  }
  kt.log = function() {
    console.log("%s - %s", Y_(), kt.format.apply(kt, arguments));
  };
  kt.inherits = At();
  kt._extend = function(t, e) {
    if (!e || !zo(e))
      return t;
    for (var r = Object.keys(e), i = r.length; i--; )
      t[r[i]] = e[r[i]];
    return t;
  };
  function db(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  var _s = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  kt.promisify = function(e) {
    if (typeof e != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (_s && e[_s]) {
      var r = e[_s];
      if (typeof r != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(r, _s, { value: r, enumerable: false, writable: false, configurable: true }), r;
    }
    function r() {
      for (var i, n, s2 = new Promise(function(l, m3) {
        i = l, n = m3;
      }), o = [], f = 0; f < arguments.length; f++)
        o.push(arguments[f]);
      o.push(function(l, m3) {
        l ? n(l) : i(m3);
      });
      try {
        e.apply(this, o);
      } catch (l) {
        n(l);
      }
      return s2;
    }
    return Object.setPrototypeOf(r, Object.getPrototypeOf(e)), _s && Object.defineProperty(r, _s, { value: r, enumerable: false, writable: false, configurable: true }), Object.defineProperties(r, ab(e));
  };
  kt.promisify.custom = _s;
  function J_(t, e) {
    if (!t) {
      var r = new Error("Promise was rejected with a falsy value");
      r.reason = t, t = r;
    }
    return e(t);
  }
  function Z_(t) {
    if (typeof t != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function e() {
      for (var r = [], i = 0; i < arguments.length; i++)
        r.push(arguments[i]);
      var n = r.pop();
      if (typeof n != "function")
        throw new TypeError("The last argument must be of type Function");
      var s2 = this, o = function() {
        return n.apply(s2, arguments);
      };
      t.apply(this, r).then(function(f) {
        W.default.nextTick(o.bind(null, null, f));
      }, function(f) {
        W.default.nextTick(J_.bind(null, f, o));
      });
    }
    return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Object.defineProperties(e, ab(t)), e;
  }
  kt.callbackify = Z_;
});
var yb = k((vD, mb) => {
  U();
  function lb(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(t);
      e && (i = i.filter(function(n) {
        return Object.getOwnPropertyDescriptor(t, n).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  function hb(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e] != null ? arguments[e] : {};
      e % 2 ? lb(Object(r), true).forEach(function(i) {
        X_(t, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lb(Object(r)).forEach(function(i) {
        Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return t;
  }
  function X_(t, e, r) {
    return e = gb(e), e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  function Q_(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function pb(t, e) {
    for (var r = 0; r < e.length; r++) {
      var i = e[r];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(t, gb(i.key), i);
    }
  }
  function eA(t, e, r) {
    return e && pb(t.prototype, e), r && pb(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function gb(t) {
    var e = tA(t, "string");
    return typeof e == "symbol" ? e : String(e);
  }
  function tA(t, e) {
    if (typeof t != "object" || t === null)
      return t;
    var r = t[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(t, e || "default");
      if (typeof i != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e === "string" ? String : Number)(t);
  }
  var rA = or(), il = rA.Buffer, iA = sp(), op = iA.inspect, nA = op && op.custom || "inspect";
  function sA(t, e, r) {
    il.prototype.copy.call(t, e, r);
  }
  mb.exports = function() {
    function t() {
      Q_(this, t), this.head = null, this.tail = null, this.length = 0;
    }
    return eA(t, [{ key: "push", value: function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    } }, { key: "unshift", value: function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(r) {
      if (this.length === 0)
        return "";
      for (var i = this.head, n = "" + i.data; i = i.next; )
        n += r + i.data;
      return n;
    } }, { key: "concat", value: function(r) {
      if (this.length === 0)
        return il.alloc(0);
      for (var i = il.allocUnsafe(r >>> 0), n = this.head, s2 = 0; n; )
        sA(n.data, i, s2), s2 += n.data.length, n = n.next;
      return i;
    } }, { key: "consume", value: function(r, i) {
      var n;
      return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(r) {
      var i = this.head, n = 1, s2 = i.data;
      for (r -= s2.length; i = i.next; ) {
        var o = i.data, f = r > o.length ? o.length : r;
        if (f === o.length ? s2 += o : s2 += o.slice(0, r), r -= f, r === 0) {
          f === o.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = o.slice(f));
          break;
        }
        ++n;
      }
      return this.length -= n, s2;
    } }, { key: "_getBuffer", value: function(r) {
      var i = il.allocUnsafe(r), n = this.head, s2 = 1;
      for (n.data.copy(i), r -= n.data.length; n = n.next; ) {
        var o = n.data, f = r > o.length ? o.length : r;
        if (o.copy(i, i.length - r, 0, f), r -= f, r === 0) {
          f === o.length ? (++s2, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = o.slice(f));
          break;
        }
        ++s2;
      }
      return this.length -= s2, i;
    } }, { key: nA, value: function(r, i) {
      return op(this, hb(hb({}, i), {}, { depth: 0, customInspect: false }));
    } }]), t;
  }();
});
var fp = k((wD, vb) => {
  U();
  function oA(t, e) {
    var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
    return i || n ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, W.default.nextTick(ap, this, t)) : W.default.nextTick(ap, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(s2) {
      !e && s2 ? r._writableState ? r._writableState.errorEmitted ? W.default.nextTick(nl, r) : (r._writableState.errorEmitted = true, W.default.nextTick(bb, r, s2)) : W.default.nextTick(bb, r, s2) : e ? (W.default.nextTick(nl, r), e(s2)) : W.default.nextTick(nl, r);
    }), this);
  }
  function bb(t, e) {
    ap(t, e), nl(t);
  }
  function nl(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
  }
  function aA() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function ap(t, e) {
    t.emit("error", e);
  }
  function fA(t, e) {
    var r = t._readableState, i = t._writableState;
    r && r.autoDestroy || i && i.autoDestroy ? t.destroy(e) : t.emit("error", e);
  }
  vb.exports = { destroy: oA, undestroy: aA, errorOrDestroy: fA };
});
var Es = k((xD, _b2) => {
  U();
  function cA(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var xb = {};
  function Xr(t, e, r) {
    r || (r = Error);
    function i(s2, o, f) {
      return typeof e == "string" ? e : e(s2, o, f);
    }
    var n = function(s2) {
      cA(o, s2);
      function o(f, l, m3) {
        return s2.call(this, i(f, l, m3)) || this;
      }
      return o;
    }(r);
    n.prototype.name = r.name, n.prototype.code = t, xb[t] = n;
  }
  function wb(t, e) {
    if (Array.isArray(t)) {
      var r = t.length;
      return t = t.map(function(i) {
        return String(i);
      }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
    } else
      return "of ".concat(e, " ").concat(String(t));
  }
  function uA(t, e, r) {
    return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
  }
  function dA(t, e, r) {
    return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
  }
  function lA(t, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
  }
  Xr("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  }, TypeError);
  Xr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
    var i;
    typeof e == "string" && uA(e, "not ") ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be";
    var n;
    if (dA(t, " argument"))
      n = "The ".concat(t, " ").concat(i, " ").concat(wb(e, "type"));
    else {
      var s2 = lA(t, ".") ? "property" : "argument";
      n = 'The "'.concat(t, '" ').concat(s2, " ").concat(i, " ").concat(wb(e, "type"));
    }
    return n += ". Received type ".concat(typeof r), n;
  }, TypeError);
  Xr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  Xr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented";
  });
  Xr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  Xr("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed";
  });
  Xr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  Xr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  Xr("ERR_STREAM_WRITE_AFTER_END", "write after end");
  Xr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  Xr("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t;
  }, TypeError);
  Xr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  _b2.exports.codes = xb;
});
var cp = k((_D, Ab) => {
  U();
  var hA = Es().codes.ERR_INVALID_OPT_VALUE;
  function pA(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
  }
  function gA(t, e, r, i) {
    var n = pA(e, i, r);
    if (n != null) {
      if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
        var s2 = i ? r : "highWaterMark";
        throw new hA(s2, n);
      }
      return Math.floor(n);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  Ab.exports = { getHighWaterMark: gA };
});
var Sb = k((AD, Eb) => {
  U();
  Eb.exports = mA;
  function mA(t, e) {
    if (up("noDeprecation"))
      return t;
    var r = false;
    function i() {
      if (!r) {
        if (up("throwDeprecation"))
          throw new Error(e);
        up("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return i;
  }
  function up(t) {
    try {
      if (!N.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = N.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var al = k((ED, kb) => {
  U();
  kb.exports = or$1;
  function Ib(t) {
    var e = this;
    this.next = null, this.entry = null, this.finish = function() {
      HA(e, t);
    };
  }
  var Ho;
  or$1.WritableState = Pf;
  var yA = { deprecate: Sb() }, Tb = R0(), ol = or().Buffer, bA = (typeof N < "u" ? N : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function vA(t) {
    return ol.from(t);
  }
  function wA(t) {
    return ol.isBuffer(t) || t instanceof bA;
  }
  var lp = fp(), xA = cp(), _A = xA.getHighWaterMark, Cn = Es().codes, AA = Cn.ERR_INVALID_ARG_TYPE, EA = Cn.ERR_METHOD_NOT_IMPLEMENTED, SA = Cn.ERR_MULTIPLE_CALLBACK, MA = Cn.ERR_STREAM_CANNOT_PIPE, IA = Cn.ERR_STREAM_DESTROYED, TA = Cn.ERR_STREAM_NULL_VALUES, FA = Cn.ERR_STREAM_WRITE_AFTER_END, RA = Cn.ERR_UNKNOWN_ENCODING, $o = lp.errorOrDestroy;
  At()(or$1, Tb);
  function kA() {
  }
  function Pf(t, e, r) {
    Ho = Ho || On(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ho), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = _A(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var i = t.decodeStrings === false;
    this.decodeStrings = !i, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(n) {
      LA(e, n);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ib(this);
  }
  Pf.prototype.getBuffer = function() {
    for (var e = this.bufferedRequest, r = []; e; )
      r.push(e), e = e.next;
    return r;
  };
  (function() {
    try {
      Object.defineProperty(Pf.prototype, "buffer", { get: yA.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var sl;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (sl = Function.prototype[Symbol.hasInstance], Object.defineProperty(or$1, Symbol.hasInstance, { value: function(e) {
    return sl.call(this, e) ? true : this !== or$1 ? false : e && e._writableState instanceof Pf;
  } })) : sl = function(e) {
    return e instanceof this;
  };
  function or$1(t) {
    Ho = Ho || On();
    var e = this instanceof Ho;
    if (!e && !sl.call(or$1, this))
      return new or$1(t);
    this._writableState = new Pf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Tb.call(this);
  }
  or$1.prototype.pipe = function() {
    $o(this, new MA());
  };
  function DA(t, e) {
    var r = new FA();
    $o(t, r), W.default.nextTick(e, r);
  }
  function BA(t, e, r, i) {
    var n;
    return r === null ? n = new TA() : typeof r != "string" && !e.objectMode && (n = new AA("chunk", ["string", "Buffer"], r)), n ? ($o(t, n), W.default.nextTick(i, n), false) : true;
  }
  or$1.prototype.write = function(t, e, r) {
    var i = this._writableState, n = false, s2 = !i.objectMode && wA(t);
    return s2 && !ol.isBuffer(t) && (t = vA(t)), typeof e == "function" && (r = e, e = null), s2 ? e = "buffer" : e || (e = i.defaultEncoding), typeof r != "function" && (r = kA), i.ending ? DA(this, r) : (s2 || BA(this, i, t, r)) && (i.pendingcb++, n = CA(this, i, s2, t, e, r)), n;
  };
  or$1.prototype.cork = function() {
    this._writableState.corked++;
  };
  or$1.prototype.uncork = function() {
    var t = this._writableState;
    t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Fb(this, t));
  };
  or$1.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
      throw new RA(e);
    return this._writableState.defaultEncoding = e, this;
  };
  Object.defineProperty(or$1.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function NA(t, e, r) {
    return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ol.from(e, r)), e;
  }
  Object.defineProperty(or$1.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function CA(t, e, r, i, n, s2) {
    if (!r) {
      var o = NA(e, i, n);
      i !== o && (r = true, n = "buffer", i = o);
    }
    var f = e.objectMode ? 1 : i.length;
    e.length += f;
    var l = e.length < e.highWaterMark;
    if (l || (e.needDrain = true), e.writing || e.corked) {
      var m3 = e.lastBufferedRequest;
      e.lastBufferedRequest = { chunk: i, encoding: n, isBuf: r, callback: s2, next: null }, m3 ? m3.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
    } else
      dp(t, e, false, f, i, n, s2);
    return l;
  }
  function dp(t, e, r, i, n, s2, o) {
    e.writelen = i, e.writecb = o, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new IA("write")) : r ? t._writev(n, e.onwrite) : t._write(n, s2, e.onwrite), e.sync = false;
  }
  function OA(t, e, r, i, n) {
    --e.pendingcb, r ? (W.default.nextTick(n, i), W.default.nextTick(qf, t, e), t._writableState.errorEmitted = true, $o(t, i)) : (n(i), t._writableState.errorEmitted = true, $o(t, i), qf(t, e));
  }
  function jA(t) {
    t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
  }
  function LA(t, e) {
    var r = t._writableState, i = r.sync, n = r.writecb;
    if (typeof n != "function")
      throw new SA();
    if (jA(r), e)
      OA(t, r, i, e, n);
    else {
      var s2 = Rb(r) || t.destroyed;
      !s2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Fb(t, r), i ? W.default.nextTick(Mb, t, r, s2, n) : Mb(t, r, s2, n);
    }
  }
  function Mb(t, e, r, i) {
    r || qA(t, e), e.pendingcb--, i(), qf(t, e);
  }
  function qA(t, e) {
    e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
  }
  function Fb(t, e) {
    e.bufferProcessing = true;
    var r = e.bufferedRequest;
    if (t._writev && r && r.next) {
      var i = e.bufferedRequestCount, n = new Array(i), s2 = e.corkedRequestsFree;
      s2.entry = r;
      for (var o = 0, f = true; r; )
        n[o] = r, r.isBuf || (f = false), r = r.next, o += 1;
      n.allBuffers = f, dp(t, e, true, e.length, n, "", s2.finish), e.pendingcb++, e.lastBufferedRequest = null, s2.next ? (e.corkedRequestsFree = s2.next, s2.next = null) : e.corkedRequestsFree = new Ib(e), e.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, m3 = r.encoding, A2 = r.callback, F3 = e.objectMode ? 1 : l.length;
        if (dp(t, e, false, F3, l, m3, A2), r = r.next, e.bufferedRequestCount--, e.writing)
          break;
      }
      r === null && (e.lastBufferedRequest = null);
    }
    e.bufferedRequest = r, e.bufferProcessing = false;
  }
  or$1.prototype._write = function(t, e, r) {
    r(new EA("_write()"));
  };
  or$1.prototype._writev = null;
  or$1.prototype.end = function(t, e, r) {
    var i = this._writableState;
    return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), i.corked && (i.corked = 1, this.uncork()), i.ending || zA(this, i, r), this;
  };
  Object.defineProperty(or$1.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function Rb(t) {
    return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
  }
  function PA(t, e) {
    t._final(function(r) {
      e.pendingcb--, r && $o(t, r), e.prefinished = true, t.emit("prefinish"), qf(t, e);
    });
  }
  function UA(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, W.default.nextTick(PA, t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function qf(t, e) {
    var r = Rb(e);
    if (r && (UA(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
      var i = t._readableState;
      (!i || i.autoDestroy && i.endEmitted) && t.destroy();
    }
    return r;
  }
  function zA(t, e, r) {
    e.ending = true, qf(t, e), r && (e.finished ? W.default.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
  }
  function HA(t, e, r) {
    var i = t.entry;
    for (t.entry = null; i; ) {
      var n = i.callback;
      e.pendingcb--, n(r), i = i.next;
    }
    e.corkedRequestsFree.next = t;
  }
  Object.defineProperty(or$1.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set: function(e) {
    !this._writableState || (this._writableState.destroyed = e);
  } });
  or$1.prototype.destroy = lp.destroy;
  or$1.prototype._undestroy = lp.undestroy;
  or$1.prototype._destroy = function(t, e) {
    e(t);
  };
});
var On = k((SD, Bb) => {
  U();
  var $A = Object.keys || function(t) {
    var e = [];
    for (var r in t)
      e.push(r);
    return e;
  };
  Bb.exports = Li;
  var Db = ul(), pp = al();
  At()(Li, Db);
  for (hp = $A(pp.prototype), fl = 0; fl < hp.length; fl++)
    cl = hp[fl], Li.prototype[cl] || (Li.prototype[cl] = pp.prototype[cl]);
  var hp, cl, fl;
  function Li(t) {
    if (!(this instanceof Li))
      return new Li(t);
    Db.call(this, t), pp.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", GA)));
  }
  Object.defineProperty(Li.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty(Li.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty(Li.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function GA() {
    this._writableState.ended || W.default.nextTick(KA, this);
  }
  function KA(t) {
    t.end();
  }
  Object.defineProperty(Li.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(e) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e);
  } });
});
var dl = k((Cb) => {
  U();
  var mp = St().Buffer, Nb = mp.isEncoding || function(t) {
    switch (t = "" + t, t && t.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function WA(t) {
    if (!t)
      return "utf8";
    for (var e; ; )
      switch (t) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t;
        default:
          if (e)
            return;
          t = ("" + t).toLowerCase(), e = true;
      }
  }
  function VA(t) {
    var e = WA(t);
    if (typeof e != "string" && (mp.isEncoding === Nb || !Nb(t)))
      throw new Error("Unknown encoding: " + t);
    return e || t;
  }
  Cb.StringDecoder = Uf;
  function Uf(t) {
    this.encoding = VA(t);
    var e;
    switch (this.encoding) {
      case "utf16le":
        this.text = e9, this.end = t9, e = 4;
        break;
      case "utf8":
        this.fillLast = ZA, e = 4;
        break;
      case "base64":
        this.text = r9, this.end = i9, e = 3;
        break;
      default:
        this.write = n9, this.end = s9;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = mp.allocUnsafe(e);
  }
  Uf.prototype.write = function(t) {
    if (t.length === 0)
      return "";
    var e, r;
    if (this.lastNeed) {
      if (e = this.fillLast(t), e === void 0)
        return "";
      r = this.lastNeed, this.lastNeed = 0;
    } else
      r = 0;
    return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
  };
  Uf.prototype.end = QA;
  Uf.prototype.text = XA;
  Uf.prototype.fillLast = function(t) {
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
  };
  function gp(t) {
    return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
  }
  function YA(t, e, r) {
    var i = e.length - 1;
    if (i < r)
      return 0;
    var n = gp(e[i]);
    return n >= 0 ? (n > 0 && (t.lastNeed = n - 1), n) : --i < r || n === -2 ? 0 : (n = gp(e[i]), n >= 0 ? (n > 0 && (t.lastNeed = n - 2), n) : --i < r || n === -2 ? 0 : (n = gp(e[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : t.lastNeed = n - 3), n) : 0));
  }
  function JA(t, e, r) {
    if ((e[0] & 192) !== 128)
      return t.lastNeed = 0, "";
    if (t.lastNeed > 1 && e.length > 1) {
      if ((e[1] & 192) !== 128)
        return t.lastNeed = 1, "";
      if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
        return t.lastNeed = 2, "";
    }
  }
  function ZA(t) {
    var e = this.lastTotal - this.lastNeed, r = JA(this, t);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
  }
  function XA(t, e) {
    var r = YA(this, t, e);
    if (!this.lastNeed)
      return t.toString("utf8", e);
    this.lastTotal = r;
    var i = t.length - (r - this.lastNeed);
    return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i);
  }
  function QA(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + "" : e;
  }
  function e9(t, e) {
    if ((t.length - e) % 2 === 0) {
      var r = t.toString("utf16le", e);
      if (r) {
        var i = r.charCodeAt(r.length - 1);
        if (i >= 55296 && i <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
      }
      return r;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
  }
  function t9(t) {
    var e = t && t.length ? this.write(t) : "";
    if (this.lastNeed) {
      var r = this.lastTotal - this.lastNeed;
      return e + this.lastChar.toString("utf16le", 0, r);
    }
    return e;
  }
  function r9(t, e) {
    var r = (t.length - e) % 3;
    return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
  }
  function i9(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
  }
  function n9(t) {
    return t.toString(this.encoding);
  }
  function s9(t) {
    return t && t.length ? this.write(t) : "";
  }
});
var zf = k((ID, Lb) => {
  U();
  var Ob = Es().codes.ERR_STREAM_PREMATURE_CLOSE;
  function o9(t) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, i = new Array(r), n = 0; n < r; n++)
          i[n] = arguments[n];
        t.apply(this, i);
      }
    };
  }
  function a9() {
  }
  function f9(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function jb(t, e, r) {
    if (typeof e == "function")
      return jb(t, null, e);
    e || (e = {}), r = o9(r || a9);
    var i = e.readable || e.readable !== false && t.readable, n = e.writable || e.writable !== false && t.writable, s2 = function() {
      t.writable || f();
    }, o = t._writableState && t._writableState.finished, f = function() {
      n = false, o = true, i || r.call(t);
    }, l = t._readableState && t._readableState.endEmitted, m3 = function() {
      i = false, l = true, n || r.call(t);
    }, A2 = function($) {
      r.call(t, $);
    }, F3 = function() {
      var $;
      if (i && !l)
        return (!t._readableState || !t._readableState.ended) && ($ = new Ob()), r.call(t, $);
      if (n && !o)
        return (!t._writableState || !t._writableState.ended) && ($ = new Ob()), r.call(t, $);
    }, z3 = function() {
      t.req.on("finish", f);
    };
    return f9(t) ? (t.on("complete", f), t.on("abort", F3), t.req ? z3() : t.on("request", z3)) : n && !t._writableState && (t.on("end", s2), t.on("close", s2)), t.on("end", m3), t.on("finish", f), e.error !== false && t.on("error", A2), t.on("close", F3), function() {
      t.removeListener("complete", f), t.removeListener("abort", F3), t.removeListener("request", z3), t.req && t.req.removeListener("finish", f), t.removeListener("end", s2), t.removeListener("close", s2), t.removeListener("finish", f), t.removeListener("end", m3), t.removeListener("error", A2), t.removeListener("close", F3);
    };
  }
  Lb.exports = jb;
});
var Pb = k((TD, qb) => {
  U();
  var ll;
  function jn(t, e, r) {
    return e = c9(e), e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  function c9(t) {
    var e = u9(t, "string");
    return typeof e == "symbol" ? e : String(e);
  }
  function u9(t, e) {
    if (typeof t != "object" || t === null)
      return t;
    var r = t[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(t, e || "default");
      if (typeof i != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e === "string" ? String : Number)(t);
  }
  var d9 = zf(), Ln = Symbol("lastResolve"), Ss = Symbol("lastReject"), Hf = Symbol("error"), hl = Symbol("ended"), Ms = Symbol("lastPromise"), yp = Symbol("handlePromise"), Is = Symbol("stream");
  function qn(t, e) {
    return { value: t, done: e };
  }
  function l9(t) {
    var e = t[Ln];
    if (e !== null) {
      var r = t[Is].read();
      r !== null && (t[Ms] = null, t[Ln] = null, t[Ss] = null, e(qn(r, false)));
    }
  }
  function h9(t) {
    W.default.nextTick(l9, t);
  }
  function p9(t, e) {
    return function(r, i) {
      t.then(function() {
        if (e[hl]) {
          r(qn(void 0, true));
          return;
        }
        e[yp](r, i);
      }, i);
    };
  }
  var g9 = Object.getPrototypeOf(function() {
  }), m9 = Object.setPrototypeOf((ll = { get stream() {
    return this[Is];
  }, next: function() {
    var e = this, r = this[Hf];
    if (r !== null)
      return Promise.reject(r);
    if (this[hl])
      return Promise.resolve(qn(void 0, true));
    if (this[Is].destroyed)
      return new Promise(function(o, f) {
        W.default.nextTick(function() {
          e[Hf] ? f(e[Hf]) : o(qn(void 0, true));
        });
      });
    var i = this[Ms], n;
    if (i)
      n = new Promise(p9(i, this));
    else {
      var s2 = this[Is].read();
      if (s2 !== null)
        return Promise.resolve(qn(s2, false));
      n = new Promise(this[yp]);
    }
    return this[Ms] = n, n;
  } }, jn(ll, Symbol.asyncIterator, function() {
    return this;
  }), jn(ll, "return", function() {
    var e = this;
    return new Promise(function(r, i) {
      e[Is].destroy(null, function(n) {
        if (n) {
          i(n);
          return;
        }
        r(qn(void 0, true));
      });
    });
  }), ll), g9), y9 = function(e) {
    var r, i = Object.create(m9, (r = {}, jn(r, Is, { value: e, writable: true }), jn(r, Ln, { value: null, writable: true }), jn(r, Ss, { value: null, writable: true }), jn(r, Hf, { value: null, writable: true }), jn(r, hl, { value: e._readableState.endEmitted, writable: true }), jn(r, yp, { value: function(s2, o) {
      var f = i[Is].read();
      f ? (i[Ms] = null, i[Ln] = null, i[Ss] = null, s2(qn(f, false))) : (i[Ln] = s2, i[Ss] = o);
    }, writable: true }), r));
    return i[Ms] = null, d9(e, function(n) {
      if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var s2 = i[Ss];
        s2 !== null && (i[Ms] = null, i[Ln] = null, i[Ss] = null, s2(n)), i[Hf] = n;
        return;
      }
      var o = i[Ln];
      o !== null && (i[Ms] = null, i[Ln] = null, i[Ss] = null, o(qn(void 0, true))), i[hl] = true;
    }), e.on("readable", h9.bind(null, i)), i;
  };
  qb.exports = y9;
});
var zb = k((FD, Ub) => {
  U();
  Ub.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var ul = k((kD, Xb) => {
  U();
  Xb.exports = qt;
  var Go;
  qt.ReadableState = Kb;
  Bd().EventEmitter;
  var Gb = function(e, r) {
    return e.listeners(r).length;
  }, Gf = R0(), pl = or().Buffer, b9 = (typeof N < "u" ? N : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function v9(t) {
    return pl.from(t);
  }
  function w9(t) {
    return pl.isBuffer(t) || t instanceof b9;
  }
  var bp = sp(), Ft;
  bp && bp.debuglog ? Ft = bp.debuglog("stream") : Ft = function() {
  };
  var x9 = yb(), Sp = fp(), _9 = cp(), A9 = _9.getHighWaterMark, gl = Es().codes, E9 = gl.ERR_INVALID_ARG_TYPE, S9 = gl.ERR_STREAM_PUSH_AFTER_EOF, M9 = gl.ERR_METHOD_NOT_IMPLEMENTED, I9 = gl.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ko, vp, wp;
  At()(qt, Gf);
  var $f = Sp.errorOrDestroy, xp = ["error", "close", "destroy", "pause", "resume"];
  function T9(t, e, r) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r);
    !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
  }
  function Kb(t, e, r) {
    Go = Go || On(), t = t || {}, typeof r != "boolean" && (r = e instanceof Go), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = A9(this, t, "readableHighWaterMark", r), this.buffer = new x9(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Ko || (Ko = dl().StringDecoder), this.decoder = new Ko(t.encoding), this.encoding = t.encoding);
  }
  function qt(t) {
    if (Go = Go || On(), !(this instanceof qt))
      return new qt(t);
    var e = this instanceof Go;
    this._readableState = new Kb(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Gf.call(this);
  }
  Object.defineProperty(qt.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set: function(e) {
    !this._readableState || (this._readableState.destroyed = e);
  } });
  qt.prototype.destroy = Sp.destroy;
  qt.prototype._undestroy = Sp.undestroy;
  qt.prototype._destroy = function(t, e) {
    e(t);
  };
  qt.prototype.push = function(t, e) {
    var r = this._readableState, i;
    return r.objectMode ? i = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = pl.from(t, e), e = ""), i = true), Wb(this, t, e, false, i);
  };
  qt.prototype.unshift = function(t) {
    return Wb(this, t, null, true, false);
  };
  function Wb(t, e, r, i, n) {
    Ft("readableAddChunk", e);
    var s2 = t._readableState;
    if (e === null)
      s2.reading = false, k9(t, s2);
    else {
      var o;
      if (n || (o = F9(s2, e)), o)
        $f(t, o);
      else if (s2.objectMode || e && e.length > 0)
        if (typeof e != "string" && !s2.objectMode && Object.getPrototypeOf(e) !== pl.prototype && (e = v9(e)), i)
          s2.endEmitted ? $f(t, new I9()) : _p(t, s2, e, true);
        else if (s2.ended)
          $f(t, new S9());
        else {
          if (s2.destroyed)
            return false;
          s2.reading = false, s2.decoder && !r ? (e = s2.decoder.write(e), s2.objectMode || e.length !== 0 ? _p(t, s2, e, false) : Ep(t, s2)) : _p(t, s2, e, false);
        }
      else
        i || (s2.reading = false, Ep(t, s2));
    }
    return !s2.ended && (s2.length < s2.highWaterMark || s2.length === 0);
  }
  function _p(t, e, r, i) {
    e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, i ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && ml(t)), Ep(t, e);
  }
  function F9(t, e) {
    var r;
    return !w9(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new E9("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
  }
  qt.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  qt.prototype.setEncoding = function(t) {
    Ko || (Ko = dl().StringDecoder);
    var e = new Ko(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, i = ""; r !== null; )
      i += e.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
  };
  var Hb = 1073741824;
  function R9(t) {
    return t >= Hb ? t = Hb : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
  }
  function $b(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = R9(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
  }
  qt.prototype.read = function(t) {
    Ft("read", t), t = parseInt(t, 10);
    var e = this._readableState, r = t;
    if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return Ft("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Ap(this) : ml(this), null;
    if (t = $b(t, e), t === 0 && e.ended)
      return e.length === 0 && Ap(this), null;
    var i = e.needReadable;
    Ft("need readable", i), (e.length === 0 || e.length - t < e.highWaterMark) && (i = true, Ft("length less than watermark", i)), e.ended || e.reading ? (i = false, Ft("reading or ended", i)) : i && (Ft("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = $b(r, e)));
    var n;
    return t > 0 ? n = Jb(t, e) : n = null, n === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Ap(this)), n !== null && this.emit("data", n), n;
  };
  function k9(t, e) {
    if (Ft("onEofChunk"), !e.ended) {
      if (e.decoder) {
        var r = e.decoder.end();
        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
      }
      e.ended = true, e.sync ? ml(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Vb(t)));
    }
  }
  function ml(t) {
    var e = t._readableState;
    Ft("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ft("emitReadable", e.flowing), e.emittedReadable = true, W.default.nextTick(Vb, t));
  }
  function Vb(t) {
    var e = t._readableState;
    Ft("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, Mp(t);
  }
  function Ep(t, e) {
    e.readingMore || (e.readingMore = true, W.default.nextTick(D9, t, e));
  }
  function D9(t, e) {
    for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      var r = e.length;
      if (Ft("maybeReadMore read 0"), t.read(0), r === e.length)
        break;
    }
    e.readingMore = false;
  }
  qt.prototype._read = function(t) {
    $f(this, new M9("_read()"));
  };
  qt.prototype.pipe = function(t, e) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = t;
        break;
      case 1:
        i.pipes = [i.pipes, t];
        break;
      default:
        i.pipes.push(t);
        break;
    }
    i.pipesCount += 1, Ft("pipe count=%d opts=%j", i.pipesCount, e);
    var n = (!e || e.end !== false) && t !== W.default.stdout && t !== W.default.stderr, s2 = n ? f : re;
    i.endEmitted ? W.default.nextTick(s2) : r.once("end", s2), t.on("unpipe", o);
    function o(W2, Z2) {
      Ft("onunpipe"), W2 === r && Z2 && Z2.hasUnpiped === false && (Z2.hasUnpiped = true, A2());
    }
    function f() {
      Ft("onend"), t.end();
    }
    var l = B9(r);
    t.on("drain", l);
    var m3 = false;
    function A2() {
      Ft("cleanup"), t.removeListener("close", V), t.removeListener("finish", $), t.removeListener("drain", l), t.removeListener("error", z3), t.removeListener("unpipe", o), r.removeListener("end", f), r.removeListener("end", re), r.removeListener("data", F3), m3 = true, i.awaitDrain && (!t._writableState || t._writableState.needDrain) && l();
    }
    r.on("data", F3);
    function F3(W2) {
      Ft("ondata");
      var Z2 = t.write(W2);
      Ft("dest.write", Z2), Z2 === false && ((i.pipesCount === 1 && i.pipes === t || i.pipesCount > 1 && Zb(i.pipes, t) !== -1) && !m3 && (Ft("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
    }
    function z3(W2) {
      Ft("onerror", W2), re(), t.removeListener("error", z3), Gb(t, "error") === 0 && $f(t, W2);
    }
    T9(t, "error", z3);
    function V() {
      t.removeListener("finish", $), re();
    }
    t.once("close", V);
    function $() {
      Ft("onfinish"), t.removeListener("close", V), re();
    }
    t.once("finish", $);
    function re() {
      Ft("unpipe"), r.unpipe(t);
    }
    return t.emit("pipe", r), i.flowing || (Ft("pipe resume"), r.resume()), t;
  };
  function B9(t) {
    return function() {
      var r = t._readableState;
      Ft("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Gb(t, "data") && (r.flowing = true, Mp(t));
    };
  }
  qt.prototype.unpipe = function(t) {
    var e = this._readableState, r = { hasUnpiped: false };
    if (e.pipesCount === 0)
      return this;
    if (e.pipesCount === 1)
      return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
    if (!t) {
      var i = e.pipes, n = e.pipesCount;
      e.pipes = null, e.pipesCount = 0, e.flowing = false;
      for (var s2 = 0; s2 < n; s2++)
        i[s2].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var o = Zb(e.pipes, t);
    return o === -1 ? this : (e.pipes.splice(o, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
  };
  qt.prototype.on = function(t, e) {
    var r = Gf.prototype.on.call(this, t, e), i = this._readableState;
    return t === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== false && this.resume()) : t === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = true, i.flowing = false, i.emittedReadable = false, Ft("on readable", i.length, i.reading), i.length ? ml(this) : i.reading || W.default.nextTick(N9, this)), r;
  };
  qt.prototype.addListener = qt.prototype.on;
  qt.prototype.removeListener = function(t, e) {
    var r = Gf.prototype.removeListener.call(this, t, e);
    return t === "readable" && W.default.nextTick(Yb, this), r;
  };
  qt.prototype.removeAllListeners = function(t) {
    var e = Gf.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === void 0) && W.default.nextTick(Yb, this), e;
  };
  function Yb(t) {
    var e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
  }
  function N9(t) {
    Ft("readable nexttick read 0"), t.read(0);
  }
  qt.prototype.resume = function() {
    var t = this._readableState;
    return t.flowing || (Ft("resume"), t.flowing = !t.readableListening, C9(this, t)), t.paused = false, this;
  };
  function C9(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, W.default.nextTick(O9, t, e));
  }
  function O9(t, e) {
    Ft("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), Mp(t), e.flowing && !e.reading && t.read(0);
  }
  qt.prototype.pause = function() {
    return Ft("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ft("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function Mp(t) {
    var e = t._readableState;
    for (Ft("flow", e.flowing); e.flowing && t.read() !== null; )
      ;
  }
  qt.prototype.wrap = function(t) {
    var e = this, r = this._readableState, i = false;
    t.on("end", function() {
      if (Ft("wrapped end"), r.decoder && !r.ended) {
        var o = r.decoder.end();
        o && o.length && e.push(o);
      }
      e.push(null);
    }), t.on("data", function(o) {
      if (Ft("wrapped data"), r.decoder && (o = r.decoder.write(o)), !(r.objectMode && o == null) && !(!r.objectMode && (!o || !o.length))) {
        var f = e.push(o);
        f || (i = true, t.pause());
      }
    });
    for (var n in t)
      this[n] === void 0 && typeof t[n] == "function" && (this[n] = function(f) {
        return function() {
          return t[f].apply(t, arguments);
        };
      }(n));
    for (var s2 = 0; s2 < xp.length; s2++)
      t.on(xp[s2], this.emit.bind(this, xp[s2]));
    return this._read = function(o) {
      Ft("wrapped _read", o), i && (i = false, t.resume());
    }, this;
  };
  typeof Symbol == "function" && (qt.prototype[Symbol.asyncIterator] = function() {
    return vp === void 0 && (vp = Pb()), vp(this);
  });
  Object.defineProperty(qt.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(qt.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(qt.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e) {
    this._readableState && (this._readableState.flowing = e);
  } });
  qt._fromList = Jb;
  Object.defineProperty(qt.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function Jb(t, e) {
    if (e.length === 0)
      return null;
    var r;
    return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
  }
  function Ap(t) {
    var e = t._readableState;
    Ft("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, W.default.nextTick(j9, e, t));
  }
  function j9(t, e) {
    if (Ft("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
      var r = e._writableState;
      (!r || r.autoDestroy && r.finished) && e.destroy();
    }
  }
  typeof Symbol == "function" && (qt.from = function(t, e) {
    return wp === void 0 && (wp = zb()), wp(qt, t, e);
  });
  function Zb(t, e) {
    for (var r = 0, i = t.length; r < i; r++)
      if (t[r] === e)
        return r;
    return -1;
  }
});
var vl = k((DD, ev) => {
  U();
  ev.exports = sn;
  var yl = Es().codes, L9 = yl.ERR_METHOD_NOT_IMPLEMENTED, q9 = yl.ERR_MULTIPLE_CALLBACK, P9 = yl.ERR_TRANSFORM_ALREADY_TRANSFORMING, U9 = yl.ERR_TRANSFORM_WITH_LENGTH_0, bl = On();
  At()(sn, bl);
  function z9(t, e) {
    var r = this._transformState;
    r.transforming = false;
    var i = r.writecb;
    if (i === null)
      return this.emit("error", new q9());
    r.writechunk = null, r.writecb = null, e != null && this.push(e), i(t);
    var n = this._readableState;
    n.reading = false, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
  }
  function sn(t) {
    if (!(this instanceof sn))
      return new sn(t);
    bl.call(this, t), this._transformState = { afterTransform: z9.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", H9);
  }
  function H9() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Qb(t, e, r);
    }) : Qb(this, null, null);
  }
  sn.prototype.push = function(t, e) {
    return this._transformState.needTransform = false, bl.prototype.push.call(this, t, e);
  };
  sn.prototype._transform = function(t, e, r) {
    r(new L9("_transform()"));
  };
  sn.prototype._write = function(t, e, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = t, i.writeencoding = e, !i.transforming) {
      var n = this._readableState;
      (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
  };
  sn.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  sn.prototype._destroy = function(t, e) {
    bl.prototype._destroy.call(this, t, function(r) {
      e(r);
    });
  };
  function Qb(t, e, r) {
    if (e)
      return t.emit("error", e);
    if (r != null && t.push(r), t._writableState.length)
      throw new U9();
    if (t._transformState.transforming)
      throw new P9();
    return t.push(null);
  }
});
var Ip = k((BD, rv) => {
  U();
  rv.exports = Kf;
  var tv = vl();
  At()(Kf, tv);
  function Kf(t) {
    if (!(this instanceof Kf))
      return new Kf(t);
    tv.call(this, t);
  }
  Kf.prototype._transform = function(t, e, r) {
    r(null, t);
  };
});
var Fp = k((ND, ov) => {
  U();
  var Tp;
  function $9(t) {
    var e = false;
    return function() {
      e || (e = true, t.apply(void 0, arguments));
    };
  }
  var sv = Es().codes, G9 = sv.ERR_MISSING_ARGS, K9 = sv.ERR_STREAM_DESTROYED;
  function iv(t) {
    if (t)
      throw t;
  }
  function W9(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function V9(t, e, r, i) {
    i = $9(i);
    var n = false;
    t.on("close", function() {
      n = true;
    }), Tp === void 0 && (Tp = zf()), Tp(t, { readable: e, writable: r }, function(o) {
      if (o)
        return i(o);
      n = true, i();
    });
    var s2 = false;
    return function(o) {
      if (!n && !s2) {
        if (s2 = true, W9(t))
          return t.abort();
        if (typeof t.destroy == "function")
          return t.destroy();
        i(o || new K9("pipe"));
      }
    };
  }
  function nv(t) {
    t();
  }
  function Y9(t, e) {
    return t.pipe(e);
  }
  function J9(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? iv : t.pop();
  }
  function Z9() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
      e[r] = arguments[r];
    var i = J9(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new G9("streams");
    var n, s2 = e.map(function(o, f) {
      var l = f < e.length - 1, m3 = f > 0;
      return V9(o, l, m3, function(A2) {
        n || (n = A2), A2 && s2.forEach(nv), !l && (s2.forEach(nv), i(n));
      });
    });
    return e.reduce(Y9);
  }
  ov.exports = Z9;
});
var Rp = k((Qr, av) => {
  U();
  Qr = av.exports = ul();
  Qr.Stream = Qr;
  Qr.Readable = Qr;
  Qr.Writable = al();
  Qr.Duplex = On();
  Qr.Transform = vl();
  Qr.PassThrough = Ip();
  Qr.finished = zf();
  Qr.pipeline = Fp();
});
var kp = k((CD, cv) => {
  U();
  var wl = St().Buffer, fv = Rp().Transform, X9 = At();
  function Q9(t, e) {
    if (!wl.isBuffer(t) && typeof t != "string")
      throw new TypeError(e + " must be a string or a buffer");
  }
  function Pn(t) {
    fv.call(this), this._block = wl.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
  }
  X9(Pn, fv);
  Pn.prototype._transform = function(t, e, r) {
    var i = null;
    try {
      this.update(t, e);
    } catch (n) {
      i = n;
    }
    r(i);
  };
  Pn.prototype._flush = function(t) {
    var e = null;
    try {
      this.push(this.digest());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Pn.prototype.update = function(t, e) {
    if (Q9(t, "Data"), this._finalized)
      throw new Error("Digest already called");
    wl.isBuffer(t) || (t = wl.from(t, e));
    for (var r = this._block, i = 0; this._blockOffset + t.length - i >= this._blockSize; ) {
      for (var n = this._blockOffset; n < this._blockSize; )
        r[n++] = t[i++];
      this._update(), this._blockOffset = 0;
    }
    for (; i < t.length; )
      r[this._blockOffset++] = t[i++];
    for (var s2 = 0, o = t.length * 8; o > 0; ++s2)
      this._length[s2] += o, o = this._length[s2] / 4294967296 | 0, o > 0 && (this._length[s2] -= 4294967296 * o);
    return this;
  };
  Pn.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  Pn.prototype.digest = function(t) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var e = this._digest();
    t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
    for (var r = 0; r < 4; ++r)
      this._length[r] = 0;
    return e;
  };
  Pn.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  cv.exports = Pn;
});
var Al = k((OD, dv) => {
  U();
  var e7 = At(), uv = kp(), t7 = St().Buffer, r7 = new Array(16);
  function xl() {
    uv.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e7(xl, uv);
  xl.prototype._update = function() {
    for (var t = r7, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    var r = this._a, i = this._b, n = this._c, s2 = this._d;
    r = Mr2(r, i, n, s2, t[0], 3614090360, 7), s2 = Mr2(s2, r, i, n, t[1], 3905402710, 12), n = Mr2(n, s2, r, i, t[2], 606105819, 17), i = Mr2(i, n, s2, r, t[3], 3250441966, 22), r = Mr2(r, i, n, s2, t[4], 4118548399, 7), s2 = Mr2(s2, r, i, n, t[5], 1200080426, 12), n = Mr2(n, s2, r, i, t[6], 2821735955, 17), i = Mr2(i, n, s2, r, t[7], 4249261313, 22), r = Mr2(r, i, n, s2, t[8], 1770035416, 7), s2 = Mr2(s2, r, i, n, t[9], 2336552879, 12), n = Mr2(n, s2, r, i, t[10], 4294925233, 17), i = Mr2(i, n, s2, r, t[11], 2304563134, 22), r = Mr2(r, i, n, s2, t[12], 1804603682, 7), s2 = Mr2(s2, r, i, n, t[13], 4254626195, 12), n = Mr2(n, s2, r, i, t[14], 2792965006, 17), i = Mr2(i, n, s2, r, t[15], 1236535329, 22), r = Ir2(r, i, n, s2, t[1], 4129170786, 5), s2 = Ir2(s2, r, i, n, t[6], 3225465664, 9), n = Ir2(n, s2, r, i, t[11], 643717713, 14), i = Ir2(i, n, s2, r, t[0], 3921069994, 20), r = Ir2(r, i, n, s2, t[5], 3593408605, 5), s2 = Ir2(s2, r, i, n, t[10], 38016083, 9), n = Ir2(n, s2, r, i, t[15], 3634488961, 14), i = Ir2(i, n, s2, r, t[4], 3889429448, 20), r = Ir2(r, i, n, s2, t[9], 568446438, 5), s2 = Ir2(s2, r, i, n, t[14], 3275163606, 9), n = Ir2(n, s2, r, i, t[3], 4107603335, 14), i = Ir2(i, n, s2, r, t[8], 1163531501, 20), r = Ir2(r, i, n, s2, t[13], 2850285829, 5), s2 = Ir2(s2, r, i, n, t[2], 4243563512, 9), n = Ir2(n, s2, r, i, t[7], 1735328473, 14), i = Ir2(i, n, s2, r, t[12], 2368359562, 20), r = Tr2(r, i, n, s2, t[5], 4294588738, 4), s2 = Tr2(s2, r, i, n, t[8], 2272392833, 11), n = Tr2(n, s2, r, i, t[11], 1839030562, 16), i = Tr2(i, n, s2, r, t[14], 4259657740, 23), r = Tr2(r, i, n, s2, t[1], 2763975236, 4), s2 = Tr2(s2, r, i, n, t[4], 1272893353, 11), n = Tr2(n, s2, r, i, t[7], 4139469664, 16), i = Tr2(i, n, s2, r, t[10], 3200236656, 23), r = Tr2(r, i, n, s2, t[13], 681279174, 4), s2 = Tr2(s2, r, i, n, t[0], 3936430074, 11), n = Tr2(n, s2, r, i, t[3], 3572445317, 16), i = Tr2(i, n, s2, r, t[6], 76029189, 23), r = Tr2(r, i, n, s2, t[9], 3654602809, 4), s2 = Tr2(s2, r, i, n, t[12], 3873151461, 11), n = Tr2(n, s2, r, i, t[15], 530742520, 16), i = Tr2(i, n, s2, r, t[2], 3299628645, 23), r = Fr(r, i, n, s2, t[0], 4096336452, 6), s2 = Fr(s2, r, i, n, t[7], 1126891415, 10), n = Fr(n, s2, r, i, t[14], 2878612391, 15), i = Fr(i, n, s2, r, t[5], 4237533241, 21), r = Fr(r, i, n, s2, t[12], 1700485571, 6), s2 = Fr(s2, r, i, n, t[3], 2399980690, 10), n = Fr(n, s2, r, i, t[10], 4293915773, 15), i = Fr(i, n, s2, r, t[1], 2240044497, 21), r = Fr(r, i, n, s2, t[8], 1873313359, 6), s2 = Fr(s2, r, i, n, t[15], 4264355552, 10), n = Fr(n, s2, r, i, t[6], 2734768916, 15), i = Fr(i, n, s2, r, t[13], 1309151649, 21), r = Fr(r, i, n, s2, t[4], 4149444226, 6), s2 = Fr(s2, r, i, n, t[11], 3174756917, 10), n = Fr(n, s2, r, i, t[2], 718787259, 15), i = Fr(i, n, s2, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + i | 0, this._c = this._c + n | 0, this._d = this._d + s2 | 0;
  };
  xl.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = t7.allocUnsafe(16);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
  };
  function _l(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Mr2(t, e, r, i, n, s2, o) {
    return _l(t + (e & r | ~e & i) + n + s2 | 0, o) + e | 0;
  }
  function Ir2(t, e, r, i, n, s2, o) {
    return _l(t + (e & i | r & ~i) + n + s2 | 0, o) + e | 0;
  }
  function Tr2(t, e, r, i, n, s2, o) {
    return _l(t + (e ^ r ^ i) + n + s2 | 0, o) + e | 0;
  }
  function Fr(t, e, r, i, n, s2, o) {
    return _l(t + (r ^ (e | ~i)) + n + s2 | 0, o) + e | 0;
  }
  dv.exports = xl;
});
var Sl = k((jD, bv) => {
  U();
  var Dp = or().Buffer, i7 = At(), yv = kp(), n7 = new Array(16), Wf = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Vf = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], Yf = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], Jf = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], Zf = [0, 1518500249, 1859775393, 2400959708, 2840853838], Xf = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function El() {
    yv.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  i7(El, yv);
  El.prototype._update = function() {
    for (var t = n7, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    for (var r = this._a | 0, i = this._b | 0, n = this._c | 0, s2 = this._d | 0, o = this._e | 0, f = this._a | 0, l = this._b | 0, m3 = this._c | 0, A2 = this._d | 0, F3 = this._e | 0, z3 = 0; z3 < 80; z3 += 1) {
      var V, $;
      z3 < 16 ? (V = lv(r, i, n, s2, o, t[Wf[z3]], Zf[0], Yf[z3]), $ = mv(f, l, m3, A2, F3, t[Vf[z3]], Xf[0], Jf[z3])) : z3 < 32 ? (V = hv(r, i, n, s2, o, t[Wf[z3]], Zf[1], Yf[z3]), $ = gv(f, l, m3, A2, F3, t[Vf[z3]], Xf[1], Jf[z3])) : z3 < 48 ? (V = pv(r, i, n, s2, o, t[Wf[z3]], Zf[2], Yf[z3]), $ = pv(f, l, m3, A2, F3, t[Vf[z3]], Xf[2], Jf[z3])) : z3 < 64 ? (V = gv(r, i, n, s2, o, t[Wf[z3]], Zf[3], Yf[z3]), $ = hv(f, l, m3, A2, F3, t[Vf[z3]], Xf[3], Jf[z3])) : (V = mv(r, i, n, s2, o, t[Wf[z3]], Zf[4], Yf[z3]), $ = lv(f, l, m3, A2, F3, t[Vf[z3]], Xf[4], Jf[z3])), r = o, o = s2, s2 = Ts(n, 10), n = i, i = V, f = F3, F3 = A2, A2 = Ts(m3, 10), m3 = l, l = $;
    }
    var re = this._b + n + A2 | 0;
    this._b = this._c + s2 + F3 | 0, this._c = this._d + o + f | 0, this._d = this._e + r + l | 0, this._e = this._a + i + m3 | 0, this._a = re;
  };
  El.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = Dp.alloc ? Dp.alloc(20) : new Dp(20);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
  };
  function Ts(t, e) {
    return t << e | t >>> 32 - e;
  }
  function lv(t, e, r, i, n, s2, o, f) {
    return Ts(t + (e ^ r ^ i) + s2 + o | 0, f) + n | 0;
  }
  function hv(t, e, r, i, n, s2, o, f) {
    return Ts(t + (e & r | ~e & i) + s2 + o | 0, f) + n | 0;
  }
  function pv(t, e, r, i, n, s2, o, f) {
    return Ts(t + ((e | ~r) ^ i) + s2 + o | 0, f) + n | 0;
  }
  function gv(t, e, r, i, n, s2, o, f) {
    return Ts(t + (e & i | r & ~i) + s2 + o | 0, f) + n | 0;
  }
  function mv(t, e, r, i, n, s2, o, f) {
    return Ts(t + (e ^ (r | ~i)) + s2 + o | 0, f) + n | 0;
  }
  bv.exports = El;
});
var Fs = k((LD, wv) => {
  U();
  var vv = St().Buffer;
  function Ml(t, e) {
    this._block = vv.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
  }
  Ml.prototype.update = function(t, e) {
    typeof t == "string" && (e = e || "utf8", t = vv.from(t, e));
    for (var r = this._block, i = this._blockSize, n = t.length, s2 = this._len, o = 0; o < n; ) {
      for (var f = s2 % i, l = Math.min(n - o, i - f), m3 = 0; m3 < l; m3++)
        r[f + m3] = t[o + m3];
      s2 += l, o += l, s2 % i === 0 && this._update(r);
    }
    return this._len += n, this;
  };
  Ml.prototype.digest = function(t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r = this._len * 8;
    if (r <= 4294967295)
      this._block.writeUInt32BE(r, this._blockSize - 4);
    else {
      var i = (r & 4294967295) >>> 0, n = (r - i) / 4294967296;
      this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
    }
    this._update(this._block);
    var s2 = this._hash();
    return t ? s2.toString(t) : s2;
  };
  Ml.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  wv.exports = Ml;
});
var Av = k((qD, _v) => {
  U();
  var s7 = At(), xv = Fs(), o7 = St().Buffer, a7 = [1518500249, 1859775393, -1894007588, -899497514], f7 = new Array(80);
  function Qf() {
    this.init(), this._w = f7, xv.call(this, 64, 56);
  }
  s7(Qf, xv);
  Qf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function c7(t) {
    return t << 5 | t >>> 27;
  }
  function u7(t) {
    return t << 30 | t >>> 2;
  }
  function d7(t, e, r, i) {
    return t === 0 ? e & r | ~e & i : t === 2 ? e & r | e & i | r & i : e ^ r ^ i;
  }
  Qf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, s2 = this._d | 0, o = this._e | 0, f = 0; f < 16; ++f)
      e[f] = t.readInt32BE(f * 4);
    for (; f < 80; ++f)
      e[f] = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16];
    for (var l = 0; l < 80; ++l) {
      var m3 = ~~(l / 20), A2 = c7(r) + d7(m3, i, n, s2) + o + e[l] + a7[m3] | 0;
      o = s2, s2 = n, n = u7(i), i = r, r = A2;
    }
    this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = s2 + this._d | 0, this._e = o + this._e | 0;
  };
  Qf.prototype._hash = function() {
    var t = o7.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  _v.exports = Qf;
});
var Mv = k((PD, Sv) => {
  U();
  var l7 = At(), Ev = Fs(), h7 = St().Buffer, p7 = [1518500249, 1859775393, -1894007588, -899497514], g7 = new Array(80);
  function ec() {
    this.init(), this._w = g7, Ev.call(this, 64, 56);
  }
  l7(ec, Ev);
  ec.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function m7(t) {
    return t << 1 | t >>> 31;
  }
  function y7(t) {
    return t << 5 | t >>> 27;
  }
  function b7(t) {
    return t << 30 | t >>> 2;
  }
  function v7(t, e, r, i) {
    return t === 0 ? e & r | ~e & i : t === 2 ? e & r | e & i | r & i : e ^ r ^ i;
  }
  ec.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, s2 = this._d | 0, o = this._e | 0, f = 0; f < 16; ++f)
      e[f] = t.readInt32BE(f * 4);
    for (; f < 80; ++f)
      e[f] = m7(e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16]);
    for (var l = 0; l < 80; ++l) {
      var m3 = ~~(l / 20), A2 = y7(r) + v7(m3, i, n, s2) + o + e[l] + p7[m3] | 0;
      o = s2, s2 = n, n = b7(i), i = r, r = A2;
    }
    this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = s2 + this._d | 0, this._e = o + this._e | 0;
  };
  ec.prototype._hash = function() {
    var t = h7.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  Sv.exports = ec;
});
var Bp = k((UD, Tv) => {
  U();
  var w7 = At(), Iv = Fs(), x7 = St().Buffer, _7 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], A7 = new Array(64);
  function tc() {
    this.init(), this._w = A7, Iv.call(this, 64, 56);
  }
  w7(tc, Iv);
  tc.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function E7(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function S7(t, e, r) {
    return t & e | r & (t | e);
  }
  function M7(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
  }
  function I7(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
  }
  function T7(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
  }
  function F7(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
  }
  tc.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, s2 = this._d | 0, o = this._e | 0, f = this._f | 0, l = this._g | 0, m3 = this._h | 0, A2 = 0; A2 < 16; ++A2)
      e[A2] = t.readInt32BE(A2 * 4);
    for (; A2 < 64; ++A2)
      e[A2] = F7(e[A2 - 2]) + e[A2 - 7] + T7(e[A2 - 15]) + e[A2 - 16] | 0;
    for (var F3 = 0; F3 < 64; ++F3) {
      var z3 = m3 + I7(o) + E7(o, f, l) + _7[F3] + e[F3] | 0, V = M7(r) + S7(r, i, n) | 0;
      m3 = l, l = f, f = o, o = s2 + z3 | 0, s2 = n, n = i, i = r, r = z3 + V | 0;
    }
    this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = s2 + this._d | 0, this._e = o + this._e | 0, this._f = f + this._f | 0, this._g = l + this._g | 0, this._h = m3 + this._h | 0;
  };
  tc.prototype._hash = function() {
    var t = x7.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
  };
  Tv.exports = tc;
});
var Rv = k((zD, Fv) => {
  U();
  var R7 = At(), k7 = Bp(), D7 = Fs(), B7 = St().Buffer, N7 = new Array(64);
  function Il() {
    this.init(), this._w = N7, D7.call(this, 64, 56);
  }
  R7(Il, k7);
  Il.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  Il.prototype._hash = function() {
    var t = B7.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
  };
  Fv.exports = Il;
});
var Np = k((HD, jv) => {
  U();
  var C7 = At(), Ov = Fs(), O7 = St().Buffer, kv = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], j7 = new Array(160);
  function rc() {
    this.init(), this._w = j7, Ov.call(this, 128, 112);
  }
  C7(rc, Ov);
  rc.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function Dv(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function Bv(t, e, r) {
    return t & e | r & (t | e);
  }
  function Nv(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
  }
  function Cv(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
  }
  function L7(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
  }
  function q7(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
  }
  function P7(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
  }
  function U7(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
  }
  function mr(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0;
  }
  rc.prototype._update = function(t) {
    for (var e = this._w, r = this._ah | 0, i = this._bh | 0, n = this._ch | 0, s2 = this._dh | 0, o = this._eh | 0, f = this._fh | 0, l = this._gh | 0, m3 = this._hh | 0, A2 = this._al | 0, F3 = this._bl | 0, z3 = this._cl | 0, V = this._dl | 0, $ = this._el | 0, re = this._fl | 0, W2 = this._gl | 0, Z2 = this._hl | 0, ue = 0; ue < 32; ue += 2)
      e[ue] = t.readInt32BE(ue * 4), e[ue + 1] = t.readInt32BE(ue * 4 + 4);
    for (; ue < 160; ue += 2) {
      var ge = e[ue - 30], Se = e[ue - 15 * 2 + 1], pe2 = L7(ge, Se), H2 = q7(Se, ge);
      ge = e[ue - 2 * 2], Se = e[ue - 2 * 2 + 1];
      var le = P7(ge, Se), ie = U7(Se, ge), se = e[ue - 7 * 2], N3 = e[ue - 7 * 2 + 1], c2 = e[ue - 16 * 2], p2 = e[ue - 16 * 2 + 1], h2 = H2 + N3 | 0, a = pe2 + se + mr(h2, H2) | 0;
      h2 = h2 + ie | 0, a = a + le + mr(h2, ie) | 0, h2 = h2 + p2 | 0, a = a + c2 + mr(h2, p2) | 0, e[ue] = a, e[ue + 1] = h2;
    }
    for (var d2 = 0; d2 < 160; d2 += 2) {
      a = e[d2], h2 = e[d2 + 1];
      var b2 = Bv(r, i, n), _2 = Bv(A2, F3, z3), v = Nv(r, A2), u = Nv(A2, r), E2 = Cv(o, $), B = Cv($, o), y2 = kv[d2], M = kv[d2 + 1], de2 = Dv(o, f, l), Ee = Dv($, re, W2), Me = Z2 + B | 0, Oe = m3 + E2 + mr(Me, Z2) | 0;
      Me = Me + Ee | 0, Oe = Oe + de2 + mr(Me, Ee) | 0, Me = Me + M | 0, Oe = Oe + y2 + mr(Me, M) | 0, Me = Me + h2 | 0, Oe = Oe + a + mr(Me, h2) | 0;
      var be = u + _2 | 0, I = v + b2 + mr(be, u) | 0;
      m3 = l, Z2 = W2, l = f, W2 = re, f = o, re = $, $ = V + Me | 0, o = s2 + Oe + mr($, V) | 0, s2 = n, V = z3, n = i, z3 = F3, i = r, F3 = A2, A2 = Me + be | 0, r = Oe + I + mr(A2, Me) | 0;
    }
    this._al = this._al + A2 | 0, this._bl = this._bl + F3 | 0, this._cl = this._cl + z3 | 0, this._dl = this._dl + V | 0, this._el = this._el + $ | 0, this._fl = this._fl + re | 0, this._gl = this._gl + W2 | 0, this._hl = this._hl + Z2 | 0, this._ah = this._ah + r + mr(this._al, A2) | 0, this._bh = this._bh + i + mr(this._bl, F3) | 0, this._ch = this._ch + n + mr(this._cl, z3) | 0, this._dh = this._dh + s2 + mr(this._dl, V) | 0, this._eh = this._eh + o + mr(this._el, $) | 0, this._fh = this._fh + f + mr(this._fl, re) | 0, this._gh = this._gh + l + mr(this._gl, W2) | 0, this._hh = this._hh + m3 + mr(this._hl, Z2) | 0;
  };
  rc.prototype._hash = function() {
    var t = O7.allocUnsafe(64);
    function e(r, i, n) {
      t.writeInt32BE(r, n), t.writeInt32BE(i, n + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
  };
  jv.exports = rc;
});
var qv = k(($D, Lv) => {
  U();
  var z7 = At(), H7 = Np(), $7 = Fs(), G7 = St().Buffer, K7 = new Array(160);
  function Tl() {
    this.init(), this._w = K7, $7.call(this, 128, 112);
  }
  z7(Tl, H7);
  Tl.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  Tl.prototype._hash = function() {
    var t = G7.allocUnsafe(48);
    function e(r, i, n) {
      t.writeInt32BE(r, n), t.writeInt32BE(i, n + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
  };
  Lv.exports = Tl;
});
var Fl = k((on, Pv) => {
  U();
  var on = Pv.exports = function(e) {
    e = e.toLowerCase();
    var r = on[e];
    if (!r)
      throw new Error(e + " is not supported (we accept pull requests)");
    return new r();
  };
  on.sha = Av();
  on.sha1 = Mv();
  on.sha224 = Rv();
  on.sha256 = Bp();
  on.sha384 = qv();
  on.sha512 = Np();
});
var zv = k((GD, Uv) => {
  U();
  Uv.exports = ei;
  var Cp = Bd().EventEmitter, W7 = At();
  W7(ei, Cp);
  ei.Readable = ul();
  ei.Writable = al();
  ei.Duplex = On();
  ei.Transform = vl();
  ei.PassThrough = Ip();
  ei.finished = zf();
  ei.pipeline = Fp();
  ei.Stream = ei;
  function ei() {
    Cp.call(this);
  }
  ei.prototype.pipe = function(t, e) {
    var r = this;
    function i(A2) {
      t.writable && t.write(A2) === false && r.pause && r.pause();
    }
    r.on("data", i);
    function n() {
      r.readable && r.resume && r.resume();
    }
    t.on("drain", n), !t._isStdio && (!e || e.end !== false) && (r.on("end", o), r.on("close", f));
    var s2 = false;
    function o() {
      s2 || (s2 = true, t.end());
    }
    function f() {
      s2 || (s2 = true, typeof t.destroy == "function" && t.destroy());
    }
    function l(A2) {
      if (m3(), Cp.listenerCount(this, "error") === 0)
        throw A2;
    }
    r.on("error", l), t.on("error", l);
    function m3() {
      r.removeListener("data", i), t.removeListener("drain", n), r.removeListener("end", o), r.removeListener("close", f), r.removeListener("error", l), t.removeListener("error", l), r.removeListener("end", m3), r.removeListener("close", m3), t.removeListener("close", m3);
    }
    return r.on("end", m3), r.on("close", m3), t.on("close", m3), t.emit("pipe", r), t;
  };
});
var an = k((KD, Gv) => {
  U();
  var Hv = St().Buffer, $v = zv().Transform, V7 = dl().StringDecoder, Y7 = At();
  function xi(t) {
    $v.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  Y7(xi, $v);
  xi.prototype.update = function(t, e, r) {
    typeof t == "string" && (t = Hv.from(t, e));
    var i = this._update(t);
    return this.hashMode ? this : (r && (i = this._toString(i, r)), i);
  };
  xi.prototype.setAutoPadding = function() {
  };
  xi.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  xi.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  xi.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  xi.prototype._transform = function(t, e, r) {
    var i;
    try {
      this.hashMode ? this._update(t) : this.push(this._update(t));
    } catch (n) {
      i = n;
    } finally {
      r(i);
    }
  };
  xi.prototype._flush = function(t) {
    var e;
    try {
      this.push(this.__final());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  xi.prototype._finalOrDigest = function(t) {
    var e = this.__final() || Hv.alloc(0);
    return t && (e = this._toString(e, t, true)), e;
  };
  xi.prototype._toString = function(t, e, r) {
    if (this._decoder || (this._decoder = new V7(e), this._encoding = e), this._encoding !== e)
      throw new Error("can't switch encodings");
    var i = this._decoder.write(t);
    return r && (i += this._decoder.end()), i;
  };
  Gv.exports = xi;
});
var Wo = k((WD, Wv) => {
  U();
  var J7 = At(), Z7 = Al(), X7 = Sl(), Q7 = Fl(), Kv = an();
  function Rl(t) {
    Kv.call(this, "digest"), this._hash = t;
  }
  J7(Rl, Kv);
  Rl.prototype._update = function(t) {
    this._hash.update(t);
  };
  Rl.prototype._final = function() {
    return this._hash.digest();
  };
  Wv.exports = function(e) {
    return e = e.toLowerCase(), e === "md5" ? new Z7() : e === "rmd160" || e === "ripemd160" ? new X7() : new Rl(Q7(e));
  };
});
var Jv = k((VD, Yv) => {
  U();
  var eE = At(), Rs = St().Buffer, Vv = an(), tE = Rs.alloc(128), Vo = 64;
  function kl(t, e) {
    Vv.call(this, "digest"), typeof e == "string" && (e = Rs.from(e)), this._alg = t, this._key = e, e.length > Vo ? e = t(e) : e.length < Vo && (e = Rs.concat([e, tE], Vo));
    for (var r = this._ipad = Rs.allocUnsafe(Vo), i = this._opad = Rs.allocUnsafe(Vo), n = 0; n < Vo; n++)
      r[n] = e[n] ^ 54, i[n] = e[n] ^ 92;
    this._hash = [r];
  }
  eE(kl, Vv);
  kl.prototype._update = function(t) {
    this._hash.push(t);
  };
  kl.prototype._final = function() {
    var t = this._alg(Rs.concat(this._hash));
    return this._alg(Rs.concat([this._opad, t]));
  };
  Yv.exports = kl;
});
var Op = k((YD, Zv) => {
  U();
  var rE = Al();
  Zv.exports = function(t) {
    return new rE().update(t).digest();
  };
});
var qp = k((JD, Qv) => {
  U();
  var iE = At(), nE = Jv(), Xv = an(), ic = St().Buffer, sE = Op(), jp = Sl(), Lp = Fl(), oE = ic.alloc(128);
  function nc(t, e) {
    Xv.call(this, "digest"), typeof e == "string" && (e = ic.from(e));
    var r = t === "sha512" || t === "sha384" ? 128 : 64;
    if (this._alg = t, this._key = e, e.length > r) {
      var i = t === "rmd160" ? new jp() : Lp(t);
      e = i.update(e).digest();
    } else
      e.length < r && (e = ic.concat([e, oE], r));
    for (var n = this._ipad = ic.allocUnsafe(r), s2 = this._opad = ic.allocUnsafe(r), o = 0; o < r; o++)
      n[o] = e[o] ^ 54, s2[o] = e[o] ^ 92;
    this._hash = t === "rmd160" ? new jp() : Lp(t), this._hash.update(n);
  }
  iE(nc, Xv);
  nc.prototype._update = function(t) {
    this._hash.update(t);
  };
  nc.prototype._final = function() {
    var t = this._hash.digest(), e = this._alg === "rmd160" ? new jp() : Lp(this._alg);
    return e.update(this._opad).update(t).digest();
  };
  Qv.exports = function(e, r) {
    return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new nc("rmd160", r) : e === "md5" ? new nE(sE, r) : new nc(e, r);
  };
});
var Pp = k((ZD, aE) => {
  aE.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
});
var t2 = k((XD, e2) => {
  U();
  e2.exports = Pp();
});
var Up = k((QD, r2) => {
  U();
  var fE = Math.pow(2, 30) - 1;
  r2.exports = function(t, e) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof e != "number")
      throw new TypeError("Key length not a number");
    if (e < 0 || e > fE || e !== e)
      throw new TypeError("Bad key length");
  };
});
var zp = k((eB, n2) => {
  U();
  var Dl;
  N.process && N.process.browser ? Dl = "utf-8" : N.process && N.process.version ? (i2 = parseInt(W.default.version.split(".")[0].slice(1), 10), Dl = i2 >= 6 ? "utf-8" : "binary") : Dl = "utf-8";
  var i2;
  n2.exports = Dl;
});
var $p = k((tB, s2) => {
  U();
  var Hp = St().Buffer;
  s2.exports = function(t, e, r) {
    if (Hp.isBuffer(t))
      return t;
    if (typeof t == "string")
      return Hp.from(t, e);
    if (ArrayBuffer.isView(t))
      return Hp.from(t.buffer);
    throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
  };
});
var Gp = k((rB, c2) => {
  U();
  var cE = Op(), uE = Sl(), dE = Fl(), ks = St().Buffer, lE = Up(), o2 = zp(), a2 = $p(), hE = ks.alloc(128), Bl = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
  function f2(t, e, r) {
    var i = pE(t), n = t === "sha512" || t === "sha384" ? 128 : 64;
    e.length > n ? e = i(e) : e.length < n && (e = ks.concat([e, hE], n));
    for (var s2 = ks.allocUnsafe(n + Bl[t]), o = ks.allocUnsafe(n + Bl[t]), f = 0; f < n; f++)
      s2[f] = e[f] ^ 54, o[f] = e[f] ^ 92;
    var l = ks.allocUnsafe(n + r + 4);
    s2.copy(l, 0, 0, n), this.ipad1 = l, this.ipad2 = s2, this.opad = o, this.alg = t, this.blocksize = n, this.hash = i, this.size = Bl[t];
  }
  f2.prototype.run = function(t, e) {
    t.copy(e, this.blocksize);
    var r = this.hash(e);
    return r.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function pE(t) {
    function e(i) {
      return dE(t).update(i).digest();
    }
    function r(i) {
      return new uE().update(i).digest();
    }
    return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? cE : e;
  }
  function gE(t, e, r, i, n) {
    lE(r, i), t = a2(t, o2, "Password"), e = a2(e, o2, "Salt"), n = n || "sha1";
    var s2 = new f2(n, t, e.length), o = ks.allocUnsafe(i), f = ks.allocUnsafe(e.length + 4);
    e.copy(f, 0, 0, e.length);
    for (var l = 0, m3 = Bl[n], A2 = Math.ceil(i / m3), F3 = 1; F3 <= A2; F3++) {
      f.writeUInt32BE(F3, e.length);
      for (var z3 = s2.run(f, s2.ipad1), V = z3, $ = 1; $ < r; $++) {
        V = s2.run(V, s2.ipad2);
        for (var re = 0; re < m3; re++)
          z3[re] ^= V[re];
      }
      z3.copy(o, l), l += m3;
    }
    return o;
  }
  c2.exports = gE;
});
var m2 = k((iB, g2) => {
  U();
  var h2 = St().Buffer, mE = Up(), u2 = zp(), d2 = Gp(), l2 = $p(), Nl, sc = N.crypto && N.crypto.subtle, yE = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Kp = [];
  function bE(t) {
    if (N.process && !N.process.browser || !sc || !sc.importKey || !sc.deriveBits)
      return Promise.resolve(false);
    if (Kp[t] !== void 0)
      return Kp[t];
    Nl = Nl || h2.alloc(8);
    var e = p2(Nl, Nl, 10, 128, t).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    return Kp[t] = e, e;
  }
  var Ds;
  function Wp() {
    return Ds || (N.process && N.process.nextTick ? Ds = N.process.nextTick : N.queueMicrotask ? Ds = N.queueMicrotask : N.setImmediate ? Ds = N.setImmediate : Ds = N.setTimeout, Ds);
  }
  function p2(t, e, r, i, n) {
    return sc.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(s2) {
      return sc.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: n } }, s2, i << 3);
    }).then(function(s2) {
      return h2.from(s2);
    });
  }
  function vE(t, e) {
    t.then(function(r) {
      Wp()(function() {
        e(null, r);
      });
    }, function(r) {
      Wp()(function() {
        e(r);
      });
    });
  }
  g2.exports = function(t, e, r, i, n, s2) {
    typeof n == "function" && (s2 = n, n = void 0), n = n || "sha1";
    var o = yE[n.toLowerCase()];
    if (!o || typeof N.Promise != "function") {
      Wp()(function() {
        var f;
        try {
          f = d2(t, e, r, i, n);
        } catch (l) {
          return s2(l);
        }
        s2(null, f);
      });
      return;
    }
    if (mE(r, i), t = l2(t, u2, "Password"), e = l2(e, u2, "Salt"), typeof s2 != "function")
      throw new Error("No callback provided to pbkdf2");
    vE(bE(o).then(function(f) {
      return f ? p2(t, e, r, i, o) : d2(t, e, r, i, n);
    }), s2);
  };
});
var Yp = k((Vp) => {
  U();
  Vp.pbkdf2 = m2();
  Vp.pbkdf2Sync = Gp();
});
var Jp = k((ti) => {
  U();
  ti.readUInt32BE = function(e, r) {
    var i = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
    return i >>> 0;
  };
  ti.writeUInt32BE = function(e, r, i) {
    e[0 + i] = r >>> 24, e[1 + i] = r >>> 16 & 255, e[2 + i] = r >>> 8 & 255, e[3 + i] = r & 255;
  };
  ti.ip = function(e, r, i, n) {
    for (var s2 = 0, o = 0, f = 6; f >= 0; f -= 2) {
      for (var l = 0; l <= 24; l += 8)
        s2 <<= 1, s2 |= r >>> l + f & 1;
      for (var l = 0; l <= 24; l += 8)
        s2 <<= 1, s2 |= e >>> l + f & 1;
    }
    for (var f = 6; f >= 0; f -= 2) {
      for (var l = 1; l <= 25; l += 8)
        o <<= 1, o |= r >>> l + f & 1;
      for (var l = 1; l <= 25; l += 8)
        o <<= 1, o |= e >>> l + f & 1;
    }
    i[n + 0] = s2 >>> 0, i[n + 1] = o >>> 0;
  };
  ti.rip = function(e, r, i, n) {
    for (var s2 = 0, o = 0, f = 0; f < 4; f++)
      for (var l = 24; l >= 0; l -= 8)
        s2 <<= 1, s2 |= r >>> l + f & 1, s2 <<= 1, s2 |= e >>> l + f & 1;
    for (var f = 4; f < 8; f++)
      for (var l = 24; l >= 0; l -= 8)
        o <<= 1, o |= r >>> l + f & 1, o <<= 1, o |= e >>> l + f & 1;
    i[n + 0] = s2 >>> 0, i[n + 1] = o >>> 0;
  };
  ti.pc1 = function(e, r, i, n) {
    for (var s2 = 0, o = 0, f = 7; f >= 5; f--) {
      for (var l = 0; l <= 24; l += 8)
        s2 <<= 1, s2 |= r >> l + f & 1;
      for (var l = 0; l <= 24; l += 8)
        s2 <<= 1, s2 |= e >> l + f & 1;
    }
    for (var l = 0; l <= 24; l += 8)
      s2 <<= 1, s2 |= r >> l + f & 1;
    for (var f = 1; f <= 3; f++) {
      for (var l = 0; l <= 24; l += 8)
        o <<= 1, o |= r >> l + f & 1;
      for (var l = 0; l <= 24; l += 8)
        o <<= 1, o |= e >> l + f & 1;
    }
    for (var l = 0; l <= 24; l += 8)
      o <<= 1, o |= e >> l + f & 1;
    i[n + 0] = s2 >>> 0, i[n + 1] = o >>> 0;
  };
  ti.r28shl = function(e, r) {
    return e << r & 268435455 | e >>> 28 - r;
  };
  var Cl = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  ti.pc2 = function(e, r, i, n) {
    for (var s2 = 0, o = 0, f = Cl.length >>> 1, l = 0; l < f; l++)
      s2 <<= 1, s2 |= e >>> Cl[l] & 1;
    for (var l = f; l < Cl.length; l++)
      o <<= 1, o |= r >>> Cl[l] & 1;
    i[n + 0] = s2 >>> 0, i[n + 1] = o >>> 0;
  };
  ti.expand = function(e, r, i) {
    var n = 0, s2 = 0;
    n = (e & 1) << 5 | e >>> 27;
    for (var o = 23; o >= 15; o -= 4)
      n <<= 6, n |= e >>> o & 63;
    for (var o = 11; o >= 3; o -= 4)
      s2 |= e >>> o & 63, s2 <<= 6;
    s2 |= (e & 31) << 1 | e >>> 31, r[i + 0] = n >>> 0, r[i + 1] = s2 >>> 0;
  };
  var y2 = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  ti.substitute = function(e, r) {
    for (var i = 0, n = 0; n < 4; n++) {
      var s2 = e >>> 18 - n * 6 & 63, o = y2[n * 64 + s2];
      i <<= 4, i |= o;
    }
    for (var n = 0; n < 4; n++) {
      var s2 = r >>> 18 - n * 6 & 63, o = y2[4 * 64 + n * 64 + s2];
      i <<= 4, i |= o;
    }
    return i >>> 0;
  };
  var b2 = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  ti.permute = function(e) {
    for (var r = 0, i = 0; i < b2.length; i++)
      r <<= 1, r |= e >>> b2[i] & 1;
    return r >>> 0;
  };
  ti.padSplit = function(e, r, i) {
    for (var n = e.toString(2); n.length < r; )
      n = "0" + n;
    for (var s2 = [], o = 0; o < r; o += i)
      s2.push(n.slice(o, o + i));
    return s2.join(" ");
  };
});
var Gr = k((oB, w2) => {
  U();
  w2.exports = v2;
  function v2(t, e) {
    if (!t)
      throw new Error(e || "Assertion failed");
  }
  v2.equal = function(e, r, i) {
    if (e != r)
      throw new Error(i || "Assertion failed: " + e + " != " + r);
  };
});
var Ol = k((aB, x2) => {
  U();
  var wE = Gr();
  function ri(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t.padding !== false;
  }
  x2.exports = ri;
  ri.prototype._init = function() {
  };
  ri.prototype.update = function(e) {
    return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
  };
  ri.prototype._buffer = function(e, r) {
    for (var i = Math.min(this.buffer.length - this.bufferOff, e.length - r), n = 0; n < i; n++)
      this.buffer[this.bufferOff + n] = e[r + n];
    return this.bufferOff += i, i;
  };
  ri.prototype._flushBuffer = function(e, r) {
    return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
  };
  ri.prototype._updateEncrypt = function(e) {
    var r = 0, i = 0, n = (this.bufferOff + e.length) / this.blockSize | 0, s2 = new Array(n * this.blockSize);
    this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (i += this._flushBuffer(s2, i)));
    for (var o = e.length - (e.length - r) % this.blockSize; r < o; r += this.blockSize)
      this._update(e, r, s2, i), i += this.blockSize;
    for (; r < e.length; r++, this.bufferOff++)
      this.buffer[this.bufferOff] = e[r];
    return s2;
  };
  ri.prototype._updateDecrypt = function(e) {
    for (var r = 0, i = 0, n = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, s2 = new Array(n * this.blockSize); n > 0; n--)
      r += this._buffer(e, r), i += this._flushBuffer(s2, i);
    return r += this._buffer(e, r), s2;
  };
  ri.prototype.final = function(e) {
    var r;
    e && (r = this.update(e));
    var i;
    return this.type === "encrypt" ? i = this._finalEncrypt() : i = this._finalDecrypt(), r ? r.concat(i) : i;
  };
  ri.prototype._pad = function(e, r) {
    if (r === 0)
      return false;
    for (; r < e.length; )
      e[r++] = 0;
    return true;
  };
  ri.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var e = new Array(this.blockSize);
    return this._update(this.buffer, 0, e, 0), e;
  };
  ri.prototype._unpad = function(e) {
    return e;
  };
  ri.prototype._finalDecrypt = function() {
    wE.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var e = new Array(this.blockSize);
    return this._flushBuffer(e, 0), this._unpad(e);
  };
});
var Zp = k((fB, E2) => {
  U();
  var _2 = Gr(), xE = At(), dr2 = Jp(), A2 = Ol();
  function _E() {
    this.tmp = new Array(2), this.keys = null;
  }
  function qi(t) {
    A2.call(this, t);
    var e = new _E();
    this._desState = e, this.deriveKeys(e, t.key);
  }
  xE(qi, A2);
  E2.exports = qi;
  qi.create = function(e) {
    return new qi(e);
  };
  var AE = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  qi.prototype.deriveKeys = function(e, r) {
    e.keys = new Array(16 * 2), _2.equal(r.length, this.blockSize, "Invalid key length");
    var i = dr2.readUInt32BE(r, 0), n = dr2.readUInt32BE(r, 4);
    dr2.pc1(i, n, e.tmp, 0), i = e.tmp[0], n = e.tmp[1];
    for (var s2 = 0; s2 < e.keys.length; s2 += 2) {
      var o = AE[s2 >>> 1];
      i = dr2.r28shl(i, o), n = dr2.r28shl(n, o), dr2.pc2(i, n, e.keys, s2);
    }
  };
  qi.prototype._update = function(e, r, i, n) {
    var s2 = this._desState, o = dr2.readUInt32BE(e, r), f = dr2.readUInt32BE(e, r + 4);
    dr2.ip(o, f, s2.tmp, 0), o = s2.tmp[0], f = s2.tmp[1], this.type === "encrypt" ? this._encrypt(s2, o, f, s2.tmp, 0) : this._decrypt(s2, o, f, s2.tmp, 0), o = s2.tmp[0], f = s2.tmp[1], dr2.writeUInt32BE(i, o, n), dr2.writeUInt32BE(i, f, n + 4);
  };
  qi.prototype._pad = function(e, r) {
    if (this.padding === false)
      return false;
    for (var i = e.length - r, n = r; n < e.length; n++)
      e[n] = i;
    return true;
  };
  qi.prototype._unpad = function(e) {
    if (this.padding === false)
      return e;
    for (var r = e[e.length - 1], i = e.length - r; i < e.length; i++)
      _2.equal(e[i], r);
    return e.slice(0, e.length - r);
  };
  qi.prototype._encrypt = function(e, r, i, n, s2) {
    for (var o = r, f = i, l = 0; l < e.keys.length; l += 2) {
      var m3 = e.keys[l], A3 = e.keys[l + 1];
      dr2.expand(f, e.tmp, 0), m3 ^= e.tmp[0], A3 ^= e.tmp[1];
      var F3 = dr2.substitute(m3, A3), z3 = dr2.permute(F3), V = f;
      f = (o ^ z3) >>> 0, o = V;
    }
    dr2.rip(f, o, n, s2);
  };
  qi.prototype._decrypt = function(e, r, i, n, s2) {
    for (var o = i, f = r, l = e.keys.length - 2; l >= 0; l -= 2) {
      var m3 = e.keys[l], A3 = e.keys[l + 1];
      dr2.expand(o, e.tmp, 0), m3 ^= e.tmp[0], A3 ^= e.tmp[1];
      var F3 = dr2.substitute(m3, A3), z3 = dr2.permute(F3), V = o;
      o = (f ^ z3) >>> 0, f = V;
    }
    dr2.rip(o, f, n, s2);
  };
});
var M2 = k((S2) => {
  U();
  var EE = Gr(), SE = At(), jl = {};
  function ME(t) {
    EE.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e = 0; e < this.iv.length; e++)
      this.iv[e] = t[e];
  }
  function IE(t) {
    function e(s2) {
      t.call(this, s2), this._cbcInit();
    }
    SE(e, t);
    for (var r = Object.keys(jl), i = 0; i < r.length; i++) {
      var n = r[i];
      e.prototype[n] = jl[n];
    }
    return e.create = function(o) {
      return new e(o);
    }, e;
  }
  S2.instantiate = IE;
  jl._cbcInit = function() {
    var e = new ME(this.options.iv);
    this._cbcState = e;
  };
  jl._update = function(e, r, i, n) {
    var s2 = this._cbcState, o = this.constructor.super_.prototype, f = s2.iv;
    if (this.type === "encrypt") {
      for (var l = 0; l < this.blockSize; l++)
        f[l] ^= e[r + l];
      o._update.call(this, f, 0, i, n);
      for (var l = 0; l < this.blockSize; l++)
        f[l] = i[n + l];
    } else {
      o._update.call(this, e, r, i, n);
      for (var l = 0; l < this.blockSize; l++)
        i[n + l] ^= f[l];
      for (var l = 0; l < this.blockSize; l++)
        f[l] = e[r + l];
    }
  };
});
var F2 = k((uB, T2) => {
  U();
  var TE = Gr(), FE = At(), I2 = Ol(), Un = Zp();
  function RE(t, e) {
    TE.equal(e.length, 24, "Invalid key length");
    var r = e.slice(0, 8), i = e.slice(8, 16), n = e.slice(16, 24);
    t === "encrypt" ? this.ciphers = [Un.create({ type: "encrypt", key: r }), Un.create({ type: "decrypt", key: i }), Un.create({ type: "encrypt", key: n })] : this.ciphers = [Un.create({ type: "decrypt", key: n }), Un.create({ type: "encrypt", key: i }), Un.create({ type: "decrypt", key: r })];
  }
  function Bs(t) {
    I2.call(this, t);
    var e = new RE(this.type, this.options.key);
    this._edeState = e;
  }
  FE(Bs, I2);
  T2.exports = Bs;
  Bs.create = function(e) {
    return new Bs(e);
  };
  Bs.prototype._update = function(e, r, i, n) {
    var s2 = this._edeState;
    s2.ciphers[0]._update(e, r, i, n), s2.ciphers[1]._update(i, n, i, n), s2.ciphers[2]._update(i, n, i, n);
  };
  Bs.prototype._pad = Un.prototype._pad;
  Bs.prototype._unpad = Un.prototype._unpad;
});
var R2 = k((Yo) => {
  U();
  Yo.utils = Jp();
  Yo.Cipher = Ol();
  Yo.DES = Zp();
  Yo.CBC = M2();
  Yo.EDE = F2();
});
var B2 = k((lB, D2) => {
  U();
  var k2 = an(), fn = R2(), kE = At(), Ns = St().Buffer, oc = { "des-ede3-cbc": fn.CBC.instantiate(fn.EDE), "des-ede3": fn.EDE, "des-ede-cbc": fn.CBC.instantiate(fn.EDE), "des-ede": fn.EDE, "des-cbc": fn.CBC.instantiate(fn.DES), "des-ecb": fn.DES };
  oc.des = oc["des-cbc"];
  oc.des3 = oc["des-ede3-cbc"];
  D2.exports = Ll;
  kE(Ll, k2);
  function Ll(t) {
    k2.call(this);
    var e = t.mode.toLowerCase(), r = oc[e], i;
    t.decrypt ? i = "decrypt" : i = "encrypt";
    var n = t.key;
    Ns.isBuffer(n) || (n = Ns.from(n)), (e === "des-ede" || e === "des-ede-cbc") && (n = Ns.concat([n, n.slice(0, 8)]));
    var s2 = t.iv;
    Ns.isBuffer(s2) || (s2 = Ns.from(s2)), this._des = r.create({ key: n, iv: s2, type: i });
  }
  Ll.prototype._update = function(t) {
    return Ns.from(this._des.update(t));
  };
  Ll.prototype._final = function() {
    return Ns.from(this._des.final());
  };
});
var N2 = k((Xp) => {
  U();
  Xp.encrypt = function(t, e) {
    return t._cipher.encryptBlock(e);
  };
  Xp.decrypt = function(t, e) {
    return t._cipher.decryptBlock(e);
  };
});
var Jo = k((pB, C2) => {
  U();
  C2.exports = function(e, r) {
    for (var i = Math.min(e.length, r.length), n = new b.Buffer(i), s2 = 0; s2 < i; ++s2)
      n[s2] = e[s2] ^ r[s2];
    return n;
  };
});
var j2 = k((Qp) => {
  U();
  var O2 = Jo();
  Qp.encrypt = function(t, e) {
    var r = O2(e, t._prev);
    return t._prev = t._cipher.encryptBlock(r), t._prev;
  };
  Qp.decrypt = function(t, e) {
    var r = t._prev;
    t._prev = e;
    var i = t._cipher.decryptBlock(e);
    return O2(i, r);
  };
});
var P2 = k((q2) => {
  U();
  var ac = St().Buffer, DE = Jo();
  function L2(t, e, r) {
    var i = e.length, n = DE(e, t._cache);
    return t._cache = t._cache.slice(i), t._prev = ac.concat([t._prev, r ? e : n]), n;
  }
  q2.encrypt = function(t, e, r) {
    for (var i = ac.allocUnsafe(0), n; e.length; )
      if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = ac.allocUnsafe(0)), t._cache.length <= e.length)
        n = t._cache.length, i = ac.concat([i, L2(t, e.slice(0, n), r)]), e = e.slice(n);
      else {
        i = ac.concat([i, L2(t, e, r)]);
        break;
      }
    return i;
  };
});
var z2 = k((U2) => {
  U();
  var e1 = St().Buffer;
  function BE(t, e, r) {
    var i = t._cipher.encryptBlock(t._prev), n = i[0] ^ e;
    return t._prev = e1.concat([t._prev.slice(1), e1.from([r ? e : n])]), n;
  }
  U2.encrypt = function(t, e, r) {
    for (var i = e.length, n = e1.allocUnsafe(i), s2 = -1; ++s2 < i; )
      n[s2] = BE(t, e[s2], r);
    return n;
  };
});
var $2 = k((H2) => {
  U();
  var ql = St().Buffer;
  function NE(t, e, r) {
    for (var i, n = -1, s2 = 8, o = 0, f, l; ++n < s2; )
      i = t._cipher.encryptBlock(t._prev), f = e & 1 << 7 - n ? 128 : 0, l = i[0] ^ f, o += (l & 128) >> n % 8, t._prev = CE(t._prev, r ? f : l);
    return o;
  }
  function CE(t, e) {
    var r = t.length, i = -1, n = ql.allocUnsafe(t.length);
    for (t = ql.concat([t, ql.from([e])]); ++i < r; )
      n[i] = t[i] << 1 | t[i + 1] >> 7;
    return n;
  }
  H2.encrypt = function(t, e, r) {
    for (var i = e.length, n = ql.allocUnsafe(i), s2 = -1; ++s2 < i; )
      n[s2] = NE(t, e[s2], r);
    return n;
  };
});
var K2 = k((G2) => {
  U();
  var OE = Jo();
  function jE(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
  }
  G2.encrypt = function(t, e) {
    for (; t._cache.length < e.length; )
      t._cache = b.Buffer.concat([t._cache, jE(t)]);
    var r = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), OE(e, r);
  };
});
var t1 = k((wB, W2) => {
  U();
  function LE(t) {
    for (var e = t.length, r; e--; )
      if (r = t.readUInt8(e), r === 255)
        t.writeUInt8(0, e);
      else {
        r++, t.writeUInt8(r, e);
        break;
      }
  }
  W2.exports = LE;
});
var i1 = k((Y2) => {
  U();
  var qE = Jo(), V2 = St().Buffer, PE = t1();
  function UE(t) {
    var e = t._cipher.encryptBlockRaw(t._prev);
    return PE(t._prev), e;
  }
  var r1 = 16;
  Y2.encrypt = function(t, e) {
    var r = Math.ceil(e.length / r1), i = t._cache.length;
    t._cache = V2.concat([t._cache, V2.allocUnsafe(r * r1)]);
    for (var n = 0; n < r; n++) {
      var s2 = UE(t), o = i + n * r1;
      t._cache.writeUInt32BE(s2[0], o + 0), t._cache.writeUInt32BE(s2[1], o + 4), t._cache.writeUInt32BE(s2[2], o + 8), t._cache.writeUInt32BE(s2[3], o + 12);
    }
    var f = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), qE(e, f);
  };
});
var n1 = k((_B, zE) => {
  zE.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
});
var Ul = k((AB, J2) => {
  U();
  var HE = { ECB: N2(), CBC: j2(), CFB: P2(), CFB8: z2(), CFB1: $2(), OFB: K2(), CTR: i1(), GCM: i1() }, Pl = n1();
  for (s1 in Pl)
    Pl[s1].module = HE[Pl[s1].mode];
  var s1;
  J2.exports = Pl;
});
var fc = k((EB, X2) => {
  U();
  var zl = St().Buffer;
  function a1(t) {
    zl.isBuffer(t) || (t = zl.from(t));
    for (var e = t.length / 4 | 0, r = new Array(e), i = 0; i < e; i++)
      r[i] = t.readUInt32BE(i * 4);
    return r;
  }
  function o1(t) {
    for (var e = 0; e < t.length; t++)
      t[e] = 0;
  }
  function Z2(t, e, r, i, n) {
    for (var s2 = r[0], o = r[1], f = r[2], l = r[3], m3 = t[0] ^ e[0], A2 = t[1] ^ e[1], F3 = t[2] ^ e[2], z3 = t[3] ^ e[3], V, $, re, W2, Z5 = 4, ue = 1; ue < n; ue++)
      V = s2[m3 >>> 24] ^ o[A2 >>> 16 & 255] ^ f[F3 >>> 8 & 255] ^ l[z3 & 255] ^ e[Z5++], $ = s2[A2 >>> 24] ^ o[F3 >>> 16 & 255] ^ f[z3 >>> 8 & 255] ^ l[m3 & 255] ^ e[Z5++], re = s2[F3 >>> 24] ^ o[z3 >>> 16 & 255] ^ f[m3 >>> 8 & 255] ^ l[A2 & 255] ^ e[Z5++], W2 = s2[z3 >>> 24] ^ o[m3 >>> 16 & 255] ^ f[A2 >>> 8 & 255] ^ l[F3 & 255] ^ e[Z5++], m3 = V, A2 = $, F3 = re, z3 = W2;
    return V = (i[m3 >>> 24] << 24 | i[A2 >>> 16 & 255] << 16 | i[F3 >>> 8 & 255] << 8 | i[z3 & 255]) ^ e[Z5++], $ = (i[A2 >>> 24] << 24 | i[F3 >>> 16 & 255] << 16 | i[z3 >>> 8 & 255] << 8 | i[m3 & 255]) ^ e[Z5++], re = (i[F3 >>> 24] << 24 | i[z3 >>> 16 & 255] << 16 | i[m3 >>> 8 & 255] << 8 | i[A2 & 255]) ^ e[Z5++], W2 = (i[z3 >>> 24] << 24 | i[m3 >>> 16 & 255] << 16 | i[A2 >>> 8 & 255] << 8 | i[F3 & 255]) ^ e[Z5++], V = V >>> 0, $ = $ >>> 0, re = re >>> 0, W2 = W2 >>> 0, [V, $, re, W2];
  }
  var $E = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], cr = function() {
    for (var t = new Array(256), e = 0; e < 256; e++)
      e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
    for (var r = [], i = [], n = [[], [], [], []], s2 = [[], [], [], []], o = 0, f = 0, l = 0; l < 256; ++l) {
      var m3 = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4;
      m3 = m3 >>> 8 ^ m3 & 255 ^ 99, r[o] = m3, i[m3] = o;
      var A2 = t[o], F3 = t[A2], z3 = t[F3], V = t[m3] * 257 ^ m3 * 16843008;
      n[0][o] = V << 24 | V >>> 8, n[1][o] = V << 16 | V >>> 16, n[2][o] = V << 8 | V >>> 24, n[3][o] = V, V = z3 * 16843009 ^ F3 * 65537 ^ A2 * 257 ^ o * 16843008, s2[0][m3] = V << 24 | V >>> 8, s2[1][m3] = V << 16 | V >>> 16, s2[2][m3] = V << 8 | V >>> 24, s2[3][m3] = V, o === 0 ? o = f = 1 : (o = A2 ^ t[t[t[z3 ^ A2]]], f ^= t[t[f]]);
    }
    return { SBOX: r, INV_SBOX: i, SUB_MIX: n, INV_SUB_MIX: s2 };
  }();
  function ii(t) {
    this._key = a1(t), this._reset();
  }
  ii.blockSize = 4 * 4;
  ii.keySize = 256 / 8;
  ii.prototype.blockSize = ii.blockSize;
  ii.prototype.keySize = ii.keySize;
  ii.prototype._reset = function() {
    for (var t = this._key, e = t.length, r = e + 6, i = (r + 1) * 4, n = [], s2 = 0; s2 < e; s2++)
      n[s2] = t[s2];
    for (s2 = e; s2 < i; s2++) {
      var o = n[s2 - 1];
      s2 % e === 0 ? (o = o << 8 | o >>> 24, o = cr.SBOX[o >>> 24] << 24 | cr.SBOX[o >>> 16 & 255] << 16 | cr.SBOX[o >>> 8 & 255] << 8 | cr.SBOX[o & 255], o ^= $E[s2 / e | 0] << 24) : e > 6 && s2 % e === 4 && (o = cr.SBOX[o >>> 24] << 24 | cr.SBOX[o >>> 16 & 255] << 16 | cr.SBOX[o >>> 8 & 255] << 8 | cr.SBOX[o & 255]), n[s2] = n[s2 - e] ^ o;
    }
    for (var f = [], l = 0; l < i; l++) {
      var m3 = i - l, A2 = n[m3 - (l % 4 ? 0 : 4)];
      l < 4 || m3 <= 4 ? f[l] = A2 : f[l] = cr.INV_SUB_MIX[0][cr.SBOX[A2 >>> 24]] ^ cr.INV_SUB_MIX[1][cr.SBOX[A2 >>> 16 & 255]] ^ cr.INV_SUB_MIX[2][cr.SBOX[A2 >>> 8 & 255]] ^ cr.INV_SUB_MIX[3][cr.SBOX[A2 & 255]];
    }
    this._nRounds = r, this._keySchedule = n, this._invKeySchedule = f;
  };
  ii.prototype.encryptBlockRaw = function(t) {
    return t = a1(t), Z2(t, this._keySchedule, cr.SUB_MIX, cr.SBOX, this._nRounds);
  };
  ii.prototype.encryptBlock = function(t) {
    var e = this.encryptBlockRaw(t), r = zl.allocUnsafe(16);
    return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
  };
  ii.prototype.decryptBlock = function(t) {
    t = a1(t);
    var e = t[1];
    t[1] = t[3], t[3] = e;
    var r = Z2(t, this._invKeySchedule, cr.INV_SUB_MIX, cr.INV_SBOX, this._nRounds), i = zl.allocUnsafe(16);
    return i.writeUInt32BE(r[0], 0), i.writeUInt32BE(r[3], 4), i.writeUInt32BE(r[2], 8), i.writeUInt32BE(r[1], 12), i;
  };
  ii.prototype.scrub = function() {
    o1(this._keySchedule), o1(this._invKeySchedule), o1(this._key);
  };
  X2.exports.AES = ii;
});
var tw = k((SB, ew) => {
  U();
  var Zo = St().Buffer, GE = Zo.alloc(16, 0);
  function KE(t) {
    return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
  }
  function Q2(t) {
    var e = Zo.allocUnsafe(16);
    return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
  }
  function cc(t) {
    this.h = t, this.state = Zo.alloc(16, 0), this.cache = Zo.allocUnsafe(0);
  }
  cc.prototype.ghash = function(t) {
    for (var e = -1; ++e < t.length; )
      this.state[e] ^= t[e];
    this._multiply();
  };
  cc.prototype._multiply = function() {
    for (var t = KE(this.h), e = [0, 0, 0, 0], r, i, n, s2 = -1; ++s2 < 128; ) {
      for (i = (this.state[~~(s2 / 8)] & 1 << 7 - s2 % 8) !== 0, i && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), n = (t[3] & 1) !== 0, r = 3; r > 0; r--)
        t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
      t[0] = t[0] >>> 1, n && (t[0] = t[0] ^ 225 << 24);
    }
    this.state = Q2(e);
  };
  cc.prototype.update = function(t) {
    this.cache = Zo.concat([this.cache, t]);
    for (var e; this.cache.length >= 16; )
      e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
  };
  cc.prototype.final = function(t, e) {
    return this.cache.length && this.ghash(Zo.concat([this.cache, GE], 16)), this.ghash(Q2([0, t, 0, e])), this.state;
  };
  ew.exports = cc;
});
var f1 = k((MB, nw) => {
  U();
  var WE = fc(), qr = St().Buffer, rw = an(), VE = At(), iw = tw(), YE = Jo(), JE = t1();
  function ZE(t, e) {
    var r = 0;
    t.length !== e.length && r++;
    for (var i = Math.min(t.length, e.length), n = 0; n < i; ++n)
      r += t[n] ^ e[n];
    return r;
  }
  function XE(t, e, r) {
    if (e.length === 12)
      return t._finID = qr.concat([e, qr.from([0, 0, 0, 1])]), qr.concat([e, qr.from([0, 0, 0, 2])]);
    var i = new iw(r), n = e.length, s2 = n % 16;
    i.update(e), s2 && (s2 = 16 - s2, i.update(qr.alloc(s2, 0))), i.update(qr.alloc(8, 0));
    var o = n * 8, f = qr.alloc(8);
    f.writeUIntBE(o, 0, 8), i.update(f), t._finID = i.state;
    var l = qr.from(t._finID);
    return JE(l), l;
  }
  function Cs(t, e, r, i) {
    rw.call(this);
    var n = qr.alloc(4, 0);
    this._cipher = new WE.AES(e);
    var s2 = this._cipher.encryptBlock(n);
    this._ghash = new iw(s2), r = XE(this, r, s2), this._prev = qr.from(r), this._cache = qr.allocUnsafe(0), this._secCache = qr.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
  }
  VE(Cs, rw);
  Cs.prototype._update = function(t) {
    if (!this._called && this._alen) {
      var e = 16 - this._alen % 16;
      e < 16 && (e = qr.alloc(e, 0), this._ghash.update(e));
    }
    this._called = true;
    var r = this._mode.encrypt(this, t);
    return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
  };
  Cs.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var t = YE(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ZE(t, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = t, this._cipher.scrub();
  };
  Cs.prototype.getAuthTag = function() {
    if (this._decrypt || !qr.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  Cs.prototype.setAuthTag = function(e) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = e;
  };
  Cs.prototype.setAAD = function(e) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(e), this._alen += e.length;
  };
  nw.exports = Cs;
});
var u1 = k((IB, ow) => {
  U();
  var QE = fc(), c1 = St().Buffer, sw = an(), eS = At();
  function Hl(t, e, r, i) {
    sw.call(this), this._cipher = new QE.AES(e), this._prev = c1.from(r), this._cache = c1.allocUnsafe(0), this._secCache = c1.allocUnsafe(0), this._decrypt = i, this._mode = t;
  }
  eS(Hl, sw);
  Hl.prototype._update = function(t) {
    return this._mode.encrypt(this, t, this._decrypt);
  };
  Hl.prototype._final = function() {
    this._cipher.scrub();
  };
  ow.exports = Hl;
});
var uc = k((TB, aw) => {
  U();
  var Os = St().Buffer, tS = Al();
  function rS(t, e, r, i) {
    if (Os.isBuffer(t) || (t = Os.from(t, "binary")), e && (Os.isBuffer(e) || (e = Os.from(e, "binary")), e.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var n = r / 8, s2 = Os.alloc(n), o = Os.alloc(i || 0), f = Os.alloc(0); n > 0 || i > 0; ) {
      var l = new tS();
      l.update(f), l.update(t), e && l.update(e), f = l.digest();
      var m3 = 0;
      if (n > 0) {
        var A2 = s2.length - n;
        m3 = Math.min(n, f.length), f.copy(s2, A2, 0, m3), n -= m3;
      }
      if (m3 < f.length && i > 0) {
        var F3 = o.length - i, z3 = Math.min(i, f.length - m3);
        f.copy(o, F3, m3, m3 + z3), i -= z3;
      }
    }
    return f.fill(0), { key: s2, iv: o };
  }
  aw.exports = rS;
});
var dw = k((d1) => {
  U();
  var fw = Ul(), iS = f1(), cn = St().Buffer, nS = u1(), cw = an(), sS = fc(), oS = uc(), aS = At();
  function dc(t, e, r) {
    cw.call(this), this._cache = new $l(), this._cipher = new sS.AES(e), this._prev = cn.from(r), this._mode = t, this._autopadding = true;
  }
  aS(dc, cw);
  dc.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, i = []; e = this._cache.get(); )
      r = this._mode.encrypt(this, e), i.push(r);
    return cn.concat(i);
  };
  var fS = cn.alloc(16, 16);
  dc.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
    if (!t.equals(fS))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  dc.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function $l() {
    this.cache = cn.allocUnsafe(0);
  }
  $l.prototype.add = function(t) {
    this.cache = cn.concat([this.cache, t]);
  };
  $l.prototype.get = function() {
    if (this.cache.length > 15) {
      var t = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), t;
    }
    return null;
  };
  $l.prototype.flush = function() {
    for (var t = 16 - this.cache.length, e = cn.allocUnsafe(t), r = -1; ++r < t; )
      e.writeUInt8(t, r);
    return cn.concat([this.cache, e]);
  };
  function uw(t, e, r) {
    var i = fw[t.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof e == "string" && (e = cn.from(e)), e.length !== i.key / 8)
      throw new TypeError("invalid key length " + e.length);
    if (typeof r == "string" && (r = cn.from(r)), i.mode !== "GCM" && r.length !== i.iv)
      throw new TypeError("invalid iv length " + r.length);
    return i.type === "stream" ? new nS(i.module, e, r) : i.type === "auth" ? new iS(i.module, e, r) : new dc(i.module, e, r);
  }
  function cS(t, e) {
    var r = fw[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var i = oS(e, false, r.key, r.iv);
    return uw(t, i.key, i.iv);
  }
  d1.createCipheriv = uw;
  d1.createCipher = cS;
});
var gw = k((l1) => {
  U();
  var uS = f1(), Xo = St().Buffer, lw = Ul(), dS = u1(), hw = an(), lS = fc(), hS = uc(), pS = At();
  function lc(t, e, r) {
    hw.call(this), this._cache = new Gl(), this._last = void 0, this._cipher = new lS.AES(e), this._prev = Xo.from(r), this._mode = t, this._autopadding = true;
  }
  pS(lc, hw);
  lc.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, i = []; e = this._cache.get(this._autopadding); )
      r = this._mode.decrypt(this, e), i.push(r);
    return Xo.concat(i);
  };
  lc.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return gS(this._mode.decrypt(this, t));
    if (t)
      throw new Error("data not multiple of block length");
  };
  lc.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Gl() {
    this.cache = Xo.allocUnsafe(0);
  }
  Gl.prototype.add = function(t) {
    this.cache = Xo.concat([this.cache, t]);
  };
  Gl.prototype.get = function(t) {
    var e;
    if (t) {
      if (this.cache.length > 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    } else if (this.cache.length >= 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    return null;
  };
  Gl.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function gS(t) {
    var e = t[15];
    if (e < 1 || e > 16)
      throw new Error("unable to decrypt data");
    for (var r = -1; ++r < e; )
      if (t[r + (16 - e)] !== e)
        throw new Error("unable to decrypt data");
    if (e !== 16)
      return t.slice(0, 16 - e);
  }
  function pw(t, e, r) {
    var i = lw[t.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof r == "string" && (r = Xo.from(r)), i.mode !== "GCM" && r.length !== i.iv)
      throw new TypeError("invalid iv length " + r.length);
    if (typeof e == "string" && (e = Xo.from(e)), e.length !== i.key / 8)
      throw new TypeError("invalid key length " + e.length);
    return i.type === "stream" ? new dS(i.module, e, r, true) : i.type === "auth" ? new uS(i.module, e, r, true) : new lc(i.module, e, r);
  }
  function mS(t, e) {
    var r = lw[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var i = hS(e, false, r.key, r.iv);
    return pw(t, i.key, i.iv);
  }
  l1.createDecipher = mS;
  l1.createDecipheriv = pw;
});
var Kl = k((_i) => {
  U();
  var mw = dw(), yw = gw(), yS = n1();
  function bS() {
    return Object.keys(yS);
  }
  _i.createCipher = _i.Cipher = mw.createCipher;
  _i.createCipheriv = _i.Cipheriv = mw.createCipheriv;
  _i.createDecipher = _i.Decipher = yw.createDecipher;
  _i.createDecipheriv = _i.Decipheriv = yw.createDecipheriv;
  _i.listCiphers = _i.getCiphers = bS;
});
var bw = k((un) => {
  U();
  un["des-ecb"] = { key: 8, iv: 0 };
  un["des-cbc"] = un.des = { key: 8, iv: 8 };
  un["des-ede3-cbc"] = un.des3 = { key: 24, iv: 8 };
  un["des-ede3"] = { key: 24, iv: 0 };
  un["des-ede-cbc"] = { key: 16, iv: 8 };
  un["des-ede"] = { key: 16, iv: 0 };
});
var Aw = k((Ai) => {
  U();
  var vw = B2(), h1 = Kl(), zn = Ul(), dn = bw(), ww = uc();
  function vS(t, e) {
    t = t.toLowerCase();
    var r, i;
    if (zn[t])
      r = zn[t].key, i = zn[t].iv;
    else if (dn[t])
      r = dn[t].key * 8, i = dn[t].iv;
    else
      throw new TypeError("invalid suite type");
    var n = ww(e, false, r, i);
    return xw(t, n.key, n.iv);
  }
  function wS(t, e) {
    t = t.toLowerCase();
    var r, i;
    if (zn[t])
      r = zn[t].key, i = zn[t].iv;
    else if (dn[t])
      r = dn[t].key * 8, i = dn[t].iv;
    else
      throw new TypeError("invalid suite type");
    var n = ww(e, false, r, i);
    return _w(t, n.key, n.iv);
  }
  function xw(t, e, r) {
    if (t = t.toLowerCase(), zn[t])
      return h1.createCipheriv(t, e, r);
    if (dn[t])
      return new vw({ key: e, iv: r, mode: t });
    throw new TypeError("invalid suite type");
  }
  function _w(t, e, r) {
    if (t = t.toLowerCase(), zn[t])
      return h1.createDecipheriv(t, e, r);
    if (dn[t])
      return new vw({ key: e, iv: r, mode: t, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function xS() {
    return Object.keys(dn).concat(h1.getCiphers());
  }
  Ai.createCipher = Ai.Cipher = vS;
  Ai.createCipheriv = Ai.Cipheriv = xw;
  Ai.createDecipher = Ai.Decipher = wS;
  Ai.createDecipheriv = Ai.Decipheriv = _w;
  Ai.listCiphers = Ai.getCiphers = xS;
});
var lr = k((Ew, p1) => {
  U();
  (function(t, e) {
    function r(N3, c2) {
      if (!N3)
        throw new Error(c2 || "Assertion failed");
    }
    function i(N3, c2) {
      N3.super_ = c2;
      var p2 = function() {
      };
      p2.prototype = c2.prototype, N3.prototype = new p2(), N3.prototype.constructor = N3;
    }
    function n(N3, c2, p2) {
      if (n.isBN(N3))
        return N3;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, N3 !== null && ((c2 === "le" || c2 === "be") && (p2 = c2, c2 = 10), this._init(N3 || 0, c2 || 10, p2 || "be"));
    }
    typeof t == "object" ? t.exports = n : e.BN = n, n.BN = n, n.wordSize = 26;
    var s2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s2 = window.Buffer : s2 = or().Buffer;
    } catch {
    }
    n.isBN = function(c2) {
      return c2 instanceof n ? true : c2 !== null && typeof c2 == "object" && c2.constructor.wordSize === n.wordSize && Array.isArray(c2.words);
    }, n.max = function(c2, p2) {
      return c2.cmp(p2) > 0 ? c2 : p2;
    }, n.min = function(c2, p2) {
      return c2.cmp(p2) < 0 ? c2 : p2;
    }, n.prototype._init = function(c2, p2, h2) {
      if (typeof c2 == "number")
        return this._initNumber(c2, p2, h2);
      if (typeof c2 == "object")
        return this._initArray(c2, p2, h2);
      p2 === "hex" && (p2 = 16), r(p2 === (p2 | 0) && p2 >= 2 && p2 <= 36), c2 = c2.toString().replace(/\s+/g, "");
      var a = 0;
      c2[0] === "-" && (a++, this.negative = 1), a < c2.length && (p2 === 16 ? this._parseHex(c2, a, h2) : (this._parseBase(c2, p2, a), h2 === "le" && this._initArray(this.toArray(), p2, h2)));
    }, n.prototype._initNumber = function(c2, p2, h2) {
      c2 < 0 && (this.negative = 1, c2 = -c2), c2 < 67108864 ? (this.words = [c2 & 67108863], this.length = 1) : c2 < 4503599627370496 ? (this.words = [c2 & 67108863, c2 / 67108864 & 67108863], this.length = 2) : (r(c2 < 9007199254740992), this.words = [c2 & 67108863, c2 / 67108864 & 67108863, 1], this.length = 3), h2 === "le" && this._initArray(this.toArray(), p2, h2);
    }, n.prototype._initArray = function(c2, p2, h2) {
      if (r(typeof c2.length == "number"), c2.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c2.length / 3), this.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        this.words[a] = 0;
      var d2, b2, _2 = 0;
      if (h2 === "be")
        for (a = c2.length - 1, d2 = 0; a >= 0; a -= 3)
          b2 = c2[a] | c2[a - 1] << 8 | c2[a - 2] << 16, this.words[d2] |= b2 << _2 & 67108863, this.words[d2 + 1] = b2 >>> 26 - _2 & 67108863, _2 += 24, _2 >= 26 && (_2 -= 26, d2++);
      else if (h2 === "le")
        for (a = 0, d2 = 0; a < c2.length; a += 3)
          b2 = c2[a] | c2[a + 1] << 8 | c2[a + 2] << 16, this.words[d2] |= b2 << _2 & 67108863, this.words[d2 + 1] = b2 >>> 26 - _2 & 67108863, _2 += 24, _2 >= 26 && (_2 -= 26, d2++);
      return this.strip();
    };
    function o(N3, c2) {
      var p2 = N3.charCodeAt(c2);
      return p2 >= 65 && p2 <= 70 ? p2 - 55 : p2 >= 97 && p2 <= 102 ? p2 - 87 : p2 - 48 & 15;
    }
    function f(N3, c2, p2) {
      var h2 = o(N3, p2);
      return p2 - 1 >= c2 && (h2 |= o(N3, p2 - 1) << 4), h2;
    }
    n.prototype._parseHex = function(c2, p2, h2) {
      this.length = Math.ceil((c2.length - p2) / 6), this.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        this.words[a] = 0;
      var d2 = 0, b2 = 0, _2;
      if (h2 === "be")
        for (a = c2.length - 1; a >= p2; a -= 2)
          _2 = f(c2, p2, a) << d2, this.words[b2] |= _2 & 67108863, d2 >= 18 ? (d2 -= 18, b2 += 1, this.words[b2] |= _2 >>> 26) : d2 += 8;
      else {
        var v = c2.length - p2;
        for (a = v % 2 === 0 ? p2 + 1 : p2; a < c2.length; a += 2)
          _2 = f(c2, p2, a) << d2, this.words[b2] |= _2 & 67108863, d2 >= 18 ? (d2 -= 18, b2 += 1, this.words[b2] |= _2 >>> 26) : d2 += 8;
      }
      this.strip();
    };
    function l(N3, c2, p2, h2) {
      for (var a = 0, d2 = Math.min(N3.length, p2), b2 = c2; b2 < d2; b2++) {
        var _2 = N3.charCodeAt(b2) - 48;
        a *= h2, _2 >= 49 ? a += _2 - 49 + 10 : _2 >= 17 ? a += _2 - 17 + 10 : a += _2;
      }
      return a;
    }
    n.prototype._parseBase = function(c2, p2, h2) {
      this.words = [0], this.length = 1;
      for (var a = 0, d2 = 1; d2 <= 67108863; d2 *= p2)
        a++;
      a--, d2 = d2 / p2 | 0;
      for (var b2 = c2.length - h2, _2 = b2 % a, v = Math.min(b2, b2 - _2) + h2, u = 0, E2 = h2; E2 < v; E2 += a)
        u = l(c2, E2, E2 + a, p2), this.imuln(d2), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
      if (_2 !== 0) {
        var B = 1;
        for (u = l(c2, E2, c2.length, p2), E2 = 0; E2 < _2; E2++)
          B *= p2;
        this.imuln(B), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
      }
      this.strip();
    }, n.prototype.copy = function(c2) {
      c2.words = new Array(this.length);
      for (var p2 = 0; p2 < this.length; p2++)
        c2.words[p2] = this.words[p2];
      c2.length = this.length, c2.negative = this.negative, c2.red = this.red;
    }, n.prototype.clone = function() {
      var c2 = new n(null);
      return this.copy(c2), c2;
    }, n.prototype._expand = function(c2) {
      for (; this.length < c2; )
        this.words[this.length++] = 0;
      return this;
    }, n.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, n.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, n.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var m3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], F3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    n.prototype.toString = function(c2, p2) {
      c2 = c2 || 10, p2 = p2 | 0 || 1;
      var h2;
      if (c2 === 16 || c2 === "hex") {
        h2 = "";
        for (var a = 0, d2 = 0, b2 = 0; b2 < this.length; b2++) {
          var _2 = this.words[b2], v = ((_2 << a | d2) & 16777215).toString(16);
          d2 = _2 >>> 24 - a & 16777215, d2 !== 0 || b2 !== this.length - 1 ? h2 = m3[6 - v.length] + v + h2 : h2 = v + h2, a += 2, a >= 26 && (a -= 26, b2--);
        }
        for (d2 !== 0 && (h2 = d2.toString(16) + h2); h2.length % p2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      if (c2 === (c2 | 0) && c2 >= 2 && c2 <= 36) {
        var u = A2[c2], E2 = F3[c2];
        h2 = "";
        var B = this.clone();
        for (B.negative = 0; !B.isZero(); ) {
          var y2 = B.modn(E2).toString(c2);
          B = B.idivn(E2), B.isZero() ? h2 = y2 + h2 : h2 = m3[u - y2.length] + y2 + h2;
        }
        for (this.isZero() && (h2 = "0" + h2); h2.length % p2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      r(false, "Base should be between 2 and 36");
    }, n.prototype.toNumber = function() {
      var c2 = this.words[0];
      return this.length === 2 ? c2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c2 : c2;
    }, n.prototype.toJSON = function() {
      return this.toString(16);
    }, n.prototype.toBuffer = function(c2, p2) {
      return r(typeof s2 < "u"), this.toArrayLike(s2, c2, p2);
    }, n.prototype.toArray = function(c2, p2) {
      return this.toArrayLike(Array, c2, p2);
    }, n.prototype.toArrayLike = function(c2, p2, h2) {
      var a = this.byteLength(), d2 = h2 || Math.max(1, a);
      r(a <= d2, "byte array longer than desired length"), r(d2 > 0, "Requested array length <= 0"), this.strip();
      var b2 = p2 === "le", _2 = new c2(d2), v, u, E2 = this.clone();
      if (b2) {
        for (u = 0; !E2.isZero(); u++)
          v = E2.andln(255), E2.iushrn(8), _2[u] = v;
        for (; u < d2; u++)
          _2[u] = 0;
      } else {
        for (u = 0; u < d2 - a; u++)
          _2[u] = 0;
        for (u = 0; !E2.isZero(); u++)
          v = E2.andln(255), E2.iushrn(8), _2[d2 - u - 1] = v;
      }
      return _2;
    }, Math.clz32 ? n.prototype._countBits = function(c2) {
      return 32 - Math.clz32(c2);
    } : n.prototype._countBits = function(c2) {
      var p2 = c2, h2 = 0;
      return p2 >= 4096 && (h2 += 13, p2 >>>= 13), p2 >= 64 && (h2 += 7, p2 >>>= 7), p2 >= 8 && (h2 += 4, p2 >>>= 4), p2 >= 2 && (h2 += 2, p2 >>>= 2), h2 + p2;
    }, n.prototype._zeroBits = function(c2) {
      if (c2 === 0)
        return 26;
      var p2 = c2, h2 = 0;
      return (p2 & 8191) === 0 && (h2 += 13, p2 >>>= 13), (p2 & 127) === 0 && (h2 += 7, p2 >>>= 7), (p2 & 15) === 0 && (h2 += 4, p2 >>>= 4), (p2 & 3) === 0 && (h2 += 2, p2 >>>= 2), (p2 & 1) === 0 && h2++, h2;
    }, n.prototype.bitLength = function() {
      var c2 = this.words[this.length - 1], p2 = this._countBits(c2);
      return (this.length - 1) * 26 + p2;
    };
    function z3(N3) {
      for (var c2 = new Array(N3.bitLength()), p2 = 0; p2 < c2.length; p2++) {
        var h2 = p2 / 26 | 0, a = p2 % 26;
        c2[p2] = (N3.words[h2] & 1 << a) >>> a;
      }
      return c2;
    }
    n.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c2 = 0, p2 = 0; p2 < this.length; p2++) {
        var h2 = this._zeroBits(this.words[p2]);
        if (c2 += h2, h2 !== 26)
          break;
      }
      return c2;
    }, n.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, n.prototype.toTwos = function(c2) {
      return this.negative !== 0 ? this.abs().inotn(c2).iaddn(1) : this.clone();
    }, n.prototype.fromTwos = function(c2) {
      return this.testn(c2 - 1) ? this.notn(c2).iaddn(1).ineg() : this.clone();
    }, n.prototype.isNeg = function() {
      return this.negative !== 0;
    }, n.prototype.neg = function() {
      return this.clone().ineg();
    }, n.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, n.prototype.iuor = function(c2) {
      for (; this.length < c2.length; )
        this.words[this.length++] = 0;
      for (var p2 = 0; p2 < c2.length; p2++)
        this.words[p2] = this.words[p2] | c2.words[p2];
      return this.strip();
    }, n.prototype.ior = function(c2) {
      return r((this.negative | c2.negative) === 0), this.iuor(c2);
    }, n.prototype.or = function(c2) {
      return this.length > c2.length ? this.clone().ior(c2) : c2.clone().ior(this);
    }, n.prototype.uor = function(c2) {
      return this.length > c2.length ? this.clone().iuor(c2) : c2.clone().iuor(this);
    }, n.prototype.iuand = function(c2) {
      var p2;
      this.length > c2.length ? p2 = c2 : p2 = this;
      for (var h2 = 0; h2 < p2.length; h2++)
        this.words[h2] = this.words[h2] & c2.words[h2];
      return this.length = p2.length, this.strip();
    }, n.prototype.iand = function(c2) {
      return r((this.negative | c2.negative) === 0), this.iuand(c2);
    }, n.prototype.and = function(c2) {
      return this.length > c2.length ? this.clone().iand(c2) : c2.clone().iand(this);
    }, n.prototype.uand = function(c2) {
      return this.length > c2.length ? this.clone().iuand(c2) : c2.clone().iuand(this);
    }, n.prototype.iuxor = function(c2) {
      var p2, h2;
      this.length > c2.length ? (p2 = this, h2 = c2) : (p2 = c2, h2 = this);
      for (var a = 0; a < h2.length; a++)
        this.words[a] = p2.words[a] ^ h2.words[a];
      if (this !== p2)
        for (; a < p2.length; a++)
          this.words[a] = p2.words[a];
      return this.length = p2.length, this.strip();
    }, n.prototype.ixor = function(c2) {
      return r((this.negative | c2.negative) === 0), this.iuxor(c2);
    }, n.prototype.xor = function(c2) {
      return this.length > c2.length ? this.clone().ixor(c2) : c2.clone().ixor(this);
    }, n.prototype.uxor = function(c2) {
      return this.length > c2.length ? this.clone().iuxor(c2) : c2.clone().iuxor(this);
    }, n.prototype.inotn = function(c2) {
      r(typeof c2 == "number" && c2 >= 0);
      var p2 = Math.ceil(c2 / 26) | 0, h2 = c2 % 26;
      this._expand(p2), h2 > 0 && p2--;
      for (var a = 0; a < p2; a++)
        this.words[a] = ~this.words[a] & 67108863;
      return h2 > 0 && (this.words[a] = ~this.words[a] & 67108863 >> 26 - h2), this.strip();
    }, n.prototype.notn = function(c2) {
      return this.clone().inotn(c2);
    }, n.prototype.setn = function(c2, p2) {
      r(typeof c2 == "number" && c2 >= 0);
      var h2 = c2 / 26 | 0, a = c2 % 26;
      return this._expand(h2 + 1), p2 ? this.words[h2] = this.words[h2] | 1 << a : this.words[h2] = this.words[h2] & ~(1 << a), this.strip();
    }, n.prototype.iadd = function(c2) {
      var p2;
      if (this.negative !== 0 && c2.negative === 0)
        return this.negative = 0, p2 = this.isub(c2), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c2.negative !== 0)
        return c2.negative = 0, p2 = this.isub(c2), c2.negative = 1, p2._normSign();
      var h2, a;
      this.length > c2.length ? (h2 = this, a = c2) : (h2 = c2, a = this);
      for (var d2 = 0, b2 = 0; b2 < a.length; b2++)
        p2 = (h2.words[b2] | 0) + (a.words[b2] | 0) + d2, this.words[b2] = p2 & 67108863, d2 = p2 >>> 26;
      for (; d2 !== 0 && b2 < h2.length; b2++)
        p2 = (h2.words[b2] | 0) + d2, this.words[b2] = p2 & 67108863, d2 = p2 >>> 26;
      if (this.length = h2.length, d2 !== 0)
        this.words[this.length] = d2, this.length++;
      else if (h2 !== this)
        for (; b2 < h2.length; b2++)
          this.words[b2] = h2.words[b2];
      return this;
    }, n.prototype.add = function(c2) {
      var p2;
      return c2.negative !== 0 && this.negative === 0 ? (c2.negative = 0, p2 = this.sub(c2), c2.negative ^= 1, p2) : c2.negative === 0 && this.negative !== 0 ? (this.negative = 0, p2 = c2.sub(this), this.negative = 1, p2) : this.length > c2.length ? this.clone().iadd(c2) : c2.clone().iadd(this);
    }, n.prototype.isub = function(c2) {
      if (c2.negative !== 0) {
        c2.negative = 0;
        var p2 = this.iadd(c2);
        return c2.negative = 1, p2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c2), this.negative = 1, this._normSign();
      var h2 = this.cmp(c2);
      if (h2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var a, d2;
      h2 > 0 ? (a = this, d2 = c2) : (a = c2, d2 = this);
      for (var b2 = 0, _2 = 0; _2 < d2.length; _2++)
        p2 = (a.words[_2] | 0) - (d2.words[_2] | 0) + b2, b2 = p2 >> 26, this.words[_2] = p2 & 67108863;
      for (; b2 !== 0 && _2 < a.length; _2++)
        p2 = (a.words[_2] | 0) + b2, b2 = p2 >> 26, this.words[_2] = p2 & 67108863;
      if (b2 === 0 && _2 < a.length && a !== this)
        for (; _2 < a.length; _2++)
          this.words[_2] = a.words[_2];
      return this.length = Math.max(this.length, _2), a !== this && (this.negative = 1), this.strip();
    }, n.prototype.sub = function(c2) {
      return this.clone().isub(c2);
    };
    function V(N3, c2, p2) {
      p2.negative = c2.negative ^ N3.negative;
      var h2 = N3.length + c2.length | 0;
      p2.length = h2, h2 = h2 - 1 | 0;
      var a = N3.words[0] | 0, d2 = c2.words[0] | 0, b2 = a * d2, _2 = b2 & 67108863, v = b2 / 67108864 | 0;
      p2.words[0] = _2;
      for (var u = 1; u < h2; u++) {
        for (var E2 = v >>> 26, B = v & 67108863, y2 = Math.min(u, c2.length - 1), M = Math.max(0, u - N3.length + 1); M <= y2; M++) {
          var de2 = u - M | 0;
          a = N3.words[de2] | 0, d2 = c2.words[M] | 0, b2 = a * d2 + B, E2 += b2 / 67108864 | 0, B = b2 & 67108863;
        }
        p2.words[u] = B | 0, v = E2 | 0;
      }
      return v !== 0 ? p2.words[u] = v | 0 : p2.length--, p2.strip();
    }
    var $ = function(c2, p2, h2) {
      var a = c2.words, d2 = p2.words, b2 = h2.words, _2 = 0, v, u, E2, B = a[0] | 0, y2 = B & 8191, M = B >>> 13, de2 = a[1] | 0, Ee = de2 & 8191, Me = de2 >>> 13, Oe = a[2] | 0, be = Oe & 8191, I = Oe >>> 13, j3 = a[3] | 0, P5 = j3 & 8191, ee2 = j3 >>> 13, oe = a[4] | 0, te = oe & 8191, ae = oe >>> 13, ne = a[5] | 0, X2 = ne & 8191, R3 = ne >>> 13, w = a[6] | 0, T2 = w & 8191, q2 = w >>> 13, L2 = a[7] | 0, G2 = L2 & 8191, K5 = L2 >>> 13, xe = a[8] | 0, me2 = xe & 8191, _e2 = xe >>> 13, fe = a[9] | 0, ke = fe & 8191, Be = fe >>> 13, gt = d2[0] | 0, je2 = gt & 8191, Ge = gt >>> 13, xt = d2[1] | 0, Pe = xt & 8191, Le = xt >>> 13, Zt = d2[2] | 0, Xe = Zt & 8191, Qe = Zt >>> 13, er = d2[3] | 0, et = er & 8191, tt = er >>> 13, zt = d2[4] | 0, ht = zt & 8191, pt2 = zt >>> 13, nn = d2[5] | 0, mt = nn & 8191, yt = nn >>> 13, ms = d2[6] | 0, it = ms & 8191, bt = ms >>> 13, S2 = d2[7] | 0, D2 = S2 & 8191, k2 = S2 >>> 13, g = d2[8] | 0, O2 = g & 8191, Q = g >>> 13, he = d2[9] | 0, ye = he & 8191, Ae = he >>> 13;
      h2.negative = c2.negative ^ p2.negative, h2.length = 19, v = Math.imul(y2, je2), u = Math.imul(y2, Ge), u = u + Math.imul(M, je2) | 0, E2 = Math.imul(M, Ge);
      var Ye = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, v = Math.imul(Ee, je2), u = Math.imul(Ee, Ge), u = u + Math.imul(Me, je2) | 0, E2 = Math.imul(Me, Ge), v = v + Math.imul(y2, Pe) | 0, u = u + Math.imul(y2, Le) | 0, u = u + Math.imul(M, Pe) | 0, E2 = E2 + Math.imul(M, Le) | 0;
      var Ne2 = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (Ne2 >>> 26) | 0, Ne2 &= 67108863, v = Math.imul(be, je2), u = Math.imul(be, Ge), u = u + Math.imul(I, je2) | 0, E2 = Math.imul(I, Ge), v = v + Math.imul(Ee, Pe) | 0, u = u + Math.imul(Ee, Le) | 0, u = u + Math.imul(Me, Pe) | 0, E2 = E2 + Math.imul(Me, Le) | 0, v = v + Math.imul(y2, Xe) | 0, u = u + Math.imul(y2, Qe) | 0, u = u + Math.imul(M, Xe) | 0, E2 = E2 + Math.imul(M, Qe) | 0;
      var rt = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, v = Math.imul(P5, je2), u = Math.imul(P5, Ge), u = u + Math.imul(ee2, je2) | 0, E2 = Math.imul(ee2, Ge), v = v + Math.imul(be, Pe) | 0, u = u + Math.imul(be, Le) | 0, u = u + Math.imul(I, Pe) | 0, E2 = E2 + Math.imul(I, Le) | 0, v = v + Math.imul(Ee, Xe) | 0, u = u + Math.imul(Ee, Qe) | 0, u = u + Math.imul(Me, Xe) | 0, E2 = E2 + Math.imul(Me, Qe) | 0, v = v + Math.imul(y2, et) | 0, u = u + Math.imul(y2, tt) | 0, u = u + Math.imul(M, et) | 0, E2 = E2 + Math.imul(M, tt) | 0;
      var $e = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, v = Math.imul(te, je2), u = Math.imul(te, Ge), u = u + Math.imul(ae, je2) | 0, E2 = Math.imul(ae, Ge), v = v + Math.imul(P5, Pe) | 0, u = u + Math.imul(P5, Le) | 0, u = u + Math.imul(ee2, Pe) | 0, E2 = E2 + Math.imul(ee2, Le) | 0, v = v + Math.imul(be, Xe) | 0, u = u + Math.imul(be, Qe) | 0, u = u + Math.imul(I, Xe) | 0, E2 = E2 + Math.imul(I, Qe) | 0, v = v + Math.imul(Ee, et) | 0, u = u + Math.imul(Ee, tt) | 0, u = u + Math.imul(Me, et) | 0, E2 = E2 + Math.imul(Me, tt) | 0, v = v + Math.imul(y2, ht) | 0, u = u + Math.imul(y2, pt2) | 0, u = u + Math.imul(M, ht) | 0, E2 = E2 + Math.imul(M, pt2) | 0;
      var nt = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, v = Math.imul(X2, je2), u = Math.imul(X2, Ge), u = u + Math.imul(R3, je2) | 0, E2 = Math.imul(R3, Ge), v = v + Math.imul(te, Pe) | 0, u = u + Math.imul(te, Le) | 0, u = u + Math.imul(ae, Pe) | 0, E2 = E2 + Math.imul(ae, Le) | 0, v = v + Math.imul(P5, Xe) | 0, u = u + Math.imul(P5, Qe) | 0, u = u + Math.imul(ee2, Xe) | 0, E2 = E2 + Math.imul(ee2, Qe) | 0, v = v + Math.imul(be, et) | 0, u = u + Math.imul(be, tt) | 0, u = u + Math.imul(I, et) | 0, E2 = E2 + Math.imul(I, tt) | 0, v = v + Math.imul(Ee, ht) | 0, u = u + Math.imul(Ee, pt2) | 0, u = u + Math.imul(Me, ht) | 0, E2 = E2 + Math.imul(Me, pt2) | 0, v = v + Math.imul(y2, mt) | 0, u = u + Math.imul(y2, yt) | 0, u = u + Math.imul(M, mt) | 0, E2 = E2 + Math.imul(M, yt) | 0;
      var st = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, v = Math.imul(T2, je2), u = Math.imul(T2, Ge), u = u + Math.imul(q2, je2) | 0, E2 = Math.imul(q2, Ge), v = v + Math.imul(X2, Pe) | 0, u = u + Math.imul(X2, Le) | 0, u = u + Math.imul(R3, Pe) | 0, E2 = E2 + Math.imul(R3, Le) | 0, v = v + Math.imul(te, Xe) | 0, u = u + Math.imul(te, Qe) | 0, u = u + Math.imul(ae, Xe) | 0, E2 = E2 + Math.imul(ae, Qe) | 0, v = v + Math.imul(P5, et) | 0, u = u + Math.imul(P5, tt) | 0, u = u + Math.imul(ee2, et) | 0, E2 = E2 + Math.imul(ee2, tt) | 0, v = v + Math.imul(be, ht) | 0, u = u + Math.imul(be, pt2) | 0, u = u + Math.imul(I, ht) | 0, E2 = E2 + Math.imul(I, pt2) | 0, v = v + Math.imul(Ee, mt) | 0, u = u + Math.imul(Ee, yt) | 0, u = u + Math.imul(Me, mt) | 0, E2 = E2 + Math.imul(Me, yt) | 0, v = v + Math.imul(y2, it) | 0, u = u + Math.imul(y2, bt) | 0, u = u + Math.imul(M, it) | 0, E2 = E2 + Math.imul(M, bt) | 0;
      var lt = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, v = Math.imul(G2, je2), u = Math.imul(G2, Ge), u = u + Math.imul(K5, je2) | 0, E2 = Math.imul(K5, Ge), v = v + Math.imul(T2, Pe) | 0, u = u + Math.imul(T2, Le) | 0, u = u + Math.imul(q2, Pe) | 0, E2 = E2 + Math.imul(q2, Le) | 0, v = v + Math.imul(X2, Xe) | 0, u = u + Math.imul(X2, Qe) | 0, u = u + Math.imul(R3, Xe) | 0, E2 = E2 + Math.imul(R3, Qe) | 0, v = v + Math.imul(te, et) | 0, u = u + Math.imul(te, tt) | 0, u = u + Math.imul(ae, et) | 0, E2 = E2 + Math.imul(ae, tt) | 0, v = v + Math.imul(P5, ht) | 0, u = u + Math.imul(P5, pt2) | 0, u = u + Math.imul(ee2, ht) | 0, E2 = E2 + Math.imul(ee2, pt2) | 0, v = v + Math.imul(be, mt) | 0, u = u + Math.imul(be, yt) | 0, u = u + Math.imul(I, mt) | 0, E2 = E2 + Math.imul(I, yt) | 0, v = v + Math.imul(Ee, it) | 0, u = u + Math.imul(Ee, bt) | 0, u = u + Math.imul(Me, it) | 0, E2 = E2 + Math.imul(Me, bt) | 0, v = v + Math.imul(y2, D2) | 0, u = u + Math.imul(y2, k2) | 0, u = u + Math.imul(M, D2) | 0, E2 = E2 + Math.imul(M, k2) | 0;
      var dt = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, v = Math.imul(me2, je2), u = Math.imul(me2, Ge), u = u + Math.imul(_e2, je2) | 0, E2 = Math.imul(_e2, Ge), v = v + Math.imul(G2, Pe) | 0, u = u + Math.imul(G2, Le) | 0, u = u + Math.imul(K5, Pe) | 0, E2 = E2 + Math.imul(K5, Le) | 0, v = v + Math.imul(T2, Xe) | 0, u = u + Math.imul(T2, Qe) | 0, u = u + Math.imul(q2, Xe) | 0, E2 = E2 + Math.imul(q2, Qe) | 0, v = v + Math.imul(X2, et) | 0, u = u + Math.imul(X2, tt) | 0, u = u + Math.imul(R3, et) | 0, E2 = E2 + Math.imul(R3, tt) | 0, v = v + Math.imul(te, ht) | 0, u = u + Math.imul(te, pt2) | 0, u = u + Math.imul(ae, ht) | 0, E2 = E2 + Math.imul(ae, pt2) | 0, v = v + Math.imul(P5, mt) | 0, u = u + Math.imul(P5, yt) | 0, u = u + Math.imul(ee2, mt) | 0, E2 = E2 + Math.imul(ee2, yt) | 0, v = v + Math.imul(be, it) | 0, u = u + Math.imul(be, bt) | 0, u = u + Math.imul(I, it) | 0, E2 = E2 + Math.imul(I, bt) | 0, v = v + Math.imul(Ee, D2) | 0, u = u + Math.imul(Ee, k2) | 0, u = u + Math.imul(Me, D2) | 0, E2 = E2 + Math.imul(Me, k2) | 0, v = v + Math.imul(y2, O2) | 0, u = u + Math.imul(y2, Q) | 0, u = u + Math.imul(M, O2) | 0, E2 = E2 + Math.imul(M, Q) | 0;
      var ot = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, v = Math.imul(ke, je2), u = Math.imul(ke, Ge), u = u + Math.imul(Be, je2) | 0, E2 = Math.imul(Be, Ge), v = v + Math.imul(me2, Pe) | 0, u = u + Math.imul(me2, Le) | 0, u = u + Math.imul(_e2, Pe) | 0, E2 = E2 + Math.imul(_e2, Le) | 0, v = v + Math.imul(G2, Xe) | 0, u = u + Math.imul(G2, Qe) | 0, u = u + Math.imul(K5, Xe) | 0, E2 = E2 + Math.imul(K5, Qe) | 0, v = v + Math.imul(T2, et) | 0, u = u + Math.imul(T2, tt) | 0, u = u + Math.imul(q2, et) | 0, E2 = E2 + Math.imul(q2, tt) | 0, v = v + Math.imul(X2, ht) | 0, u = u + Math.imul(X2, pt2) | 0, u = u + Math.imul(R3, ht) | 0, E2 = E2 + Math.imul(R3, pt2) | 0, v = v + Math.imul(te, mt) | 0, u = u + Math.imul(te, yt) | 0, u = u + Math.imul(ae, mt) | 0, E2 = E2 + Math.imul(ae, yt) | 0, v = v + Math.imul(P5, it) | 0, u = u + Math.imul(P5, bt) | 0, u = u + Math.imul(ee2, it) | 0, E2 = E2 + Math.imul(ee2, bt) | 0, v = v + Math.imul(be, D2) | 0, u = u + Math.imul(be, k2) | 0, u = u + Math.imul(I, D2) | 0, E2 = E2 + Math.imul(I, k2) | 0, v = v + Math.imul(Ee, O2) | 0, u = u + Math.imul(Ee, Q) | 0, u = u + Math.imul(Me, O2) | 0, E2 = E2 + Math.imul(Me, Q) | 0, v = v + Math.imul(y2, ye) | 0, u = u + Math.imul(y2, Ae) | 0, u = u + Math.imul(M, ye) | 0, E2 = E2 + Math.imul(M, Ae) | 0;
      var ft = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, v = Math.imul(ke, Pe), u = Math.imul(ke, Le), u = u + Math.imul(Be, Pe) | 0, E2 = Math.imul(Be, Le), v = v + Math.imul(me2, Xe) | 0, u = u + Math.imul(me2, Qe) | 0, u = u + Math.imul(_e2, Xe) | 0, E2 = E2 + Math.imul(_e2, Qe) | 0, v = v + Math.imul(G2, et) | 0, u = u + Math.imul(G2, tt) | 0, u = u + Math.imul(K5, et) | 0, E2 = E2 + Math.imul(K5, tt) | 0, v = v + Math.imul(T2, ht) | 0, u = u + Math.imul(T2, pt2) | 0, u = u + Math.imul(q2, ht) | 0, E2 = E2 + Math.imul(q2, pt2) | 0, v = v + Math.imul(X2, mt) | 0, u = u + Math.imul(X2, yt) | 0, u = u + Math.imul(R3, mt) | 0, E2 = E2 + Math.imul(R3, yt) | 0, v = v + Math.imul(te, it) | 0, u = u + Math.imul(te, bt) | 0, u = u + Math.imul(ae, it) | 0, E2 = E2 + Math.imul(ae, bt) | 0, v = v + Math.imul(P5, D2) | 0, u = u + Math.imul(P5, k2) | 0, u = u + Math.imul(ee2, D2) | 0, E2 = E2 + Math.imul(ee2, k2) | 0, v = v + Math.imul(be, O2) | 0, u = u + Math.imul(be, Q) | 0, u = u + Math.imul(I, O2) | 0, E2 = E2 + Math.imul(I, Q) | 0, v = v + Math.imul(Ee, ye) | 0, u = u + Math.imul(Ee, Ae) | 0, u = u + Math.imul(Me, ye) | 0, E2 = E2 + Math.imul(Me, Ae) | 0;
      var at = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, v = Math.imul(ke, Xe), u = Math.imul(ke, Qe), u = u + Math.imul(Be, Xe) | 0, E2 = Math.imul(Be, Qe), v = v + Math.imul(me2, et) | 0, u = u + Math.imul(me2, tt) | 0, u = u + Math.imul(_e2, et) | 0, E2 = E2 + Math.imul(_e2, tt) | 0, v = v + Math.imul(G2, ht) | 0, u = u + Math.imul(G2, pt2) | 0, u = u + Math.imul(K5, ht) | 0, E2 = E2 + Math.imul(K5, pt2) | 0, v = v + Math.imul(T2, mt) | 0, u = u + Math.imul(T2, yt) | 0, u = u + Math.imul(q2, mt) | 0, E2 = E2 + Math.imul(q2, yt) | 0, v = v + Math.imul(X2, it) | 0, u = u + Math.imul(X2, bt) | 0, u = u + Math.imul(R3, it) | 0, E2 = E2 + Math.imul(R3, bt) | 0, v = v + Math.imul(te, D2) | 0, u = u + Math.imul(te, k2) | 0, u = u + Math.imul(ae, D2) | 0, E2 = E2 + Math.imul(ae, k2) | 0, v = v + Math.imul(P5, O2) | 0, u = u + Math.imul(P5, Q) | 0, u = u + Math.imul(ee2, O2) | 0, E2 = E2 + Math.imul(ee2, Q) | 0, v = v + Math.imul(be, ye) | 0, u = u + Math.imul(be, Ae) | 0, u = u + Math.imul(I, ye) | 0, E2 = E2 + Math.imul(I, Ae) | 0;
      var Ke = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, v = Math.imul(ke, et), u = Math.imul(ke, tt), u = u + Math.imul(Be, et) | 0, E2 = Math.imul(Be, tt), v = v + Math.imul(me2, ht) | 0, u = u + Math.imul(me2, pt2) | 0, u = u + Math.imul(_e2, ht) | 0, E2 = E2 + Math.imul(_e2, pt2) | 0, v = v + Math.imul(G2, mt) | 0, u = u + Math.imul(G2, yt) | 0, u = u + Math.imul(K5, mt) | 0, E2 = E2 + Math.imul(K5, yt) | 0, v = v + Math.imul(T2, it) | 0, u = u + Math.imul(T2, bt) | 0, u = u + Math.imul(q2, it) | 0, E2 = E2 + Math.imul(q2, bt) | 0, v = v + Math.imul(X2, D2) | 0, u = u + Math.imul(X2, k2) | 0, u = u + Math.imul(R3, D2) | 0, E2 = E2 + Math.imul(R3, k2) | 0, v = v + Math.imul(te, O2) | 0, u = u + Math.imul(te, Q) | 0, u = u + Math.imul(ae, O2) | 0, E2 = E2 + Math.imul(ae, Q) | 0, v = v + Math.imul(P5, ye) | 0, u = u + Math.imul(P5, Ae) | 0, u = u + Math.imul(ee2, ye) | 0, E2 = E2 + Math.imul(ee2, Ae) | 0;
      var Je = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, v = Math.imul(ke, ht), u = Math.imul(ke, pt2), u = u + Math.imul(Be, ht) | 0, E2 = Math.imul(Be, pt2), v = v + Math.imul(me2, mt) | 0, u = u + Math.imul(me2, yt) | 0, u = u + Math.imul(_e2, mt) | 0, E2 = E2 + Math.imul(_e2, yt) | 0, v = v + Math.imul(G2, it) | 0, u = u + Math.imul(G2, bt) | 0, u = u + Math.imul(K5, it) | 0, E2 = E2 + Math.imul(K5, bt) | 0, v = v + Math.imul(T2, D2) | 0, u = u + Math.imul(T2, k2) | 0, u = u + Math.imul(q2, D2) | 0, E2 = E2 + Math.imul(q2, k2) | 0, v = v + Math.imul(X2, O2) | 0, u = u + Math.imul(X2, Q) | 0, u = u + Math.imul(R3, O2) | 0, E2 = E2 + Math.imul(R3, Q) | 0, v = v + Math.imul(te, ye) | 0, u = u + Math.imul(te, Ae) | 0, u = u + Math.imul(ae, ye) | 0, E2 = E2 + Math.imul(ae, Ae) | 0;
      var ze = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, v = Math.imul(ke, mt), u = Math.imul(ke, yt), u = u + Math.imul(Be, mt) | 0, E2 = Math.imul(Be, yt), v = v + Math.imul(me2, it) | 0, u = u + Math.imul(me2, bt) | 0, u = u + Math.imul(_e2, it) | 0, E2 = E2 + Math.imul(_e2, bt) | 0, v = v + Math.imul(G2, D2) | 0, u = u + Math.imul(G2, k2) | 0, u = u + Math.imul(K5, D2) | 0, E2 = E2 + Math.imul(K5, k2) | 0, v = v + Math.imul(T2, O2) | 0, u = u + Math.imul(T2, Q) | 0, u = u + Math.imul(q2, O2) | 0, E2 = E2 + Math.imul(q2, Q) | 0, v = v + Math.imul(X2, ye) | 0, u = u + Math.imul(X2, Ae) | 0, u = u + Math.imul(R3, ye) | 0, E2 = E2 + Math.imul(R3, Ae) | 0;
      var We = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, v = Math.imul(ke, it), u = Math.imul(ke, bt), u = u + Math.imul(Be, it) | 0, E2 = Math.imul(Be, bt), v = v + Math.imul(me2, D2) | 0, u = u + Math.imul(me2, k2) | 0, u = u + Math.imul(_e2, D2) | 0, E2 = E2 + Math.imul(_e2, k2) | 0, v = v + Math.imul(G2, O2) | 0, u = u + Math.imul(G2, Q) | 0, u = u + Math.imul(K5, O2) | 0, E2 = E2 + Math.imul(K5, Q) | 0, v = v + Math.imul(T2, ye) | 0, u = u + Math.imul(T2, Ae) | 0, u = u + Math.imul(q2, ye) | 0, E2 = E2 + Math.imul(q2, Ae) | 0;
      var Ve = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, v = Math.imul(ke, D2), u = Math.imul(ke, k2), u = u + Math.imul(Be, D2) | 0, E2 = Math.imul(Be, k2), v = v + Math.imul(me2, O2) | 0, u = u + Math.imul(me2, Q) | 0, u = u + Math.imul(_e2, O2) | 0, E2 = E2 + Math.imul(_e2, Q) | 0, v = v + Math.imul(G2, ye) | 0, u = u + Math.imul(G2, Ae) | 0, u = u + Math.imul(K5, ye) | 0, E2 = E2 + Math.imul(K5, Ae) | 0;
      var qe = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, v = Math.imul(ke, O2), u = Math.imul(ke, Q), u = u + Math.imul(Be, O2) | 0, E2 = Math.imul(Be, Q), v = v + Math.imul(me2, ye) | 0, u = u + Math.imul(me2, Ae) | 0, u = u + Math.imul(_e2, ye) | 0, E2 = E2 + Math.imul(_e2, Ae) | 0;
      var ve = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      _2 = (E2 + (u >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, v = Math.imul(ke, ye), u = Math.imul(ke, Ae), u = u + Math.imul(Be, ye) | 0, E2 = Math.imul(Be, Ae);
      var we = (_2 + v | 0) + ((u & 8191) << 13) | 0;
      return _2 = (E2 + (u >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, b2[0] = Ye, b2[1] = Ne2, b2[2] = rt, b2[3] = $e, b2[4] = nt, b2[5] = st, b2[6] = lt, b2[7] = dt, b2[8] = ot, b2[9] = ft, b2[10] = at, b2[11] = Ke, b2[12] = Je, b2[13] = ze, b2[14] = We, b2[15] = Ve, b2[16] = qe, b2[17] = ve, b2[18] = we, _2 !== 0 && (b2[19] = _2, h2.length++), h2;
    };
    Math.imul || ($ = V);
    function re(N3, c2, p2) {
      p2.negative = c2.negative ^ N3.negative, p2.length = N3.length + c2.length;
      for (var h2 = 0, a = 0, d2 = 0; d2 < p2.length - 1; d2++) {
        var b2 = a;
        a = 0;
        for (var _2 = h2 & 67108863, v = Math.min(d2, c2.length - 1), u = Math.max(0, d2 - N3.length + 1); u <= v; u++) {
          var E2 = d2 - u, B = N3.words[E2] | 0, y2 = c2.words[u] | 0, M = B * y2, de2 = M & 67108863;
          b2 = b2 + (M / 67108864 | 0) | 0, de2 = de2 + _2 | 0, _2 = de2 & 67108863, b2 = b2 + (de2 >>> 26) | 0, a += b2 >>> 26, b2 &= 67108863;
        }
        p2.words[d2] = _2, h2 = b2, b2 = a;
      }
      return h2 !== 0 ? p2.words[d2] = h2 : p2.length--, p2.strip();
    }
    function W2(N3, c2, p2) {
      var h2 = new Z2();
      return h2.mulp(N3, c2, p2);
    }
    n.prototype.mulTo = function(c2, p2) {
      var h2, a = this.length + c2.length;
      return this.length === 10 && c2.length === 10 ? h2 = $(this, c2, p2) : a < 63 ? h2 = V(this, c2, p2) : a < 1024 ? h2 = re(this, c2, p2) : h2 = W2(this, c2, p2), h2;
    };
    function Z2(N3, c2) {
      this.x = N3, this.y = c2;
    }
    Z2.prototype.makeRBT = function(c2) {
      for (var p2 = new Array(c2), h2 = n.prototype._countBits(c2) - 1, a = 0; a < c2; a++)
        p2[a] = this.revBin(a, h2, c2);
      return p2;
    }, Z2.prototype.revBin = function(c2, p2, h2) {
      if (c2 === 0 || c2 === h2 - 1)
        return c2;
      for (var a = 0, d2 = 0; d2 < p2; d2++)
        a |= (c2 & 1) << p2 - d2 - 1, c2 >>= 1;
      return a;
    }, Z2.prototype.permute = function(c2, p2, h2, a, d2, b2) {
      for (var _2 = 0; _2 < b2; _2++)
        a[_2] = p2[c2[_2]], d2[_2] = h2[c2[_2]];
    }, Z2.prototype.transform = function(c2, p2, h2, a, d2, b2) {
      this.permute(b2, c2, p2, h2, a, d2);
      for (var _2 = 1; _2 < d2; _2 <<= 1)
        for (var v = _2 << 1, u = Math.cos(2 * Math.PI / v), E2 = Math.sin(2 * Math.PI / v), B = 0; B < d2; B += v)
          for (var y2 = u, M = E2, de2 = 0; de2 < _2; de2++) {
            var Ee = h2[B + de2], Me = a[B + de2], Oe = h2[B + de2 + _2], be = a[B + de2 + _2], I = y2 * Oe - M * be;
            be = y2 * be + M * Oe, Oe = I, h2[B + de2] = Ee + Oe, a[B + de2] = Me + be, h2[B + de2 + _2] = Ee - Oe, a[B + de2 + _2] = Me - be, de2 !== v && (I = u * y2 - E2 * M, M = u * M + E2 * y2, y2 = I);
          }
    }, Z2.prototype.guessLen13b = function(c2, p2) {
      var h2 = Math.max(p2, c2) | 1, a = h2 & 1, d2 = 0;
      for (h2 = h2 / 2 | 0; h2; h2 = h2 >>> 1)
        d2++;
      return 1 << d2 + 1 + a;
    }, Z2.prototype.conjugate = function(c2, p2, h2) {
      if (!(h2 <= 1))
        for (var a = 0; a < h2 / 2; a++) {
          var d2 = c2[a];
          c2[a] = c2[h2 - a - 1], c2[h2 - a - 1] = d2, d2 = p2[a], p2[a] = -p2[h2 - a - 1], p2[h2 - a - 1] = -d2;
        }
    }, Z2.prototype.normalize13b = function(c2, p2) {
      for (var h2 = 0, a = 0; a < p2 / 2; a++) {
        var d2 = Math.round(c2[2 * a + 1] / p2) * 8192 + Math.round(c2[2 * a] / p2) + h2;
        c2[a] = d2 & 67108863, d2 < 67108864 ? h2 = 0 : h2 = d2 / 67108864 | 0;
      }
      return c2;
    }, Z2.prototype.convert13b = function(c2, p2, h2, a) {
      for (var d2 = 0, b2 = 0; b2 < p2; b2++)
        d2 = d2 + (c2[b2] | 0), h2[2 * b2] = d2 & 8191, d2 = d2 >>> 13, h2[2 * b2 + 1] = d2 & 8191, d2 = d2 >>> 13;
      for (b2 = 2 * p2; b2 < a; ++b2)
        h2[b2] = 0;
      r(d2 === 0), r((d2 & -8192) === 0);
    }, Z2.prototype.stub = function(c2) {
      for (var p2 = new Array(c2), h2 = 0; h2 < c2; h2++)
        p2[h2] = 0;
      return p2;
    }, Z2.prototype.mulp = function(c2, p2, h2) {
      var a = 2 * this.guessLen13b(c2.length, p2.length), d2 = this.makeRBT(a), b2 = this.stub(a), _2 = new Array(a), v = new Array(a), u = new Array(a), E2 = new Array(a), B = new Array(a), y2 = new Array(a), M = h2.words;
      M.length = a, this.convert13b(c2.words, c2.length, _2, a), this.convert13b(p2.words, p2.length, E2, a), this.transform(_2, b2, v, u, a, d2), this.transform(E2, b2, B, y2, a, d2);
      for (var de2 = 0; de2 < a; de2++) {
        var Ee = v[de2] * B[de2] - u[de2] * y2[de2];
        u[de2] = v[de2] * y2[de2] + u[de2] * B[de2], v[de2] = Ee;
      }
      return this.conjugate(v, u, a), this.transform(v, u, M, b2, a, d2), this.conjugate(M, b2, a), this.normalize13b(M, a), h2.negative = c2.negative ^ p2.negative, h2.length = c2.length + p2.length, h2.strip();
    }, n.prototype.mul = function(c2) {
      var p2 = new n(null);
      return p2.words = new Array(this.length + c2.length), this.mulTo(c2, p2);
    }, n.prototype.mulf = function(c2) {
      var p2 = new n(null);
      return p2.words = new Array(this.length + c2.length), W2(this, c2, p2);
    }, n.prototype.imul = function(c2) {
      return this.clone().mulTo(c2, this);
    }, n.prototype.imuln = function(c2) {
      r(typeof c2 == "number"), r(c2 < 67108864);
      for (var p2 = 0, h2 = 0; h2 < this.length; h2++) {
        var a = (this.words[h2] | 0) * c2, d2 = (a & 67108863) + (p2 & 67108863);
        p2 >>= 26, p2 += a / 67108864 | 0, p2 += d2 >>> 26, this.words[h2] = d2 & 67108863;
      }
      return p2 !== 0 && (this.words[h2] = p2, this.length++), this;
    }, n.prototype.muln = function(c2) {
      return this.clone().imuln(c2);
    }, n.prototype.sqr = function() {
      return this.mul(this);
    }, n.prototype.isqr = function() {
      return this.imul(this.clone());
    }, n.prototype.pow = function(c2) {
      var p2 = z3(c2);
      if (p2.length === 0)
        return new n(1);
      for (var h2 = this, a = 0; a < p2.length && p2[a] === 0; a++, h2 = h2.sqr())
        ;
      if (++a < p2.length)
        for (var d2 = h2.sqr(); a < p2.length; a++, d2 = d2.sqr())
          p2[a] !== 0 && (h2 = h2.mul(d2));
      return h2;
    }, n.prototype.iushln = function(c2) {
      r(typeof c2 == "number" && c2 >= 0);
      var p2 = c2 % 26, h2 = (c2 - p2) / 26, a = 67108863 >>> 26 - p2 << 26 - p2, d2;
      if (p2 !== 0) {
        var b2 = 0;
        for (d2 = 0; d2 < this.length; d2++) {
          var _2 = this.words[d2] & a, v = (this.words[d2] | 0) - _2 << p2;
          this.words[d2] = v | b2, b2 = _2 >>> 26 - p2;
        }
        b2 && (this.words[d2] = b2, this.length++);
      }
      if (h2 !== 0) {
        for (d2 = this.length - 1; d2 >= 0; d2--)
          this.words[d2 + h2] = this.words[d2];
        for (d2 = 0; d2 < h2; d2++)
          this.words[d2] = 0;
        this.length += h2;
      }
      return this.strip();
    }, n.prototype.ishln = function(c2) {
      return r(this.negative === 0), this.iushln(c2);
    }, n.prototype.iushrn = function(c2, p2, h2) {
      r(typeof c2 == "number" && c2 >= 0);
      var a;
      p2 ? a = (p2 - p2 % 26) / 26 : a = 0;
      var d2 = c2 % 26, b2 = Math.min((c2 - d2) / 26, this.length), _2 = 67108863 ^ 67108863 >>> d2 << d2, v = h2;
      if (a -= b2, a = Math.max(0, a), v) {
        for (var u = 0; u < b2; u++)
          v.words[u] = this.words[u];
        v.length = b2;
      }
      if (b2 !== 0)
        if (this.length > b2)
          for (this.length -= b2, u = 0; u < this.length; u++)
            this.words[u] = this.words[u + b2];
        else
          this.words[0] = 0, this.length = 1;
      var E2 = 0;
      for (u = this.length - 1; u >= 0 && (E2 !== 0 || u >= a); u--) {
        var B = this.words[u] | 0;
        this.words[u] = E2 << 26 - d2 | B >>> d2, E2 = B & _2;
      }
      return v && E2 !== 0 && (v.words[v.length++] = E2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, n.prototype.ishrn = function(c2, p2, h2) {
      return r(this.negative === 0), this.iushrn(c2, p2, h2);
    }, n.prototype.shln = function(c2) {
      return this.clone().ishln(c2);
    }, n.prototype.ushln = function(c2) {
      return this.clone().iushln(c2);
    }, n.prototype.shrn = function(c2) {
      return this.clone().ishrn(c2);
    }, n.prototype.ushrn = function(c2) {
      return this.clone().iushrn(c2);
    }, n.prototype.testn = function(c2) {
      r(typeof c2 == "number" && c2 >= 0);
      var p2 = c2 % 26, h2 = (c2 - p2) / 26, a = 1 << p2;
      if (this.length <= h2)
        return false;
      var d2 = this.words[h2];
      return !!(d2 & a);
    }, n.prototype.imaskn = function(c2) {
      r(typeof c2 == "number" && c2 >= 0);
      var p2 = c2 % 26, h2 = (c2 - p2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h2)
        return this;
      if (p2 !== 0 && h2++, this.length = Math.min(h2, this.length), p2 !== 0) {
        var a = 67108863 ^ 67108863 >>> p2 << p2;
        this.words[this.length - 1] &= a;
      }
      return this.strip();
    }, n.prototype.maskn = function(c2) {
      return this.clone().imaskn(c2);
    }, n.prototype.iaddn = function(c2) {
      return r(typeof c2 == "number"), r(c2 < 67108864), c2 < 0 ? this.isubn(-c2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < c2 ? (this.words[0] = c2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c2), this.negative = 1, this) : this._iaddn(c2);
    }, n.prototype._iaddn = function(c2) {
      this.words[0] += c2;
      for (var p2 = 0; p2 < this.length && this.words[p2] >= 67108864; p2++)
        this.words[p2] -= 67108864, p2 === this.length - 1 ? this.words[p2 + 1] = 1 : this.words[p2 + 1]++;
      return this.length = Math.max(this.length, p2 + 1), this;
    }, n.prototype.isubn = function(c2) {
      if (r(typeof c2 == "number"), r(c2 < 67108864), c2 < 0)
        return this.iaddn(-c2);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c2), this.negative = 1, this;
      if (this.words[0] -= c2, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var p2 = 0; p2 < this.length && this.words[p2] < 0; p2++)
          this.words[p2] += 67108864, this.words[p2 + 1] -= 1;
      return this.strip();
    }, n.prototype.addn = function(c2) {
      return this.clone().iaddn(c2);
    }, n.prototype.subn = function(c2) {
      return this.clone().isubn(c2);
    }, n.prototype.iabs = function() {
      return this.negative = 0, this;
    }, n.prototype.abs = function() {
      return this.clone().iabs();
    }, n.prototype._ishlnsubmul = function(c2, p2, h2) {
      var a = c2.length + h2, d2;
      this._expand(a);
      var b2, _2 = 0;
      for (d2 = 0; d2 < c2.length; d2++) {
        b2 = (this.words[d2 + h2] | 0) + _2;
        var v = (c2.words[d2] | 0) * p2;
        b2 -= v & 67108863, _2 = (b2 >> 26) - (v / 67108864 | 0), this.words[d2 + h2] = b2 & 67108863;
      }
      for (; d2 < this.length - h2; d2++)
        b2 = (this.words[d2 + h2] | 0) + _2, _2 = b2 >> 26, this.words[d2 + h2] = b2 & 67108863;
      if (_2 === 0)
        return this.strip();
      for (r(_2 === -1), _2 = 0, d2 = 0; d2 < this.length; d2++)
        b2 = -(this.words[d2] | 0) + _2, _2 = b2 >> 26, this.words[d2] = b2 & 67108863;
      return this.negative = 1, this.strip();
    }, n.prototype._wordDiv = function(c2, p2) {
      var h2 = this.length - c2.length, a = this.clone(), d2 = c2, b2 = d2.words[d2.length - 1] | 0, _2 = this._countBits(b2);
      h2 = 26 - _2, h2 !== 0 && (d2 = d2.ushln(h2), a.iushln(h2), b2 = d2.words[d2.length - 1] | 0);
      var v = a.length - d2.length, u;
      if (p2 !== "mod") {
        u = new n(null), u.length = v + 1, u.words = new Array(u.length);
        for (var E2 = 0; E2 < u.length; E2++)
          u.words[E2] = 0;
      }
      var B = a.clone()._ishlnsubmul(d2, 1, v);
      B.negative === 0 && (a = B, u && (u.words[v] = 1));
      for (var y2 = v - 1; y2 >= 0; y2--) {
        var M = (a.words[d2.length + y2] | 0) * 67108864 + (a.words[d2.length + y2 - 1] | 0);
        for (M = Math.min(M / b2 | 0, 67108863), a._ishlnsubmul(d2, M, y2); a.negative !== 0; )
          M--, a.negative = 0, a._ishlnsubmul(d2, 1, y2), a.isZero() || (a.negative ^= 1);
        u && (u.words[y2] = M);
      }
      return u && u.strip(), a.strip(), p2 !== "div" && h2 !== 0 && a.iushrn(h2), { div: u || null, mod: a };
    }, n.prototype.divmod = function(c2, p2, h2) {
      if (r(!c2.isZero()), this.isZero())
        return { div: new n(0), mod: new n(0) };
      var a, d2, b2;
      return this.negative !== 0 && c2.negative === 0 ? (b2 = this.neg().divmod(c2, p2), p2 !== "mod" && (a = b2.div.neg()), p2 !== "div" && (d2 = b2.mod.neg(), h2 && d2.negative !== 0 && d2.iadd(c2)), { div: a, mod: d2 }) : this.negative === 0 && c2.negative !== 0 ? (b2 = this.divmod(c2.neg(), p2), p2 !== "mod" && (a = b2.div.neg()), { div: a, mod: b2.mod }) : (this.negative & c2.negative) !== 0 ? (b2 = this.neg().divmod(c2.neg(), p2), p2 !== "div" && (d2 = b2.mod.neg(), h2 && d2.negative !== 0 && d2.isub(c2)), { div: b2.div, mod: d2 }) : c2.length > this.length || this.cmp(c2) < 0 ? { div: new n(0), mod: this } : c2.length === 1 ? p2 === "div" ? { div: this.divn(c2.words[0]), mod: null } : p2 === "mod" ? { div: null, mod: new n(this.modn(c2.words[0])) } : { div: this.divn(c2.words[0]), mod: new n(this.modn(c2.words[0])) } : this._wordDiv(c2, p2);
    }, n.prototype.div = function(c2) {
      return this.divmod(c2, "div", false).div;
    }, n.prototype.mod = function(c2) {
      return this.divmod(c2, "mod", false).mod;
    }, n.prototype.umod = function(c2) {
      return this.divmod(c2, "mod", true).mod;
    }, n.prototype.divRound = function(c2) {
      var p2 = this.divmod(c2);
      if (p2.mod.isZero())
        return p2.div;
      var h2 = p2.div.negative !== 0 ? p2.mod.isub(c2) : p2.mod, a = c2.ushrn(1), d2 = c2.andln(1), b2 = h2.cmp(a);
      return b2 < 0 || d2 === 1 && b2 === 0 ? p2.div : p2.div.negative !== 0 ? p2.div.isubn(1) : p2.div.iaddn(1);
    }, n.prototype.modn = function(c2) {
      r(c2 <= 67108863);
      for (var p2 = (1 << 26) % c2, h2 = 0, a = this.length - 1; a >= 0; a--)
        h2 = (p2 * h2 + (this.words[a] | 0)) % c2;
      return h2;
    }, n.prototype.idivn = function(c2) {
      r(c2 <= 67108863);
      for (var p2 = 0, h2 = this.length - 1; h2 >= 0; h2--) {
        var a = (this.words[h2] | 0) + p2 * 67108864;
        this.words[h2] = a / c2 | 0, p2 = a % c2;
      }
      return this.strip();
    }, n.prototype.divn = function(c2) {
      return this.clone().idivn(c2);
    }, n.prototype.egcd = function(c2) {
      r(c2.negative === 0), r(!c2.isZero());
      var p2 = this, h2 = c2.clone();
      p2.negative !== 0 ? p2 = p2.umod(c2) : p2 = p2.clone();
      for (var a = new n(1), d2 = new n(0), b2 = new n(0), _2 = new n(1), v = 0; p2.isEven() && h2.isEven(); )
        p2.iushrn(1), h2.iushrn(1), ++v;
      for (var u = h2.clone(), E2 = p2.clone(); !p2.isZero(); ) {
        for (var B = 0, y2 = 1; (p2.words[0] & y2) === 0 && B < 26; ++B, y2 <<= 1)
          ;
        if (B > 0)
          for (p2.iushrn(B); B-- > 0; )
            (a.isOdd() || d2.isOdd()) && (a.iadd(u), d2.isub(E2)), a.iushrn(1), d2.iushrn(1);
        for (var M = 0, de2 = 1; (h2.words[0] & de2) === 0 && M < 26; ++M, de2 <<= 1)
          ;
        if (M > 0)
          for (h2.iushrn(M); M-- > 0; )
            (b2.isOdd() || _2.isOdd()) && (b2.iadd(u), _2.isub(E2)), b2.iushrn(1), _2.iushrn(1);
        p2.cmp(h2) >= 0 ? (p2.isub(h2), a.isub(b2), d2.isub(_2)) : (h2.isub(p2), b2.isub(a), _2.isub(d2));
      }
      return { a: b2, b: _2, gcd: h2.iushln(v) };
    }, n.prototype._invmp = function(c2) {
      r(c2.negative === 0), r(!c2.isZero());
      var p2 = this, h2 = c2.clone();
      p2.negative !== 0 ? p2 = p2.umod(c2) : p2 = p2.clone();
      for (var a = new n(1), d2 = new n(0), b2 = h2.clone(); p2.cmpn(1) > 0 && h2.cmpn(1) > 0; ) {
        for (var _2 = 0, v = 1; (p2.words[0] & v) === 0 && _2 < 26; ++_2, v <<= 1)
          ;
        if (_2 > 0)
          for (p2.iushrn(_2); _2-- > 0; )
            a.isOdd() && a.iadd(b2), a.iushrn(1);
        for (var u = 0, E2 = 1; (h2.words[0] & E2) === 0 && u < 26; ++u, E2 <<= 1)
          ;
        if (u > 0)
          for (h2.iushrn(u); u-- > 0; )
            d2.isOdd() && d2.iadd(b2), d2.iushrn(1);
        p2.cmp(h2) >= 0 ? (p2.isub(h2), a.isub(d2)) : (h2.isub(p2), d2.isub(a));
      }
      var B;
      return p2.cmpn(1) === 0 ? B = a : B = d2, B.cmpn(0) < 0 && B.iadd(c2), B;
    }, n.prototype.gcd = function(c2) {
      if (this.isZero())
        return c2.abs();
      if (c2.isZero())
        return this.abs();
      var p2 = this.clone(), h2 = c2.clone();
      p2.negative = 0, h2.negative = 0;
      for (var a = 0; p2.isEven() && h2.isEven(); a++)
        p2.iushrn(1), h2.iushrn(1);
      do {
        for (; p2.isEven(); )
          p2.iushrn(1);
        for (; h2.isEven(); )
          h2.iushrn(1);
        var d2 = p2.cmp(h2);
        if (d2 < 0) {
          var b2 = p2;
          p2 = h2, h2 = b2;
        } else if (d2 === 0 || h2.cmpn(1) === 0)
          break;
        p2.isub(h2);
      } while (true);
      return h2.iushln(a);
    }, n.prototype.invm = function(c2) {
      return this.egcd(c2).a.umod(c2);
    }, n.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, n.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, n.prototype.andln = function(c2) {
      return this.words[0] & c2;
    }, n.prototype.bincn = function(c2) {
      r(typeof c2 == "number");
      var p2 = c2 % 26, h2 = (c2 - p2) / 26, a = 1 << p2;
      if (this.length <= h2)
        return this._expand(h2 + 1), this.words[h2] |= a, this;
      for (var d2 = a, b2 = h2; d2 !== 0 && b2 < this.length; b2++) {
        var _2 = this.words[b2] | 0;
        _2 += d2, d2 = _2 >>> 26, _2 &= 67108863, this.words[b2] = _2;
      }
      return d2 !== 0 && (this.words[b2] = d2, this.length++), this;
    }, n.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, n.prototype.cmpn = function(c2) {
      var p2 = c2 < 0;
      if (this.negative !== 0 && !p2)
        return -1;
      if (this.negative === 0 && p2)
        return 1;
      this.strip();
      var h2;
      if (this.length > 1)
        h2 = 1;
      else {
        p2 && (c2 = -c2), r(c2 <= 67108863, "Number is too big");
        var a = this.words[0] | 0;
        h2 = a === c2 ? 0 : a < c2 ? -1 : 1;
      }
      return this.negative !== 0 ? -h2 | 0 : h2;
    }, n.prototype.cmp = function(c2) {
      if (this.negative !== 0 && c2.negative === 0)
        return -1;
      if (this.negative === 0 && c2.negative !== 0)
        return 1;
      var p2 = this.ucmp(c2);
      return this.negative !== 0 ? -p2 | 0 : p2;
    }, n.prototype.ucmp = function(c2) {
      if (this.length > c2.length)
        return 1;
      if (this.length < c2.length)
        return -1;
      for (var p2 = 0, h2 = this.length - 1; h2 >= 0; h2--) {
        var a = this.words[h2] | 0, d2 = c2.words[h2] | 0;
        if (a !== d2) {
          a < d2 ? p2 = -1 : a > d2 && (p2 = 1);
          break;
        }
      }
      return p2;
    }, n.prototype.gtn = function(c2) {
      return this.cmpn(c2) === 1;
    }, n.prototype.gt = function(c2) {
      return this.cmp(c2) === 1;
    }, n.prototype.gten = function(c2) {
      return this.cmpn(c2) >= 0;
    }, n.prototype.gte = function(c2) {
      return this.cmp(c2) >= 0;
    }, n.prototype.ltn = function(c2) {
      return this.cmpn(c2) === -1;
    }, n.prototype.lt = function(c2) {
      return this.cmp(c2) === -1;
    }, n.prototype.lten = function(c2) {
      return this.cmpn(c2) <= 0;
    }, n.prototype.lte = function(c2) {
      return this.cmp(c2) <= 0;
    }, n.prototype.eqn = function(c2) {
      return this.cmpn(c2) === 0;
    }, n.prototype.eq = function(c2) {
      return this.cmp(c2) === 0;
    }, n.red = function(c2) {
      return new ie(c2);
    }, n.prototype.toRed = function(c2) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), c2.convertTo(this)._forceRed(c2);
    }, n.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, n.prototype._forceRed = function(c2) {
      return this.red = c2, this;
    }, n.prototype.forceRed = function(c2) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(c2);
    }, n.prototype.redAdd = function(c2) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, c2);
    }, n.prototype.redIAdd = function(c2) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c2);
    }, n.prototype.redSub = function(c2) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, c2);
    }, n.prototype.redISub = function(c2) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, c2);
    }, n.prototype.redShl = function(c2) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, c2);
    }, n.prototype.redMul = function(c2) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, c2), this.red.mul(this, c2);
    }, n.prototype.redIMul = function(c2) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, c2), this.red.imul(this, c2);
    }, n.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, n.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, n.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, n.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, n.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, n.prototype.redPow = function(c2) {
      return r(this.red && !c2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c2);
    };
    var ue = { k256: null, p224: null, p192: null, p25519: null };
    function ge(N3, c2) {
      this.name = N3, this.p = new n(c2, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ge.prototype._tmp = function() {
      var c2 = new n(null);
      return c2.words = new Array(Math.ceil(this.n / 13)), c2;
    }, ge.prototype.ireduce = function(c2) {
      var p2 = c2, h2;
      do
        this.split(p2, this.tmp), p2 = this.imulK(p2), p2 = p2.iadd(this.tmp), h2 = p2.bitLength();
      while (h2 > this.n);
      var a = h2 < this.n ? -1 : p2.ucmp(this.p);
      return a === 0 ? (p2.words[0] = 0, p2.length = 1) : a > 0 ? p2.isub(this.p) : p2.strip !== void 0 ? p2.strip() : p2._strip(), p2;
    }, ge.prototype.split = function(c2, p2) {
      c2.iushrn(this.n, 0, p2);
    }, ge.prototype.imulK = function(c2) {
      return c2.imul(this.k);
    };
    function Se() {
      ge.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    i(Se, ge), Se.prototype.split = function(c2, p2) {
      for (var h2 = 4194303, a = Math.min(c2.length, 9), d2 = 0; d2 < a; d2++)
        p2.words[d2] = c2.words[d2];
      if (p2.length = a, c2.length <= 9) {
        c2.words[0] = 0, c2.length = 1;
        return;
      }
      var b2 = c2.words[9];
      for (p2.words[p2.length++] = b2 & h2, d2 = 10; d2 < c2.length; d2++) {
        var _2 = c2.words[d2] | 0;
        c2.words[d2 - 10] = (_2 & h2) << 4 | b2 >>> 22, b2 = _2;
      }
      b2 >>>= 22, c2.words[d2 - 10] = b2, b2 === 0 && c2.length > 10 ? c2.length -= 10 : c2.length -= 9;
    }, Se.prototype.imulK = function(c2) {
      c2.words[c2.length] = 0, c2.words[c2.length + 1] = 0, c2.length += 2;
      for (var p2 = 0, h2 = 0; h2 < c2.length; h2++) {
        var a = c2.words[h2] | 0;
        p2 += a * 977, c2.words[h2] = p2 & 67108863, p2 = a * 64 + (p2 / 67108864 | 0);
      }
      return c2.words[c2.length - 1] === 0 && (c2.length--, c2.words[c2.length - 1] === 0 && c2.length--), c2;
    };
    function pe2() {
      ge.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    i(pe2, ge);
    function H2() {
      ge.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    i(H2, ge);
    function le() {
      ge.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    i(le, ge), le.prototype.imulK = function(c2) {
      for (var p2 = 0, h2 = 0; h2 < c2.length; h2++) {
        var a = (c2.words[h2] | 0) * 19 + p2, d2 = a & 67108863;
        a >>>= 26, c2.words[h2] = d2, p2 = a;
      }
      return p2 !== 0 && (c2.words[c2.length++] = p2), c2;
    }, n._prime = function(c2) {
      if (ue[c2])
        return ue[c2];
      var p2;
      if (c2 === "k256")
        p2 = new Se();
      else if (c2 === "p224")
        p2 = new pe2();
      else if (c2 === "p192")
        p2 = new H2();
      else if (c2 === "p25519")
        p2 = new le();
      else
        throw new Error("Unknown prime " + c2);
      return ue[c2] = p2, p2;
    };
    function ie(N3) {
      if (typeof N3 == "string") {
        var c2 = n._prime(N3);
        this.m = c2.p, this.prime = c2;
      } else
        r(N3.gtn(1), "modulus must be greater than 1"), this.m = N3, this.prime = null;
    }
    ie.prototype._verify1 = function(c2) {
      r(c2.negative === 0, "red works only with positives"), r(c2.red, "red works only with red numbers");
    }, ie.prototype._verify2 = function(c2, p2) {
      r((c2.negative | p2.negative) === 0, "red works only with positives"), r(c2.red && c2.red === p2.red, "red works only with red numbers");
    }, ie.prototype.imod = function(c2) {
      return this.prime ? this.prime.ireduce(c2)._forceRed(this) : c2.umod(this.m)._forceRed(this);
    }, ie.prototype.neg = function(c2) {
      return c2.isZero() ? c2.clone() : this.m.sub(c2)._forceRed(this);
    }, ie.prototype.add = function(c2, p2) {
      this._verify2(c2, p2);
      var h2 = c2.add(p2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2._forceRed(this);
    }, ie.prototype.iadd = function(c2, p2) {
      this._verify2(c2, p2);
      var h2 = c2.iadd(p2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2;
    }, ie.prototype.sub = function(c2, p2) {
      this._verify2(c2, p2);
      var h2 = c2.sub(p2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2._forceRed(this);
    }, ie.prototype.isub = function(c2, p2) {
      this._verify2(c2, p2);
      var h2 = c2.isub(p2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2;
    }, ie.prototype.shl = function(c2, p2) {
      return this._verify1(c2), this.imod(c2.ushln(p2));
    }, ie.prototype.imul = function(c2, p2) {
      return this._verify2(c2, p2), this.imod(c2.imul(p2));
    }, ie.prototype.mul = function(c2, p2) {
      return this._verify2(c2, p2), this.imod(c2.mul(p2));
    }, ie.prototype.isqr = function(c2) {
      return this.imul(c2, c2.clone());
    }, ie.prototype.sqr = function(c2) {
      return this.mul(c2, c2);
    }, ie.prototype.sqrt = function(c2) {
      if (c2.isZero())
        return c2.clone();
      var p2 = this.m.andln(3);
      if (r(p2 % 2 === 1), p2 === 3) {
        var h2 = this.m.add(new n(1)).iushrn(2);
        return this.pow(c2, h2);
      }
      for (var a = this.m.subn(1), d2 = 0; !a.isZero() && a.andln(1) === 0; )
        d2++, a.iushrn(1);
      r(!a.isZero());
      var b2 = new n(1).toRed(this), _2 = b2.redNeg(), v = this.m.subn(1).iushrn(1), u = this.m.bitLength();
      for (u = new n(2 * u * u).toRed(this); this.pow(u, v).cmp(_2) !== 0; )
        u.redIAdd(_2);
      for (var E2 = this.pow(u, a), B = this.pow(c2, a.addn(1).iushrn(1)), y2 = this.pow(c2, a), M = d2; y2.cmp(b2) !== 0; ) {
        for (var de2 = y2, Ee = 0; de2.cmp(b2) !== 0; Ee++)
          de2 = de2.redSqr();
        r(Ee < M);
        var Me = this.pow(E2, new n(1).iushln(M - Ee - 1));
        B = B.redMul(Me), E2 = Me.redSqr(), y2 = y2.redMul(E2), M = Ee;
      }
      return B;
    }, ie.prototype.invm = function(c2) {
      var p2 = c2._invmp(this.m);
      return p2.negative !== 0 ? (p2.negative = 0, this.imod(p2).redNeg()) : this.imod(p2);
    }, ie.prototype.pow = function(c2, p2) {
      if (p2.isZero())
        return new n(1).toRed(this);
      if (p2.cmpn(1) === 0)
        return c2.clone();
      var h2 = 4, a = new Array(1 << h2);
      a[0] = new n(1).toRed(this), a[1] = c2;
      for (var d2 = 2; d2 < a.length; d2++)
        a[d2] = this.mul(a[d2 - 1], c2);
      var b2 = a[0], _2 = 0, v = 0, u = p2.bitLength() % 26;
      for (u === 0 && (u = 26), d2 = p2.length - 1; d2 >= 0; d2--) {
        for (var E2 = p2.words[d2], B = u - 1; B >= 0; B--) {
          var y2 = E2 >> B & 1;
          if (b2 !== a[0] && (b2 = this.sqr(b2)), y2 === 0 && _2 === 0) {
            v = 0;
            continue;
          }
          _2 <<= 1, _2 |= y2, v++, !(v !== h2 && (d2 !== 0 || B !== 0)) && (b2 = this.mul(b2, a[_2]), v = 0, _2 = 0);
        }
        u = 26;
      }
      return b2;
    }, ie.prototype.convertTo = function(c2) {
      var p2 = c2.umod(this.m);
      return p2 === c2 ? p2.clone() : p2;
    }, ie.prototype.convertFrom = function(c2) {
      var p2 = c2.clone();
      return p2.red = null, p2;
    }, n.mont = function(c2) {
      return new se(c2);
    };
    function se(N3) {
      ie.call(this, N3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(se, ie), se.prototype.convertTo = function(c2) {
      return this.imod(c2.ushln(this.shift));
    }, se.prototype.convertFrom = function(c2) {
      var p2 = this.imod(c2.mul(this.rinv));
      return p2.red = null, p2;
    }, se.prototype.imul = function(c2, p2) {
      if (c2.isZero() || p2.isZero())
        return c2.words[0] = 0, c2.length = 1, c2;
      var h2 = c2.imul(p2), a = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d2 = h2.isub(a).iushrn(this.shift), b2 = d2;
      return d2.cmp(this.m) >= 0 ? b2 = d2.isub(this.m) : d2.cmpn(0) < 0 && (b2 = d2.iadd(this.m)), b2._forceRed(this);
    }, se.prototype.mul = function(c2, p2) {
      if (c2.isZero() || p2.isZero())
        return new n(0)._forceRed(this);
      var h2 = c2.mul(p2), a = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d2 = h2.isub(a).iushrn(this.shift), b2 = d2;
      return d2.cmp(this.m) >= 0 ? b2 = d2.isub(this.m) : d2.cmpn(0) < 0 && (b2 = d2.iadd(this.m)), b2._forceRed(this);
    }, se.prototype.invm = function(c2) {
      var p2 = this.imod(c2._invmp(this.m).mul(this.r2));
      return p2._forceRed(this);
    };
  })(typeof p1 > "u" || p1, Ew);
});
var Wl = k((NB, y1) => {
  U();
  var g1;
  y1.exports = function(e) {
    return g1 || (g1 = new Hn(null)), g1.generate(e);
  };
  function Hn(t) {
    this.rand = t;
  }
  y1.exports.Rand = Hn;
  Hn.prototype.generate = function(e) {
    return this._rand(e);
  };
  Hn.prototype._rand = function(e) {
    if (this.rand.getBytes)
      return this.rand.getBytes(e);
    for (var r = new Uint8Array(e), i = 0; i < r.length; i++)
      r[i] = this.rand.getByte();
    return r;
  };
  if (typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? Hn.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.crypto.getRandomValues(r), r;
    } : self.msCrypto && self.msCrypto.getRandomValues ? Hn.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.msCrypto.getRandomValues(r), r;
    } : typeof window == "object" && (Hn.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      if (m1 = b1(), typeof m1.randomBytes != "function")
        throw new Error("Not supported");
      Hn.prototype._rand = function(e) {
        return m1.randomBytes(e);
      };
    } catch {
    }
  var m1;
});
var v1 = k((CB, Sw) => {
  U();
  var js = lr(), _S = Wl();
  function Ls(t) {
    this.rand = t || new _S.Rand();
  }
  Sw.exports = Ls;
  Ls.create = function(e) {
    return new Ls(e);
  };
  Ls.prototype._randbelow = function(e) {
    var r = e.bitLength(), i = Math.ceil(r / 8);
    do
      var n = new js(this.rand.generate(i));
    while (n.cmp(e) >= 0);
    return n;
  };
  Ls.prototype._randrange = function(e, r) {
    var i = r.sub(e);
    return e.add(this._randbelow(i));
  };
  Ls.prototype.test = function(e, r, i) {
    var n = e.bitLength(), s2 = js.mont(e), o = new js(1).toRed(s2);
    r || (r = Math.max(1, n / 48 | 0));
    for (var f = e.subn(1), l = 0; !f.testn(l); l++)
      ;
    for (var m3 = e.shrn(l), A2 = f.toRed(s2), F3 = true; r > 0; r--) {
      var z3 = this._randrange(new js(2), f);
      i && i(z3);
      var V = z3.toRed(s2).redPow(m3);
      if (!(V.cmp(o) === 0 || V.cmp(A2) === 0)) {
        for (var $ = 1; $ < l; $++) {
          if (V = V.redSqr(), V.cmp(o) === 0)
            return false;
          if (V.cmp(A2) === 0)
            break;
        }
        if ($ === l)
          return false;
      }
    }
    return F3;
  };
  Ls.prototype.getDivisor = function(e, r) {
    var i = e.bitLength(), n = js.mont(e), s2 = new js(1).toRed(n);
    r || (r = Math.max(1, i / 48 | 0));
    for (var o = e.subn(1), f = 0; !o.testn(f); f++)
      ;
    for (var l = e.shrn(f), m3 = o.toRed(n); r > 0; r--) {
      var A2 = this._randrange(new js(2), o), F3 = e.gcd(A2);
      if (F3.cmpn(1) !== 0)
        return F3;
      var z3 = A2.toRed(n).redPow(l);
      if (!(z3.cmp(s2) === 0 || z3.cmp(m3) === 0)) {
        for (var V = 1; V < f; V++) {
          if (z3 = z3.redSqr(), z3.cmp(s2) === 0)
            return z3.fromRed().subn(1).gcd(e);
          if (z3.cmp(m3) === 0)
            break;
        }
        if (V === f)
          return z3 = z3.redSqr(), z3.fromRed().subn(1).gcd(e);
      }
    }
    return false;
  };
});
var S1 = k((PB, Tw) => {
  U();
  var AS = bs();
  Tw.exports = E1;
  E1.simpleSieve = _1;
  E1.fermatTest = A1;
  var wr = lr(), ES = new wr(24), SS = v1(), Mw = new SS(), MS = new wr(1), x1 = new wr(2), IS = new wr(5);
  new wr(16);
  new wr(8);
  var TS = new wr(10), FS = new wr(3);
  new wr(7);
  var RS = new wr(11), Iw = new wr(4);
  new wr(12);
  var w1 = null;
  function kS() {
    if (w1 !== null)
      return w1;
    var t = 1048576, e = [];
    e[0] = 2;
    for (var r = 1, i = 3; i < t; i += 2) {
      for (var n = Math.ceil(Math.sqrt(i)), s2 = 0; s2 < r && e[s2] <= n && i % e[s2] !== 0; s2++)
        ;
      r !== s2 && e[s2] <= n || (e[r++] = i);
    }
    return w1 = e, e;
  }
  function _1(t) {
    for (var e = kS(), r = 0; r < e.length; r++)
      if (t.modn(e[r]) === 0)
        return t.cmpn(e[r]) === 0;
    return true;
  }
  function A1(t) {
    var e = wr.mont(t);
    return x1.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
  }
  function E1(t, e) {
    if (t < 16)
      return e === 2 || e === 5 ? new wr([140, 123]) : new wr([140, 39]);
    e = new wr(e);
    for (var r, i; ; ) {
      for (r = new wr(AS(Math.ceil(t / 8))); r.bitLength() > t; )
        r.ishrn(1);
      if (r.isEven() && r.iadd(MS), r.testn(1) || r.iadd(x1), e.cmp(x1)) {
        if (!e.cmp(IS))
          for (; r.mod(TS).cmp(FS); )
            r.iadd(Iw);
      } else
        for (; r.mod(ES).cmp(RS); )
          r.iadd(Iw);
      if (i = r.shrn(1), _1(i) && _1(r) && A1(i) && A1(r) && Mw.test(i) && Mw.test(r))
        return r;
    }
  }
});
var Fw = k((UB, DS) => {
  DS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
});
var Bw = k((zB, Dw) => {
  U();
  var ni = lr(), BS = v1(), Rw = new BS(), NS = new ni(24), CS = new ni(11), OS = new ni(10), jS = new ni(3), LS = new ni(7), kw = S1(), qS = bs();
  Dw.exports = ln;
  function PS(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this._pub = new ni(t), this;
  }
  function US(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this._priv = new ni(t), this;
  }
  var Vl = {};
  function zS(t, e) {
    var r = e.toString("hex"), i = [r, t.toString(16)].join("_");
    if (i in Vl)
      return Vl[i];
    var n = 0;
    if (t.isEven() || !kw.simpleSieve || !kw.fermatTest(t) || !Rw.test(t))
      return n += 1, r === "02" || r === "05" ? n += 8 : n += 4, Vl[i] = n, n;
    Rw.test(t.shrn(1)) || (n += 2);
    var s2;
    switch (r) {
      case "02":
        t.mod(NS).cmp(CS) && (n += 8);
        break;
      case "05":
        s2 = t.mod(OS), s2.cmp(jS) && s2.cmp(LS) && (n += 8);
        break;
      default:
        n += 4;
    }
    return Vl[i] = n, n;
  }
  function ln(t, e, r) {
    this.setGenerator(e), this.__prime = new ni(t), this._prime = ni.mont(this.__prime), this._primeLen = t.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r ? (this.setPublicKey = PS, this.setPrivateKey = US) : this._primeCode = 8;
  }
  Object.defineProperty(ln.prototype, "verifyError", { enumerable: true, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = zS(this.__prime, this.__gen)), this._primeCode;
  } });
  ln.prototype.generateKeys = function() {
    return this._priv || (this._priv = new ni(qS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  };
  ln.prototype.computeSecret = function(t) {
    t = new ni(t), t = t.toRed(this._prime);
    var e = t.redPow(this._priv).fromRed(), r = new b.Buffer(e.toArray()), i = this.getPrime();
    if (r.length < i.length) {
      var n = new b.Buffer(i.length - r.length);
      n.fill(0), r = b.Buffer.concat([n, r]);
    }
    return r;
  };
  ln.prototype.getPublicKey = function(e) {
    return Yl(this._pub, e);
  };
  ln.prototype.getPrivateKey = function(e) {
    return Yl(this._priv, e);
  };
  ln.prototype.getPrime = function(t) {
    return Yl(this.__prime, t);
  };
  ln.prototype.getGenerator = function(t) {
    return Yl(this._gen, t);
  };
  ln.prototype.setGenerator = function(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this.__gen = t, this._gen = new ni(t), this;
  };
  function Yl(t, e) {
    var r = new b.Buffer(t.toArray());
    return e ? r.toString(e) : r;
  }
});
var Ow = k((Qo) => {
  U();
  var HS = S1(), Nw = Fw(), M1 = Bw();
  function $S(t) {
    var e = new b.Buffer(Nw[t].prime, "hex"), r = new b.Buffer(Nw[t].gen, "hex");
    return new M1(e, r);
  }
  var GS = { binary: true, hex: true, base64: true };
  function Cw(t, e, r, i) {
    return b.Buffer.isBuffer(e) || GS[e] === void 0 ? Cw(t, "binary", e, r) : (e = e || "binary", i = i || "binary", r = r || new b.Buffer([2]), b.Buffer.isBuffer(r) || (r = new b.Buffer(r, i)), typeof t == "number" ? new M1(HS(t, r), r, true) : (b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), new M1(t, r, true)));
  }
  Qo.DiffieHellmanGroup = Qo.createDiffieHellmanGroup = Qo.getDiffieHellman = $S;
  Qo.createDiffieHellman = Qo.DiffieHellman = Cw;
});
var Jl = k((jw, I1) => {
  U();
  (function(t, e) {
    function r(h2, a) {
      if (!h2)
        throw new Error(a || "Assertion failed");
    }
    function i(h2, a) {
      h2.super_ = a;
      var d2 = function() {
      };
      d2.prototype = a.prototype, h2.prototype = new d2(), h2.prototype.constructor = h2;
    }
    function n(h2, a, d2) {
      if (n.isBN(h2))
        return h2;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, h2 !== null && ((a === "le" || a === "be") && (d2 = a, a = 10), this._init(h2 || 0, a || 10, d2 || "be"));
    }
    typeof t == "object" ? t.exports = n : e.BN = n, n.BN = n, n.wordSize = 26;
    var s2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s2 = window.Buffer : s2 = or().Buffer;
    } catch {
    }
    n.isBN = function(a) {
      return a instanceof n ? true : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words);
    }, n.max = function(a, d2) {
      return a.cmp(d2) > 0 ? a : d2;
    }, n.min = function(a, d2) {
      return a.cmp(d2) < 0 ? a : d2;
    }, n.prototype._init = function(a, d2, b2) {
      if (typeof a == "number")
        return this._initNumber(a, d2, b2);
      if (typeof a == "object")
        return this._initArray(a, d2, b2);
      d2 === "hex" && (d2 = 16), r(d2 === (d2 | 0) && d2 >= 2 && d2 <= 36), a = a.toString().replace(/\s+/g, "");
      var _2 = 0;
      a[0] === "-" && (_2++, this.negative = 1), _2 < a.length && (d2 === 16 ? this._parseHex(a, _2, b2) : (this._parseBase(a, d2, _2), b2 === "le" && this._initArray(this.toArray(), d2, b2)));
    }, n.prototype._initNumber = function(a, d2, b2) {
      a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [a & 67108863, a / 67108864 & 67108863], this.length = 2) : (r(a < 9007199254740992), this.words = [a & 67108863, a / 67108864 & 67108863, 1], this.length = 3), b2 === "le" && this._initArray(this.toArray(), d2, b2);
    }, n.prototype._initArray = function(a, d2, b2) {
      if (r(typeof a.length == "number"), a.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
      for (var _2 = 0; _2 < this.length; _2++)
        this.words[_2] = 0;
      var v, u, E2 = 0;
      if (b2 === "be")
        for (_2 = a.length - 1, v = 0; _2 >= 0; _2 -= 3)
          u = a[_2] | a[_2 - 1] << 8 | a[_2 - 2] << 16, this.words[v] |= u << E2 & 67108863, this.words[v + 1] = u >>> 26 - E2 & 67108863, E2 += 24, E2 >= 26 && (E2 -= 26, v++);
      else if (b2 === "le")
        for (_2 = 0, v = 0; _2 < a.length; _2 += 3)
          u = a[_2] | a[_2 + 1] << 8 | a[_2 + 2] << 16, this.words[v] |= u << E2 & 67108863, this.words[v + 1] = u >>> 26 - E2 & 67108863, E2 += 24, E2 >= 26 && (E2 -= 26, v++);
      return this._strip();
    };
    function o(h2, a) {
      var d2 = h2.charCodeAt(a);
      if (d2 >= 48 && d2 <= 57)
        return d2 - 48;
      if (d2 >= 65 && d2 <= 70)
        return d2 - 55;
      if (d2 >= 97 && d2 <= 102)
        return d2 - 87;
      r(false, "Invalid character in " + h2);
    }
    function f(h2, a, d2) {
      var b2 = o(h2, d2);
      return d2 - 1 >= a && (b2 |= o(h2, d2 - 1) << 4), b2;
    }
    n.prototype._parseHex = function(a, d2, b2) {
      this.length = Math.ceil((a.length - d2) / 6), this.words = new Array(this.length);
      for (var _2 = 0; _2 < this.length; _2++)
        this.words[_2] = 0;
      var v = 0, u = 0, E2;
      if (b2 === "be")
        for (_2 = a.length - 1; _2 >= d2; _2 -= 2)
          E2 = f(a, d2, _2) << v, this.words[u] |= E2 & 67108863, v >= 18 ? (v -= 18, u += 1, this.words[u] |= E2 >>> 26) : v += 8;
      else {
        var B = a.length - d2;
        for (_2 = B % 2 === 0 ? d2 + 1 : d2; _2 < a.length; _2 += 2)
          E2 = f(a, d2, _2) << v, this.words[u] |= E2 & 67108863, v >= 18 ? (v -= 18, u += 1, this.words[u] |= E2 >>> 26) : v += 8;
      }
      this._strip();
    };
    function l(h2, a, d2, b2) {
      for (var _2 = 0, v = 0, u = Math.min(h2.length, d2), E2 = a; E2 < u; E2++) {
        var B = h2.charCodeAt(E2) - 48;
        _2 *= b2, B >= 49 ? v = B - 49 + 10 : B >= 17 ? v = B - 17 + 10 : v = B, r(B >= 0 && v < b2, "Invalid character"), _2 += v;
      }
      return _2;
    }
    n.prototype._parseBase = function(a, d2, b2) {
      this.words = [0], this.length = 1;
      for (var _2 = 0, v = 1; v <= 67108863; v *= d2)
        _2++;
      _2--, v = v / d2 | 0;
      for (var u = a.length - b2, E2 = u % _2, B = Math.min(u, u - E2) + b2, y2 = 0, M = b2; M < B; M += _2)
        y2 = l(a, M, M + _2, d2), this.imuln(v), this.words[0] + y2 < 67108864 ? this.words[0] += y2 : this._iaddn(y2);
      if (E2 !== 0) {
        var de2 = 1;
        for (y2 = l(a, M, a.length, d2), M = 0; M < E2; M++)
          de2 *= d2;
        this.imuln(de2), this.words[0] + y2 < 67108864 ? this.words[0] += y2 : this._iaddn(y2);
      }
      this._strip();
    }, n.prototype.copy = function(a) {
      a.words = new Array(this.length);
      for (var d2 = 0; d2 < this.length; d2++)
        a.words[d2] = this.words[d2];
      a.length = this.length, a.negative = this.negative, a.red = this.red;
    };
    function m3(h2, a) {
      h2.words = a.words, h2.length = a.length, h2.negative = a.negative, h2.red = a.red;
    }
    if (n.prototype._move = function(a) {
      m3(a, this);
    }, n.prototype.clone = function() {
      var a = new n(null);
      return this.copy(a), a;
    }, n.prototype._expand = function(a) {
      for (; this.length < a; )
        this.words[this.length++] = 0;
      return this;
    }, n.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, n.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        n.prototype[Symbol.for("nodejs.util.inspect.custom")] = A2;
      } catch {
        n.prototype.inspect = A2;
      }
    else
      n.prototype.inspect = A2;
    function A2() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var F3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], z3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], V = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    n.prototype.toString = function(a, d2) {
      a = a || 10, d2 = d2 | 0 || 1;
      var b2;
      if (a === 16 || a === "hex") {
        b2 = "";
        for (var _2 = 0, v = 0, u = 0; u < this.length; u++) {
          var E2 = this.words[u], B = ((E2 << _2 | v) & 16777215).toString(16);
          v = E2 >>> 24 - _2 & 16777215, _2 += 2, _2 >= 26 && (_2 -= 26, u--), v !== 0 || u !== this.length - 1 ? b2 = F3[6 - B.length] + B + b2 : b2 = B + b2;
        }
        for (v !== 0 && (b2 = v.toString(16) + b2); b2.length % d2 !== 0; )
          b2 = "0" + b2;
        return this.negative !== 0 && (b2 = "-" + b2), b2;
      }
      if (a === (a | 0) && a >= 2 && a <= 36) {
        var y2 = z3[a], M = V[a];
        b2 = "";
        var de2 = this.clone();
        for (de2.negative = 0; !de2.isZero(); ) {
          var Ee = de2.modrn(M).toString(a);
          de2 = de2.idivn(M), de2.isZero() ? b2 = Ee + b2 : b2 = F3[y2 - Ee.length] + Ee + b2;
        }
        for (this.isZero() && (b2 = "0" + b2); b2.length % d2 !== 0; )
          b2 = "0" + b2;
        return this.negative !== 0 && (b2 = "-" + b2), b2;
      }
      r(false, "Base should be between 2 and 36");
    }, n.prototype.toNumber = function() {
      var a = this.words[0];
      return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
    }, n.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, s2 && (n.prototype.toBuffer = function(a, d2) {
      return this.toArrayLike(s2, a, d2);
    }), n.prototype.toArray = function(a, d2) {
      return this.toArrayLike(Array, a, d2);
    };
    var $ = function(a, d2) {
      return a.allocUnsafe ? a.allocUnsafe(d2) : new a(d2);
    };
    n.prototype.toArrayLike = function(a, d2, b2) {
      this._strip();
      var _2 = this.byteLength(), v = b2 || Math.max(1, _2);
      r(_2 <= v, "byte array longer than desired length"), r(v > 0, "Requested array length <= 0");
      var u = $(a, v), E2 = d2 === "le" ? "LE" : "BE";
      return this["_toArrayLike" + E2](u, _2), u;
    }, n.prototype._toArrayLikeLE = function(a, d2) {
      for (var b2 = 0, _2 = 0, v = 0, u = 0; v < this.length; v++) {
        var E2 = this.words[v] << u | _2;
        a[b2++] = E2 & 255, b2 < a.length && (a[b2++] = E2 >> 8 & 255), b2 < a.length && (a[b2++] = E2 >> 16 & 255), u === 6 ? (b2 < a.length && (a[b2++] = E2 >> 24 & 255), _2 = 0, u = 0) : (_2 = E2 >>> 24, u += 2);
      }
      if (b2 < a.length)
        for (a[b2++] = _2; b2 < a.length; )
          a[b2++] = 0;
    }, n.prototype._toArrayLikeBE = function(a, d2) {
      for (var b2 = a.length - 1, _2 = 0, v = 0, u = 0; v < this.length; v++) {
        var E2 = this.words[v] << u | _2;
        a[b2--] = E2 & 255, b2 >= 0 && (a[b2--] = E2 >> 8 & 255), b2 >= 0 && (a[b2--] = E2 >> 16 & 255), u === 6 ? (b2 >= 0 && (a[b2--] = E2 >> 24 & 255), _2 = 0, u = 0) : (_2 = E2 >>> 24, u += 2);
      }
      if (b2 >= 0)
        for (a[b2--] = _2; b2 >= 0; )
          a[b2--] = 0;
    }, Math.clz32 ? n.prototype._countBits = function(a) {
      return 32 - Math.clz32(a);
    } : n.prototype._countBits = function(a) {
      var d2 = a, b2 = 0;
      return d2 >= 4096 && (b2 += 13, d2 >>>= 13), d2 >= 64 && (b2 += 7, d2 >>>= 7), d2 >= 8 && (b2 += 4, d2 >>>= 4), d2 >= 2 && (b2 += 2, d2 >>>= 2), b2 + d2;
    }, n.prototype._zeroBits = function(a) {
      if (a === 0)
        return 26;
      var d2 = a, b2 = 0;
      return (d2 & 8191) === 0 && (b2 += 13, d2 >>>= 13), (d2 & 127) === 0 && (b2 += 7, d2 >>>= 7), (d2 & 15) === 0 && (b2 += 4, d2 >>>= 4), (d2 & 3) === 0 && (b2 += 2, d2 >>>= 2), (d2 & 1) === 0 && b2++, b2;
    }, n.prototype.bitLength = function() {
      var a = this.words[this.length - 1], d2 = this._countBits(a);
      return (this.length - 1) * 26 + d2;
    };
    function re(h2) {
      for (var a = new Array(h2.bitLength()), d2 = 0; d2 < a.length; d2++) {
        var b2 = d2 / 26 | 0, _2 = d2 % 26;
        a[d2] = h2.words[b2] >>> _2 & 1;
      }
      return a;
    }
    n.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var a = 0, d2 = 0; d2 < this.length; d2++) {
        var b2 = this._zeroBits(this.words[d2]);
        if (a += b2, b2 !== 26)
          break;
      }
      return a;
    }, n.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, n.prototype.toTwos = function(a) {
      return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
    }, n.prototype.fromTwos = function(a) {
      return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
    }, n.prototype.isNeg = function() {
      return this.negative !== 0;
    }, n.prototype.neg = function() {
      return this.clone().ineg();
    }, n.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, n.prototype.iuor = function(a) {
      for (; this.length < a.length; )
        this.words[this.length++] = 0;
      for (var d2 = 0; d2 < a.length; d2++)
        this.words[d2] = this.words[d2] | a.words[d2];
      return this._strip();
    }, n.prototype.ior = function(a) {
      return r((this.negative | a.negative) === 0), this.iuor(a);
    }, n.prototype.or = function(a) {
      return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
    }, n.prototype.uor = function(a) {
      return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
    }, n.prototype.iuand = function(a) {
      var d2;
      this.length > a.length ? d2 = a : d2 = this;
      for (var b2 = 0; b2 < d2.length; b2++)
        this.words[b2] = this.words[b2] & a.words[b2];
      return this.length = d2.length, this._strip();
    }, n.prototype.iand = function(a) {
      return r((this.negative | a.negative) === 0), this.iuand(a);
    }, n.prototype.and = function(a) {
      return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
    }, n.prototype.uand = function(a) {
      return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
    }, n.prototype.iuxor = function(a) {
      var d2, b2;
      this.length > a.length ? (d2 = this, b2 = a) : (d2 = a, b2 = this);
      for (var _2 = 0; _2 < b2.length; _2++)
        this.words[_2] = d2.words[_2] ^ b2.words[_2];
      if (this !== d2)
        for (; _2 < d2.length; _2++)
          this.words[_2] = d2.words[_2];
      return this.length = d2.length, this._strip();
    }, n.prototype.ixor = function(a) {
      return r((this.negative | a.negative) === 0), this.iuxor(a);
    }, n.prototype.xor = function(a) {
      return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
    }, n.prototype.uxor = function(a) {
      return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
    }, n.prototype.inotn = function(a) {
      r(typeof a == "number" && a >= 0);
      var d2 = Math.ceil(a / 26) | 0, b2 = a % 26;
      this._expand(d2), b2 > 0 && d2--;
      for (var _2 = 0; _2 < d2; _2++)
        this.words[_2] = ~this.words[_2] & 67108863;
      return b2 > 0 && (this.words[_2] = ~this.words[_2] & 67108863 >> 26 - b2), this._strip();
    }, n.prototype.notn = function(a) {
      return this.clone().inotn(a);
    }, n.prototype.setn = function(a, d2) {
      r(typeof a == "number" && a >= 0);
      var b2 = a / 26 | 0, _2 = a % 26;
      return this._expand(b2 + 1), d2 ? this.words[b2] = this.words[b2] | 1 << _2 : this.words[b2] = this.words[b2] & ~(1 << _2), this._strip();
    }, n.prototype.iadd = function(a) {
      var d2;
      if (this.negative !== 0 && a.negative === 0)
        return this.negative = 0, d2 = this.isub(a), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && a.negative !== 0)
        return a.negative = 0, d2 = this.isub(a), a.negative = 1, d2._normSign();
      var b2, _2;
      this.length > a.length ? (b2 = this, _2 = a) : (b2 = a, _2 = this);
      for (var v = 0, u = 0; u < _2.length; u++)
        d2 = (b2.words[u] | 0) + (_2.words[u] | 0) + v, this.words[u] = d2 & 67108863, v = d2 >>> 26;
      for (; v !== 0 && u < b2.length; u++)
        d2 = (b2.words[u] | 0) + v, this.words[u] = d2 & 67108863, v = d2 >>> 26;
      if (this.length = b2.length, v !== 0)
        this.words[this.length] = v, this.length++;
      else if (b2 !== this)
        for (; u < b2.length; u++)
          this.words[u] = b2.words[u];
      return this;
    }, n.prototype.add = function(a) {
      var d2;
      return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, d2 = this.sub(a), a.negative ^= 1, d2) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, d2 = a.sub(this), this.negative = 1, d2) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
    }, n.prototype.isub = function(a) {
      if (a.negative !== 0) {
        a.negative = 0;
        var d2 = this.iadd(a);
        return a.negative = 1, d2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
      var b2 = this.cmp(a);
      if (b2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var _2, v;
      b2 > 0 ? (_2 = this, v = a) : (_2 = a, v = this);
      for (var u = 0, E2 = 0; E2 < v.length; E2++)
        d2 = (_2.words[E2] | 0) - (v.words[E2] | 0) + u, u = d2 >> 26, this.words[E2] = d2 & 67108863;
      for (; u !== 0 && E2 < _2.length; E2++)
        d2 = (_2.words[E2] | 0) + u, u = d2 >> 26, this.words[E2] = d2 & 67108863;
      if (u === 0 && E2 < _2.length && _2 !== this)
        for (; E2 < _2.length; E2++)
          this.words[E2] = _2.words[E2];
      return this.length = Math.max(this.length, E2), _2 !== this && (this.negative = 1), this._strip();
    }, n.prototype.sub = function(a) {
      return this.clone().isub(a);
    };
    function W2(h2, a, d2) {
      d2.negative = a.negative ^ h2.negative;
      var b2 = h2.length + a.length | 0;
      d2.length = b2, b2 = b2 - 1 | 0;
      var _2 = h2.words[0] | 0, v = a.words[0] | 0, u = _2 * v, E2 = u & 67108863, B = u / 67108864 | 0;
      d2.words[0] = E2;
      for (var y2 = 1; y2 < b2; y2++) {
        for (var M = B >>> 26, de2 = B & 67108863, Ee = Math.min(y2, a.length - 1), Me = Math.max(0, y2 - h2.length + 1); Me <= Ee; Me++) {
          var Oe = y2 - Me | 0;
          _2 = h2.words[Oe] | 0, v = a.words[Me] | 0, u = _2 * v + de2, M += u / 67108864 | 0, de2 = u & 67108863;
        }
        d2.words[y2] = de2 | 0, B = M | 0;
      }
      return B !== 0 ? d2.words[y2] = B | 0 : d2.length--, d2._strip();
    }
    var Z2 = function(a, d2, b2) {
      var _2 = a.words, v = d2.words, u = b2.words, E2 = 0, B, y2, M, de2 = _2[0] | 0, Ee = de2 & 8191, Me = de2 >>> 13, Oe = _2[1] | 0, be = Oe & 8191, I = Oe >>> 13, j3 = _2[2] | 0, P5 = j3 & 8191, ee2 = j3 >>> 13, oe = _2[3] | 0, te = oe & 8191, ae = oe >>> 13, ne = _2[4] | 0, X2 = ne & 8191, R3 = ne >>> 13, w = _2[5] | 0, T2 = w & 8191, q2 = w >>> 13, L2 = _2[6] | 0, G2 = L2 & 8191, K5 = L2 >>> 13, xe = _2[7] | 0, me2 = xe & 8191, _e2 = xe >>> 13, fe = _2[8] | 0, ke = fe & 8191, Be = fe >>> 13, gt = _2[9] | 0, je2 = gt & 8191, Ge = gt >>> 13, xt = v[0] | 0, Pe = xt & 8191, Le = xt >>> 13, Zt = v[1] | 0, Xe = Zt & 8191, Qe = Zt >>> 13, er = v[2] | 0, et = er & 8191, tt = er >>> 13, zt = v[3] | 0, ht = zt & 8191, pt2 = zt >>> 13, nn = v[4] | 0, mt = nn & 8191, yt = nn >>> 13, ms = v[5] | 0, it = ms & 8191, bt = ms >>> 13, S2 = v[6] | 0, D2 = S2 & 8191, k2 = S2 >>> 13, g = v[7] | 0, O2 = g & 8191, Q = g >>> 13, he = v[8] | 0, ye = he & 8191, Ae = he >>> 13, Ye = v[9] | 0, Ne2 = Ye & 8191, rt = Ye >>> 13;
      b2.negative = a.negative ^ d2.negative, b2.length = 19, B = Math.imul(Ee, Pe), y2 = Math.imul(Ee, Le), y2 = y2 + Math.imul(Me, Pe) | 0, M = Math.imul(Me, Le);
      var $e = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, B = Math.imul(be, Pe), y2 = Math.imul(be, Le), y2 = y2 + Math.imul(I, Pe) | 0, M = Math.imul(I, Le), B = B + Math.imul(Ee, Xe) | 0, y2 = y2 + Math.imul(Ee, Qe) | 0, y2 = y2 + Math.imul(Me, Xe) | 0, M = M + Math.imul(Me, Qe) | 0;
      var nt = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, B = Math.imul(P5, Pe), y2 = Math.imul(P5, Le), y2 = y2 + Math.imul(ee2, Pe) | 0, M = Math.imul(ee2, Le), B = B + Math.imul(be, Xe) | 0, y2 = y2 + Math.imul(be, Qe) | 0, y2 = y2 + Math.imul(I, Xe) | 0, M = M + Math.imul(I, Qe) | 0, B = B + Math.imul(Ee, et) | 0, y2 = y2 + Math.imul(Ee, tt) | 0, y2 = y2 + Math.imul(Me, et) | 0, M = M + Math.imul(Me, tt) | 0;
      var st = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, B = Math.imul(te, Pe), y2 = Math.imul(te, Le), y2 = y2 + Math.imul(ae, Pe) | 0, M = Math.imul(ae, Le), B = B + Math.imul(P5, Xe) | 0, y2 = y2 + Math.imul(P5, Qe) | 0, y2 = y2 + Math.imul(ee2, Xe) | 0, M = M + Math.imul(ee2, Qe) | 0, B = B + Math.imul(be, et) | 0, y2 = y2 + Math.imul(be, tt) | 0, y2 = y2 + Math.imul(I, et) | 0, M = M + Math.imul(I, tt) | 0, B = B + Math.imul(Ee, ht) | 0, y2 = y2 + Math.imul(Ee, pt2) | 0, y2 = y2 + Math.imul(Me, ht) | 0, M = M + Math.imul(Me, pt2) | 0;
      var lt = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, B = Math.imul(X2, Pe), y2 = Math.imul(X2, Le), y2 = y2 + Math.imul(R3, Pe) | 0, M = Math.imul(R3, Le), B = B + Math.imul(te, Xe) | 0, y2 = y2 + Math.imul(te, Qe) | 0, y2 = y2 + Math.imul(ae, Xe) | 0, M = M + Math.imul(ae, Qe) | 0, B = B + Math.imul(P5, et) | 0, y2 = y2 + Math.imul(P5, tt) | 0, y2 = y2 + Math.imul(ee2, et) | 0, M = M + Math.imul(ee2, tt) | 0, B = B + Math.imul(be, ht) | 0, y2 = y2 + Math.imul(be, pt2) | 0, y2 = y2 + Math.imul(I, ht) | 0, M = M + Math.imul(I, pt2) | 0, B = B + Math.imul(Ee, mt) | 0, y2 = y2 + Math.imul(Ee, yt) | 0, y2 = y2 + Math.imul(Me, mt) | 0, M = M + Math.imul(Me, yt) | 0;
      var dt = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, B = Math.imul(T2, Pe), y2 = Math.imul(T2, Le), y2 = y2 + Math.imul(q2, Pe) | 0, M = Math.imul(q2, Le), B = B + Math.imul(X2, Xe) | 0, y2 = y2 + Math.imul(X2, Qe) | 0, y2 = y2 + Math.imul(R3, Xe) | 0, M = M + Math.imul(R3, Qe) | 0, B = B + Math.imul(te, et) | 0, y2 = y2 + Math.imul(te, tt) | 0, y2 = y2 + Math.imul(ae, et) | 0, M = M + Math.imul(ae, tt) | 0, B = B + Math.imul(P5, ht) | 0, y2 = y2 + Math.imul(P5, pt2) | 0, y2 = y2 + Math.imul(ee2, ht) | 0, M = M + Math.imul(ee2, pt2) | 0, B = B + Math.imul(be, mt) | 0, y2 = y2 + Math.imul(be, yt) | 0, y2 = y2 + Math.imul(I, mt) | 0, M = M + Math.imul(I, yt) | 0, B = B + Math.imul(Ee, it) | 0, y2 = y2 + Math.imul(Ee, bt) | 0, y2 = y2 + Math.imul(Me, it) | 0, M = M + Math.imul(Me, bt) | 0;
      var ot = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, B = Math.imul(G2, Pe), y2 = Math.imul(G2, Le), y2 = y2 + Math.imul(K5, Pe) | 0, M = Math.imul(K5, Le), B = B + Math.imul(T2, Xe) | 0, y2 = y2 + Math.imul(T2, Qe) | 0, y2 = y2 + Math.imul(q2, Xe) | 0, M = M + Math.imul(q2, Qe) | 0, B = B + Math.imul(X2, et) | 0, y2 = y2 + Math.imul(X2, tt) | 0, y2 = y2 + Math.imul(R3, et) | 0, M = M + Math.imul(R3, tt) | 0, B = B + Math.imul(te, ht) | 0, y2 = y2 + Math.imul(te, pt2) | 0, y2 = y2 + Math.imul(ae, ht) | 0, M = M + Math.imul(ae, pt2) | 0, B = B + Math.imul(P5, mt) | 0, y2 = y2 + Math.imul(P5, yt) | 0, y2 = y2 + Math.imul(ee2, mt) | 0, M = M + Math.imul(ee2, yt) | 0, B = B + Math.imul(be, it) | 0, y2 = y2 + Math.imul(be, bt) | 0, y2 = y2 + Math.imul(I, it) | 0, M = M + Math.imul(I, bt) | 0, B = B + Math.imul(Ee, D2) | 0, y2 = y2 + Math.imul(Ee, k2) | 0, y2 = y2 + Math.imul(Me, D2) | 0, M = M + Math.imul(Me, k2) | 0;
      var ft = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, B = Math.imul(me2, Pe), y2 = Math.imul(me2, Le), y2 = y2 + Math.imul(_e2, Pe) | 0, M = Math.imul(_e2, Le), B = B + Math.imul(G2, Xe) | 0, y2 = y2 + Math.imul(G2, Qe) | 0, y2 = y2 + Math.imul(K5, Xe) | 0, M = M + Math.imul(K5, Qe) | 0, B = B + Math.imul(T2, et) | 0, y2 = y2 + Math.imul(T2, tt) | 0, y2 = y2 + Math.imul(q2, et) | 0, M = M + Math.imul(q2, tt) | 0, B = B + Math.imul(X2, ht) | 0, y2 = y2 + Math.imul(X2, pt2) | 0, y2 = y2 + Math.imul(R3, ht) | 0, M = M + Math.imul(R3, pt2) | 0, B = B + Math.imul(te, mt) | 0, y2 = y2 + Math.imul(te, yt) | 0, y2 = y2 + Math.imul(ae, mt) | 0, M = M + Math.imul(ae, yt) | 0, B = B + Math.imul(P5, it) | 0, y2 = y2 + Math.imul(P5, bt) | 0, y2 = y2 + Math.imul(ee2, it) | 0, M = M + Math.imul(ee2, bt) | 0, B = B + Math.imul(be, D2) | 0, y2 = y2 + Math.imul(be, k2) | 0, y2 = y2 + Math.imul(I, D2) | 0, M = M + Math.imul(I, k2) | 0, B = B + Math.imul(Ee, O2) | 0, y2 = y2 + Math.imul(Ee, Q) | 0, y2 = y2 + Math.imul(Me, O2) | 0, M = M + Math.imul(Me, Q) | 0;
      var at = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, B = Math.imul(ke, Pe), y2 = Math.imul(ke, Le), y2 = y2 + Math.imul(Be, Pe) | 0, M = Math.imul(Be, Le), B = B + Math.imul(me2, Xe) | 0, y2 = y2 + Math.imul(me2, Qe) | 0, y2 = y2 + Math.imul(_e2, Xe) | 0, M = M + Math.imul(_e2, Qe) | 0, B = B + Math.imul(G2, et) | 0, y2 = y2 + Math.imul(G2, tt) | 0, y2 = y2 + Math.imul(K5, et) | 0, M = M + Math.imul(K5, tt) | 0, B = B + Math.imul(T2, ht) | 0, y2 = y2 + Math.imul(T2, pt2) | 0, y2 = y2 + Math.imul(q2, ht) | 0, M = M + Math.imul(q2, pt2) | 0, B = B + Math.imul(X2, mt) | 0, y2 = y2 + Math.imul(X2, yt) | 0, y2 = y2 + Math.imul(R3, mt) | 0, M = M + Math.imul(R3, yt) | 0, B = B + Math.imul(te, it) | 0, y2 = y2 + Math.imul(te, bt) | 0, y2 = y2 + Math.imul(ae, it) | 0, M = M + Math.imul(ae, bt) | 0, B = B + Math.imul(P5, D2) | 0, y2 = y2 + Math.imul(P5, k2) | 0, y2 = y2 + Math.imul(ee2, D2) | 0, M = M + Math.imul(ee2, k2) | 0, B = B + Math.imul(be, O2) | 0, y2 = y2 + Math.imul(be, Q) | 0, y2 = y2 + Math.imul(I, O2) | 0, M = M + Math.imul(I, Q) | 0, B = B + Math.imul(Ee, ye) | 0, y2 = y2 + Math.imul(Ee, Ae) | 0, y2 = y2 + Math.imul(Me, ye) | 0, M = M + Math.imul(Me, Ae) | 0;
      var Ke = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, B = Math.imul(je2, Pe), y2 = Math.imul(je2, Le), y2 = y2 + Math.imul(Ge, Pe) | 0, M = Math.imul(Ge, Le), B = B + Math.imul(ke, Xe) | 0, y2 = y2 + Math.imul(ke, Qe) | 0, y2 = y2 + Math.imul(Be, Xe) | 0, M = M + Math.imul(Be, Qe) | 0, B = B + Math.imul(me2, et) | 0, y2 = y2 + Math.imul(me2, tt) | 0, y2 = y2 + Math.imul(_e2, et) | 0, M = M + Math.imul(_e2, tt) | 0, B = B + Math.imul(G2, ht) | 0, y2 = y2 + Math.imul(G2, pt2) | 0, y2 = y2 + Math.imul(K5, ht) | 0, M = M + Math.imul(K5, pt2) | 0, B = B + Math.imul(T2, mt) | 0, y2 = y2 + Math.imul(T2, yt) | 0, y2 = y2 + Math.imul(q2, mt) | 0, M = M + Math.imul(q2, yt) | 0, B = B + Math.imul(X2, it) | 0, y2 = y2 + Math.imul(X2, bt) | 0, y2 = y2 + Math.imul(R3, it) | 0, M = M + Math.imul(R3, bt) | 0, B = B + Math.imul(te, D2) | 0, y2 = y2 + Math.imul(te, k2) | 0, y2 = y2 + Math.imul(ae, D2) | 0, M = M + Math.imul(ae, k2) | 0, B = B + Math.imul(P5, O2) | 0, y2 = y2 + Math.imul(P5, Q) | 0, y2 = y2 + Math.imul(ee2, O2) | 0, M = M + Math.imul(ee2, Q) | 0, B = B + Math.imul(be, ye) | 0, y2 = y2 + Math.imul(be, Ae) | 0, y2 = y2 + Math.imul(I, ye) | 0, M = M + Math.imul(I, Ae) | 0, B = B + Math.imul(Ee, Ne2) | 0, y2 = y2 + Math.imul(Ee, rt) | 0, y2 = y2 + Math.imul(Me, Ne2) | 0, M = M + Math.imul(Me, rt) | 0;
      var Je = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(je2, Xe), y2 = Math.imul(je2, Qe), y2 = y2 + Math.imul(Ge, Xe) | 0, M = Math.imul(Ge, Qe), B = B + Math.imul(ke, et) | 0, y2 = y2 + Math.imul(ke, tt) | 0, y2 = y2 + Math.imul(Be, et) | 0, M = M + Math.imul(Be, tt) | 0, B = B + Math.imul(me2, ht) | 0, y2 = y2 + Math.imul(me2, pt2) | 0, y2 = y2 + Math.imul(_e2, ht) | 0, M = M + Math.imul(_e2, pt2) | 0, B = B + Math.imul(G2, mt) | 0, y2 = y2 + Math.imul(G2, yt) | 0, y2 = y2 + Math.imul(K5, mt) | 0, M = M + Math.imul(K5, yt) | 0, B = B + Math.imul(T2, it) | 0, y2 = y2 + Math.imul(T2, bt) | 0, y2 = y2 + Math.imul(q2, it) | 0, M = M + Math.imul(q2, bt) | 0, B = B + Math.imul(X2, D2) | 0, y2 = y2 + Math.imul(X2, k2) | 0, y2 = y2 + Math.imul(R3, D2) | 0, M = M + Math.imul(R3, k2) | 0, B = B + Math.imul(te, O2) | 0, y2 = y2 + Math.imul(te, Q) | 0, y2 = y2 + Math.imul(ae, O2) | 0, M = M + Math.imul(ae, Q) | 0, B = B + Math.imul(P5, ye) | 0, y2 = y2 + Math.imul(P5, Ae) | 0, y2 = y2 + Math.imul(ee2, ye) | 0, M = M + Math.imul(ee2, Ae) | 0, B = B + Math.imul(be, Ne2) | 0, y2 = y2 + Math.imul(be, rt) | 0, y2 = y2 + Math.imul(I, Ne2) | 0, M = M + Math.imul(I, rt) | 0;
      var ze = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B = Math.imul(je2, et), y2 = Math.imul(je2, tt), y2 = y2 + Math.imul(Ge, et) | 0, M = Math.imul(Ge, tt), B = B + Math.imul(ke, ht) | 0, y2 = y2 + Math.imul(ke, pt2) | 0, y2 = y2 + Math.imul(Be, ht) | 0, M = M + Math.imul(Be, pt2) | 0, B = B + Math.imul(me2, mt) | 0, y2 = y2 + Math.imul(me2, yt) | 0, y2 = y2 + Math.imul(_e2, mt) | 0, M = M + Math.imul(_e2, yt) | 0, B = B + Math.imul(G2, it) | 0, y2 = y2 + Math.imul(G2, bt) | 0, y2 = y2 + Math.imul(K5, it) | 0, M = M + Math.imul(K5, bt) | 0, B = B + Math.imul(T2, D2) | 0, y2 = y2 + Math.imul(T2, k2) | 0, y2 = y2 + Math.imul(q2, D2) | 0, M = M + Math.imul(q2, k2) | 0, B = B + Math.imul(X2, O2) | 0, y2 = y2 + Math.imul(X2, Q) | 0, y2 = y2 + Math.imul(R3, O2) | 0, M = M + Math.imul(R3, Q) | 0, B = B + Math.imul(te, ye) | 0, y2 = y2 + Math.imul(te, Ae) | 0, y2 = y2 + Math.imul(ae, ye) | 0, M = M + Math.imul(ae, Ae) | 0, B = B + Math.imul(P5, Ne2) | 0, y2 = y2 + Math.imul(P5, rt) | 0, y2 = y2 + Math.imul(ee2, Ne2) | 0, M = M + Math.imul(ee2, rt) | 0;
      var We = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, B = Math.imul(je2, ht), y2 = Math.imul(je2, pt2), y2 = y2 + Math.imul(Ge, ht) | 0, M = Math.imul(Ge, pt2), B = B + Math.imul(ke, mt) | 0, y2 = y2 + Math.imul(ke, yt) | 0, y2 = y2 + Math.imul(Be, mt) | 0, M = M + Math.imul(Be, yt) | 0, B = B + Math.imul(me2, it) | 0, y2 = y2 + Math.imul(me2, bt) | 0, y2 = y2 + Math.imul(_e2, it) | 0, M = M + Math.imul(_e2, bt) | 0, B = B + Math.imul(G2, D2) | 0, y2 = y2 + Math.imul(G2, k2) | 0, y2 = y2 + Math.imul(K5, D2) | 0, M = M + Math.imul(K5, k2) | 0, B = B + Math.imul(T2, O2) | 0, y2 = y2 + Math.imul(T2, Q) | 0, y2 = y2 + Math.imul(q2, O2) | 0, M = M + Math.imul(q2, Q) | 0, B = B + Math.imul(X2, ye) | 0, y2 = y2 + Math.imul(X2, Ae) | 0, y2 = y2 + Math.imul(R3, ye) | 0, M = M + Math.imul(R3, Ae) | 0, B = B + Math.imul(te, Ne2) | 0, y2 = y2 + Math.imul(te, rt) | 0, y2 = y2 + Math.imul(ae, Ne2) | 0, M = M + Math.imul(ae, rt) | 0;
      var Ve = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, B = Math.imul(je2, mt), y2 = Math.imul(je2, yt), y2 = y2 + Math.imul(Ge, mt) | 0, M = Math.imul(Ge, yt), B = B + Math.imul(ke, it) | 0, y2 = y2 + Math.imul(ke, bt) | 0, y2 = y2 + Math.imul(Be, it) | 0, M = M + Math.imul(Be, bt) | 0, B = B + Math.imul(me2, D2) | 0, y2 = y2 + Math.imul(me2, k2) | 0, y2 = y2 + Math.imul(_e2, D2) | 0, M = M + Math.imul(_e2, k2) | 0, B = B + Math.imul(G2, O2) | 0, y2 = y2 + Math.imul(G2, Q) | 0, y2 = y2 + Math.imul(K5, O2) | 0, M = M + Math.imul(K5, Q) | 0, B = B + Math.imul(T2, ye) | 0, y2 = y2 + Math.imul(T2, Ae) | 0, y2 = y2 + Math.imul(q2, ye) | 0, M = M + Math.imul(q2, Ae) | 0, B = B + Math.imul(X2, Ne2) | 0, y2 = y2 + Math.imul(X2, rt) | 0, y2 = y2 + Math.imul(R3, Ne2) | 0, M = M + Math.imul(R3, rt) | 0;
      var qe = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, B = Math.imul(je2, it), y2 = Math.imul(je2, bt), y2 = y2 + Math.imul(Ge, it) | 0, M = Math.imul(Ge, bt), B = B + Math.imul(ke, D2) | 0, y2 = y2 + Math.imul(ke, k2) | 0, y2 = y2 + Math.imul(Be, D2) | 0, M = M + Math.imul(Be, k2) | 0, B = B + Math.imul(me2, O2) | 0, y2 = y2 + Math.imul(me2, Q) | 0, y2 = y2 + Math.imul(_e2, O2) | 0, M = M + Math.imul(_e2, Q) | 0, B = B + Math.imul(G2, ye) | 0, y2 = y2 + Math.imul(G2, Ae) | 0, y2 = y2 + Math.imul(K5, ye) | 0, M = M + Math.imul(K5, Ae) | 0, B = B + Math.imul(T2, Ne2) | 0, y2 = y2 + Math.imul(T2, rt) | 0, y2 = y2 + Math.imul(q2, Ne2) | 0, M = M + Math.imul(q2, rt) | 0;
      var ve = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, B = Math.imul(je2, D2), y2 = Math.imul(je2, k2), y2 = y2 + Math.imul(Ge, D2) | 0, M = Math.imul(Ge, k2), B = B + Math.imul(ke, O2) | 0, y2 = y2 + Math.imul(ke, Q) | 0, y2 = y2 + Math.imul(Be, O2) | 0, M = M + Math.imul(Be, Q) | 0, B = B + Math.imul(me2, ye) | 0, y2 = y2 + Math.imul(me2, Ae) | 0, y2 = y2 + Math.imul(_e2, ye) | 0, M = M + Math.imul(_e2, Ae) | 0, B = B + Math.imul(G2, Ne2) | 0, y2 = y2 + Math.imul(G2, rt) | 0, y2 = y2 + Math.imul(K5, Ne2) | 0, M = M + Math.imul(K5, rt) | 0;
      var we = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, B = Math.imul(je2, O2), y2 = Math.imul(je2, Q), y2 = y2 + Math.imul(Ge, O2) | 0, M = Math.imul(Ge, Q), B = B + Math.imul(ke, ye) | 0, y2 = y2 + Math.imul(ke, Ae) | 0, y2 = y2 + Math.imul(Be, ye) | 0, M = M + Math.imul(Be, Ae) | 0, B = B + Math.imul(me2, Ne2) | 0, y2 = y2 + Math.imul(me2, rt) | 0, y2 = y2 + Math.imul(_e2, Ne2) | 0, M = M + Math.imul(_e2, rt) | 0;
      var De = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, B = Math.imul(je2, ye), y2 = Math.imul(je2, Ae), y2 = y2 + Math.imul(Ge, ye) | 0, M = Math.imul(Ge, Ae), B = B + Math.imul(ke, Ne2) | 0, y2 = y2 + Math.imul(ke, rt) | 0, y2 = y2 + Math.imul(Be, Ne2) | 0, M = M + Math.imul(Be, rt) | 0;
      var Te = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      E2 = (M + (y2 >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, B = Math.imul(je2, Ne2), y2 = Math.imul(je2, rt), y2 = y2 + Math.imul(Ge, Ne2) | 0, M = Math.imul(Ge, rt);
      var Fe = (E2 + B | 0) + ((y2 & 8191) << 13) | 0;
      return E2 = (M + (y2 >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, u[0] = $e, u[1] = nt, u[2] = st, u[3] = lt, u[4] = dt, u[5] = ot, u[6] = ft, u[7] = at, u[8] = Ke, u[9] = Je, u[10] = ze, u[11] = We, u[12] = Ve, u[13] = qe, u[14] = ve, u[15] = we, u[16] = De, u[17] = Te, u[18] = Fe, E2 !== 0 && (u[19] = E2, b2.length++), b2;
    };
    Math.imul || (Z2 = W2);
    function ue(h2, a, d2) {
      d2.negative = a.negative ^ h2.negative, d2.length = h2.length + a.length;
      for (var b2 = 0, _2 = 0, v = 0; v < d2.length - 1; v++) {
        var u = _2;
        _2 = 0;
        for (var E2 = b2 & 67108863, B = Math.min(v, a.length - 1), y2 = Math.max(0, v - h2.length + 1); y2 <= B; y2++) {
          var M = v - y2, de2 = h2.words[M] | 0, Ee = a.words[y2] | 0, Me = de2 * Ee, Oe = Me & 67108863;
          u = u + (Me / 67108864 | 0) | 0, Oe = Oe + E2 | 0, E2 = Oe & 67108863, u = u + (Oe >>> 26) | 0, _2 += u >>> 26, u &= 67108863;
        }
        d2.words[v] = E2, b2 = u, u = _2;
      }
      return b2 !== 0 ? d2.words[v] = b2 : d2.length--, d2._strip();
    }
    function ge(h2, a, d2) {
      return ue(h2, a, d2);
    }
    n.prototype.mulTo = function(a, d2) {
      var b2, _2 = this.length + a.length;
      return this.length === 10 && a.length === 10 ? b2 = Z2(this, a, d2) : _2 < 63 ? b2 = W2(this, a, d2) : _2 < 1024 ? b2 = ue(this, a, d2) : b2 = ge(this, a, d2), b2;
    };
    n.prototype.mul = function(a) {
      var d2 = new n(null);
      return d2.words = new Array(this.length + a.length), this.mulTo(a, d2);
    }, n.prototype.mulf = function(a) {
      var d2 = new n(null);
      return d2.words = new Array(this.length + a.length), ge(this, a, d2);
    }, n.prototype.imul = function(a) {
      return this.clone().mulTo(a, this);
    }, n.prototype.imuln = function(a) {
      var d2 = a < 0;
      d2 && (a = -a), r(typeof a == "number"), r(a < 67108864);
      for (var b2 = 0, _2 = 0; _2 < this.length; _2++) {
        var v = (this.words[_2] | 0) * a, u = (v & 67108863) + (b2 & 67108863);
        b2 >>= 26, b2 += v / 67108864 | 0, b2 += u >>> 26, this.words[_2] = u & 67108863;
      }
      return b2 !== 0 && (this.words[_2] = b2, this.length++), d2 ? this.ineg() : this;
    }, n.prototype.muln = function(a) {
      return this.clone().imuln(a);
    }, n.prototype.sqr = function() {
      return this.mul(this);
    }, n.prototype.isqr = function() {
      return this.imul(this.clone());
    }, n.prototype.pow = function(a) {
      var d2 = re(a);
      if (d2.length === 0)
        return new n(1);
      for (var b2 = this, _2 = 0; _2 < d2.length && d2[_2] === 0; _2++, b2 = b2.sqr())
        ;
      if (++_2 < d2.length)
        for (var v = b2.sqr(); _2 < d2.length; _2++, v = v.sqr())
          d2[_2] !== 0 && (b2 = b2.mul(v));
      return b2;
    }, n.prototype.iushln = function(a) {
      r(typeof a == "number" && a >= 0);
      var d2 = a % 26, b2 = (a - d2) / 26, _2 = 67108863 >>> 26 - d2 << 26 - d2, v;
      if (d2 !== 0) {
        var u = 0;
        for (v = 0; v < this.length; v++) {
          var E2 = this.words[v] & _2, B = (this.words[v] | 0) - E2 << d2;
          this.words[v] = B | u, u = E2 >>> 26 - d2;
        }
        u && (this.words[v] = u, this.length++);
      }
      if (b2 !== 0) {
        for (v = this.length - 1; v >= 0; v--)
          this.words[v + b2] = this.words[v];
        for (v = 0; v < b2; v++)
          this.words[v] = 0;
        this.length += b2;
      }
      return this._strip();
    }, n.prototype.ishln = function(a) {
      return r(this.negative === 0), this.iushln(a);
    }, n.prototype.iushrn = function(a, d2, b2) {
      r(typeof a == "number" && a >= 0);
      var _2;
      d2 ? _2 = (d2 - d2 % 26) / 26 : _2 = 0;
      var v = a % 26, u = Math.min((a - v) / 26, this.length), E2 = 67108863 ^ 67108863 >>> v << v, B = b2;
      if (_2 -= u, _2 = Math.max(0, _2), B) {
        for (var y2 = 0; y2 < u; y2++)
          B.words[y2] = this.words[y2];
        B.length = u;
      }
      if (u !== 0)
        if (this.length > u)
          for (this.length -= u, y2 = 0; y2 < this.length; y2++)
            this.words[y2] = this.words[y2 + u];
        else
          this.words[0] = 0, this.length = 1;
      var M = 0;
      for (y2 = this.length - 1; y2 >= 0 && (M !== 0 || y2 >= _2); y2--) {
        var de2 = this.words[y2] | 0;
        this.words[y2] = M << 26 - v | de2 >>> v, M = de2 & E2;
      }
      return B && M !== 0 && (B.words[B.length++] = M), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, n.prototype.ishrn = function(a, d2, b2) {
      return r(this.negative === 0), this.iushrn(a, d2, b2);
    }, n.prototype.shln = function(a) {
      return this.clone().ishln(a);
    }, n.prototype.ushln = function(a) {
      return this.clone().iushln(a);
    }, n.prototype.shrn = function(a) {
      return this.clone().ishrn(a);
    }, n.prototype.ushrn = function(a) {
      return this.clone().iushrn(a);
    }, n.prototype.testn = function(a) {
      r(typeof a == "number" && a >= 0);
      var d2 = a % 26, b2 = (a - d2) / 26, _2 = 1 << d2;
      if (this.length <= b2)
        return false;
      var v = this.words[b2];
      return !!(v & _2);
    }, n.prototype.imaskn = function(a) {
      r(typeof a == "number" && a >= 0);
      var d2 = a % 26, b2 = (a - d2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= b2)
        return this;
      if (d2 !== 0 && b2++, this.length = Math.min(b2, this.length), d2 !== 0) {
        var _2 = 67108863 ^ 67108863 >>> d2 << d2;
        this.words[this.length - 1] &= _2;
      }
      return this._strip();
    }, n.prototype.maskn = function(a) {
      return this.clone().imaskn(a);
    }, n.prototype.iaddn = function(a) {
      return r(typeof a == "number"), r(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
    }, n.prototype._iaddn = function(a) {
      this.words[0] += a;
      for (var d2 = 0; d2 < this.length && this.words[d2] >= 67108864; d2++)
        this.words[d2] -= 67108864, d2 === this.length - 1 ? this.words[d2 + 1] = 1 : this.words[d2 + 1]++;
      return this.length = Math.max(this.length, d2 + 1), this;
    }, n.prototype.isubn = function(a) {
      if (r(typeof a == "number"), r(a < 67108864), a < 0)
        return this.iaddn(-a);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(a), this.negative = 1, this;
      if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var d2 = 0; d2 < this.length && this.words[d2] < 0; d2++)
          this.words[d2] += 67108864, this.words[d2 + 1] -= 1;
      return this._strip();
    }, n.prototype.addn = function(a) {
      return this.clone().iaddn(a);
    }, n.prototype.subn = function(a) {
      return this.clone().isubn(a);
    }, n.prototype.iabs = function() {
      return this.negative = 0, this;
    }, n.prototype.abs = function() {
      return this.clone().iabs();
    }, n.prototype._ishlnsubmul = function(a, d2, b2) {
      var _2 = a.length + b2, v;
      this._expand(_2);
      var u, E2 = 0;
      for (v = 0; v < a.length; v++) {
        u = (this.words[v + b2] | 0) + E2;
        var B = (a.words[v] | 0) * d2;
        u -= B & 67108863, E2 = (u >> 26) - (B / 67108864 | 0), this.words[v + b2] = u & 67108863;
      }
      for (; v < this.length - b2; v++)
        u = (this.words[v + b2] | 0) + E2, E2 = u >> 26, this.words[v + b2] = u & 67108863;
      if (E2 === 0)
        return this._strip();
      for (r(E2 === -1), E2 = 0, v = 0; v < this.length; v++)
        u = -(this.words[v] | 0) + E2, E2 = u >> 26, this.words[v] = u & 67108863;
      return this.negative = 1, this._strip();
    }, n.prototype._wordDiv = function(a, d2) {
      var b2 = this.length - a.length, _2 = this.clone(), v = a, u = v.words[v.length - 1] | 0, E2 = this._countBits(u);
      b2 = 26 - E2, b2 !== 0 && (v = v.ushln(b2), _2.iushln(b2), u = v.words[v.length - 1] | 0);
      var B = _2.length - v.length, y2;
      if (d2 !== "mod") {
        y2 = new n(null), y2.length = B + 1, y2.words = new Array(y2.length);
        for (var M = 0; M < y2.length; M++)
          y2.words[M] = 0;
      }
      var de2 = _2.clone()._ishlnsubmul(v, 1, B);
      de2.negative === 0 && (_2 = de2, y2 && (y2.words[B] = 1));
      for (var Ee = B - 1; Ee >= 0; Ee--) {
        var Me = (_2.words[v.length + Ee] | 0) * 67108864 + (_2.words[v.length + Ee - 1] | 0);
        for (Me = Math.min(Me / u | 0, 67108863), _2._ishlnsubmul(v, Me, Ee); _2.negative !== 0; )
          Me--, _2.negative = 0, _2._ishlnsubmul(v, 1, Ee), _2.isZero() || (_2.negative ^= 1);
        y2 && (y2.words[Ee] = Me);
      }
      return y2 && y2._strip(), _2._strip(), d2 !== "div" && b2 !== 0 && _2.iushrn(b2), { div: y2 || null, mod: _2 };
    }, n.prototype.divmod = function(a, d2, b2) {
      if (r(!a.isZero()), this.isZero())
        return { div: new n(0), mod: new n(0) };
      var _2, v, u;
      return this.negative !== 0 && a.negative === 0 ? (u = this.neg().divmod(a, d2), d2 !== "mod" && (_2 = u.div.neg()), d2 !== "div" && (v = u.mod.neg(), b2 && v.negative !== 0 && v.iadd(a)), { div: _2, mod: v }) : this.negative === 0 && a.negative !== 0 ? (u = this.divmod(a.neg(), d2), d2 !== "mod" && (_2 = u.div.neg()), { div: _2, mod: u.mod }) : (this.negative & a.negative) !== 0 ? (u = this.neg().divmod(a.neg(), d2), d2 !== "div" && (v = u.mod.neg(), b2 && v.negative !== 0 && v.isub(a)), { div: u.div, mod: v }) : a.length > this.length || this.cmp(a) < 0 ? { div: new n(0), mod: this } : a.length === 1 ? d2 === "div" ? { div: this.divn(a.words[0]), mod: null } : d2 === "mod" ? { div: null, mod: new n(this.modrn(a.words[0])) } : { div: this.divn(a.words[0]), mod: new n(this.modrn(a.words[0])) } : this._wordDiv(a, d2);
    }, n.prototype.div = function(a) {
      return this.divmod(a, "div", false).div;
    }, n.prototype.mod = function(a) {
      return this.divmod(a, "mod", false).mod;
    }, n.prototype.umod = function(a) {
      return this.divmod(a, "mod", true).mod;
    }, n.prototype.divRound = function(a) {
      var d2 = this.divmod(a);
      if (d2.mod.isZero())
        return d2.div;
      var b2 = d2.div.negative !== 0 ? d2.mod.isub(a) : d2.mod, _2 = a.ushrn(1), v = a.andln(1), u = b2.cmp(_2);
      return u < 0 || v === 1 && u === 0 ? d2.div : d2.div.negative !== 0 ? d2.div.isubn(1) : d2.div.iaddn(1);
    }, n.prototype.modrn = function(a) {
      var d2 = a < 0;
      d2 && (a = -a), r(a <= 67108863);
      for (var b2 = (1 << 26) % a, _2 = 0, v = this.length - 1; v >= 0; v--)
        _2 = (b2 * _2 + (this.words[v] | 0)) % a;
      return d2 ? -_2 : _2;
    }, n.prototype.modn = function(a) {
      return this.modrn(a);
    }, n.prototype.idivn = function(a) {
      var d2 = a < 0;
      d2 && (a = -a), r(a <= 67108863);
      for (var b2 = 0, _2 = this.length - 1; _2 >= 0; _2--) {
        var v = (this.words[_2] | 0) + b2 * 67108864;
        this.words[_2] = v / a | 0, b2 = v % a;
      }
      return this._strip(), d2 ? this.ineg() : this;
    }, n.prototype.divn = function(a) {
      return this.clone().idivn(a);
    }, n.prototype.egcd = function(a) {
      r(a.negative === 0), r(!a.isZero());
      var d2 = this, b2 = a.clone();
      d2.negative !== 0 ? d2 = d2.umod(a) : d2 = d2.clone();
      for (var _2 = new n(1), v = new n(0), u = new n(0), E2 = new n(1), B = 0; d2.isEven() && b2.isEven(); )
        d2.iushrn(1), b2.iushrn(1), ++B;
      for (var y2 = b2.clone(), M = d2.clone(); !d2.isZero(); ) {
        for (var de2 = 0, Ee = 1; (d2.words[0] & Ee) === 0 && de2 < 26; ++de2, Ee <<= 1)
          ;
        if (de2 > 0)
          for (d2.iushrn(de2); de2-- > 0; )
            (_2.isOdd() || v.isOdd()) && (_2.iadd(y2), v.isub(M)), _2.iushrn(1), v.iushrn(1);
        for (var Me = 0, Oe = 1; (b2.words[0] & Oe) === 0 && Me < 26; ++Me, Oe <<= 1)
          ;
        if (Me > 0)
          for (b2.iushrn(Me); Me-- > 0; )
            (u.isOdd() || E2.isOdd()) && (u.iadd(y2), E2.isub(M)), u.iushrn(1), E2.iushrn(1);
        d2.cmp(b2) >= 0 ? (d2.isub(b2), _2.isub(u), v.isub(E2)) : (b2.isub(d2), u.isub(_2), E2.isub(v));
      }
      return { a: u, b: E2, gcd: b2.iushln(B) };
    }, n.prototype._invmp = function(a) {
      r(a.negative === 0), r(!a.isZero());
      var d2 = this, b2 = a.clone();
      d2.negative !== 0 ? d2 = d2.umod(a) : d2 = d2.clone();
      for (var _2 = new n(1), v = new n(0), u = b2.clone(); d2.cmpn(1) > 0 && b2.cmpn(1) > 0; ) {
        for (var E2 = 0, B = 1; (d2.words[0] & B) === 0 && E2 < 26; ++E2, B <<= 1)
          ;
        if (E2 > 0)
          for (d2.iushrn(E2); E2-- > 0; )
            _2.isOdd() && _2.iadd(u), _2.iushrn(1);
        for (var y2 = 0, M = 1; (b2.words[0] & M) === 0 && y2 < 26; ++y2, M <<= 1)
          ;
        if (y2 > 0)
          for (b2.iushrn(y2); y2-- > 0; )
            v.isOdd() && v.iadd(u), v.iushrn(1);
        d2.cmp(b2) >= 0 ? (d2.isub(b2), _2.isub(v)) : (b2.isub(d2), v.isub(_2));
      }
      var de2;
      return d2.cmpn(1) === 0 ? de2 = _2 : de2 = v, de2.cmpn(0) < 0 && de2.iadd(a), de2;
    }, n.prototype.gcd = function(a) {
      if (this.isZero())
        return a.abs();
      if (a.isZero())
        return this.abs();
      var d2 = this.clone(), b2 = a.clone();
      d2.negative = 0, b2.negative = 0;
      for (var _2 = 0; d2.isEven() && b2.isEven(); _2++)
        d2.iushrn(1), b2.iushrn(1);
      do {
        for (; d2.isEven(); )
          d2.iushrn(1);
        for (; b2.isEven(); )
          b2.iushrn(1);
        var v = d2.cmp(b2);
        if (v < 0) {
          var u = d2;
          d2 = b2, b2 = u;
        } else if (v === 0 || b2.cmpn(1) === 0)
          break;
        d2.isub(b2);
      } while (true);
      return b2.iushln(_2);
    }, n.prototype.invm = function(a) {
      return this.egcd(a).a.umod(a);
    }, n.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, n.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, n.prototype.andln = function(a) {
      return this.words[0] & a;
    }, n.prototype.bincn = function(a) {
      r(typeof a == "number");
      var d2 = a % 26, b2 = (a - d2) / 26, _2 = 1 << d2;
      if (this.length <= b2)
        return this._expand(b2 + 1), this.words[b2] |= _2, this;
      for (var v = _2, u = b2; v !== 0 && u < this.length; u++) {
        var E2 = this.words[u] | 0;
        E2 += v, v = E2 >>> 26, E2 &= 67108863, this.words[u] = E2;
      }
      return v !== 0 && (this.words[u] = v, this.length++), this;
    }, n.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, n.prototype.cmpn = function(a) {
      var d2 = a < 0;
      if (this.negative !== 0 && !d2)
        return -1;
      if (this.negative === 0 && d2)
        return 1;
      this._strip();
      var b2;
      if (this.length > 1)
        b2 = 1;
      else {
        d2 && (a = -a), r(a <= 67108863, "Number is too big");
        var _2 = this.words[0] | 0;
        b2 = _2 === a ? 0 : _2 < a ? -1 : 1;
      }
      return this.negative !== 0 ? -b2 | 0 : b2;
    }, n.prototype.cmp = function(a) {
      if (this.negative !== 0 && a.negative === 0)
        return -1;
      if (this.negative === 0 && a.negative !== 0)
        return 1;
      var d2 = this.ucmp(a);
      return this.negative !== 0 ? -d2 | 0 : d2;
    }, n.prototype.ucmp = function(a) {
      if (this.length > a.length)
        return 1;
      if (this.length < a.length)
        return -1;
      for (var d2 = 0, b2 = this.length - 1; b2 >= 0; b2--) {
        var _2 = this.words[b2] | 0, v = a.words[b2] | 0;
        if (_2 !== v) {
          _2 < v ? d2 = -1 : _2 > v && (d2 = 1);
          break;
        }
      }
      return d2;
    }, n.prototype.gtn = function(a) {
      return this.cmpn(a) === 1;
    }, n.prototype.gt = function(a) {
      return this.cmp(a) === 1;
    }, n.prototype.gten = function(a) {
      return this.cmpn(a) >= 0;
    }, n.prototype.gte = function(a) {
      return this.cmp(a) >= 0;
    }, n.prototype.ltn = function(a) {
      return this.cmpn(a) === -1;
    }, n.prototype.lt = function(a) {
      return this.cmp(a) === -1;
    }, n.prototype.lten = function(a) {
      return this.cmpn(a) <= 0;
    }, n.prototype.lte = function(a) {
      return this.cmp(a) <= 0;
    }, n.prototype.eqn = function(a) {
      return this.cmpn(a) === 0;
    }, n.prototype.eq = function(a) {
      return this.cmp(a) === 0;
    }, n.red = function(a) {
      return new c2(a);
    }, n.prototype.toRed = function(a) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
    }, n.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, n.prototype._forceRed = function(a) {
      return this.red = a, this;
    }, n.prototype.forceRed = function(a) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(a);
    }, n.prototype.redAdd = function(a) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
    }, n.prototype.redIAdd = function(a) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
    }, n.prototype.redSub = function(a) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
    }, n.prototype.redISub = function(a) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
    }, n.prototype.redShl = function(a) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
    }, n.prototype.redMul = function(a) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
    }, n.prototype.redIMul = function(a) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
    }, n.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, n.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, n.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, n.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, n.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, n.prototype.redPow = function(a) {
      return r(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
    };
    var pe2 = { k256: null, p224: null, p192: null, p25519: null };
    function H2(h2, a) {
      this.name = h2, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    H2.prototype._tmp = function() {
      var a = new n(null);
      return a.words = new Array(Math.ceil(this.n / 13)), a;
    }, H2.prototype.ireduce = function(a) {
      var d2 = a, b2;
      do
        this.split(d2, this.tmp), d2 = this.imulK(d2), d2 = d2.iadd(this.tmp), b2 = d2.bitLength();
      while (b2 > this.n);
      var _2 = b2 < this.n ? -1 : d2.ucmp(this.p);
      return _2 === 0 ? (d2.words[0] = 0, d2.length = 1) : _2 > 0 ? d2.isub(this.p) : d2.strip !== void 0 ? d2.strip() : d2._strip(), d2;
    }, H2.prototype.split = function(a, d2) {
      a.iushrn(this.n, 0, d2);
    }, H2.prototype.imulK = function(a) {
      return a.imul(this.k);
    };
    function le() {
      H2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    i(le, H2), le.prototype.split = function(a, d2) {
      for (var b2 = 4194303, _2 = Math.min(a.length, 9), v = 0; v < _2; v++)
        d2.words[v] = a.words[v];
      if (d2.length = _2, a.length <= 9) {
        a.words[0] = 0, a.length = 1;
        return;
      }
      var u = a.words[9];
      for (d2.words[d2.length++] = u & b2, v = 10; v < a.length; v++) {
        var E2 = a.words[v] | 0;
        a.words[v - 10] = (E2 & b2) << 4 | u >>> 22, u = E2;
      }
      u >>>= 22, a.words[v - 10] = u, u === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
    }, le.prototype.imulK = function(a) {
      a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
      for (var d2 = 0, b2 = 0; b2 < a.length; b2++) {
        var _2 = a.words[b2] | 0;
        d2 += _2 * 977, a.words[b2] = d2 & 67108863, d2 = _2 * 64 + (d2 / 67108864 | 0);
      }
      return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
    };
    function ie() {
      H2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    i(ie, H2);
    function se() {
      H2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    i(se, H2);
    function N3() {
      H2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    i(N3, H2), N3.prototype.imulK = function(a) {
      for (var d2 = 0, b2 = 0; b2 < a.length; b2++) {
        var _2 = (a.words[b2] | 0) * 19 + d2, v = _2 & 67108863;
        _2 >>>= 26, a.words[b2] = v, d2 = _2;
      }
      return d2 !== 0 && (a.words[a.length++] = d2), a;
    }, n._prime = function(a) {
      if (pe2[a])
        return pe2[a];
      var d2;
      if (a === "k256")
        d2 = new le();
      else if (a === "p224")
        d2 = new ie();
      else if (a === "p192")
        d2 = new se();
      else if (a === "p25519")
        d2 = new N3();
      else
        throw new Error("Unknown prime " + a);
      return pe2[a] = d2, d2;
    };
    function c2(h2) {
      if (typeof h2 == "string") {
        var a = n._prime(h2);
        this.m = a.p, this.prime = a;
      } else
        r(h2.gtn(1), "modulus must be greater than 1"), this.m = h2, this.prime = null;
    }
    c2.prototype._verify1 = function(a) {
      r(a.negative === 0, "red works only with positives"), r(a.red, "red works only with red numbers");
    }, c2.prototype._verify2 = function(a, d2) {
      r((a.negative | d2.negative) === 0, "red works only with positives"), r(a.red && a.red === d2.red, "red works only with red numbers");
    }, c2.prototype.imod = function(a) {
      return this.prime ? this.prime.ireduce(a)._forceRed(this) : (m3(a, a.umod(this.m)._forceRed(this)), a);
    }, c2.prototype.neg = function(a) {
      return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
    }, c2.prototype.add = function(a, d2) {
      this._verify2(a, d2);
      var b2 = a.add(d2);
      return b2.cmp(this.m) >= 0 && b2.isub(this.m), b2._forceRed(this);
    }, c2.prototype.iadd = function(a, d2) {
      this._verify2(a, d2);
      var b2 = a.iadd(d2);
      return b2.cmp(this.m) >= 0 && b2.isub(this.m), b2;
    }, c2.prototype.sub = function(a, d2) {
      this._verify2(a, d2);
      var b2 = a.sub(d2);
      return b2.cmpn(0) < 0 && b2.iadd(this.m), b2._forceRed(this);
    }, c2.prototype.isub = function(a, d2) {
      this._verify2(a, d2);
      var b2 = a.isub(d2);
      return b2.cmpn(0) < 0 && b2.iadd(this.m), b2;
    }, c2.prototype.shl = function(a, d2) {
      return this._verify1(a), this.imod(a.ushln(d2));
    }, c2.prototype.imul = function(a, d2) {
      return this._verify2(a, d2), this.imod(a.imul(d2));
    }, c2.prototype.mul = function(a, d2) {
      return this._verify2(a, d2), this.imod(a.mul(d2));
    }, c2.prototype.isqr = function(a) {
      return this.imul(a, a.clone());
    }, c2.prototype.sqr = function(a) {
      return this.mul(a, a);
    }, c2.prototype.sqrt = function(a) {
      if (a.isZero())
        return a.clone();
      var d2 = this.m.andln(3);
      if (r(d2 % 2 === 1), d2 === 3) {
        var b2 = this.m.add(new n(1)).iushrn(2);
        return this.pow(a, b2);
      }
      for (var _2 = this.m.subn(1), v = 0; !_2.isZero() && _2.andln(1) === 0; )
        v++, _2.iushrn(1);
      r(!_2.isZero());
      var u = new n(1).toRed(this), E2 = u.redNeg(), B = this.m.subn(1).iushrn(1), y2 = this.m.bitLength();
      for (y2 = new n(2 * y2 * y2).toRed(this); this.pow(y2, B).cmp(E2) !== 0; )
        y2.redIAdd(E2);
      for (var M = this.pow(y2, _2), de2 = this.pow(a, _2.addn(1).iushrn(1)), Ee = this.pow(a, _2), Me = v; Ee.cmp(u) !== 0; ) {
        for (var Oe = Ee, be = 0; Oe.cmp(u) !== 0; be++)
          Oe = Oe.redSqr();
        r(be < Me);
        var I = this.pow(M, new n(1).iushln(Me - be - 1));
        de2 = de2.redMul(I), M = I.redSqr(), Ee = Ee.redMul(M), Me = be;
      }
      return de2;
    }, c2.prototype.invm = function(a) {
      var d2 = a._invmp(this.m);
      return d2.negative !== 0 ? (d2.negative = 0, this.imod(d2).redNeg()) : this.imod(d2);
    }, c2.prototype.pow = function(a, d2) {
      if (d2.isZero())
        return new n(1).toRed(this);
      if (d2.cmpn(1) === 0)
        return a.clone();
      var b2 = 4, _2 = new Array(1 << b2);
      _2[0] = new n(1).toRed(this), _2[1] = a;
      for (var v = 2; v < _2.length; v++)
        _2[v] = this.mul(_2[v - 1], a);
      var u = _2[0], E2 = 0, B = 0, y2 = d2.bitLength() % 26;
      for (y2 === 0 && (y2 = 26), v = d2.length - 1; v >= 0; v--) {
        for (var M = d2.words[v], de2 = y2 - 1; de2 >= 0; de2--) {
          var Ee = M >> de2 & 1;
          if (u !== _2[0] && (u = this.sqr(u)), Ee === 0 && E2 === 0) {
            B = 0;
            continue;
          }
          E2 <<= 1, E2 |= Ee, B++, !(B !== b2 && (v !== 0 || de2 !== 0)) && (u = this.mul(u, _2[E2]), B = 0, E2 = 0);
        }
        y2 = 26;
      }
      return u;
    }, c2.prototype.convertTo = function(a) {
      var d2 = a.umod(this.m);
      return d2 === a ? d2.clone() : d2;
    }, c2.prototype.convertFrom = function(a) {
      var d2 = a.clone();
      return d2.red = null, d2;
    }, n.mont = function(a) {
      return new p2(a);
    };
    function p2(h2) {
      c2.call(this, h2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(p2, c2), p2.prototype.convertTo = function(a) {
      return this.imod(a.ushln(this.shift));
    }, p2.prototype.convertFrom = function(a) {
      var d2 = this.imod(a.mul(this.rinv));
      return d2.red = null, d2;
    }, p2.prototype.imul = function(a, d2) {
      if (a.isZero() || d2.isZero())
        return a.words[0] = 0, a.length = 1, a;
      var b2 = a.imul(d2), _2 = b2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = b2.isub(_2).iushrn(this.shift), u = v;
      return v.cmp(this.m) >= 0 ? u = v.isub(this.m) : v.cmpn(0) < 0 && (u = v.iadd(this.m)), u._forceRed(this);
    }, p2.prototype.mul = function(a, d2) {
      if (a.isZero() || d2.isZero())
        return new n(0)._forceRed(this);
      var b2 = a.mul(d2), _2 = b2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = b2.isub(_2).iushrn(this.shift), u = v;
      return v.cmp(this.m) >= 0 ? u = v.isub(this.m) : v.cmpn(0) < 0 && (u = v.iadd(this.m)), u._forceRed(this);
    }, p2.prototype.invm = function(a) {
      var d2 = this.imod(a._invmp(this.m).mul(this.r2));
      return d2._forceRed(this);
    };
  })(typeof I1 > "u" || I1, jw);
});
var Zl = k(($B, Pw) => {
  U();
  var ea = Jl(), KS = bs();
  function WS(t) {
    var e = Lw(t), r = e.toRed(ea.mont(t.modulus)).redPow(new ea(t.publicExponent)).fromRed();
    return { blinder: r, unblinder: e.invm(t.modulus) };
  }
  function Lw(t) {
    var e = t.modulus.byteLength(), r;
    do
      r = new ea(KS(e));
    while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
    return r;
  }
  function qw(t, e) {
    var r = WS(e), i = e.modulus.byteLength(), n = new ea(t).mul(r.blinder).umod(e.modulus), s2 = n.toRed(ea.mont(e.prime1)), o = n.toRed(ea.mont(e.prime2)), f = e.coefficient, l = e.prime1, m3 = e.prime2, A2 = s2.redPow(e.exponent1).fromRed(), F3 = o.redPow(e.exponent2).fromRed(), z3 = A2.isub(F3).imul(f).umod(l).imul(m3);
    return F3.iadd(z3).imul(r.unblinder).umod(e.modulus).toArrayLike(b.Buffer, "be", i);
  }
  qw.getr = Lw;
  Pw.exports = qw;
});
var Uw = k((GB, VS) => {
  VS.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
});
var T1 = k(($w) => {
  U();
  var Xl = $w;
  function YS(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t != "string") {
      for (var i = 0; i < t.length; i++)
        r[i] = t[i] | 0;
      return r;
    }
    if (e === "hex") {
      t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
      for (var i = 0; i < t.length; i += 2)
        r.push(parseInt(t[i] + t[i + 1], 16));
    } else
      for (var i = 0; i < t.length; i++) {
        var n = t.charCodeAt(i), s2 = n >> 8, o = n & 255;
        s2 ? r.push(s2, o) : r.push(o);
      }
    return r;
  }
  Xl.toArray = YS;
  function zw(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Xl.zero2 = zw;
  function Hw(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += zw(t[r].toString(16));
    return e;
  }
  Xl.toHex = Hw;
  Xl.encode = function(e, r) {
    return r === "hex" ? Hw(e) : e;
  };
});
var Kr = k((Gw) => {
  U();
  var Ei = Gw, JS = lr(), ZS = Gr(), Ql = T1();
  Ei.assert = ZS;
  Ei.toArray = Ql.toArray;
  Ei.zero2 = Ql.zero2;
  Ei.toHex = Ql.toHex;
  Ei.encode = Ql.encode;
  function XS(t, e, r) {
    var i = new Array(Math.max(t.bitLength(), r) + 1);
    i.fill(0);
    for (var n = 1 << e + 1, s2 = t.clone(), o = 0; o < i.length; o++) {
      var f, l = s2.andln(n - 1);
      s2.isOdd() ? (l > (n >> 1) - 1 ? f = (n >> 1) - l : f = l, s2.isubn(f)) : f = 0, i[o] = f, s2.iushrn(1);
    }
    return i;
  }
  Ei.getNAF = XS;
  function QS(t, e) {
    var r = [[], []];
    t = t.clone(), e = e.clone();
    for (var i = 0, n = 0, s2; t.cmpn(-i) > 0 || e.cmpn(-n) > 0; ) {
      var o = t.andln(3) + i & 3, f = e.andln(3) + n & 3;
      o === 3 && (o = -1), f === 3 && (f = -1);
      var l;
      (o & 1) === 0 ? l = 0 : (s2 = t.andln(7) + i & 7, (s2 === 3 || s2 === 5) && f === 2 ? l = -o : l = o), r[0].push(l);
      var m3;
      (f & 1) === 0 ? m3 = 0 : (s2 = e.andln(7) + n & 7, (s2 === 3 || s2 === 5) && o === 2 ? m3 = -f : m3 = f), r[1].push(m3), 2 * i === l + 1 && (i = 1 - i), 2 * n === m3 + 1 && (n = 1 - n), t.iushrn(1), e.iushrn(1);
    }
    return r;
  }
  Ei.getJSF = QS;
  function eM(t, e, r) {
    var i = "_" + e;
    t.prototype[e] = function() {
      return this[i] !== void 0 ? this[i] : this[i] = r.call(this);
    };
  }
  Ei.cachedProperty = eM;
  function tM(t) {
    return typeof t == "string" ? Ei.toArray(t, "hex") : t;
  }
  Ei.parseBytes = tM;
  function rM(t) {
    return new JS(t, "hex", "le");
  }
  Ei.intFromLE = rM;
});
var pc = k((VB, Kw) => {
  U();
  var qs = lr(), hc = Kr(), eh = hc.getNAF, iM = hc.getJSF, th = hc.assert;
  function $n(t, e) {
    this.type = t, this.p = new qs(e.p, 16), this.red = e.prime ? qs.red(e.prime) : qs.mont(this.p), this.zero = new qs(0).toRed(this.red), this.one = new qs(1).toRed(this.red), this.two = new qs(2).toRed(this.red), this.n = e.n && new qs(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  Kw.exports = $n;
  $n.prototype.point = function() {
    throw new Error("Not implemented");
  };
  $n.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  $n.prototype._fixedNafMul = function(e, r) {
    th(e.precomputed);
    var i = e._getDoubles(), n = eh(r, 1, this._bitLength), s2 = (1 << i.step + 1) - (i.step % 2 === 0 ? 2 : 1);
    s2 /= 3;
    var o = [], f, l;
    for (f = 0; f < n.length; f += i.step) {
      l = 0;
      for (var m3 = f + i.step - 1; m3 >= f; m3--)
        l = (l << 1) + n[m3];
      o.push(l);
    }
    for (var A2 = this.jpoint(null, null, null), F3 = this.jpoint(null, null, null), z3 = s2; z3 > 0; z3--) {
      for (f = 0; f < o.length; f++)
        l = o[f], l === z3 ? F3 = F3.mixedAdd(i.points[f]) : l === -z3 && (F3 = F3.mixedAdd(i.points[f].neg()));
      A2 = A2.add(F3);
    }
    return A2.toP();
  };
  $n.prototype._wnafMul = function(e, r) {
    var i = 4, n = e._getNAFPoints(i);
    i = n.wnd;
    for (var s2 = n.points, o = eh(r, i, this._bitLength), f = this.jpoint(null, null, null), l = o.length - 1; l >= 0; l--) {
      for (var m3 = 0; l >= 0 && o[l] === 0; l--)
        m3++;
      if (l >= 0 && m3++, f = f.dblp(m3), l < 0)
        break;
      var A2 = o[l];
      th(A2 !== 0), e.type === "affine" ? A2 > 0 ? f = f.mixedAdd(s2[A2 - 1 >> 1]) : f = f.mixedAdd(s2[-A2 - 1 >> 1].neg()) : A2 > 0 ? f = f.add(s2[A2 - 1 >> 1]) : f = f.add(s2[-A2 - 1 >> 1].neg());
    }
    return e.type === "affine" ? f.toP() : f;
  };
  $n.prototype._wnafMulAdd = function(e, r, i, n, s2) {
    var o = this._wnafT1, f = this._wnafT2, l = this._wnafT3, m3 = 0, A2, F3, z3;
    for (A2 = 0; A2 < n; A2++) {
      z3 = r[A2];
      var V = z3._getNAFPoints(e);
      o[A2] = V.wnd, f[A2] = V.points;
    }
    for (A2 = n - 1; A2 >= 1; A2 -= 2) {
      var $ = A2 - 1, re = A2;
      if (o[$] !== 1 || o[re] !== 1) {
        l[$] = eh(i[$], o[$], this._bitLength), l[re] = eh(i[re], o[re], this._bitLength), m3 = Math.max(l[$].length, m3), m3 = Math.max(l[re].length, m3);
        continue;
      }
      var W2 = [r[$], null, null, r[re]];
      r[$].y.cmp(r[re].y) === 0 ? (W2[1] = r[$].add(r[re]), W2[2] = r[$].toJ().mixedAdd(r[re].neg())) : r[$].y.cmp(r[re].y.redNeg()) === 0 ? (W2[1] = r[$].toJ().mixedAdd(r[re]), W2[2] = r[$].add(r[re].neg())) : (W2[1] = r[$].toJ().mixedAdd(r[re]), W2[2] = r[$].toJ().mixedAdd(r[re].neg()));
      var Z2 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], ue = iM(i[$], i[re]);
      for (m3 = Math.max(ue[0].length, m3), l[$] = new Array(m3), l[re] = new Array(m3), F3 = 0; F3 < m3; F3++) {
        var ge = ue[0][F3] | 0, Se = ue[1][F3] | 0;
        l[$][F3] = Z2[(ge + 1) * 3 + (Se + 1)], l[re][F3] = 0, f[$] = W2;
      }
    }
    var pe2 = this.jpoint(null, null, null), H2 = this._wnafT4;
    for (A2 = m3; A2 >= 0; A2--) {
      for (var le = 0; A2 >= 0; ) {
        var ie = true;
        for (F3 = 0; F3 < n; F3++)
          H2[F3] = l[F3][A2] | 0, H2[F3] !== 0 && (ie = false);
        if (!ie)
          break;
        le++, A2--;
      }
      if (A2 >= 0 && le++, pe2 = pe2.dblp(le), A2 < 0)
        break;
      for (F3 = 0; F3 < n; F3++) {
        var se = H2[F3];
        se !== 0 && (se > 0 ? z3 = f[F3][se - 1 >> 1] : se < 0 && (z3 = f[F3][-se - 1 >> 1].neg()), z3.type === "affine" ? pe2 = pe2.mixedAdd(z3) : pe2 = pe2.add(z3));
      }
    }
    for (A2 = 0; A2 < n; A2++)
      f[A2] = null;
    return s2 ? pe2 : pe2.toP();
  };
  function si(t, e) {
    this.curve = t, this.type = e, this.precomputed = null;
  }
  $n.BasePoint = si;
  si.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  si.prototype.validate = function() {
    return this.curve.validate(this);
  };
  $n.prototype.decodePoint = function(e, r) {
    e = hc.toArray(e, r);
    var i = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * i) {
      e[0] === 6 ? th(e[e.length - 1] % 2 === 0) : e[0] === 7 && th(e[e.length - 1] % 2 === 1);
      var n = this.point(e.slice(1, 1 + i), e.slice(1 + i, 1 + 2 * i));
      return n;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i)
      return this.pointFromX(e.slice(1, 1 + i), e[0] === 3);
    throw new Error("Unknown point format");
  };
  si.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  si.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(), i = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray("be", r));
  };
  si.prototype.encode = function(e, r) {
    return hc.encode(this._encode(r), e);
  };
  si.prototype.precompute = function(e) {
    if (this.precomputed)
      return this;
    var r = { doubles: null, naf: null, beta: null };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
  };
  si.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
      return false;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
  };
  si.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var i = [this], n = this, s2 = 0; s2 < r; s2 += e) {
      for (var o = 0; o < e; o++)
        n = n.dbl();
      i.push(n);
    }
    return { step: e, points: i };
  };
  si.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var r = [this], i = (1 << e) - 1, n = i === 1 ? null : this.dbl(), s2 = 1; s2 < i; s2++)
      r[s2] = r[s2 - 1].add(n);
    return { wnd: e, points: r };
  };
  si.prototype._getBeta = function() {
    return null;
  };
  si.prototype.dblp = function(e) {
    for (var r = this, i = 0; i < e; i++)
      r = r.dbl();
    return r;
  };
});
var Vw = k((YB, Ww) => {
  U();
  var nM = Kr(), ar = lr(), F1 = At(), ta = pc(), sM = nM.assert;
  function oi(t) {
    ta.call(this, "short", t), this.a = new ar(t.a, 16).toRed(this.red), this.b = new ar(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  F1(oi, ta);
  Ww.exports = oi;
  oi.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var r, i;
      if (e.beta)
        r = new ar(e.beta, 16).toRed(this.red);
      else {
        var n = this._getEndoRoots(this.p);
        r = n[0].cmp(n[1]) < 0 ? n[0] : n[1], r = r.toRed(this.red);
      }
      if (e.lambda)
        i = new ar(e.lambda, 16);
      else {
        var s2 = this._getEndoRoots(this.n);
        this.g.mul(s2[0]).x.cmp(this.g.x.redMul(r)) === 0 ? i = s2[0] : (i = s2[1], sM(this.g.mul(i).x.cmp(this.g.x.redMul(r)) === 0));
      }
      var o;
      return e.basis ? o = e.basis.map(function(f) {
        return { a: new ar(f.a, 16), b: new ar(f.b, 16) };
      }) : o = this._getEndoBasis(i), { beta: r, lambda: i, basis: o };
    }
  };
  oi.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : ar.mont(e), i = new ar(2).toRed(r).redInvm(), n = i.redNeg(), s2 = new ar(3).toRed(r).redNeg().redSqrt().redMul(i), o = n.redAdd(s2).fromRed(), f = n.redSub(s2).fromRed();
    return [o, f];
  };
  oi.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, n = this.n.clone(), s2 = new ar(1), o = new ar(0), f = new ar(0), l = new ar(1), m3, A2, F3, z3, V, $, re, W2 = 0, Z2, ue; i.cmpn(0) !== 0; ) {
      var ge = n.div(i);
      Z2 = n.sub(ge.mul(i)), ue = f.sub(ge.mul(s2));
      var Se = l.sub(ge.mul(o));
      if (!F3 && Z2.cmp(r) < 0)
        m3 = re.neg(), A2 = s2, F3 = Z2.neg(), z3 = ue;
      else if (F3 && ++W2 === 2)
        break;
      re = Z2, n = i, i = Z2, f = s2, s2 = ue, l = o, o = Se;
    }
    V = Z2.neg(), $ = ue;
    var pe2 = F3.sqr().add(z3.sqr()), H2 = V.sqr().add($.sqr());
    return H2.cmp(pe2) >= 0 && (V = m3, $ = A2), F3.negative && (F3 = F3.neg(), z3 = z3.neg()), V.negative && (V = V.neg(), $ = $.neg()), [{ a: F3, b: z3 }, { a: V, b: $ }];
  };
  oi.prototype._endoSplit = function(e) {
    var r = this.endo.basis, i = r[0], n = r[1], s2 = n.b.mul(e).divRound(this.n), o = i.b.neg().mul(e).divRound(this.n), f = s2.mul(i.a), l = o.mul(n.a), m3 = s2.mul(i.b), A2 = o.mul(n.b), F3 = e.sub(f).sub(l), z3 = m3.add(A2).neg();
    return { k1: F3, k2: z3 };
  };
  oi.prototype.pointFromX = function(e, r) {
    e = new ar(e, 16), e.red || (e = e.toRed(this.red));
    var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), n = i.redSqrt();
    if (n.redSqr().redSub(i).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var s2 = n.fromRed().isOdd();
    return (r && !s2 || !r && s2) && (n = n.redNeg()), this.point(e, n);
  };
  oi.prototype.validate = function(e) {
    if (e.inf)
      return true;
    var r = e.x, i = e.y, n = this.a.redMul(r), s2 = r.redSqr().redMul(r).redIAdd(n).redIAdd(this.b);
    return i.redSqr().redISub(s2).cmpn(0) === 0;
  };
  oi.prototype._endoWnafMulAdd = function(e, r, i) {
    for (var n = this._endoWnafT1, s2 = this._endoWnafT2, o = 0; o < e.length; o++) {
      var f = this._endoSplit(r[o]), l = e[o], m3 = l._getBeta();
      f.k1.negative && (f.k1.ineg(), l = l.neg(true)), f.k2.negative && (f.k2.ineg(), m3 = m3.neg(true)), n[o * 2] = l, n[o * 2 + 1] = m3, s2[o * 2] = f.k1, s2[o * 2 + 1] = f.k2;
    }
    for (var A2 = this._wnafMulAdd(1, n, s2, o * 2, i), F3 = 0; F3 < o * 2; F3++)
      n[F3] = null, s2[F3] = null;
    return A2;
  };
  function yr(t, e, r, i) {
    ta.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new ar(e, 16), this.y = new ar(r, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  F1(yr, ta.BasePoint);
  oi.prototype.point = function(e, r, i) {
    return new yr(this, e, r, i);
  };
  oi.prototype.pointFromJSON = function(e, r) {
    return yr.fromJSON(this, e, r);
  };
  yr.prototype._getBeta = function() {
    if (!!this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta)
        return e.beta;
      var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var i = this.curve, n = function(s2) {
          return i.point(s2.x.redMul(i.endo.beta), s2.y);
        };
        e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(n) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(n) } };
      }
      return r;
    }
  };
  yr.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
  };
  yr.fromJSON = function(e, r, i) {
    typeof r == "string" && (r = JSON.parse(r));
    var n = e.point(r[0], r[1], i);
    if (!r[2])
      return n;
    function s2(f) {
      return e.point(f[0], f[1], i);
    }
    var o = r[2];
    return n.precomputed = { beta: null, doubles: o.doubles && { step: o.doubles.step, points: [n].concat(o.doubles.points.map(s2)) }, naf: o.naf && { wnd: o.naf.wnd, points: [n].concat(o.naf.points.map(s2)) } }, n;
  };
  yr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  yr.prototype.isInfinity = function() {
    return this.inf;
  };
  yr.prototype.add = function(e) {
    if (this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.eq(e))
      return this.dbl();
    if (this.neg().eq(e))
      return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
      return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var i = r.redSqr().redISub(this.x).redISub(e.x), n = r.redMul(this.x.redSub(i)).redISub(this.y);
    return this.curve.point(i, n);
  };
  yr.prototype.dbl = function() {
    if (this.inf)
      return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
      return this.curve.point(null, null);
    var r = this.curve.a, i = this.x.redSqr(), n = e.redInvm(), s2 = i.redAdd(i).redIAdd(i).redIAdd(r).redMul(n), o = s2.redSqr().redISub(this.x.redAdd(this.x)), f = s2.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, f);
  };
  yr.prototype.getX = function() {
    return this.x.fromRed();
  };
  yr.prototype.getY = function() {
    return this.y.fromRed();
  };
  yr.prototype.mul = function(e) {
    return e = new ar(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
  };
  yr.prototype.mulAdd = function(e, r, i) {
    var n = [this, r], s2 = [e, i];
    return this.curve.endo ? this.curve._endoWnafMulAdd(n, s2) : this.curve._wnafMulAdd(1, n, s2, 2);
  };
  yr.prototype.jmulAdd = function(e, r, i) {
    var n = [this, r], s2 = [e, i];
    return this.curve.endo ? this.curve._endoWnafMulAdd(n, s2, true) : this.curve._wnafMulAdd(1, n, s2, 2, true);
  };
  yr.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  yr.prototype.neg = function(e) {
    if (this.inf)
      return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var i = this.precomputed, n = function(s2) {
        return s2.neg();
      };
      r.precomputed = { naf: i.naf && { wnd: i.naf.wnd, points: i.naf.points.map(n) }, doubles: i.doubles && { step: i.doubles.step, points: i.doubles.points.map(n) } };
    }
    return r;
  };
  yr.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function xr(t, e, r, i) {
    ta.BasePoint.call(this, t, "jacobian"), e === null && r === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new ar(0)) : (this.x = new ar(e, 16), this.y = new ar(r, 16), this.z = new ar(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  F1(xr, ta.BasePoint);
  oi.prototype.jpoint = function(e, r, i) {
    return new xr(this, e, r, i);
  };
  xr.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var e = this.z.redInvm(), r = e.redSqr(), i = this.x.redMul(r), n = this.y.redMul(r).redMul(e);
    return this.curve.point(i, n);
  };
  xr.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  xr.prototype.add = function(e) {
    if (this.isInfinity())
      return e;
    if (e.isInfinity())
      return this;
    var r = e.z.redSqr(), i = this.z.redSqr(), n = this.x.redMul(r), s2 = e.x.redMul(i), o = this.y.redMul(r.redMul(e.z)), f = e.y.redMul(i.redMul(this.z)), l = n.redSub(s2), m3 = o.redSub(f);
    if (l.cmpn(0) === 0)
      return m3.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var A2 = l.redSqr(), F3 = A2.redMul(l), z3 = n.redMul(A2), V = m3.redSqr().redIAdd(F3).redISub(z3).redISub(z3), $ = m3.redMul(z3.redISub(V)).redISub(o.redMul(F3)), re = this.z.redMul(e.z).redMul(l);
    return this.curve.jpoint(V, $, re);
  };
  xr.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
      return e.toJ();
    if (e.isInfinity())
      return this;
    var r = this.z.redSqr(), i = this.x, n = e.x.redMul(r), s2 = this.y, o = e.y.redMul(r).redMul(this.z), f = i.redSub(n), l = s2.redSub(o);
    if (f.cmpn(0) === 0)
      return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var m3 = f.redSqr(), A2 = m3.redMul(f), F3 = i.redMul(m3), z3 = l.redSqr().redIAdd(A2).redISub(F3).redISub(F3), V = l.redMul(F3.redISub(z3)).redISub(s2.redMul(A2)), $ = this.z.redMul(f);
    return this.curve.jpoint(z3, V, $);
  };
  xr.prototype.dblp = function(e) {
    if (e === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!e)
      return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
      var i = this;
      for (r = 0; r < e; r++)
        i = i.dbl();
      return i;
    }
    var n = this.curve.a, s2 = this.curve.tinv, o = this.x, f = this.y, l = this.z, m3 = l.redSqr().redSqr(), A2 = f.redAdd(f);
    for (r = 0; r < e; r++) {
      var F3 = o.redSqr(), z3 = A2.redSqr(), V = z3.redSqr(), $ = F3.redAdd(F3).redIAdd(F3).redIAdd(n.redMul(m3)), re = o.redMul(z3), W2 = $.redSqr().redISub(re.redAdd(re)), Z2 = re.redISub(W2), ue = $.redMul(Z2);
      ue = ue.redIAdd(ue).redISub(V);
      var ge = A2.redMul(l);
      r + 1 < e && (m3 = m3.redMul(V)), o = W2, l = ge, A2 = ue;
    }
    return this.curve.jpoint(o, A2.redMul(s2), l);
  };
  xr.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  xr.prototype._zeroDbl = function() {
    var e, r, i;
    if (this.zOne) {
      var n = this.x.redSqr(), s2 = this.y.redSqr(), o = s2.redSqr(), f = this.x.redAdd(s2).redSqr().redISub(n).redISub(o);
      f = f.redIAdd(f);
      var l = n.redAdd(n).redIAdd(n), m3 = l.redSqr().redISub(f).redISub(f), A2 = o.redIAdd(o);
      A2 = A2.redIAdd(A2), A2 = A2.redIAdd(A2), e = m3, r = l.redMul(f.redISub(m3)).redISub(A2), i = this.y.redAdd(this.y);
    } else {
      var F3 = this.x.redSqr(), z3 = this.y.redSqr(), V = z3.redSqr(), $ = this.x.redAdd(z3).redSqr().redISub(F3).redISub(V);
      $ = $.redIAdd($);
      var re = F3.redAdd(F3).redIAdd(F3), W2 = re.redSqr(), Z2 = V.redIAdd(V);
      Z2 = Z2.redIAdd(Z2), Z2 = Z2.redIAdd(Z2), e = W2.redISub($).redISub($), r = re.redMul($.redISub(e)).redISub(Z2), i = this.y.redMul(this.z), i = i.redIAdd(i);
    }
    return this.curve.jpoint(e, r, i);
  };
  xr.prototype._threeDbl = function() {
    var e, r, i;
    if (this.zOne) {
      var n = this.x.redSqr(), s2 = this.y.redSqr(), o = s2.redSqr(), f = this.x.redAdd(s2).redSqr().redISub(n).redISub(o);
      f = f.redIAdd(f);
      var l = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a), m3 = l.redSqr().redISub(f).redISub(f);
      e = m3;
      var A2 = o.redIAdd(o);
      A2 = A2.redIAdd(A2), A2 = A2.redIAdd(A2), r = l.redMul(f.redISub(m3)).redISub(A2), i = this.y.redAdd(this.y);
    } else {
      var F3 = this.z.redSqr(), z3 = this.y.redSqr(), V = this.x.redMul(z3), $ = this.x.redSub(F3).redMul(this.x.redAdd(F3));
      $ = $.redAdd($).redIAdd($);
      var re = V.redIAdd(V);
      re = re.redIAdd(re);
      var W2 = re.redAdd(re);
      e = $.redSqr().redISub(W2), i = this.y.redAdd(this.z).redSqr().redISub(z3).redISub(F3);
      var Z2 = z3.redSqr();
      Z2 = Z2.redIAdd(Z2), Z2 = Z2.redIAdd(Z2), Z2 = Z2.redIAdd(Z2), r = $.redMul(re.redISub(e)).redISub(Z2);
    }
    return this.curve.jpoint(e, r, i);
  };
  xr.prototype._dbl = function() {
    var e = this.curve.a, r = this.x, i = this.y, n = this.z, s2 = n.redSqr().redSqr(), o = r.redSqr(), f = i.redSqr(), l = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s2)), m3 = r.redAdd(r);
    m3 = m3.redIAdd(m3);
    var A2 = m3.redMul(f), F3 = l.redSqr().redISub(A2.redAdd(A2)), z3 = A2.redISub(F3), V = f.redSqr();
    V = V.redIAdd(V), V = V.redIAdd(V), V = V.redIAdd(V);
    var $ = l.redMul(z3).redISub(V), re = i.redAdd(i).redMul(n);
    return this.curve.jpoint(F3, $, re);
  };
  xr.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var e = this.x.redSqr(), r = this.y.redSqr(), i = this.z.redSqr(), n = r.redSqr(), s2 = e.redAdd(e).redIAdd(e), o = s2.redSqr(), f = this.x.redAdd(r).redSqr().redISub(e).redISub(n);
    f = f.redIAdd(f), f = f.redAdd(f).redIAdd(f), f = f.redISub(o);
    var l = f.redSqr(), m3 = n.redIAdd(n);
    m3 = m3.redIAdd(m3), m3 = m3.redIAdd(m3), m3 = m3.redIAdd(m3);
    var A2 = s2.redIAdd(f).redSqr().redISub(o).redISub(l).redISub(m3), F3 = r.redMul(A2);
    F3 = F3.redIAdd(F3), F3 = F3.redIAdd(F3);
    var z3 = this.x.redMul(l).redISub(F3);
    z3 = z3.redIAdd(z3), z3 = z3.redIAdd(z3);
    var V = this.y.redMul(A2.redMul(m3.redISub(A2)).redISub(f.redMul(l)));
    V = V.redIAdd(V), V = V.redIAdd(V), V = V.redIAdd(V);
    var $ = this.z.redAdd(f).redSqr().redISub(i).redISub(l);
    return this.curve.jpoint(z3, V, $);
  };
  xr.prototype.mul = function(e, r) {
    return e = new ar(e, r), this.curve._wnafMul(this, e);
  };
  xr.prototype.eq = function(e) {
    if (e.type === "affine")
      return this.eq(e.toJ());
    if (this === e)
      return true;
    var r = this.z.redSqr(), i = e.z.redSqr();
    if (this.x.redMul(i).redISub(e.x.redMul(r)).cmpn(0) !== 0)
      return false;
    var n = r.redMul(this.z), s2 = i.redMul(e.z);
    return this.y.redMul(s2).redISub(e.y.redMul(n)).cmpn(0) === 0;
  };
  xr.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(i) === 0)
      return true;
    for (var n = e.clone(), s2 = this.curve.redN.redMul(r); ; ) {
      if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
        return false;
      if (i.redIAdd(s2), this.x.cmp(i) === 0)
        return true;
    }
  };
  xr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  xr.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
});
var Zw = k((JB, Jw) => {
  U();
  var ra = lr(), Yw = At(), rh = pc(), oM = Kr();
  function ia(t) {
    rh.call(this, "mont", t), this.a = new ra(t.a, 16).toRed(this.red), this.b = new ra(t.b, 16).toRed(this.red), this.i4 = new ra(4).toRed(this.red).redInvm(), this.two = new ra(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  Yw(ia, rh);
  Jw.exports = ia;
  ia.prototype.validate = function(e) {
    var r = e.normalize().x, i = r.redSqr(), n = i.redMul(r).redAdd(i.redMul(this.a)).redAdd(r), s2 = n.redSqrt();
    return s2.redSqr().cmp(n) === 0;
  };
  function br(t, e, r) {
    rh.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new ra(e, 16), this.z = new ra(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  Yw(br, rh.BasePoint);
  ia.prototype.decodePoint = function(e, r) {
    return this.point(oM.toArray(e, r), 1);
  };
  ia.prototype.point = function(e, r) {
    return new br(this, e, r);
  };
  ia.prototype.pointFromJSON = function(e) {
    return br.fromJSON(this, e);
  };
  br.prototype.precompute = function() {
  };
  br.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  br.fromJSON = function(e, r) {
    return new br(e, r[0], r[1] || e.one);
  };
  br.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  br.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  br.prototype.dbl = function() {
    var e = this.x.redAdd(this.z), r = e.redSqr(), i = this.x.redSub(this.z), n = i.redSqr(), s2 = r.redSub(n), o = r.redMul(n), f = s2.redMul(n.redAdd(this.curve.a24.redMul(s2)));
    return this.curve.point(o, f);
  };
  br.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  br.prototype.diffAdd = function(e, r) {
    var i = this.x.redAdd(this.z), n = this.x.redSub(this.z), s2 = e.x.redAdd(e.z), o = e.x.redSub(e.z), f = o.redMul(i), l = s2.redMul(n), m3 = r.z.redMul(f.redAdd(l).redSqr()), A2 = r.x.redMul(f.redISub(l).redSqr());
    return this.curve.point(m3, A2);
  };
  br.prototype.mul = function(e) {
    for (var r = e.clone(), i = this, n = this.curve.point(null, null), s2 = this, o = []; r.cmpn(0) !== 0; r.iushrn(1))
      o.push(r.andln(1));
    for (var f = o.length - 1; f >= 0; f--)
      o[f] === 0 ? (i = i.diffAdd(n, s2), n = n.dbl()) : (n = i.diffAdd(n, s2), i = i.dbl());
    return n;
  };
  br.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  br.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  br.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0;
  };
  br.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  br.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
});
var ex = k((ZB, Qw) => {
  U();
  var aM = Kr(), hn = lr(), Xw = At(), ih = pc(), fM = aM.assert;
  function Pi(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, ih.call(this, "edwards", t), this.a = new hn(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new hn(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new hn(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), fM(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
  }
  Xw(Pi, ih);
  Qw.exports = Pi;
  Pi.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e);
  };
  Pi.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e);
  };
  Pi.prototype.jpoint = function(e, r, i, n) {
    return this.point(e, r, i, n);
  };
  Pi.prototype.pointFromX = function(e, r) {
    e = new hn(e, 16), e.red || (e = e.toRed(this.red));
    var i = e.redSqr(), n = this.c2.redSub(this.a.redMul(i)), s2 = this.one.redSub(this.c2.redMul(this.d).redMul(i)), o = n.redMul(s2.redInvm()), f = o.redSqrt();
    if (f.redSqr().redSub(o).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var l = f.fromRed().isOdd();
    return (r && !l || !r && l) && (f = f.redNeg()), this.point(e, f);
  };
  Pi.prototype.pointFromY = function(e, r) {
    e = new hn(e, 16), e.red || (e = e.toRed(this.red));
    var i = e.redSqr(), n = i.redSub(this.c2), s2 = i.redMul(this.d).redMul(this.c2).redSub(this.a), o = n.redMul(s2.redInvm());
    if (o.cmp(this.zero) === 0) {
      if (r)
        throw new Error("invalid point");
      return this.point(this.zero, e);
    }
    var f = o.redSqrt();
    if (f.redSqr().redSub(o).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return f.fromRed().isOdd() !== r && (f = f.redNeg()), this.point(f, e);
  };
  Pi.prototype.validate = function(e) {
    if (e.isInfinity())
      return true;
    e.normalize();
    var r = e.x.redSqr(), i = e.y.redSqr(), n = r.redMul(this.a).redAdd(i), s2 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(i)));
    return n.cmp(s2) === 0;
  };
  function Qt(t, e, r, i, n) {
    ih.BasePoint.call(this, t, "projective"), e === null && r === null && i === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new hn(e, 16), this.y = new hn(r, 16), this.z = i ? new hn(i, 16) : this.curve.one, this.t = n && new hn(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  Xw(Qt, ih.BasePoint);
  Pi.prototype.pointFromJSON = function(e) {
    return Qt.fromJSON(this, e);
  };
  Pi.prototype.point = function(e, r, i, n) {
    return new Qt(this, e, r, i, n);
  };
  Qt.fromJSON = function(e, r) {
    return new Qt(e, r[0], r[1], r[2]);
  };
  Qt.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Qt.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Qt.prototype._extDbl = function() {
    var e = this.x.redSqr(), r = this.y.redSqr(), i = this.z.redSqr();
    i = i.redIAdd(i);
    var n = this.curve._mulA(e), s2 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), o = n.redAdd(r), f = o.redSub(i), l = n.redSub(r), m3 = s2.redMul(f), A2 = o.redMul(l), F3 = s2.redMul(l), z3 = f.redMul(o);
    return this.curve.point(m3, A2, z3, F3);
  };
  Qt.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), i = this.y.redSqr(), n, s2, o, f, l, m3;
    if (this.curve.twisted) {
      f = this.curve._mulA(r);
      var A2 = f.redAdd(i);
      this.zOne ? (n = e.redSub(r).redSub(i).redMul(A2.redSub(this.curve.two)), s2 = A2.redMul(f.redSub(i)), o = A2.redSqr().redSub(A2).redSub(A2)) : (l = this.z.redSqr(), m3 = A2.redSub(l).redISub(l), n = e.redSub(r).redISub(i).redMul(m3), s2 = A2.redMul(f.redSub(i)), o = A2.redMul(m3));
    } else
      f = r.redAdd(i), l = this.curve._mulC(this.z).redSqr(), m3 = f.redSub(l).redSub(l), n = this.curve._mulC(e.redISub(f)).redMul(m3), s2 = this.curve._mulC(f).redMul(r.redISub(i)), o = f.redMul(m3);
    return this.curve.point(n, s2, o);
  };
  Qt.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  Qt.prototype._extAdd = function(e) {
    var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), i = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), n = this.t.redMul(this.curve.dd).redMul(e.t), s2 = this.z.redMul(e.z.redAdd(e.z)), o = i.redSub(r), f = s2.redSub(n), l = s2.redAdd(n), m3 = i.redAdd(r), A2 = o.redMul(f), F3 = l.redMul(m3), z3 = o.redMul(m3), V = f.redMul(l);
    return this.curve.point(A2, F3, V, z3);
  };
  Qt.prototype._projAdd = function(e) {
    var r = this.z.redMul(e.z), i = r.redSqr(), n = this.x.redMul(e.x), s2 = this.y.redMul(e.y), o = this.curve.d.redMul(n).redMul(s2), f = i.redSub(o), l = i.redAdd(o), m3 = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(n).redISub(s2), A2 = r.redMul(f).redMul(m3), F3, z3;
    return this.curve.twisted ? (F3 = r.redMul(l).redMul(s2.redSub(this.curve._mulA(n))), z3 = f.redMul(l)) : (F3 = r.redMul(l).redMul(s2.redSub(n)), z3 = this.curve._mulC(f).redMul(l)), this.curve.point(A2, F3, z3);
  };
  Qt.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
  };
  Qt.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
  };
  Qt.prototype.mulAdd = function(e, r, i) {
    return this.curve._wnafMulAdd(1, [this, r], [e, i], 2, false);
  };
  Qt.prototype.jmulAdd = function(e, r, i) {
    return this.curve._wnafMulAdd(1, [this, r], [e, i], 2, true);
  };
  Qt.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
  };
  Qt.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Qt.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  Qt.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  Qt.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
  };
  Qt.prototype.eqXToP = function(e) {
    var r = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r) === 0)
      return true;
    for (var i = e.clone(), n = this.curve.redN.redMul(this.z); ; ) {
      if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
        return false;
      if (r.redIAdd(n), this.x.cmp(r) === 0)
        return true;
    }
  };
  Qt.prototype.toP = Qt.prototype.normalize;
  Qt.prototype.mixedAdd = Qt.prototype.add;
});
var R1 = k((tx) => {
  U();
  var nh = tx;
  nh.base = pc();
  nh.short = Vw();
  nh.mont = Zw();
  nh.edwards = ex();
});
var Si = k((Xt) => {
  U();
  var cM = Gr(), uM = At();
  Xt.inherits = uM;
  function dM(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
  }
  function lM(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t == "string")
      if (e) {
        if (e === "hex")
          for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), n = 0; n < t.length; n += 2)
            r.push(parseInt(t[n] + t[n + 1], 16));
      } else
        for (var i = 0, n = 0; n < t.length; n++) {
          var s2 = t.charCodeAt(n);
          s2 < 128 ? r[i++] = s2 : s2 < 2048 ? (r[i++] = s2 >> 6 | 192, r[i++] = s2 & 63 | 128) : dM(t, n) ? (s2 = 65536 + ((s2 & 1023) << 10) + (t.charCodeAt(++n) & 1023), r[i++] = s2 >> 18 | 240, r[i++] = s2 >> 12 & 63 | 128, r[i++] = s2 >> 6 & 63 | 128, r[i++] = s2 & 63 | 128) : (r[i++] = s2 >> 12 | 224, r[i++] = s2 >> 6 & 63 | 128, r[i++] = s2 & 63 | 128);
        }
    else
      for (n = 0; n < t.length; n++)
        r[n] = t[n] | 0;
    return r;
  }
  Xt.toArray = lM;
  function hM(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += ix(t[r].toString(16));
    return e;
  }
  Xt.toHex = hM;
  function rx(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0;
  }
  Xt.htonl = rx;
  function pM(t, e) {
    for (var r = "", i = 0; i < t.length; i++) {
      var n = t[i];
      e === "little" && (n = rx(n)), r += nx(n.toString(16));
    }
    return r;
  }
  Xt.toHex32 = pM;
  function ix(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Xt.zero2 = ix;
  function nx(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
  }
  Xt.zero8 = nx;
  function gM(t, e, r, i) {
    var n = r - e;
    cM(n % 4 === 0);
    for (var s2 = new Array(n / 4), o = 0, f = e; o < s2.length; o++, f += 4) {
      var l;
      i === "big" ? l = t[f] << 24 | t[f + 1] << 16 | t[f + 2] << 8 | t[f + 3] : l = t[f + 3] << 24 | t[f + 2] << 16 | t[f + 1] << 8 | t[f], s2[o] = l >>> 0;
    }
    return s2;
  }
  Xt.join32 = gM;
  function mM(t, e) {
    for (var r = new Array(t.length * 4), i = 0, n = 0; i < t.length; i++, n += 4) {
      var s2 = t[i];
      e === "big" ? (r[n] = s2 >>> 24, r[n + 1] = s2 >>> 16 & 255, r[n + 2] = s2 >>> 8 & 255, r[n + 3] = s2 & 255) : (r[n + 3] = s2 >>> 24, r[n + 2] = s2 >>> 16 & 255, r[n + 1] = s2 >>> 8 & 255, r[n] = s2 & 255);
    }
    return r;
  }
  Xt.split32 = mM;
  function yM(t, e) {
    return t >>> e | t << 32 - e;
  }
  Xt.rotr32 = yM;
  function bM(t, e) {
    return t << e | t >>> 32 - e;
  }
  Xt.rotl32 = bM;
  function vM(t, e) {
    return t + e >>> 0;
  }
  Xt.sum32 = vM;
  function wM(t, e, r) {
    return t + e + r >>> 0;
  }
  Xt.sum32_3 = wM;
  function xM(t, e, r, i) {
    return t + e + r + i >>> 0;
  }
  Xt.sum32_4 = xM;
  function _M(t, e, r, i, n) {
    return t + e + r + i + n >>> 0;
  }
  Xt.sum32_5 = _M;
  function AM(t, e, r, i) {
    var n = t[e], s2 = t[e + 1], o = i + s2 >>> 0, f = (o < i ? 1 : 0) + r + n;
    t[e] = f >>> 0, t[e + 1] = o;
  }
  Xt.sum64 = AM;
  function EM(t, e, r, i) {
    var n = e + i >>> 0, s2 = (n < e ? 1 : 0) + t + r;
    return s2 >>> 0;
  }
  Xt.sum64_hi = EM;
  function SM(t, e, r, i) {
    var n = e + i;
    return n >>> 0;
  }
  Xt.sum64_lo = SM;
  function MM(t, e, r, i, n, s2, o, f) {
    var l = 0, m3 = e;
    m3 = m3 + i >>> 0, l += m3 < e ? 1 : 0, m3 = m3 + s2 >>> 0, l += m3 < s2 ? 1 : 0, m3 = m3 + f >>> 0, l += m3 < f ? 1 : 0;
    var A2 = t + r + n + o + l;
    return A2 >>> 0;
  }
  Xt.sum64_4_hi = MM;
  function IM(t, e, r, i, n, s2, o, f) {
    var l = e + i + s2 + f;
    return l >>> 0;
  }
  Xt.sum64_4_lo = IM;
  function TM(t, e, r, i, n, s2, o, f, l, m3) {
    var A2 = 0, F3 = e;
    F3 = F3 + i >>> 0, A2 += F3 < e ? 1 : 0, F3 = F3 + s2 >>> 0, A2 += F3 < s2 ? 1 : 0, F3 = F3 + f >>> 0, A2 += F3 < f ? 1 : 0, F3 = F3 + m3 >>> 0, A2 += F3 < m3 ? 1 : 0;
    var z3 = t + r + n + o + l + A2;
    return z3 >>> 0;
  }
  Xt.sum64_5_hi = TM;
  function FM(t, e, r, i, n, s2, o, f, l, m3) {
    var A2 = e + i + s2 + f + m3;
    return A2 >>> 0;
  }
  Xt.sum64_5_lo = FM;
  function RM(t, e, r) {
    var i = e << 32 - r | t >>> r;
    return i >>> 0;
  }
  Xt.rotr64_hi = RM;
  function kM(t, e, r) {
    var i = t << 32 - r | e >>> r;
    return i >>> 0;
  }
  Xt.rotr64_lo = kM;
  function DM(t, e, r) {
    return t >>> r;
  }
  Xt.shr64_hi = DM;
  function BM(t, e, r) {
    var i = t << 32 - r | e >>> r;
    return i >>> 0;
  }
  Xt.shr64_lo = BM;
});
var na = k((ox) => {
  U();
  var sx = Si(), NM = Gr();
  function sh() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  ox.BlockHash = sh;
  sh.prototype.update = function(e, r) {
    if (e = sx.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var i = e.length % this._delta8;
      this.pending = e.slice(e.length - i, e.length), this.pending.length === 0 && (this.pending = null), e = sx.join32(e, 0, e.length - i, this.endian);
      for (var n = 0; n < e.length; n += this._delta32)
        this._update(e, n, n + this._delta32);
    }
    return this;
  };
  sh.prototype.digest = function(e) {
    return this.update(this._pad()), NM(this.pending === null), this._digest(e);
  };
  sh.prototype._pad = function() {
    var e = this.pendingTotal, r = this._delta8, i = r - (e + this.padLength) % r, n = new Array(i + this.padLength);
    n[0] = 128;
    for (var s2 = 1; s2 < i; s2++)
      n[s2] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var o = 8; o < this.padLength; o++)
        n[s2++] = 0;
      n[s2++] = 0, n[s2++] = 0, n[s2++] = 0, n[s2++] = 0, n[s2++] = e >>> 24 & 255, n[s2++] = e >>> 16 & 255, n[s2++] = e >>> 8 & 255, n[s2++] = e & 255;
    } else
      for (n[s2++] = e & 255, n[s2++] = e >>> 8 & 255, n[s2++] = e >>> 16 & 255, n[s2++] = e >>> 24 & 255, n[s2++] = 0, n[s2++] = 0, n[s2++] = 0, n[s2++] = 0, o = 8; o < this.padLength; o++)
        n[s2++] = 0;
    return n;
  };
});
var k1 = k((pn) => {
  U();
  var CM = Si(), Ui = CM.rotr32;
  function OM(t, e, r, i) {
    if (t === 0)
      return ax(e, r, i);
    if (t === 1 || t === 3)
      return cx(e, r, i);
    if (t === 2)
      return fx(e, r, i);
  }
  pn.ft_1 = OM;
  function ax(t, e, r) {
    return t & e ^ ~t & r;
  }
  pn.ch32 = ax;
  function fx(t, e, r) {
    return t & e ^ t & r ^ e & r;
  }
  pn.maj32 = fx;
  function cx(t, e, r) {
    return t ^ e ^ r;
  }
  pn.p32 = cx;
  function jM(t) {
    return Ui(t, 2) ^ Ui(t, 13) ^ Ui(t, 22);
  }
  pn.s0_256 = jM;
  function LM(t) {
    return Ui(t, 6) ^ Ui(t, 11) ^ Ui(t, 25);
  }
  pn.s1_256 = LM;
  function qM(t) {
    return Ui(t, 7) ^ Ui(t, 18) ^ t >>> 3;
  }
  pn.g0_256 = qM;
  function PM(t) {
    return Ui(t, 17) ^ Ui(t, 19) ^ t >>> 10;
  }
  pn.g1_256 = PM;
});
var lx = k((rN, dx) => {
  U();
  var sa = Si(), UM = na(), zM = k1(), D1 = sa.rotl32, gc = sa.sum32, HM = sa.sum32_5, $M = zM.ft_1, ux = UM.BlockHash, GM = [1518500249, 1859775393, 2400959708, 3395469782];
  function zi() {
    if (!(this instanceof zi))
      return new zi();
    ux.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
  }
  sa.inherits(zi, ux);
  dx.exports = zi;
  zi.blockSize = 512;
  zi.outSize = 160;
  zi.hmacStrength = 80;
  zi.padLength = 64;
  zi.prototype._update = function(e, r) {
    for (var i = this.W, n = 0; n < 16; n++)
      i[n] = e[r + n];
    for (; n < i.length; n++)
      i[n] = D1(i[n - 3] ^ i[n - 8] ^ i[n - 14] ^ i[n - 16], 1);
    var s2 = this.h[0], o = this.h[1], f = this.h[2], l = this.h[3], m3 = this.h[4];
    for (n = 0; n < i.length; n++) {
      var A2 = ~~(n / 20), F3 = HM(D1(s2, 5), $M(A2, o, f, l), m3, i[n], GM[A2]);
      m3 = l, l = f, f = D1(o, 30), o = s2, s2 = F3;
    }
    this.h[0] = gc(this.h[0], s2), this.h[1] = gc(this.h[1], o), this.h[2] = gc(this.h[2], f), this.h[3] = gc(this.h[3], l), this.h[4] = gc(this.h[4], m3);
  };
  zi.prototype._digest = function(e) {
    return e === "hex" ? sa.toHex32(this.h, "big") : sa.split32(this.h, "big");
  };
});
var B1 = k((iN, px) => {
  U();
  var oa = Si(), KM = na(), aa = k1(), WM = Gr(), Mi = oa.sum32, VM = oa.sum32_4, YM = oa.sum32_5, JM = aa.ch32, ZM = aa.maj32, XM = aa.s0_256, QM = aa.s1_256, eI = aa.g0_256, tI = aa.g1_256, hx = KM.BlockHash, rI = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function Hi() {
    if (!(this instanceof Hi))
      return new Hi();
    hx.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = rI, this.W = new Array(64);
  }
  oa.inherits(Hi, hx);
  px.exports = Hi;
  Hi.blockSize = 512;
  Hi.outSize = 256;
  Hi.hmacStrength = 192;
  Hi.padLength = 64;
  Hi.prototype._update = function(e, r) {
    for (var i = this.W, n = 0; n < 16; n++)
      i[n] = e[r + n];
    for (; n < i.length; n++)
      i[n] = VM(tI(i[n - 2]), i[n - 7], eI(i[n - 15]), i[n - 16]);
    var s2 = this.h[0], o = this.h[1], f = this.h[2], l = this.h[3], m3 = this.h[4], A2 = this.h[5], F3 = this.h[6], z3 = this.h[7];
    for (WM(this.k.length === i.length), n = 0; n < i.length; n++) {
      var V = YM(z3, QM(m3), JM(m3, A2, F3), this.k[n], i[n]), $ = Mi(XM(s2), ZM(s2, o, f));
      z3 = F3, F3 = A2, A2 = m3, m3 = Mi(l, V), l = f, f = o, o = s2, s2 = Mi(V, $);
    }
    this.h[0] = Mi(this.h[0], s2), this.h[1] = Mi(this.h[1], o), this.h[2] = Mi(this.h[2], f), this.h[3] = Mi(this.h[3], l), this.h[4] = Mi(this.h[4], m3), this.h[5] = Mi(this.h[5], A2), this.h[6] = Mi(this.h[6], F3), this.h[7] = Mi(this.h[7], z3);
  };
  Hi.prototype._digest = function(e) {
    return e === "hex" ? oa.toHex32(this.h, "big") : oa.split32(this.h, "big");
  };
});
var yx = k((nN, mx) => {
  U();
  var N1 = Si(), gx = B1();
  function gn() {
    if (!(this instanceof gn))
      return new gn();
    gx.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  N1.inherits(gn, gx);
  mx.exports = gn;
  gn.blockSize = 512;
  gn.outSize = 224;
  gn.hmacStrength = 192;
  gn.padLength = 64;
  gn.prototype._digest = function(e) {
    return e === "hex" ? N1.toHex32(this.h.slice(0, 7), "big") : N1.split32(this.h.slice(0, 7), "big");
  };
});
var j1 = k((sN, xx) => {
  U();
  var Pr = Si(), iI = na(), nI = Gr(), $i = Pr.rotr64_hi, Gi = Pr.rotr64_lo, bx = Pr.shr64_hi, vx = Pr.shr64_lo, Gn = Pr.sum64, C1 = Pr.sum64_hi, O1 = Pr.sum64_lo, sI = Pr.sum64_4_hi, oI = Pr.sum64_4_lo, aI = Pr.sum64_5_hi, fI = Pr.sum64_5_lo, wx = iI.BlockHash, cI = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  function Ii() {
    if (!(this instanceof Ii))
      return new Ii();
    wx.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = cI, this.W = new Array(160);
  }
  Pr.inherits(Ii, wx);
  xx.exports = Ii;
  Ii.blockSize = 1024;
  Ii.outSize = 512;
  Ii.hmacStrength = 192;
  Ii.padLength = 128;
  Ii.prototype._prepareBlock = function(e, r) {
    for (var i = this.W, n = 0; n < 32; n++)
      i[n] = e[r + n];
    for (; n < i.length; n += 2) {
      var s2 = wI(i[n - 4], i[n - 3]), o = xI(i[n - 4], i[n - 3]), f = i[n - 14], l = i[n - 13], m3 = bI(i[n - 30], i[n - 29]), A2 = vI(i[n - 30], i[n - 29]), F3 = i[n - 32], z3 = i[n - 31];
      i[n] = sI(s2, o, f, l, m3, A2, F3, z3), i[n + 1] = oI(s2, o, f, l, m3, A2, F3, z3);
    }
  };
  Ii.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var i = this.W, n = this.h[0], s2 = this.h[1], o = this.h[2], f = this.h[3], l = this.h[4], m3 = this.h[5], A2 = this.h[6], F3 = this.h[7], z3 = this.h[8], V = this.h[9], $ = this.h[10], re = this.h[11], W2 = this.h[12], Z2 = this.h[13], ue = this.h[14], ge = this.h[15];
    nI(this.k.length === i.length);
    for (var Se = 0; Se < i.length; Se += 2) {
      var pe2 = ue, H2 = ge, le = mI(z3, V), ie = yI(z3, V), se = uI(z3, V, $, re, W2), N3 = dI(z3, V, $, re, W2, Z2), c2 = this.k[Se], p2 = this.k[Se + 1], h2 = i[Se], a = i[Se + 1], d2 = aI(pe2, H2, le, ie, se, N3, c2, p2, h2, a), b2 = fI(pe2, H2, le, ie, se, N3, c2, p2, h2, a);
      pe2 = pI(n, s2), H2 = gI(n, s2), le = lI(n, s2, o, f, l), ie = hI(n, s2, o, f, l, m3);
      var _2 = C1(pe2, H2, le, ie), v = O1(pe2, H2, le, ie);
      ue = W2, ge = Z2, W2 = $, Z2 = re, $ = z3, re = V, z3 = C1(A2, F3, d2, b2), V = O1(F3, F3, d2, b2), A2 = l, F3 = m3, l = o, m3 = f, o = n, f = s2, n = C1(d2, b2, _2, v), s2 = O1(d2, b2, _2, v);
    }
    Gn(this.h, 0, n, s2), Gn(this.h, 2, o, f), Gn(this.h, 4, l, m3), Gn(this.h, 6, A2, F3), Gn(this.h, 8, z3, V), Gn(this.h, 10, $, re), Gn(this.h, 12, W2, Z2), Gn(this.h, 14, ue, ge);
  };
  Ii.prototype._digest = function(e) {
    return e === "hex" ? Pr.toHex32(this.h, "big") : Pr.split32(this.h, "big");
  };
  function uI(t, e, r, i, n) {
    var s2 = t & r ^ ~t & n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function dI(t, e, r, i, n, s2) {
    var o = e & i ^ ~e & s2;
    return o < 0 && (o += 4294967296), o;
  }
  function lI(t, e, r, i, n) {
    var s2 = t & r ^ t & n ^ r & n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function hI(t, e, r, i, n, s2) {
    var o = e & i ^ e & s2 ^ i & s2;
    return o < 0 && (o += 4294967296), o;
  }
  function pI(t, e) {
    var r = $i(t, e, 28), i = $i(e, t, 2), n = $i(e, t, 7), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function gI(t, e) {
    var r = Gi(t, e, 28), i = Gi(e, t, 2), n = Gi(e, t, 7), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function mI(t, e) {
    var r = $i(t, e, 14), i = $i(t, e, 18), n = $i(e, t, 9), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function yI(t, e) {
    var r = Gi(t, e, 14), i = Gi(t, e, 18), n = Gi(e, t, 9), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function bI(t, e) {
    var r = $i(t, e, 1), i = $i(t, e, 8), n = bx(t, e, 7), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function vI(t, e) {
    var r = Gi(t, e, 1), i = Gi(t, e, 8), n = vx(t, e, 7), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function wI(t, e) {
    var r = $i(t, e, 19), i = $i(e, t, 29), n = bx(t, e, 6), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
  function xI(t, e) {
    var r = Gi(t, e, 19), i = Gi(e, t, 29), n = vx(t, e, 6), s2 = r ^ i ^ n;
    return s2 < 0 && (s2 += 4294967296), s2;
  }
});
var Ex = k((oN, Ax) => {
  U();
  var L1 = Si(), _x = j1();
  function mn() {
    if (!(this instanceof mn))
      return new mn();
    _x.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  L1.inherits(mn, _x);
  Ax.exports = mn;
  mn.blockSize = 1024;
  mn.outSize = 384;
  mn.hmacStrength = 192;
  mn.padLength = 128;
  mn.prototype._digest = function(e) {
    return e === "hex" ? L1.toHex32(this.h.slice(0, 12), "big") : L1.split32(this.h.slice(0, 12), "big");
  };
});
var Sx = k((fa) => {
  U();
  fa.sha1 = lx();
  fa.sha224 = yx();
  fa.sha256 = B1();
  fa.sha384 = Ex();
  fa.sha512 = j1();
});
var kx = k((Rx) => {
  U();
  var Ps = Si(), _I = na(), oh = Ps.rotl32, Mx = Ps.sum32, mc = Ps.sum32_3, Ix = Ps.sum32_4, Fx = _I.BlockHash;
  function Ki() {
    if (!(this instanceof Ki))
      return new Ki();
    Fx.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  Ps.inherits(Ki, Fx);
  Rx.ripemd160 = Ki;
  Ki.blockSize = 512;
  Ki.outSize = 160;
  Ki.hmacStrength = 192;
  Ki.padLength = 64;
  Ki.prototype._update = function(e, r) {
    for (var i = this.h[0], n = this.h[1], s2 = this.h[2], o = this.h[3], f = this.h[4], l = i, m3 = n, A2 = s2, F3 = o, z3 = f, V = 0; V < 80; V++) {
      var $ = Mx(oh(Ix(i, Tx(V, n, s2, o), e[SI[V] + r], AI(V)), II[V]), f);
      i = f, f = o, o = oh(s2, 10), s2 = n, n = $, $ = Mx(oh(Ix(l, Tx(79 - V, m3, A2, F3), e[MI[V] + r], EI(V)), TI[V]), z3), l = z3, z3 = F3, F3 = oh(A2, 10), A2 = m3, m3 = $;
    }
    $ = mc(this.h[1], s2, F3), this.h[1] = mc(this.h[2], o, z3), this.h[2] = mc(this.h[3], f, l), this.h[3] = mc(this.h[4], i, m3), this.h[4] = mc(this.h[0], n, A2), this.h[0] = $;
  };
  Ki.prototype._digest = function(e) {
    return e === "hex" ? Ps.toHex32(this.h, "little") : Ps.split32(this.h, "little");
  };
  function Tx(t, e, r, i) {
    return t <= 15 ? e ^ r ^ i : t <= 31 ? e & r | ~e & i : t <= 47 ? (e | ~r) ^ i : t <= 63 ? e & i | r & ~i : e ^ (r | ~i);
  }
  function AI(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
  }
  function EI(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
  }
  var SI = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], MI = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], II = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], TI = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
});
var Bx = k((cN, Dx) => {
  U();
  var FI = Si(), RI = Gr();
  function ca(t, e, r) {
    if (!(this instanceof ca))
      return new ca(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(FI.toArray(e, r));
  }
  Dx.exports = ca;
  ca.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), RI(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++)
      e.push(0);
    for (r = 0; r < e.length; r++)
      e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
      e[r] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  ca.prototype.update = function(e, r) {
    return this.inner.update(e, r), this;
  };
  ca.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
});
var ah = k((Nx) => {
  U();
  var _r = Nx;
  _r.utils = Si();
  _r.common = na();
  _r.sha = Sx();
  _r.ripemd = kx();
  _r.hmac = Bx();
  _r.sha1 = _r.sha.sha1;
  _r.sha256 = _r.sha.sha256;
  _r.sha224 = _r.sha.sha224;
  _r.sha384 = _r.sha.sha384;
  _r.sha512 = _r.sha.sha512;
  _r.ripemd160 = _r.ripemd.ripemd160;
});
var Ox = k((dN, Cx) => {
  U();
  Cx.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
});
var fh = k((qx) => {
  U();
  var P1 = qx, Kn = ah(), q1 = R1(), kI = Kr(), jx = kI.assert;
  function Lx(t) {
    t.type === "short" ? this.curve = new q1.short(t) : t.type === "edwards" ? this.curve = new q1.edwards(t) : this.curve = new q1.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, jx(this.g.validate(), "Invalid curve"), jx(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  P1.PresetCurve = Lx;
  function Wn(t, e) {
    Object.defineProperty(P1, t, { configurable: true, enumerable: true, get: function() {
      var r = new Lx(e);
      return Object.defineProperty(P1, t, { configurable: true, enumerable: true, value: r }), r;
    } });
  }
  Wn("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Kn.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
  Wn("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Kn.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
  Wn("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Kn.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
  Wn("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Kn.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
  Wn("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Kn.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
  Wn("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Kn.sha256, gRed: false, g: ["9"] });
  Wn("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Kn.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var U1;
  try {
    U1 = Ox();
  } catch {
    U1 = void 0;
  }
  Wn("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Kn.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", U1] });
});
var zx = k((hN, Ux) => {
  U();
  var DI = ah(), Us = T1(), Px = Gr();
  function Vn(t) {
    if (!(this instanceof Vn))
      return new Vn(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Us.toArray(t.entropy, t.entropyEnc || "hex"), r = Us.toArray(t.nonce, t.nonceEnc || "hex"), i = Us.toArray(t.pers, t.persEnc || "hex");
    Px(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, i);
  }
  Ux.exports = Vn;
  Vn.prototype._init = function(e, r, i) {
    var n = e.concat(r).concat(i);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var s2 = 0; s2 < this.V.length; s2++)
      this.K[s2] = 0, this.V[s2] = 1;
    this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  Vn.prototype._hmac = function() {
    return new DI.hmac(this.hash, this.K);
  };
  Vn.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  Vn.prototype.reseed = function(e, r, i, n) {
    typeof r != "string" && (n = i, i = r, r = null), e = Us.toArray(e, r), i = Us.toArray(i, n), Px(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(i || [])), this._reseed = 1;
  };
  Vn.prototype.generate = function(e, r, i, n) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof r != "string" && (n = i, i = r, r = null), i && (i = Us.toArray(i, n || "hex"), this._update(i));
    for (var s2 = []; s2.length < e; )
      this.V = this._hmac().update(this.V).digest(), s2 = s2.concat(this.V);
    var o = s2.slice(0, e);
    return this._update(i), this._reseed++, Us.encode(o, r);
  };
});
var $x = k((pN, Hx) => {
  U();
  var BI = lr(), NI = Kr(), z1 = NI.assert;
  function Rr(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  Hx.exports = Rr;
  Rr.fromPublic = function(e, r, i) {
    return r instanceof Rr ? r : new Rr(e, { pub: r, pubEnc: i });
  };
  Rr.fromPrivate = function(e, r, i) {
    return r instanceof Rr ? r : new Rr(e, { priv: r, privEnc: i });
  };
  Rr.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
  };
  Rr.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
  };
  Rr.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  Rr.prototype._importPrivate = function(e, r) {
    this.priv = new BI(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  Rr.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? z1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && z1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, r);
  };
  Rr.prototype.derive = function(e) {
    return e.validate() || z1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  Rr.prototype.sign = function(e, r, i) {
    return this.ec.sign(e, this, r, i);
  };
  Rr.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this);
  };
  Rr.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});
var Wx = k((gN, Kx) => {
  U();
  var ch = lr(), G1 = Kr(), CI = G1.assert;
  function uh(t, e) {
    if (t instanceof uh)
      return t;
    this._importDER(t, e) || (CI(t.r && t.s, "Signature without r or s"), this.r = new ch(t.r, 16), this.s = new ch(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
  }
  Kx.exports = uh;
  function OI() {
    this.place = 0;
  }
  function H1(t, e) {
    var r = t[e.place++];
    if (!(r & 128))
      return r;
    var i = r & 15;
    if (i === 0 || i > 4)
      return false;
    for (var n = 0, s2 = 0, o = e.place; s2 < i; s2++, o++)
      n <<= 8, n |= t[o], n >>>= 0;
    return n <= 127 ? false : (e.place = o, n);
  }
  function Gx(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
      e++;
    return e === 0 ? t : t.slice(e);
  }
  uh.prototype._importDER = function(e, r) {
    e = G1.toArray(e, r);
    var i = new OI();
    if (e[i.place++] !== 48)
      return false;
    var n = H1(e, i);
    if (n === false || n + i.place !== e.length || e[i.place++] !== 2)
      return false;
    var s2 = H1(e, i);
    if (s2 === false)
      return false;
    var o = e.slice(i.place, s2 + i.place);
    if (i.place += s2, e[i.place++] !== 2)
      return false;
    var f = H1(e, i);
    if (f === false || e.length !== f + i.place)
      return false;
    var l = e.slice(i.place, f + i.place);
    if (o[0] === 0)
      if (o[1] & 128)
        o = o.slice(1);
      else
        return false;
    if (l[0] === 0)
      if (l[1] & 128)
        l = l.slice(1);
      else
        return false;
    return this.r = new ch(o), this.s = new ch(l), this.recoveryParam = null, true;
  };
  function $1(t, e) {
    if (e < 128) {
      t.push(e);
      return;
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r; )
      t.push(e >>> (r << 3) & 255);
    t.push(e);
  }
  uh.prototype.toDER = function(e) {
    var r = this.r.toArray(), i = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), i[0] & 128 && (i = [0].concat(i)), r = Gx(r), i = Gx(i); !i[0] && !(i[1] & 128); )
      i = i.slice(1);
    var n = [2];
    $1(n, r.length), n = n.concat(r), n.push(2), $1(n, i.length);
    var s2 = n.concat(i), o = [48];
    return $1(o, s2.length), o = o.concat(s2), G1.encode(o, e);
  };
});
var Zx = k((mN, Jx) => {
  U();
  var zs = lr(), Vx = zx(), jI = Kr(), K1 = fh(), LI = Wl(), Yx = jI.assert, W1 = $x(), dh = Wx();
  function ai(t) {
    if (!(this instanceof ai))
      return new ai(t);
    typeof t == "string" && (Yx(Object.prototype.hasOwnProperty.call(K1, t), "Unknown curve " + t), t = K1[t]), t instanceof K1.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
  }
  Jx.exports = ai;
  ai.prototype.keyPair = function(e) {
    return new W1(this, e);
  };
  ai.prototype.keyFromPrivate = function(e, r) {
    return W1.fromPrivate(this, e, r);
  };
  ai.prototype.keyFromPublic = function(e, r) {
    return W1.fromPublic(this, e, r);
  };
  ai.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new Vx({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || LI(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), i = this.n.byteLength(), n = this.n.sub(new zs(2)); ; ) {
      var s2 = new zs(r.generate(i));
      if (!(s2.cmp(n) > 0))
        return s2.iaddn(1), this.keyFromPrivate(s2);
    }
  };
  ai.prototype._truncateToN = function(e, r) {
    var i = e.byteLength() * 8 - this.n.bitLength();
    return i > 0 && (e = e.ushrn(i)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  ai.prototype.sign = function(e, r, i, n) {
    typeof i == "object" && (n = i, i = null), n || (n = {}), r = this.keyFromPrivate(r, i), e = this._truncateToN(new zs(e, 16));
    for (var s2 = this.n.byteLength(), o = r.getPrivate().toArray("be", s2), f = e.toArray("be", s2), l = new Vx({ hash: this.hash, entropy: o, nonce: f, pers: n.pers, persEnc: n.persEnc || "utf8" }), m3 = this.n.sub(new zs(1)), A2 = 0; ; A2++) {
      var F3 = n.k ? n.k(A2) : new zs(l.generate(this.n.byteLength()));
      if (F3 = this._truncateToN(F3, true), !(F3.cmpn(1) <= 0 || F3.cmp(m3) >= 0)) {
        var z3 = this.g.mul(F3);
        if (!z3.isInfinity()) {
          var V = z3.getX(), $ = V.umod(this.n);
          if ($.cmpn(0) !== 0) {
            var re = F3.invm(this.n).mul($.mul(r.getPrivate()).iadd(e));
            if (re = re.umod(this.n), re.cmpn(0) !== 0) {
              var W2 = (z3.getY().isOdd() ? 1 : 0) | (V.cmp($) !== 0 ? 2 : 0);
              return n.canonical && re.cmp(this.nh) > 0 && (re = this.n.sub(re), W2 ^= 1), new dh({ r: $, s: re, recoveryParam: W2 });
            }
          }
        }
      }
    }
  };
  ai.prototype.verify = function(e, r, i, n) {
    e = this._truncateToN(new zs(e, 16)), i = this.keyFromPublic(i, n), r = new dh(r, "hex");
    var s2 = r.r, o = r.s;
    if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
      return false;
    var f = o.invm(this.n), l = f.mul(e).umod(this.n), m3 = f.mul(s2).umod(this.n), A2;
    return this.curve._maxwellTrick ? (A2 = this.g.jmulAdd(l, i.getPublic(), m3), A2.isInfinity() ? false : A2.eqXToP(s2)) : (A2 = this.g.mulAdd(l, i.getPublic(), m3), A2.isInfinity() ? false : A2.getX().umod(this.n).cmp(s2) === 0);
  };
  ai.prototype.recoverPubKey = function(t, e, r, i) {
    Yx((3 & r) === r, "The recovery param is more than two bits"), e = new dh(e, i);
    var n = this.n, s2 = new zs(t), o = e.r, f = e.s, l = r & 1, m3 = r >> 1;
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && m3)
      throw new Error("Unable to find sencond key candinate");
    m3 ? o = this.curve.pointFromX(o.add(this.curve.n), l) : o = this.curve.pointFromX(o, l);
    var A2 = e.r.invm(n), F3 = n.sub(s2).mul(A2).umod(n), z3 = f.mul(A2).umod(n);
    return this.g.mulAdd(F3, o, z3);
  };
  ai.prototype.getKeyRecoveryParam = function(t, e, r, i) {
    if (e = new dh(e, i), e.recoveryParam !== null)
      return e.recoveryParam;
    for (var n = 0; n < 4; n++) {
      var s2;
      try {
        s2 = this.recoverPubKey(t, e, n);
      } catch {
        continue;
      }
      if (s2.eq(r))
        return n;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});
var t6 = k((yN, e6) => {
  U();
  var yc = Kr(), Qx = yc.assert, Xx = yc.parseBytes, ua = yc.cachedProperty;
  function vr(t, e) {
    this.eddsa = t, this._secret = Xx(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Xx(e.pub);
  }
  vr.fromPublic = function(e, r) {
    return r instanceof vr ? r : new vr(e, { pub: r });
  };
  vr.fromSecret = function(e, r) {
    return r instanceof vr ? r : new vr(e, { secret: r });
  };
  vr.prototype.secret = function() {
    return this._secret;
  };
  ua(vr, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  ua(vr, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  ua(vr, "privBytes", function() {
    var e = this.eddsa, r = this.hash(), i = e.encodingLength - 1, n = r.slice(0, e.encodingLength);
    return n[0] &= 248, n[i] &= 127, n[i] |= 64, n;
  });
  ua(vr, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  ua(vr, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  ua(vr, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  vr.prototype.sign = function(e) {
    return Qx(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
  };
  vr.prototype.verify = function(e, r) {
    return this.eddsa.verify(e, r, this);
  };
  vr.prototype.getSecret = function(e) {
    return Qx(this._secret, "KeyPair is public only"), yc.encode(this.secret(), e);
  };
  vr.prototype.getPublic = function(e) {
    return yc.encode(this.pubBytes(), e);
  };
  e6.exports = vr;
});
var i6 = k((bN, r6) => {
  U();
  var qI = lr(), lh = Kr(), PI = lh.assert, hh = lh.cachedProperty, UI = lh.parseBytes;
  function Hs(t, e) {
    this.eddsa = t, typeof e != "object" && (e = UI(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), PI(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof qI && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
  }
  hh(Hs, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  hh(Hs, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  hh(Hs, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  hh(Hs, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  Hs.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Hs.prototype.toHex = function() {
    return lh.encode(this.toBytes(), "hex").toUpperCase();
  };
  r6.exports = Hs;
});
var f6 = k((vN, a6) => {
  U();
  var zI = ah(), HI = fh(), da = Kr(), $I = da.assert, s6 = da.parseBytes, o6 = t6(), n6 = i6();
  function Ur2(t) {
    if ($I(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof Ur2))
      return new Ur2(t);
    t = HI[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = zI.sha512;
  }
  a6.exports = Ur2;
  Ur2.prototype.sign = function(e, r) {
    e = s6(e);
    var i = this.keyFromSecret(r), n = this.hashInt(i.messagePrefix(), e), s2 = this.g.mul(n), o = this.encodePoint(s2), f = this.hashInt(o, i.pubBytes(), e).mul(i.priv()), l = n.add(f).umod(this.curve.n);
    return this.makeSignature({ R: s2, S: l, Rencoded: o });
  };
  Ur2.prototype.verify = function(e, r, i) {
    e = s6(e), r = this.makeSignature(r);
    var n = this.keyFromPublic(i), s2 = this.hashInt(r.Rencoded(), n.pubBytes(), e), o = this.g.mul(r.S()), f = r.R().add(n.pub().mul(s2));
    return f.eq(o);
  };
  Ur2.prototype.hashInt = function() {
    for (var e = this.hash(), r = 0; r < arguments.length; r++)
      e.update(arguments[r]);
    return da.intFromLE(e.digest()).umod(this.curve.n);
  };
  Ur2.prototype.keyFromPublic = function(e) {
    return o6.fromPublic(this, e);
  };
  Ur2.prototype.keyFromSecret = function(e) {
    return o6.fromSecret(this, e);
  };
  Ur2.prototype.makeSignature = function(e) {
    return e instanceof n6 ? e : new n6(this, e);
  };
  Ur2.prototype.encodePoint = function(e) {
    var r = e.getY().toArray("le", this.encodingLength);
    return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
  };
  Ur2.prototype.decodePoint = function(e) {
    e = da.parseBytes(e);
    var r = e.length - 1, i = e.slice(0, r).concat(e[r] & -129), n = (e[r] & 128) !== 0, s2 = da.intFromLE(i);
    return this.curve.pointFromY(s2, n);
  };
  Ur2.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength);
  };
  Ur2.prototype.decodeInt = function(e) {
    return da.intFromLE(e);
  };
  Ur2.prototype.isPoint = function(e) {
    return e instanceof this.pointClass;
  };
});
var ph = k((c6) => {
  U();
  var $s = c6;
  $s.version = Uw().version;
  $s.utils = Kr();
  $s.rand = Wl();
  $s.curve = R1();
  $s.curves = fh();
  $s.ec = Zx();
  $s.eddsa = f6();
});
var mh = k((xN, u6) => {
  U();
  var gh = or(), la = gh.Buffer, fi = {}, ci;
  for (ci in gh)
    !gh.hasOwnProperty(ci) || ci === "SlowBuffer" || ci === "Buffer" || (fi[ci] = gh[ci]);
  var ha = fi.Buffer = {};
  for (ci in la)
    !la.hasOwnProperty(ci) || ci === "allocUnsafe" || ci === "allocUnsafeSlow" || (ha[ci] = la[ci]);
  fi.Buffer.prototype = la.prototype;
  (!ha.from || ha.from === Uint8Array.from) && (ha.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
    if (t && typeof t.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    return la(t, e, r);
  });
  ha.alloc || (ha.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
    if (t < 0 || t >= 2 * (1 << 30))
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    var i = la(t);
    return !e || e.length === 0 ? i.fill(0) : typeof r == "string" ? i.fill(e, r) : i.fill(e), i;
  });
  if (!fi.kStringMaxLength)
    try {
      fi.kStringMaxLength = W.default.binding("buffer").kStringMaxLength;
    } catch {
    }
  fi.constants || (fi.constants = { MAX_LENGTH: fi.kMaxLength }, fi.kStringMaxLength && (fi.constants.MAX_STRING_LENGTH = fi.kStringMaxLength));
  u6.exports = fi;
});
var yh = k((d6) => {
  U();
  var GI = At();
  function ui(t) {
    this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
  }
  d6.Reporter = ui;
  ui.prototype.isError = function(e) {
    return e instanceof pa;
  };
  ui.prototype.save = function() {
    let e = this._reporterState;
    return { obj: e.obj, pathLen: e.path.length };
  };
  ui.prototype.restore = function(e) {
    let r = this._reporterState;
    r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
  };
  ui.prototype.enterKey = function(e) {
    return this._reporterState.path.push(e);
  };
  ui.prototype.exitKey = function(e) {
    let r = this._reporterState;
    r.path = r.path.slice(0, e - 1);
  };
  ui.prototype.leaveKey = function(e, r, i) {
    let n = this._reporterState;
    this.exitKey(e), n.obj !== null && (n.obj[r] = i);
  };
  ui.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  ui.prototype.enterObject = function() {
    let e = this._reporterState, r = e.obj;
    return e.obj = {}, r;
  };
  ui.prototype.leaveObject = function(e) {
    let r = this._reporterState, i = r.obj;
    return r.obj = e, i;
  };
  ui.prototype.error = function(e) {
    let r, i = this._reporterState, n = e instanceof pa;
    if (n ? r = e : r = new pa(i.path.map(function(s2) {
      return "[" + JSON.stringify(s2) + "]";
    }).join(""), e.message || e, e.stack), !i.options.partial)
      throw r;
    return n || i.errors.push(r), r;
  };
  ui.prototype.wrapResult = function(e) {
    let r = this._reporterState;
    return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
  };
  function pa(t, e) {
    this.path = t, this.rethrow(e);
  }
  GI(pa, Error);
  pa.prototype.rethrow = function(e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, pa), !this.stack)
      try {
        throw new Error(this.message);
      } catch (r) {
        this.stack = r.stack;
      }
    return this;
  };
});
var ya = k((V1) => {
  U();
  var KI = At(), bh = yh().Reporter, ga = mh().Buffer;
  function di(t, e) {
    if (bh.call(this, e), !ga.isBuffer(t)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = t, this.offset = 0, this.length = t.length;
  }
  KI(di, bh);
  V1.DecoderBuffer = di;
  di.isDecoderBuffer = function(e) {
    return e instanceof di ? true : typeof e == "object" && ga.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
  };
  di.prototype.save = function() {
    return { offset: this.offset, reporter: bh.prototype.save.call(this) };
  };
  di.prototype.restore = function(e) {
    let r = new di(this.base);
    return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, bh.prototype.restore.call(this, e.reporter), r;
  };
  di.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  di.prototype.readUInt8 = function(e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
  };
  di.prototype.skip = function(e, r) {
    if (!(this.offset + e <= this.length))
      return this.error(r || "DecoderBuffer overrun");
    let i = new di(this.base);
    return i._reporterState = this._reporterState, i.offset = this.offset, i.length = this.offset + e, this.offset += e, i;
  };
  di.prototype.raw = function(e) {
    return this.base.slice(e ? e.offset : this.offset, this.length);
  };
  function ma(t, e) {
    if (Array.isArray(t))
      this.length = 0, this.value = t.map(function(r) {
        return ma.isEncoderBuffer(r) || (r = new ma(r, e)), this.length += r.length, r;
      }, this);
    else if (typeof t == "number") {
      if (!(0 <= t && t <= 255))
        return e.error("non-byte EncoderBuffer value");
      this.value = t, this.length = 1;
    } else if (typeof t == "string")
      this.value = t, this.length = ga.byteLength(t);
    else if (ga.isBuffer(t))
      this.value = t, this.length = t.length;
    else
      return e.error("Unsupported type: " + typeof t);
  }
  V1.EncoderBuffer = ma;
  ma.isEncoderBuffer = function(e) {
    return e instanceof ma ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
  };
  ma.prototype.join = function(e, r) {
    return e || (e = ga.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(i) {
      i.join(e, r), r += i.length;
    }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : ga.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
  };
});
var vh = k((EN, h6) => {
  U();
  var WI = yh().Reporter, VI = ya().EncoderBuffer, YI = ya().DecoderBuffer, Cr2 = Gr(), l6 = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], JI = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(l6), ZI = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function Yt(t, e, r) {
    let i = {};
    this._baseState = i, i.name = r, i.enc = t, i.parent = e || null, i.children = null, i.tag = null, i.args = null, i.reverseArgs = null, i.choice = null, i.optional = false, i.any = false, i.obj = false, i.use = null, i.useDecoder = null, i.key = null, i.default = null, i.explicit = null, i.implicit = null, i.contains = null, i.parent || (i.children = [], this._wrap());
  }
  h6.exports = Yt;
  var XI = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  Yt.prototype.clone = function() {
    let e = this._baseState, r = {};
    XI.forEach(function(n) {
      r[n] = e[n];
    });
    let i = new this.constructor(r.parent);
    return i._baseState = r, i;
  };
  Yt.prototype._wrap = function() {
    let e = this._baseState;
    JI.forEach(function(r) {
      this[r] = function() {
        let n = new this.constructor(this);
        return e.children.push(n), n[r].apply(n, arguments);
      };
    }, this);
  };
  Yt.prototype._init = function(e) {
    let r = this._baseState;
    Cr2(r.parent === null), e.call(this), r.children = r.children.filter(function(i) {
      return i._baseState.parent === this;
    }, this), Cr2.equal(r.children.length, 1, "Root node can have only one child");
  };
  Yt.prototype._useArgs = function(e) {
    let r = this._baseState, i = e.filter(function(n) {
      return n instanceof this.constructor;
    }, this);
    e = e.filter(function(n) {
      return !(n instanceof this.constructor);
    }, this), i.length !== 0 && (Cr2(r.children === null), r.children = i, i.forEach(function(n) {
      n._baseState.parent = this;
    }, this)), e.length !== 0 && (Cr2(r.args === null), r.args = e, r.reverseArgs = e.map(function(n) {
      if (typeof n != "object" || n.constructor !== Object)
        return n;
      let s2 = {};
      return Object.keys(n).forEach(function(o) {
        o == (o | 0) && (o |= 0);
        let f = n[o];
        s2[f] = o;
      }), s2;
    }));
  };
  ZI.forEach(function(t) {
    Yt.prototype[t] = function() {
      let r = this._baseState;
      throw new Error(t + " not implemented for encoding: " + r.enc);
    };
  });
  l6.forEach(function(t) {
    Yt.prototype[t] = function() {
      let r = this._baseState, i = Array.prototype.slice.call(arguments);
      return Cr2(r.tag === null), r.tag = t, this._useArgs(i), this;
    };
  });
  Yt.prototype.use = function(e) {
    Cr2(e);
    let r = this._baseState;
    return Cr2(r.use === null), r.use = e, this;
  };
  Yt.prototype.optional = function() {
    let e = this._baseState;
    return e.optional = true, this;
  };
  Yt.prototype.def = function(e) {
    let r = this._baseState;
    return Cr2(r.default === null), r.default = e, r.optional = true, this;
  };
  Yt.prototype.explicit = function(e) {
    let r = this._baseState;
    return Cr2(r.explicit === null && r.implicit === null), r.explicit = e, this;
  };
  Yt.prototype.implicit = function(e) {
    let r = this._baseState;
    return Cr2(r.explicit === null && r.implicit === null), r.implicit = e, this;
  };
  Yt.prototype.obj = function() {
    let e = this._baseState, r = Array.prototype.slice.call(arguments);
    return e.obj = true, r.length !== 0 && this._useArgs(r), this;
  };
  Yt.prototype.key = function(e) {
    let r = this._baseState;
    return Cr2(r.key === null), r.key = e, this;
  };
  Yt.prototype.any = function() {
    let e = this._baseState;
    return e.any = true, this;
  };
  Yt.prototype.choice = function(e) {
    let r = this._baseState;
    return Cr2(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(i) {
      return e[i];
    })), this;
  };
  Yt.prototype.contains = function(e) {
    let r = this._baseState;
    return Cr2(r.use === null), r.contains = e, this;
  };
  Yt.prototype._decode = function(e, r) {
    let i = this._baseState;
    if (i.parent === null)
      return e.wrapResult(i.children[0]._decode(e, r));
    let n = i.default, s2 = true, o = null;
    if (i.key !== null && (o = e.enterKey(i.key)), i.optional) {
      let l = null;
      if (i.explicit !== null ? l = i.explicit : i.implicit !== null ? l = i.implicit : i.tag !== null && (l = i.tag), l === null && !i.any) {
        let m3 = e.save();
        try {
          i.choice === null ? this._decodeGeneric(i.tag, e, r) : this._decodeChoice(e, r), s2 = true;
        } catch {
          s2 = false;
        }
        e.restore(m3);
      } else if (s2 = this._peekTag(e, l, i.any), e.isError(s2))
        return s2;
    }
    let f;
    if (i.obj && s2 && (f = e.enterObject()), s2) {
      if (i.explicit !== null) {
        let m3 = this._decodeTag(e, i.explicit);
        if (e.isError(m3))
          return m3;
        e = m3;
      }
      let l = e.offset;
      if (i.use === null && i.choice === null) {
        let m3;
        i.any && (m3 = e.save());
        let A2 = this._decodeTag(e, i.implicit !== null ? i.implicit : i.tag, i.any);
        if (e.isError(A2))
          return A2;
        i.any ? n = e.raw(m3) : e = A2;
      }
      if (r && r.track && i.tag !== null && r.track(e.path(), l, e.length, "tagged"), r && r.track && i.tag !== null && r.track(e.path(), e.offset, e.length, "content"), i.any || (i.choice === null ? n = this._decodeGeneric(i.tag, e, r) : n = this._decodeChoice(e, r)), e.isError(n))
        return n;
      if (!i.any && i.choice === null && i.children !== null && i.children.forEach(function(A2) {
        A2._decode(e, r);
      }), i.contains && (i.tag === "octstr" || i.tag === "bitstr")) {
        let m3 = new YI(n);
        n = this._getUse(i.contains, e._reporterState.obj)._decode(m3, r);
      }
    }
    return i.obj && s2 && (n = e.leaveObject(f)), i.key !== null && (n !== null || s2 === true) ? e.leaveKey(o, i.key, n) : o !== null && e.exitKey(o), n;
  };
  Yt.prototype._decodeGeneric = function(e, r, i) {
    let n = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, n.args[0], i) : /str$/.test(e) ? this._decodeStr(r, e, i) : e === "objid" && n.args ? this._decodeObjid(r, n.args[0], n.args[1], i) : e === "objid" ? this._decodeObjid(r, null, null, i) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, i) : e === "null_" ? this._decodeNull(r, i) : e === "bool" ? this._decodeBool(r, i) : e === "objDesc" ? this._decodeStr(r, e, i) : e === "int" || e === "enum" ? this._decodeInt(r, n.args && n.args[0], i) : n.use !== null ? this._getUse(n.use, r._reporterState.obj)._decode(r, i) : r.error("unknown tag: " + e);
  };
  Yt.prototype._getUse = function(e, r) {
    let i = this._baseState;
    return i.useDecoder = this._use(e, r), Cr2(i.useDecoder._baseState.parent === null), i.useDecoder = i.useDecoder._baseState.children[0], i.implicit !== i.useDecoder._baseState.implicit && (i.useDecoder = i.useDecoder.clone(), i.useDecoder._baseState.implicit = i.implicit), i.useDecoder;
  };
  Yt.prototype._decodeChoice = function(e, r) {
    let i = this._baseState, n = null, s2 = false;
    return Object.keys(i.choice).some(function(o) {
      let f = e.save(), l = i.choice[o];
      try {
        let m3 = l._decode(e, r);
        if (e.isError(m3))
          return false;
        n = { type: o, value: m3 }, s2 = true;
      } catch {
        return e.restore(f), false;
      }
      return true;
    }, this), s2 ? n : e.error("Choice not matched");
  };
  Yt.prototype._createEncoderBuffer = function(e) {
    return new VI(e, this.reporter);
  };
  Yt.prototype._encode = function(e, r, i) {
    let n = this._baseState;
    if (n.default !== null && n.default === e)
      return;
    let s2 = this._encodeValue(e, r, i);
    if (s2 !== void 0 && !this._skipDefault(s2, r, i))
      return s2;
  };
  Yt.prototype._encodeValue = function(e, r, i) {
    let n = this._baseState;
    if (n.parent === null)
      return n.children[0]._encode(e, r || new WI());
    let s2 = null;
    if (this.reporter = r, n.optional && e === void 0)
      if (n.default !== null)
        e = n.default;
      else
        return;
    let o = null, f = false;
    if (n.any)
      s2 = this._createEncoderBuffer(e);
    else if (n.choice)
      s2 = this._encodeChoice(e, r);
    else if (n.contains)
      o = this._getUse(n.contains, i)._encode(e, r), f = true;
    else if (n.children)
      o = n.children.map(function(l) {
        if (l._baseState.tag === "null_")
          return l._encode(null, r, e);
        if (l._baseState.key === null)
          return r.error("Child should have a key");
        let m3 = r.enterKey(l._baseState.key);
        if (typeof e != "object")
          return r.error("Child expected, but input is not object");
        let A2 = l._encode(e[l._baseState.key], r, e);
        return r.leaveKey(m3), A2;
      }, this).filter(function(l) {
        return l;
      }), o = this._createEncoderBuffer(o);
    else if (n.tag === "seqof" || n.tag === "setof") {
      if (!(n.args && n.args.length === 1))
        return r.error("Too many args for : " + n.tag);
      if (!Array.isArray(e))
        return r.error("seqof/setof, but data is not Array");
      let l = this.clone();
      l._baseState.implicit = null, o = this._createEncoderBuffer(e.map(function(m3) {
        let A2 = this._baseState;
        return this._getUse(A2.args[0], e)._encode(m3, r);
      }, l));
    } else
      n.use !== null ? s2 = this._getUse(n.use, i)._encode(e, r) : (o = this._encodePrimitive(n.tag, e), f = true);
    if (!n.any && n.choice === null) {
      let l = n.implicit !== null ? n.implicit : n.tag, m3 = n.implicit === null ? "universal" : "context";
      l === null ? n.use === null && r.error("Tag could be omitted only for .use()") : n.use === null && (s2 = this._encodeComposite(l, f, m3, o));
    }
    return n.explicit !== null && (s2 = this._encodeComposite(n.explicit, false, "context", s2)), s2;
  };
  Yt.prototype._encodeChoice = function(e, r) {
    let i = this._baseState, n = i.choice[e.type];
    return n || Cr2(false, e.type + " not found in " + JSON.stringify(Object.keys(i.choice))), n._encode(e.value, r);
  };
  Yt.prototype._encodePrimitive = function(e, r) {
    let i = this._baseState;
    if (/str$/.test(e))
      return this._encodeStr(r, e);
    if (e === "objid" && i.args)
      return this._encodeObjid(r, i.reverseArgs[0], i.args[1]);
    if (e === "objid")
      return this._encodeObjid(r, null, null);
    if (e === "gentime" || e === "utctime")
      return this._encodeTime(r, e);
    if (e === "null_")
      return this._encodeNull();
    if (e === "int" || e === "enum")
      return this._encodeInt(r, i.args && i.reverseArgs[0]);
    if (e === "bool")
      return this._encodeBool(r);
    if (e === "objDesc")
      return this._encodeStr(r, e);
    throw new Error("Unsupported tag: " + e);
  };
  Yt.prototype._isNumstr = function(e) {
    return /^[0-9 ]*$/.test(e);
  };
  Yt.prototype._isPrintstr = function(e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
  };
});
var wh = k((Gs) => {
  U();
  function p6(t) {
    let e = {};
    return Object.keys(t).forEach(function(r) {
      (r | 0) == r && (r = r | 0);
      let i = t[r];
      e[i] = r;
    }), e;
  }
  Gs.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  Gs.tagClassByName = p6(Gs.tagClass);
  Gs.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  Gs.tagByName = p6(Gs.tag);
});
var J1 = k((MN, y6) => {
  U();
  var QI = At(), yn = mh().Buffer, g6 = vh(), Y1 = wh();
  function m6(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ti(), this.tree._init(t.body);
  }
  y6.exports = m6;
  m6.prototype.encode = function(e, r) {
    return this.tree._encode(e, r).join();
  };
  function Ti(t) {
    g6.call(this, "der", t);
  }
  QI(Ti, g6);
  Ti.prototype._encodeComposite = function(e, r, i, n) {
    let s2 = eT(e, r, i, this.reporter);
    if (n.length < 128) {
      let l = yn.alloc(2);
      return l[0] = s2, l[1] = n.length, this._createEncoderBuffer([l, n]);
    }
    let o = 1;
    for (let l = n.length; l >= 256; l >>= 8)
      o++;
    let f = yn.alloc(1 + 1 + o);
    f[0] = s2, f[1] = 128 | o;
    for (let l = 1 + o, m3 = n.length; m3 > 0; l--, m3 >>= 8)
      f[l] = m3 & 255;
    return this._createEncoderBuffer([f, n]);
  };
  Ti.prototype._encodeStr = function(e, r) {
    if (r === "bitstr")
      return this._createEncoderBuffer([e.unused | 0, e.data]);
    if (r === "bmpstr") {
      let i = yn.alloc(e.length * 2);
      for (let n = 0; n < e.length; n++)
        i.writeUInt16BE(e.charCodeAt(n), n * 2);
      return this._createEncoderBuffer(i);
    } else
      return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
  };
  Ti.prototype._encodeObjid = function(e, r, i) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("string objid given, but no values map found");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("objid not found in values map");
      e = r[e].split(/[\s.]+/g);
      for (let f = 0; f < e.length; f++)
        e[f] |= 0;
    } else if (Array.isArray(e)) {
      e = e.slice();
      for (let f = 0; f < e.length; f++)
        e[f] |= 0;
    }
    if (!Array.isArray(e))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!i) {
      if (e[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      e.splice(0, 2, e[0] * 40 + e[1]);
    }
    let n = 0;
    for (let f = 0; f < e.length; f++) {
      let l = e[f];
      for (n++; l >= 128; l >>= 7)
        n++;
    }
    let s2 = yn.alloc(n), o = s2.length - 1;
    for (let f = e.length - 1; f >= 0; f--) {
      let l = e[f];
      for (s2[o--] = l & 127; (l >>= 7) > 0; )
        s2[o--] = 128 | l & 127;
    }
    return this._createEncoderBuffer(s2);
  };
  function li(t) {
    return t < 10 ? "0" + t : t;
  }
  Ti.prototype._encodeTime = function(e, r) {
    let i, n = new Date(e);
    return r === "gentime" ? i = [li(n.getUTCFullYear()), li(n.getUTCMonth() + 1), li(n.getUTCDate()), li(n.getUTCHours()), li(n.getUTCMinutes()), li(n.getUTCSeconds()), "Z"].join("") : r === "utctime" ? i = [li(n.getUTCFullYear() % 100), li(n.getUTCMonth() + 1), li(n.getUTCDate()), li(n.getUTCHours()), li(n.getUTCMinutes()), li(n.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(i, "octstr");
  };
  Ti.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  Ti.prototype._encodeInt = function(e, r) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("String int or enum given, but no values map");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
      e = r[e];
    }
    if (typeof e != "number" && !yn.isBuffer(e)) {
      let s2 = e.toArray();
      !e.sign && s2[0] & 128 && s2.unshift(0), e = yn.from(s2);
    }
    if (yn.isBuffer(e)) {
      let s2 = e.length;
      e.length === 0 && s2++;
      let o = yn.alloc(s2);
      return e.copy(o), e.length === 0 && (o[0] = 0), this._createEncoderBuffer(o);
    }
    if (e < 128)
      return this._createEncoderBuffer(e);
    if (e < 256)
      return this._createEncoderBuffer([0, e]);
    let i = 1;
    for (let s2 = e; s2 >= 256; s2 >>= 8)
      i++;
    let n = new Array(i);
    for (let s2 = n.length - 1; s2 >= 0; s2--)
      n[s2] = e & 255, e >>= 8;
    return n[0] & 128 && n.unshift(0), this._createEncoderBuffer(yn.from(n));
  };
  Ti.prototype._encodeBool = function(e) {
    return this._createEncoderBuffer(e ? 255 : 0);
  };
  Ti.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
  };
  Ti.prototype._skipDefault = function(e, r, i) {
    let n = this._baseState, s2;
    if (n.default === null)
      return false;
    let o = e.join();
    if (n.defaultBuffer === void 0 && (n.defaultBuffer = this._encodeValue(n.default, r, i).join()), o.length !== n.defaultBuffer.length)
      return false;
    for (s2 = 0; s2 < o.length; s2++)
      if (o[s2] !== n.defaultBuffer[s2])
        return false;
    return true;
  };
  function eT(t, e, r, i) {
    let n;
    if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), Y1.tagByName.hasOwnProperty(t))
      n = Y1.tagByName[t];
    else if (typeof t == "number" && (t | 0) === t)
      n = t;
    else
      return i.error("Unknown tag: " + t);
    return n >= 31 ? i.error("Multi-octet tag encoding unsupported") : (e || (n |= 32), n |= Y1.tagClassByName[r || "universal"] << 6, n);
  }
});
var v6 = k((IN, b6) => {
  U();
  var tT = At(), Z1 = J1();
  function X1(t) {
    Z1.call(this, t), this.enc = "pem";
  }
  tT(X1, Z1);
  b6.exports = X1;
  X1.prototype.encode = function(e, r) {
    let n = Z1.prototype.encode.call(this, e).toString("base64"), s2 = ["-----BEGIN " + r.label + "-----"];
    for (let o = 0; o < n.length; o += 64)
      s2.push(n.slice(o, o + 64));
    return s2.push("-----END " + r.label + "-----"), s2.join(`
`);
  };
});
var Q1 = k((x6) => {
  U();
  var w6 = x6;
  w6.der = J1();
  w6.pem = v6();
});
var tg = k((FN, I6) => {
  U();
  var rT = At(), iT = lr(), _6 = ya().DecoderBuffer, E6 = vh(), A6 = wh();
  function S6(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Wr(), this.tree._init(t.body);
  }
  I6.exports = S6;
  S6.prototype.decode = function(e, r) {
    return _6.isDecoderBuffer(e) || (e = new _6(e, r)), this.tree._decode(e, r);
  };
  function Wr(t) {
    E6.call(this, "der", t);
  }
  rT(Wr, E6);
  Wr.prototype._peekTag = function(e, r, i) {
    if (e.isEmpty())
      return false;
    let n = e.save(), s2 = eg(e, 'Failed to peek tag: "' + r + '"');
    return e.isError(s2) ? s2 : (e.restore(n), s2.tag === r || s2.tagStr === r || s2.tagStr + "of" === r || i);
  };
  Wr.prototype._decodeTag = function(e, r, i) {
    let n = eg(e, 'Failed to decode tag of "' + r + '"');
    if (e.isError(n))
      return n;
    let s2 = M6(e, n.primitive, 'Failed to get length of "' + r + '"');
    if (e.isError(s2))
      return s2;
    if (!i && n.tag !== r && n.tagStr !== r && n.tagStr + "of" !== r)
      return e.error('Failed to match tag: "' + r + '"');
    if (n.primitive || s2 !== null)
      return e.skip(s2, 'Failed to match body of: "' + r + '"');
    let o = e.save(), f = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(f) ? f : (s2 = e.offset - o.offset, e.restore(o), e.skip(s2, 'Failed to match body of: "' + r + '"'));
  };
  Wr.prototype._skipUntilEnd = function(e, r) {
    for (; ; ) {
      let i = eg(e, r);
      if (e.isError(i))
        return i;
      let n = M6(e, i.primitive, r);
      if (e.isError(n))
        return n;
      let s2;
      if (i.primitive || n !== null ? s2 = e.skip(n) : s2 = this._skipUntilEnd(e, r), e.isError(s2))
        return s2;
      if (i.tagStr === "end")
        break;
    }
  };
  Wr.prototype._decodeList = function(e, r, i, n) {
    let s2 = [];
    for (; !e.isEmpty(); ) {
      let o = this._peekTag(e, "end");
      if (e.isError(o))
        return o;
      let f = i.decode(e, "der", n);
      if (e.isError(f) && o)
        break;
      s2.push(f);
    }
    return s2;
  };
  Wr.prototype._decodeStr = function(e, r) {
    if (r === "bitstr") {
      let i = e.readUInt8();
      return e.isError(i) ? i : { unused: i, data: e.raw() };
    } else if (r === "bmpstr") {
      let i = e.raw();
      if (i.length % 2 === 1)
        return e.error("Decoding of string type: bmpstr length mismatch");
      let n = "";
      for (let s2 = 0; s2 < i.length / 2; s2++)
        n += String.fromCharCode(i.readUInt16BE(s2 * 2));
      return n;
    } else if (r === "numstr") {
      let i = e.raw().toString("ascii");
      return this._isNumstr(i) ? i : e.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (r === "octstr")
        return e.raw();
      if (r === "objDesc")
        return e.raw();
      if (r === "printstr") {
        let i = e.raw().toString("ascii");
        return this._isPrintstr(i) ? i : e.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
    }
  };
  Wr.prototype._decodeObjid = function(e, r, i) {
    let n, s2 = [], o = 0, f = 0;
    for (; !e.isEmpty(); )
      f = e.readUInt8(), o <<= 7, o |= f & 127, (f & 128) === 0 && (s2.push(o), o = 0);
    f & 128 && s2.push(o);
    let l = s2[0] / 40 | 0, m3 = s2[0] % 40;
    if (i ? n = s2 : n = [l, m3].concat(s2.slice(1)), r) {
      let A2 = r[n.join(" ")];
      A2 === void 0 && (A2 = r[n.join(".")]), A2 !== void 0 && (n = A2);
    }
    return n;
  };
  Wr.prototype._decodeTime = function(e, r) {
    let i = e.raw().toString(), n, s2, o, f, l, m3;
    if (r === "gentime")
      n = i.slice(0, 4) | 0, s2 = i.slice(4, 6) | 0, o = i.slice(6, 8) | 0, f = i.slice(8, 10) | 0, l = i.slice(10, 12) | 0, m3 = i.slice(12, 14) | 0;
    else if (r === "utctime")
      n = i.slice(0, 2) | 0, s2 = i.slice(2, 4) | 0, o = i.slice(4, 6) | 0, f = i.slice(6, 8) | 0, l = i.slice(8, 10) | 0, m3 = i.slice(10, 12) | 0, n < 70 ? n = 2e3 + n : n = 1900 + n;
    else
      return e.error("Decoding " + r + " time is not supported yet");
    return Date.UTC(n, s2 - 1, o, f, l, m3, 0);
  };
  Wr.prototype._decodeNull = function() {
    return null;
  };
  Wr.prototype._decodeBool = function(e) {
    let r = e.readUInt8();
    return e.isError(r) ? r : r !== 0;
  };
  Wr.prototype._decodeInt = function(e, r) {
    let i = e.raw(), n = new iT(i);
    return r && (n = r[n.toString(10)] || n), n;
  };
  Wr.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
  };
  function eg(t, e) {
    let r = t.readUInt8(e);
    if (t.isError(r))
      return r;
    let i = A6.tagClass[r >> 6], n = (r & 32) === 0;
    if ((r & 31) === 31) {
      let o = r;
      for (r = 0; (o & 128) === 128; ) {
        if (o = t.readUInt8(e), t.isError(o))
          return o;
        r <<= 7, r |= o & 127;
      }
    } else
      r &= 31;
    let s2 = A6.tag[r];
    return { cls: i, primitive: n, tag: r, tagStr: s2 };
  }
  function M6(t, e, r) {
    let i = t.readUInt8(r);
    if (t.isError(i))
      return i;
    if (!e && i === 128)
      return null;
    if ((i & 128) === 0)
      return i;
    let n = i & 127;
    if (n > 4)
      return t.error("length octect is too long");
    i = 0;
    for (let s2 = 0; s2 < n; s2++) {
      i <<= 8;
      let o = t.readUInt8(r);
      if (t.isError(o))
        return o;
      i |= o;
    }
    return i;
  }
});
var F6 = k((RN, T6) => {
  U();
  var nT = At(), sT = mh().Buffer, rg = tg();
  function ig(t) {
    rg.call(this, t), this.enc = "pem";
  }
  nT(ig, rg);
  T6.exports = ig;
  ig.prototype.decode = function(e, r) {
    let i = e.toString().split(/[\r\n]+/g), n = r.label.toUpperCase(), s2 = /^-----(BEGIN|END) ([^-]+)-----$/, o = -1, f = -1;
    for (let A2 = 0; A2 < i.length; A2++) {
      let F3 = i[A2].match(s2);
      if (F3 !== null && F3[2] === n)
        if (o === -1) {
          if (F3[1] !== "BEGIN")
            break;
          o = A2;
        } else {
          if (F3[1] !== "END")
            break;
          f = A2;
          break;
        }
    }
    if (o === -1 || f === -1)
      throw new Error("PEM section not found for: " + n);
    let l = i.slice(o + 1, f).join("");
    l.replace(/[^a-z0-9+/=]+/gi, "");
    let m3 = sT.from(l, "base64");
    return rg.prototype.decode.call(this, m3, r);
  };
});
var ng = k((k6) => {
  U();
  var R6 = k6;
  R6.der = tg();
  R6.pem = F6();
});
var B6 = k((D6) => {
  U();
  var oT = Q1(), aT = ng(), fT = At(), cT = D6;
  cT.define = function(e, r) {
    return new ba(e, r);
  };
  function ba(t, e) {
    this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
  }
  ba.prototype._createNamed = function(e) {
    let r = this.name;
    function i(n) {
      this._initNamed(n, r);
    }
    return fT(i, e), i.prototype._initNamed = function(s2, o) {
      e.call(this, s2, o);
    }, new i(this);
  };
  ba.prototype._getDecoder = function(e) {
    return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(aT[e])), this.decoders[e];
  };
  ba.prototype.decode = function(e, r, i) {
    return this._getDecoder(r).decode(e, i);
  };
  ba.prototype._getEncoder = function(e) {
    return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(oT[e])), this.encoders[e];
  };
  ba.prototype.encode = function(e, r, i) {
    return this._getEncoder(r).encode(e, i);
  };
});
var C6 = k((N6) => {
  U();
  var xh = N6;
  xh.Reporter = yh().Reporter;
  xh.DecoderBuffer = ya().DecoderBuffer;
  xh.EncoderBuffer = ya().EncoderBuffer;
  xh.Node = vh();
});
var L6 = k((j6) => {
  U();
  var O6 = j6;
  O6._reverse = function(e) {
    let r = {};
    return Object.keys(e).forEach(function(i) {
      (i | 0) == i && (i = i | 0);
      let n = e[i];
      r[n] = i;
    }), r;
  };
  O6.der = wh();
});
var sg = k((q6) => {
  U();
  var va = q6;
  va.bignum = lr();
  va.define = B6().define;
  va.base = C6();
  va.constants = L6();
  va.decoders = ng();
  va.encoders = Q1();
});
var H6 = k((ON, z6) => {
  U();
  var Fi = sg(), P6 = Fi.define("Time", function() {
    this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
  }), uT = Fi.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), og = Fi.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), dT = Fi.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(og), this.key("subjectPublicKey").bitstr());
  }), lT = Fi.define("RelativeDistinguishedName", function() {
    this.setof(uT);
  }), hT = Fi.define("RDNSequence", function() {
    this.seqof(lT);
  }), U6 = Fi.define("Name", function() {
    this.choice({ rdnSequence: this.use(hT) });
  }), pT = Fi.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(P6), this.key("notAfter").use(P6));
  }), gT = Fi.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  }), mT = Fi.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(og), this.key("issuer").use(U6), this.key("validity").use(pT), this.key("subject").use(U6), this.key("subjectPublicKeyInfo").use(dT), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(gT).optional());
  }), yT = Fi.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(mT), this.key("signatureAlgorithm").use(og), this.key("signatureValue").bitstr());
  });
  z6.exports = yT;
});
var G6 = k((ki) => {
  U();
  var Ri = sg();
  ki.certificate = H6();
  var bT = Ri.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  ki.RSAPrivateKey = bT;
  var vT = Ri.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  ki.RSAPublicKey = vT;
  var wT = Ri.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use($6), this.key("subjectPublicKey").bitstr());
  });
  ki.PublicKey = wT;
  var $6 = Ri.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), xT = Ri.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use($6), this.key("subjectPrivateKey").octstr());
  });
  ki.PrivateKey = xT;
  var _T = Ri.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  ki.EncryptedPrivateKey = _T;
  var AT = Ri.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  ki.DSAPrivateKey = AT;
  ki.DSAparam = Ri.define("DSAparam", function() {
    this.int();
  });
  var ET = Ri.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ST), this.key("publicKey").optional().explicit(1).bitstr());
  });
  ki.ECPrivateKey = ET;
  var ST = Ri.define("ECParameters", function() {
    this.choice({ namedCurve: this.objid() });
  });
  ki.signature = Ri.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
});
var K6 = k((LN, MT) => {
  MT.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
});
var V6 = k((qN, W6) => {
  U();
  var IT = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, TT = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, FT = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, RT = uc(), kT = Kl(), _h2 = St().Buffer;
  W6.exports = function(t, e) {
    var r = t.toString(), i = r.match(IT), n;
    if (i) {
      var o = "aes" + i[1], f = _h2.from(i[2], "hex"), l = _h2.from(i[3].replace(/[\r\n]/g, ""), "base64"), m3 = RT(e, f.slice(0, 8), parseInt(i[1], 10)).key, A2 = [], F3 = kT.createDecipheriv(o, m3, f);
      A2.push(F3.update(l)), A2.push(F3.final()), n = _h2.concat(A2);
    } else {
      var s2 = r.match(FT);
      n = _h2.from(s2[2].replace(/[\r\n]/g, ""), "base64");
    }
    var z3 = r.match(TT)[1];
    return { tag: z3, data: n };
  };
});
var bc = k((PN, J6) => {
  U();
  var zr = G6(), DT = K6(), BT = V6(), NT = Kl(), CT = Yp(), ag = St().Buffer;
  J6.exports = Y6;
  function Y6(t) {
    var e;
    typeof t == "object" && !ag.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = ag.from(t));
    var r = BT(t, e), i = r.tag, n = r.data, s2, o;
    switch (i) {
      case "CERTIFICATE":
        o = zr.certificate.decode(n, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (o || (o = zr.PublicKey.decode(n, "der")), s2 = o.algorithm.algorithm.join("."), s2) {
          case "1.2.840.113549.1.1.1":
            return zr.RSAPublicKey.decode(o.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return o.subjectPrivateKey = o.subjectPublicKey, { type: "ec", data: o };
          case "1.2.840.10040.4.1":
            return o.algorithm.params.pub_key = zr.DSAparam.decode(o.subjectPublicKey.data, "der"), { type: "dsa", data: o.algorithm.params };
          default:
            throw new Error("unknown key id " + s2);
        }
      case "ENCRYPTED PRIVATE KEY":
        n = zr.EncryptedPrivateKey.decode(n, "der"), n = OT(n, e);
      case "PRIVATE KEY":
        switch (o = zr.PrivateKey.decode(n, "der"), s2 = o.algorithm.algorithm.join("."), s2) {
          case "1.2.840.113549.1.1.1":
            return zr.RSAPrivateKey.decode(o.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return { curve: o.algorithm.curve, privateKey: zr.ECPrivateKey.decode(o.subjectPrivateKey, "der").privateKey };
          case "1.2.840.10040.4.1":
            return o.algorithm.params.priv_key = zr.DSAparam.decode(o.subjectPrivateKey, "der"), { type: "dsa", params: o.algorithm.params };
          default:
            throw new Error("unknown key id " + s2);
        }
      case "RSA PUBLIC KEY":
        return zr.RSAPublicKey.decode(n, "der");
      case "RSA PRIVATE KEY":
        return zr.RSAPrivateKey.decode(n, "der");
      case "DSA PRIVATE KEY":
        return { type: "dsa", params: zr.DSAPrivateKey.decode(n, "der") };
      case "EC PRIVATE KEY":
        return n = zr.ECPrivateKey.decode(n, "der"), { curve: n.parameters.value, privateKey: n.privateKey };
      default:
        throw new Error("unknown key type " + i);
    }
  }
  Y6.signature = zr.signature;
  function OT(t, e) {
    var r = t.algorithm.decrypt.kde.kdeparams.salt, i = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), n = DT[t.algorithm.decrypt.cipher.algo.join(".")], s2 = t.algorithm.decrypt.cipher.iv, o = t.subjectPrivateKey, f = parseInt(n.split("-")[1], 10) / 8, l = CT.pbkdf2Sync(e, r, i, f, "sha1"), m3 = NT.createDecipheriv(n, l, s2), A2 = [];
    return A2.push(m3.update(o)), A2.push(m3.final()), ag.concat(A2);
  }
});
var fg = k((UN, jT) => {
  jT.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
});
var Q6 = k((zN, Eh) => {
  U();
  var kr = St().Buffer, Ks = qp(), LT = Zl(), qT = ph().ec, Ah = Jl(), PT = bc(), UT = fg();
  function zT(t, e, r, i, n) {
    var s2 = PT(e);
    if (s2.curve) {
      if (i !== "ecdsa" && i !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return HT(t, s2);
    } else if (s2.type === "dsa") {
      if (i !== "dsa")
        throw new Error("wrong private key type");
      return $T(t, s2, r);
    } else if (i !== "rsa" && i !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    t = kr.concat([n, t]);
    for (var o = s2.modulus.byteLength(), f = [0, 1]; t.length + f.length + 1 < o; )
      f.push(255);
    f.push(0);
    for (var l = -1; ++l < t.length; )
      f.push(t[l]);
    var m3 = LT(f, s2);
    return m3;
  }
  function HT(t, e) {
    var r = UT[e.curve.join(".")];
    if (!r)
      throw new Error("unknown curve " + e.curve.join("."));
    var i = new qT(r), n = i.keyFromPrivate(e.privateKey), s2 = n.sign(t);
    return kr.from(s2.toDER());
  }
  function $T(t, e, r) {
    for (var i = e.params.priv_key, n = e.params.p, s2 = e.params.q, o = e.params.g, f = new Ah(0), l, m3 = cg(t, s2).mod(s2), A2 = false, F3 = Z6(i, s2, t, r); A2 === false; )
      l = X6(s2, F3, r), f = WT(o, l, n, s2), A2 = l.invm(s2).imul(m3.add(i.mul(f))).mod(s2), A2.cmpn(0) === 0 && (A2 = false, f = new Ah(0));
    return GT(f, A2);
  }
  function GT(t, e) {
    t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
    var r = t.length + e.length + 4, i = [48, r, 2, t.length];
    return i = i.concat(t, [2, e.length], e), kr.from(i);
  }
  function Z6(t, e, r, i) {
    if (t = kr.from(t.toArray()), t.length < e.byteLength()) {
      var n = kr.alloc(e.byteLength() - t.length);
      t = kr.concat([n, t]);
    }
    var s2 = r.length, o = KT(r, e), f = kr.alloc(s2);
    f.fill(1);
    var l = kr.alloc(s2);
    return l = Ks(i, l).update(f).update(kr.from([0])).update(t).update(o).digest(), f = Ks(i, l).update(f).digest(), l = Ks(i, l).update(f).update(kr.from([1])).update(t).update(o).digest(), f = Ks(i, l).update(f).digest(), { k: l, v: f };
  }
  function cg(t, e) {
    var r = new Ah(t), i = (t.length << 3) - e.bitLength();
    return i > 0 && r.ishrn(i), r;
  }
  function KT(t, e) {
    t = cg(t, e), t = t.mod(e);
    var r = kr.from(t.toArray());
    if (r.length < e.byteLength()) {
      var i = kr.alloc(e.byteLength() - r.length);
      r = kr.concat([i, r]);
    }
    return r;
  }
  function X6(t, e, r) {
    var i, n;
    do {
      for (i = kr.alloc(0); i.length * 8 < t.bitLength(); )
        e.v = Ks(r, e.k).update(e.v).digest(), i = kr.concat([i, e.v]);
      n = cg(i, t), e.k = Ks(r, e.k).update(e.v).update(kr.from([0])).digest(), e.v = Ks(r, e.k).update(e.v).digest();
    } while (n.cmp(t) !== -1);
    return n;
  }
  function WT(t, e, r, i) {
    return t.toRed(Ah.mont(r)).redPow(e).fromRed().mod(i);
  }
  Eh.exports = zT;
  Eh.exports.getKey = Z6;
  Eh.exports.makeKey = X6;
});
var i3 = k((HN, r3) => {
  U();
  var ug = St().Buffer, vc = Jl(), VT = ph().ec, t3 = bc(), YT = fg();
  function JT(t, e, r, i, n) {
    var s2 = t3(r);
    if (s2.type === "ec") {
      if (i !== "ecdsa" && i !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return ZT(t, e, s2);
    } else if (s2.type === "dsa") {
      if (i !== "dsa")
        throw new Error("wrong public key type");
      return XT(t, e, s2);
    } else if (i !== "rsa" && i !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    e = ug.concat([n, e]);
    for (var o = s2.modulus.byteLength(), f = [1], l = 0; e.length + f.length + 2 < o; )
      f.push(255), l++;
    f.push(0);
    for (var m3 = -1; ++m3 < e.length; )
      f.push(e[m3]);
    f = ug.from(f);
    var A2 = vc.mont(s2.modulus);
    t = new vc(t).toRed(A2), t = t.redPow(new vc(s2.publicExponent)), t = ug.from(t.fromRed().toArray());
    var F3 = l < 8 ? 1 : 0;
    for (o = Math.min(t.length, f.length), t.length !== f.length && (F3 = 1), m3 = -1; ++m3 < o; )
      F3 |= t[m3] ^ f[m3];
    return F3 === 0;
  }
  function ZT(t, e, r) {
    var i = YT[r.data.algorithm.curve.join(".")];
    if (!i)
      throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
    var n = new VT(i), s2 = r.data.subjectPrivateKey.data;
    return n.verify(e, t, s2);
  }
  function XT(t, e, r) {
    var i = r.data.p, n = r.data.q, s2 = r.data.g, o = r.data.pub_key, f = t3.signature.decode(t, "der"), l = f.s, m3 = f.r;
    e3(l, n), e3(m3, n);
    var A2 = vc.mont(i), F3 = l.invm(n), z3 = s2.toRed(A2).redPow(new vc(e).mul(F3).mod(n)).fromRed().mul(o.toRed(A2).redPow(m3.mul(F3).mod(n)).fromRed()).mod(i).mod(n);
    return z3.cmp(m3) === 0;
  }
  function e3(t, e) {
    if (t.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (t.cmp(e) >= e)
      throw new Error("invalid sig");
  }
  r3.exports = JT;
});
var c3 = k(($N, f3) => {
  U();
  var Sh = St().Buffer, o3 = Wo(), Mh = Rp(), a3 = At(), QT = Q6(), eF = i3(), Ws = Pp();
  Object.keys(Ws).forEach(function(t) {
    Ws[t].id = Sh.from(Ws[t].id, "hex"), Ws[t.toLowerCase()] = Ws[t];
  });
  function wc(t) {
    Mh.Writable.call(this);
    var e = Ws[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hashType = e.hash, this._hash = o3(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  a3(wc, Mh.Writable);
  wc.prototype._write = function(e, r, i) {
    this._hash.update(e), i();
  };
  wc.prototype.update = function(e, r) {
    return typeof e == "string" && (e = Sh.from(e, r)), this._hash.update(e), this;
  };
  wc.prototype.sign = function(e, r) {
    this.end();
    var i = this._hash.digest(), n = QT(i, e, this._hashType, this._signType, this._tag);
    return r ? n.toString(r) : n;
  };
  function xc(t) {
    Mh.Writable.call(this);
    var e = Ws[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hash = o3(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  a3(xc, Mh.Writable);
  xc.prototype._write = function(e, r, i) {
    this._hash.update(e), i();
  };
  xc.prototype.update = function(e, r) {
    return typeof e == "string" && (e = Sh.from(e, r)), this._hash.update(e), this;
  };
  xc.prototype.verify = function(e, r, i) {
    typeof r == "string" && (r = Sh.from(r, i)), this.end();
    var n = this._hash.digest();
    return eF(r, n, e, this._signType, this._tag);
  };
  function n3(t) {
    return new wc(t);
  }
  function s3(t) {
    return new xc(t);
  }
  f3.exports = { Sign: n3, Verify: s3, createSign: n3, createVerify: s3 };
});
var d3 = k((GN, u3) => {
  U();
  var tF = ph(), rF = lr();
  u3.exports = function(e) {
    return new Vs(e);
  };
  var Vr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  Vr.p224 = Vr.secp224r1;
  Vr.p256 = Vr.secp256r1 = Vr.prime256v1;
  Vr.p192 = Vr.secp192r1 = Vr.prime192v1;
  Vr.p384 = Vr.secp384r1;
  Vr.p521 = Vr.secp521r1;
  function Vs(t) {
    this.curveType = Vr[t], this.curveType || (this.curveType = { name: t }), this.curve = new tF.ec(this.curveType.name), this.keys = void 0;
  }
  Vs.prototype.generateKeys = function(t, e) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
  };
  Vs.prototype.computeSecret = function(t, e, r) {
    e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e));
    var i = this.curve.keyFromPublic(t).getPublic(), n = i.mul(this.keys.getPrivate()).getX();
    return dg(n, r, this.curveType.byteLength);
  };
  Vs.prototype.getPublicKey = function(t, e) {
    var r = this.keys.getPublic(e === "compressed", true);
    return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), dg(r, t);
  };
  Vs.prototype.getPrivateKey = function(t) {
    return dg(this.keys.getPrivate(), t);
  };
  Vs.prototype.setPublicKey = function(t, e) {
    return e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e)), this.keys._importPublic(t), this;
  };
  Vs.prototype.setPrivateKey = function(t, e) {
    e = e || "utf8", b.Buffer.isBuffer(t) || (t = new b.Buffer(t, e));
    var r = new rF(t);
    return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
  };
  function dg(t, e, r) {
    Array.isArray(t) || (t = t.toArray());
    var i = new b.Buffer(t);
    if (r && i.length < r) {
      var n = new b.Buffer(r - i.length);
      n.fill(0), i = b.Buffer.concat([n, i]);
    }
    return e ? i.toString(e) : i;
  }
});
var hg = k((KN, l3) => {
  U();
  var iF = Wo(), lg = St().Buffer;
  l3.exports = function(t, e) {
    for (var r = lg.alloc(0), i = 0, n; r.length < e; )
      n = nF(i++), r = lg.concat([r, iF("sha1").update(t).update(n).digest()]);
    return r.slice(0, e);
  };
  function nF(t) {
    var e = lg.allocUnsafe(4);
    return e.writeUInt32BE(t, 0), e;
  }
});
var pg = k((WN, h3) => {
  U();
  h3.exports = function(e, r) {
    for (var i = e.length, n = -1; ++n < i; )
      e[n] ^= r[n];
    return e;
  };
});
var gg = k((VN, g3) => {
  U();
  var p3 = lr(), sF = St().Buffer;
  function oF(t, e) {
    return sF.from(t.toRed(p3.mont(e.modulus)).redPow(new p3(e.publicExponent)).fromRed().toArray());
  }
  g3.exports = oF;
});
var v3 = k((YN, b3) => {
  U();
  var aF = bc(), mg = bs(), fF = Wo(), m3 = hg(), y3 = pg(), yg = lr(), cF = gg(), uF = Zl(), Di = St().Buffer;
  b3.exports = function(e, r, i) {
    var n;
    e.padding ? n = e.padding : i ? n = 1 : n = 4;
    var s2 = aF(e), o;
    if (n === 4)
      o = dF(s2, r);
    else if (n === 1)
      o = lF(s2, r, i);
    else if (n === 3) {
      if (o = new yg(r), o.cmp(s2.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return i ? uF(o, s2) : cF(o, s2);
  };
  function dF(t, e) {
    var r = t.modulus.byteLength(), i = e.length, n = fF("sha1").update(Di.alloc(0)).digest(), s2 = n.length, o = 2 * s2;
    if (i > r - o - 2)
      throw new Error("message too long");
    var f = Di.alloc(r - i - o - 2), l = r - s2 - 1, m5 = mg(s2), A2 = y3(Di.concat([n, f, Di.alloc(1, 1), e], l), m3(m5, l)), F3 = y3(m5, m3(A2, s2));
    return new yg(Di.concat([Di.alloc(1), F3, A2], r));
  }
  function lF(t, e, r) {
    var i = e.length, n = t.modulus.byteLength();
    if (i > n - 11)
      throw new Error("message too long");
    var s2;
    return r ? s2 = Di.alloc(n - i - 3, 255) : s2 = hF(n - i - 3), new yg(Di.concat([Di.from([0, r ? 1 : 2]), s2, Di.alloc(1), e], n));
  }
  function hF(t) {
    for (var e = Di.allocUnsafe(t), r = 0, i = mg(t * 2), n = 0, s2; r < t; )
      n === i.length && (i = mg(t * 2), n = 0), s2 = i[n++], s2 && (e[r++] = s2);
    return e;
  }
});
var E3 = k((JN, A3) => {
  U();
  var pF = bc(), w3 = hg(), x3 = pg(), _3 = lr(), gF = Zl(), mF = Wo(), yF = gg(), _c2 = St().Buffer;
  A3.exports = function(e, r, i) {
    var n;
    e.padding ? n = e.padding : i ? n = 1 : n = 4;
    var s2 = pF(e), o = s2.modulus.byteLength();
    if (r.length > o || new _3(r).cmp(s2.modulus) >= 0)
      throw new Error("decryption error");
    var f;
    i ? f = yF(new _3(r), s2) : f = gF(r, s2);
    var l = _c2.alloc(o - f.length);
    if (f = _c2.concat([l, f], o), n === 4)
      return bF(s2, f);
    if (n === 1)
      return vF(s2, f, i);
    if (n === 3)
      return f;
    throw new Error("unknown padding");
  };
  function bF(t, e) {
    var r = t.modulus.byteLength(), i = mF("sha1").update(_c2.alloc(0)).digest(), n = i.length;
    if (e[0] !== 0)
      throw new Error("decryption error");
    var s2 = e.slice(1, n + 1), o = e.slice(n + 1), f = x3(s2, w3(o, n)), l = x3(o, w3(f, r - n - 1));
    if (wF(i, l.slice(0, n)))
      throw new Error("decryption error");
    for (var m3 = n; l[m3] === 0; )
      m3++;
    if (l[m3++] !== 1)
      throw new Error("decryption error");
    return l.slice(m3);
  }
  function vF(t, e, r) {
    for (var i = e.slice(0, 2), n = 2, s2 = 0; e[n++] !== 0; )
      if (n >= e.length) {
        s2++;
        break;
      }
    var o = e.slice(2, n - 1);
    if ((i.toString("hex") !== "0002" && !r || i.toString("hex") !== "0001" && r) && s2++, o.length < 8 && s2++, s2)
      throw new Error("decryption error");
    return e.slice(n);
  }
  function wF(t, e) {
    t = _c2.from(t), e = _c2.from(e);
    var r = 0, i = t.length;
    t.length !== e.length && (r++, i = Math.min(t.length, e.length));
    for (var n = -1; ++n < i; )
      r += t[n] ^ e[n];
    return r;
  }
});
var S3 = k((Ys) => {
  U();
  Ys.publicEncrypt = v3();
  Ys.privateDecrypt = E3();
  Ys.privateEncrypt = function(e, r) {
    return Ys.publicEncrypt(e, r, true);
  };
  Ys.publicDecrypt = function(e, r) {
    return Ys.privateDecrypt(e, r, true);
  };
});
var C3 = k((Ac) => {
  U();
  function M3() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var T3 = St(), I3 = bs(), F3 = T3.Buffer, R3 = T3.kMaxLength, bg = N.crypto || N.msCrypto, k3 = Math.pow(2, 32) - 1;
  function D3(t, e) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("offset must be a number");
    if (t > k3 || t < 0)
      throw new TypeError("offset must be a uint32");
    if (t > R3 || t > e)
      throw new RangeError("offset out of range");
  }
  function B3(t, e, r) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("size must be a number");
    if (t > k3 || t < 0)
      throw new TypeError("size must be a uint32");
    if (t + e > r || t > R3)
      throw new RangeError("buffer too small");
  }
  bg && bg.getRandomValues || !W.default.browser ? (Ac.randomFill = xF, Ac.randomFillSync = _F) : (Ac.randomFill = M3, Ac.randomFillSync = M3);
  function xF(t, e, r, i) {
    if (!F3.isBuffer(t) && !(t instanceof N.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof e == "function")
      i = e, e = 0, r = t.length;
    else if (typeof r == "function")
      i = r, r = t.length - e;
    else if (typeof i != "function")
      throw new TypeError('"cb" argument must be a function');
    return D3(e, t.length), B3(r, e, t.length), N3(t, e, r, i);
  }
  function N3(t, e, r, i) {
    if (W.default.browser) {
      var n = t.buffer, s2 = new Uint8Array(n, e, r);
      if (bg.getRandomValues(s2), i) {
        W.default.nextTick(function() {
          i(null, t);
        });
        return;
      }
      return t;
    }
    if (i) {
      I3(r, function(f, l) {
        if (f)
          return i(f);
        l.copy(t, e), i(null, t);
      });
      return;
    }
    var o = I3(r);
    return o.copy(t, e), t;
  }
  function _F(t, e, r) {
    if (typeof e > "u" && (e = 0), !F3.isBuffer(t) && !(t instanceof N.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return D3(e, t.length), r === void 0 && (r = t.length - e), B3(r, e, t.length), N3(t, e, r);
  }
});
var b1 = k((Mt) => {
  U();
  Mt.randomBytes = Mt.rng = Mt.pseudoRandomBytes = Mt.prng = bs();
  Mt.createHash = Mt.Hash = Wo();
  Mt.createHmac = Mt.Hmac = qp();
  var AF = t2(), EF = Object.keys(AF), SF = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(EF);
  Mt.getHashes = function() {
    return SF;
  };
  var O3 = Yp();
  Mt.pbkdf2 = O3.pbkdf2;
  Mt.pbkdf2Sync = O3.pbkdf2Sync;
  var Wi = Aw();
  Mt.Cipher = Wi.Cipher;
  Mt.createCipher = Wi.createCipher;
  Mt.Cipheriv = Wi.Cipheriv;
  Mt.createCipheriv = Wi.createCipheriv;
  Mt.Decipher = Wi.Decipher;
  Mt.createDecipher = Wi.createDecipher;
  Mt.Decipheriv = Wi.Decipheriv;
  Mt.createDecipheriv = Wi.createDecipheriv;
  Mt.getCiphers = Wi.getCiphers;
  Mt.listCiphers = Wi.listCiphers;
  var Ec = Ow();
  Mt.DiffieHellmanGroup = Ec.DiffieHellmanGroup;
  Mt.createDiffieHellmanGroup = Ec.createDiffieHellmanGroup;
  Mt.getDiffieHellman = Ec.getDiffieHellman;
  Mt.createDiffieHellman = Ec.createDiffieHellman;
  Mt.DiffieHellman = Ec.DiffieHellman;
  var Ih = c3();
  Mt.createSign = Ih.createSign;
  Mt.Sign = Ih.Sign;
  Mt.createVerify = Ih.createVerify;
  Mt.Verify = Ih.Verify;
  Mt.createECDH = d3();
  var Th = S3();
  Mt.publicEncrypt = Th.publicEncrypt;
  Mt.privateEncrypt = Th.privateEncrypt;
  Mt.publicDecrypt = Th.publicDecrypt;
  Mt.privateDecrypt = Th.privateDecrypt;
  var j3 = C3();
  Mt.randomFill = j3.randomFill;
  Mt.randomFillSync = j3.randomFillSync;
  Mt.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  };
  Mt.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
});
var L3 = k((eC, Fh) => {
  U();
  (function(t) {
    var e = function(S2) {
      var D2, k2 = new Float64Array(16);
      if (S2)
        for (D2 = 0; D2 < S2.length; D2++)
          k2[D2] = S2[D2];
      return k2;
    }, r = function() {
      throw new Error("no PRNG");
    }, i = new Uint8Array(16), n = new Uint8Array(32);
    n[0] = 9;
    var s2 = e(), o = e([1]), f = e([56129, 1]), l = e([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), m3 = e([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), A2 = e([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), F3 = e([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), z3 = e([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function V(S2, D2, k2, g) {
      S2[D2] = k2 >> 24 & 255, S2[D2 + 1] = k2 >> 16 & 255, S2[D2 + 2] = k2 >> 8 & 255, S2[D2 + 3] = k2 & 255, S2[D2 + 4] = g >> 24 & 255, S2[D2 + 5] = g >> 16 & 255, S2[D2 + 6] = g >> 8 & 255, S2[D2 + 7] = g & 255;
    }
    function $(S2, D2, k2, g, O2) {
      var Q, he = 0;
      for (Q = 0; Q < O2; Q++)
        he |= S2[D2 + Q] ^ k2[g + Q];
      return (1 & he - 1 >>> 8) - 1;
    }
    function re(S2, D2, k2, g) {
      return $(S2, D2, k2, g, 16);
    }
    function W2(S2, D2, k2, g) {
      return $(S2, D2, k2, g, 32);
    }
    function Z2(S2, D2, k2, g) {
      for (var O2 = g[0] & 255 | (g[1] & 255) << 8 | (g[2] & 255) << 16 | (g[3] & 255) << 24, Q = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, he = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, ye = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, Ae = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, Ye = g[4] & 255 | (g[5] & 255) << 8 | (g[6] & 255) << 16 | (g[7] & 255) << 24, Ne2 = D2[0] & 255 | (D2[1] & 255) << 8 | (D2[2] & 255) << 16 | (D2[3] & 255) << 24, rt = D2[4] & 255 | (D2[5] & 255) << 8 | (D2[6] & 255) << 16 | (D2[7] & 255) << 24, $e = D2[8] & 255 | (D2[9] & 255) << 8 | (D2[10] & 255) << 16 | (D2[11] & 255) << 24, nt = D2[12] & 255 | (D2[13] & 255) << 8 | (D2[14] & 255) << 16 | (D2[15] & 255) << 24, st = g[8] & 255 | (g[9] & 255) << 8 | (g[10] & 255) << 16 | (g[11] & 255) << 24, lt = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, dt = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, ot = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, ft = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, at = g[12] & 255 | (g[13] & 255) << 8 | (g[14] & 255) << 16 | (g[15] & 255) << 24, Ke = O2, Je = Q, ze = he, We = ye, Ve = Ae, qe = Ye, ve = Ne2, we = rt, De = $e, Te = nt, Fe = st, Ce = lt, ct2 = dt, vt = ot, _t = ft, wt = at, J2, It = 0; It < 20; It += 2)
        J2 = Ke + ct2 | 0, Ve ^= J2 << 7 | J2 >>> 32 - 7, J2 = Ve + Ke | 0, De ^= J2 << 9 | J2 >>> 32 - 9, J2 = De + Ve | 0, ct2 ^= J2 << 13 | J2 >>> 32 - 13, J2 = ct2 + De | 0, Ke ^= J2 << 18 | J2 >>> 32 - 18, J2 = qe + Je | 0, Te ^= J2 << 7 | J2 >>> 32 - 7, J2 = Te + qe | 0, vt ^= J2 << 9 | J2 >>> 32 - 9, J2 = vt + Te | 0, Je ^= J2 << 13 | J2 >>> 32 - 13, J2 = Je + vt | 0, qe ^= J2 << 18 | J2 >>> 32 - 18, J2 = Fe + ve | 0, _t ^= J2 << 7 | J2 >>> 32 - 7, J2 = _t + Fe | 0, ze ^= J2 << 9 | J2 >>> 32 - 9, J2 = ze + _t | 0, ve ^= J2 << 13 | J2 >>> 32 - 13, J2 = ve + ze | 0, Fe ^= J2 << 18 | J2 >>> 32 - 18, J2 = wt + Ce | 0, We ^= J2 << 7 | J2 >>> 32 - 7, J2 = We + wt | 0, we ^= J2 << 9 | J2 >>> 32 - 9, J2 = we + We | 0, Ce ^= J2 << 13 | J2 >>> 32 - 13, J2 = Ce + we | 0, wt ^= J2 << 18 | J2 >>> 32 - 18, J2 = Ke + We | 0, Je ^= J2 << 7 | J2 >>> 32 - 7, J2 = Je + Ke | 0, ze ^= J2 << 9 | J2 >>> 32 - 9, J2 = ze + Je | 0, We ^= J2 << 13 | J2 >>> 32 - 13, J2 = We + ze | 0, Ke ^= J2 << 18 | J2 >>> 32 - 18, J2 = qe + Ve | 0, ve ^= J2 << 7 | J2 >>> 32 - 7, J2 = ve + qe | 0, we ^= J2 << 9 | J2 >>> 32 - 9, J2 = we + ve | 0, Ve ^= J2 << 13 | J2 >>> 32 - 13, J2 = Ve + we | 0, qe ^= J2 << 18 | J2 >>> 32 - 18, J2 = Fe + Te | 0, Ce ^= J2 << 7 | J2 >>> 32 - 7, J2 = Ce + Fe | 0, De ^= J2 << 9 | J2 >>> 32 - 9, J2 = De + Ce | 0, Te ^= J2 << 13 | J2 >>> 32 - 13, J2 = Te + De | 0, Fe ^= J2 << 18 | J2 >>> 32 - 18, J2 = wt + _t | 0, ct2 ^= J2 << 7 | J2 >>> 32 - 7, J2 = ct2 + wt | 0, vt ^= J2 << 9 | J2 >>> 32 - 9, J2 = vt + ct2 | 0, _t ^= J2 << 13 | J2 >>> 32 - 13, J2 = _t + vt | 0, wt ^= J2 << 18 | J2 >>> 32 - 18;
      Ke = Ke + O2 | 0, Je = Je + Q | 0, ze = ze + he | 0, We = We + ye | 0, Ve = Ve + Ae | 0, qe = qe + Ye | 0, ve = ve + Ne2 | 0, we = we + rt | 0, De = De + $e | 0, Te = Te + nt | 0, Fe = Fe + st | 0, Ce = Ce + lt | 0, ct2 = ct2 + dt | 0, vt = vt + ot | 0, _t = _t + ft | 0, wt = wt + at | 0, S2[0] = Ke >>> 0 & 255, S2[1] = Ke >>> 8 & 255, S2[2] = Ke >>> 16 & 255, S2[3] = Ke >>> 24 & 255, S2[4] = Je >>> 0 & 255, S2[5] = Je >>> 8 & 255, S2[6] = Je >>> 16 & 255, S2[7] = Je >>> 24 & 255, S2[8] = ze >>> 0 & 255, S2[9] = ze >>> 8 & 255, S2[10] = ze >>> 16 & 255, S2[11] = ze >>> 24 & 255, S2[12] = We >>> 0 & 255, S2[13] = We >>> 8 & 255, S2[14] = We >>> 16 & 255, S2[15] = We >>> 24 & 255, S2[16] = Ve >>> 0 & 255, S2[17] = Ve >>> 8 & 255, S2[18] = Ve >>> 16 & 255, S2[19] = Ve >>> 24 & 255, S2[20] = qe >>> 0 & 255, S2[21] = qe >>> 8 & 255, S2[22] = qe >>> 16 & 255, S2[23] = qe >>> 24 & 255, S2[24] = ve >>> 0 & 255, S2[25] = ve >>> 8 & 255, S2[26] = ve >>> 16 & 255, S2[27] = ve >>> 24 & 255, S2[28] = we >>> 0 & 255, S2[29] = we >>> 8 & 255, S2[30] = we >>> 16 & 255, S2[31] = we >>> 24 & 255, S2[32] = De >>> 0 & 255, S2[33] = De >>> 8 & 255, S2[34] = De >>> 16 & 255, S2[35] = De >>> 24 & 255, S2[36] = Te >>> 0 & 255, S2[37] = Te >>> 8 & 255, S2[38] = Te >>> 16 & 255, S2[39] = Te >>> 24 & 255, S2[40] = Fe >>> 0 & 255, S2[41] = Fe >>> 8 & 255, S2[42] = Fe >>> 16 & 255, S2[43] = Fe >>> 24 & 255, S2[44] = Ce >>> 0 & 255, S2[45] = Ce >>> 8 & 255, S2[46] = Ce >>> 16 & 255, S2[47] = Ce >>> 24 & 255, S2[48] = ct2 >>> 0 & 255, S2[49] = ct2 >>> 8 & 255, S2[50] = ct2 >>> 16 & 255, S2[51] = ct2 >>> 24 & 255, S2[52] = vt >>> 0 & 255, S2[53] = vt >>> 8 & 255, S2[54] = vt >>> 16 & 255, S2[55] = vt >>> 24 & 255, S2[56] = _t >>> 0 & 255, S2[57] = _t >>> 8 & 255, S2[58] = _t >>> 16 & 255, S2[59] = _t >>> 24 & 255, S2[60] = wt >>> 0 & 255, S2[61] = wt >>> 8 & 255, S2[62] = wt >>> 16 & 255, S2[63] = wt >>> 24 & 255;
    }
    function ue(S2, D2, k2, g) {
      for (var O2 = g[0] & 255 | (g[1] & 255) << 8 | (g[2] & 255) << 16 | (g[3] & 255) << 24, Q = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, he = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, ye = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, Ae = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, Ye = g[4] & 255 | (g[5] & 255) << 8 | (g[6] & 255) << 16 | (g[7] & 255) << 24, Ne2 = D2[0] & 255 | (D2[1] & 255) << 8 | (D2[2] & 255) << 16 | (D2[3] & 255) << 24, rt = D2[4] & 255 | (D2[5] & 255) << 8 | (D2[6] & 255) << 16 | (D2[7] & 255) << 24, $e = D2[8] & 255 | (D2[9] & 255) << 8 | (D2[10] & 255) << 16 | (D2[11] & 255) << 24, nt = D2[12] & 255 | (D2[13] & 255) << 8 | (D2[14] & 255) << 16 | (D2[15] & 255) << 24, st = g[8] & 255 | (g[9] & 255) << 8 | (g[10] & 255) << 16 | (g[11] & 255) << 24, lt = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, dt = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, ot = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, ft = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, at = g[12] & 255 | (g[13] & 255) << 8 | (g[14] & 255) << 16 | (g[15] & 255) << 24, Ke = O2, Je = Q, ze = he, We = ye, Ve = Ae, qe = Ye, ve = Ne2, we = rt, De = $e, Te = nt, Fe = st, Ce = lt, ct2 = dt, vt = ot, _t = ft, wt = at, J2, It = 0; It < 20; It += 2)
        J2 = Ke + ct2 | 0, Ve ^= J2 << 7 | J2 >>> 32 - 7, J2 = Ve + Ke | 0, De ^= J2 << 9 | J2 >>> 32 - 9, J2 = De + Ve | 0, ct2 ^= J2 << 13 | J2 >>> 32 - 13, J2 = ct2 + De | 0, Ke ^= J2 << 18 | J2 >>> 32 - 18, J2 = qe + Je | 0, Te ^= J2 << 7 | J2 >>> 32 - 7, J2 = Te + qe | 0, vt ^= J2 << 9 | J2 >>> 32 - 9, J2 = vt + Te | 0, Je ^= J2 << 13 | J2 >>> 32 - 13, J2 = Je + vt | 0, qe ^= J2 << 18 | J2 >>> 32 - 18, J2 = Fe + ve | 0, _t ^= J2 << 7 | J2 >>> 32 - 7, J2 = _t + Fe | 0, ze ^= J2 << 9 | J2 >>> 32 - 9, J2 = ze + _t | 0, ve ^= J2 << 13 | J2 >>> 32 - 13, J2 = ve + ze | 0, Fe ^= J2 << 18 | J2 >>> 32 - 18, J2 = wt + Ce | 0, We ^= J2 << 7 | J2 >>> 32 - 7, J2 = We + wt | 0, we ^= J2 << 9 | J2 >>> 32 - 9, J2 = we + We | 0, Ce ^= J2 << 13 | J2 >>> 32 - 13, J2 = Ce + we | 0, wt ^= J2 << 18 | J2 >>> 32 - 18, J2 = Ke + We | 0, Je ^= J2 << 7 | J2 >>> 32 - 7, J2 = Je + Ke | 0, ze ^= J2 << 9 | J2 >>> 32 - 9, J2 = ze + Je | 0, We ^= J2 << 13 | J2 >>> 32 - 13, J2 = We + ze | 0, Ke ^= J2 << 18 | J2 >>> 32 - 18, J2 = qe + Ve | 0, ve ^= J2 << 7 | J2 >>> 32 - 7, J2 = ve + qe | 0, we ^= J2 << 9 | J2 >>> 32 - 9, J2 = we + ve | 0, Ve ^= J2 << 13 | J2 >>> 32 - 13, J2 = Ve + we | 0, qe ^= J2 << 18 | J2 >>> 32 - 18, J2 = Fe + Te | 0, Ce ^= J2 << 7 | J2 >>> 32 - 7, J2 = Ce + Fe | 0, De ^= J2 << 9 | J2 >>> 32 - 9, J2 = De + Ce | 0, Te ^= J2 << 13 | J2 >>> 32 - 13, J2 = Te + De | 0, Fe ^= J2 << 18 | J2 >>> 32 - 18, J2 = wt + _t | 0, ct2 ^= J2 << 7 | J2 >>> 32 - 7, J2 = ct2 + wt | 0, vt ^= J2 << 9 | J2 >>> 32 - 9, J2 = vt + ct2 | 0, _t ^= J2 << 13 | J2 >>> 32 - 13, J2 = _t + vt | 0, wt ^= J2 << 18 | J2 >>> 32 - 18;
      S2[0] = Ke >>> 0 & 255, S2[1] = Ke >>> 8 & 255, S2[2] = Ke >>> 16 & 255, S2[3] = Ke >>> 24 & 255, S2[4] = qe >>> 0 & 255, S2[5] = qe >>> 8 & 255, S2[6] = qe >>> 16 & 255, S2[7] = qe >>> 24 & 255, S2[8] = Fe >>> 0 & 255, S2[9] = Fe >>> 8 & 255, S2[10] = Fe >>> 16 & 255, S2[11] = Fe >>> 24 & 255, S2[12] = wt >>> 0 & 255, S2[13] = wt >>> 8 & 255, S2[14] = wt >>> 16 & 255, S2[15] = wt >>> 24 & 255, S2[16] = ve >>> 0 & 255, S2[17] = ve >>> 8 & 255, S2[18] = ve >>> 16 & 255, S2[19] = ve >>> 24 & 255, S2[20] = we >>> 0 & 255, S2[21] = we >>> 8 & 255, S2[22] = we >>> 16 & 255, S2[23] = we >>> 24 & 255, S2[24] = De >>> 0 & 255, S2[25] = De >>> 8 & 255, S2[26] = De >>> 16 & 255, S2[27] = De >>> 24 & 255, S2[28] = Te >>> 0 & 255, S2[29] = Te >>> 8 & 255, S2[30] = Te >>> 16 & 255, S2[31] = Te >>> 24 & 255;
    }
    function ge(S2, D2, k2, g) {
      Z2(S2, D2, k2, g);
    }
    function Se(S2, D2, k2, g) {
      ue(S2, D2, k2, g);
    }
    var pe2 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function H2(S2, D2, k2, g, O2, Q, he) {
      var ye = new Uint8Array(16), Ae = new Uint8Array(64), Ye, Ne2;
      for (Ne2 = 0; Ne2 < 16; Ne2++)
        ye[Ne2] = 0;
      for (Ne2 = 0; Ne2 < 8; Ne2++)
        ye[Ne2] = Q[Ne2];
      for (; O2 >= 64; ) {
        for (ge(Ae, ye, he, pe2), Ne2 = 0; Ne2 < 64; Ne2++)
          S2[D2 + Ne2] = k2[g + Ne2] ^ Ae[Ne2];
        for (Ye = 1, Ne2 = 8; Ne2 < 16; Ne2++)
          Ye = Ye + (ye[Ne2] & 255) | 0, ye[Ne2] = Ye & 255, Ye >>>= 8;
        O2 -= 64, D2 += 64, g += 64;
      }
      if (O2 > 0)
        for (ge(Ae, ye, he, pe2), Ne2 = 0; Ne2 < O2; Ne2++)
          S2[D2 + Ne2] = k2[g + Ne2] ^ Ae[Ne2];
      return 0;
    }
    function le(S2, D2, k2, g, O2) {
      var Q = new Uint8Array(16), he = new Uint8Array(64), ye, Ae;
      for (Ae = 0; Ae < 16; Ae++)
        Q[Ae] = 0;
      for (Ae = 0; Ae < 8; Ae++)
        Q[Ae] = g[Ae];
      for (; k2 >= 64; ) {
        for (ge(he, Q, O2, pe2), Ae = 0; Ae < 64; Ae++)
          S2[D2 + Ae] = he[Ae];
        for (ye = 1, Ae = 8; Ae < 16; Ae++)
          ye = ye + (Q[Ae] & 255) | 0, Q[Ae] = ye & 255, ye >>>= 8;
        k2 -= 64, D2 += 64;
      }
      if (k2 > 0)
        for (ge(he, Q, O2, pe2), Ae = 0; Ae < k2; Ae++)
          S2[D2 + Ae] = he[Ae];
      return 0;
    }
    function ie(S2, D2, k2, g, O2) {
      var Q = new Uint8Array(32);
      Se(Q, g, O2, pe2);
      for (var he = new Uint8Array(8), ye = 0; ye < 8; ye++)
        he[ye] = g[ye + 16];
      return le(S2, D2, k2, he, Q);
    }
    function se(S2, D2, k2, g, O2, Q, he) {
      var ye = new Uint8Array(32);
      Se(ye, Q, he, pe2);
      for (var Ae = new Uint8Array(8), Ye = 0; Ye < 8; Ye++)
        Ae[Ye] = Q[Ye + 16];
      return H2(S2, D2, k2, g, O2, Ae, ye);
    }
    var N3 = function(S2) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var D2, k2, g, O2, Q, he, ye, Ae;
      D2 = S2[0] & 255 | (S2[1] & 255) << 8, this.r[0] = D2 & 8191, k2 = S2[2] & 255 | (S2[3] & 255) << 8, this.r[1] = (D2 >>> 13 | k2 << 3) & 8191, g = S2[4] & 255 | (S2[5] & 255) << 8, this.r[2] = (k2 >>> 10 | g << 6) & 7939, O2 = S2[6] & 255 | (S2[7] & 255) << 8, this.r[3] = (g >>> 7 | O2 << 9) & 8191, Q = S2[8] & 255 | (S2[9] & 255) << 8, this.r[4] = (O2 >>> 4 | Q << 12) & 255, this.r[5] = Q >>> 1 & 8190, he = S2[10] & 255 | (S2[11] & 255) << 8, this.r[6] = (Q >>> 14 | he << 2) & 8191, ye = S2[12] & 255 | (S2[13] & 255) << 8, this.r[7] = (he >>> 11 | ye << 5) & 8065, Ae = S2[14] & 255 | (S2[15] & 255) << 8, this.r[8] = (ye >>> 8 | Ae << 8) & 8191, this.r[9] = Ae >>> 5 & 127, this.pad[0] = S2[16] & 255 | (S2[17] & 255) << 8, this.pad[1] = S2[18] & 255 | (S2[19] & 255) << 8, this.pad[2] = S2[20] & 255 | (S2[21] & 255) << 8, this.pad[3] = S2[22] & 255 | (S2[23] & 255) << 8, this.pad[4] = S2[24] & 255 | (S2[25] & 255) << 8, this.pad[5] = S2[26] & 255 | (S2[27] & 255) << 8, this.pad[6] = S2[28] & 255 | (S2[29] & 255) << 8, this.pad[7] = S2[30] & 255 | (S2[31] & 255) << 8;
    };
    N3.prototype.blocks = function(S2, D2, k2) {
      for (var g = this.fin ? 0 : 2048, O2, Q, he, ye, Ae, Ye, Ne2, rt, $e, nt, st, lt, dt, ot, ft, at, Ke, Je, ze, We = this.h[0], Ve = this.h[1], qe = this.h[2], ve = this.h[3], we = this.h[4], De = this.h[5], Te = this.h[6], Fe = this.h[7], Ce = this.h[8], ct2 = this.h[9], vt = this.r[0], _t = this.r[1], wt = this.r[2], J2 = this.r[3], It = this.r[4], jt = this.r[5], Lt = this.r[6], Et = this.r[7], Nt = this.r[8], Ct = this.r[9]; k2 >= 16; )
        O2 = S2[D2 + 0] & 255 | (S2[D2 + 1] & 255) << 8, We += O2 & 8191, Q = S2[D2 + 2] & 255 | (S2[D2 + 3] & 255) << 8, Ve += (O2 >>> 13 | Q << 3) & 8191, he = S2[D2 + 4] & 255 | (S2[D2 + 5] & 255) << 8, qe += (Q >>> 10 | he << 6) & 8191, ye = S2[D2 + 6] & 255 | (S2[D2 + 7] & 255) << 8, ve += (he >>> 7 | ye << 9) & 8191, Ae = S2[D2 + 8] & 255 | (S2[D2 + 9] & 255) << 8, we += (ye >>> 4 | Ae << 12) & 8191, De += Ae >>> 1 & 8191, Ye = S2[D2 + 10] & 255 | (S2[D2 + 11] & 255) << 8, Te += (Ae >>> 14 | Ye << 2) & 8191, Ne2 = S2[D2 + 12] & 255 | (S2[D2 + 13] & 255) << 8, Fe += (Ye >>> 11 | Ne2 << 5) & 8191, rt = S2[D2 + 14] & 255 | (S2[D2 + 15] & 255) << 8, Ce += (Ne2 >>> 8 | rt << 8) & 8191, ct2 += rt >>> 5 | g, $e = 0, nt = $e, nt += We * vt, nt += Ve * (5 * Ct), nt += qe * (5 * Nt), nt += ve * (5 * Et), nt += we * (5 * Lt), $e = nt >>> 13, nt &= 8191, nt += De * (5 * jt), nt += Te * (5 * It), nt += Fe * (5 * J2), nt += Ce * (5 * wt), nt += ct2 * (5 * _t), $e += nt >>> 13, nt &= 8191, st = $e, st += We * _t, st += Ve * vt, st += qe * (5 * Ct), st += ve * (5 * Nt), st += we * (5 * Et), $e = st >>> 13, st &= 8191, st += De * (5 * Lt), st += Te * (5 * jt), st += Fe * (5 * It), st += Ce * (5 * J2), st += ct2 * (5 * wt), $e += st >>> 13, st &= 8191, lt = $e, lt += We * wt, lt += Ve * _t, lt += qe * vt, lt += ve * (5 * Ct), lt += we * (5 * Nt), $e = lt >>> 13, lt &= 8191, lt += De * (5 * Et), lt += Te * (5 * Lt), lt += Fe * (5 * jt), lt += Ce * (5 * It), lt += ct2 * (5 * J2), $e += lt >>> 13, lt &= 8191, dt = $e, dt += We * J2, dt += Ve * wt, dt += qe * _t, dt += ve * vt, dt += we * (5 * Ct), $e = dt >>> 13, dt &= 8191, dt += De * (5 * Nt), dt += Te * (5 * Et), dt += Fe * (5 * Lt), dt += Ce * (5 * jt), dt += ct2 * (5 * It), $e += dt >>> 13, dt &= 8191, ot = $e, ot += We * It, ot += Ve * J2, ot += qe * wt, ot += ve * _t, ot += we * vt, $e = ot >>> 13, ot &= 8191, ot += De * (5 * Ct), ot += Te * (5 * Nt), ot += Fe * (5 * Et), ot += Ce * (5 * Lt), ot += ct2 * (5 * jt), $e += ot >>> 13, ot &= 8191, ft = $e, ft += We * jt, ft += Ve * It, ft += qe * J2, ft += ve * wt, ft += we * _t, $e = ft >>> 13, ft &= 8191, ft += De * vt, ft += Te * (5 * Ct), ft += Fe * (5 * Nt), ft += Ce * (5 * Et), ft += ct2 * (5 * Lt), $e += ft >>> 13, ft &= 8191, at = $e, at += We * Lt, at += Ve * jt, at += qe * It, at += ve * J2, at += we * wt, $e = at >>> 13, at &= 8191, at += De * _t, at += Te * vt, at += Fe * (5 * Ct), at += Ce * (5 * Nt), at += ct2 * (5 * Et), $e += at >>> 13, at &= 8191, Ke = $e, Ke += We * Et, Ke += Ve * Lt, Ke += qe * jt, Ke += ve * It, Ke += we * J2, $e = Ke >>> 13, Ke &= 8191, Ke += De * wt, Ke += Te * _t, Ke += Fe * vt, Ke += Ce * (5 * Ct), Ke += ct2 * (5 * Nt), $e += Ke >>> 13, Ke &= 8191, Je = $e, Je += We * Nt, Je += Ve * Et, Je += qe * Lt, Je += ve * jt, Je += we * It, $e = Je >>> 13, Je &= 8191, Je += De * J2, Je += Te * wt, Je += Fe * _t, Je += Ce * vt, Je += ct2 * (5 * Ct), $e += Je >>> 13, Je &= 8191, ze = $e, ze += We * Ct, ze += Ve * Nt, ze += qe * Et, ze += ve * Lt, ze += we * jt, $e = ze >>> 13, ze &= 8191, ze += De * It, ze += Te * J2, ze += Fe * wt, ze += Ce * _t, ze += ct2 * vt, $e += ze >>> 13, ze &= 8191, $e = ($e << 2) + $e | 0, $e = $e + nt | 0, nt = $e & 8191, $e = $e >>> 13, st += $e, We = nt, Ve = st, qe = lt, ve = dt, we = ot, De = ft, Te = at, Fe = Ke, Ce = Je, ct2 = ze, D2 += 16, k2 -= 16;
      this.h[0] = We, this.h[1] = Ve, this.h[2] = qe, this.h[3] = ve, this.h[4] = we, this.h[5] = De, this.h[6] = Te, this.h[7] = Fe, this.h[8] = Ce, this.h[9] = ct2;
    }, N3.prototype.finish = function(S2, D2) {
      var k2 = new Uint16Array(10), g, O2, Q, he;
      if (this.leftover) {
        for (he = this.leftover, this.buffer[he++] = 1; he < 16; he++)
          this.buffer[he] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (g = this.h[1] >>> 13, this.h[1] &= 8191, he = 2; he < 10; he++)
        this.h[he] += g, g = this.h[he] >>> 13, this.h[he] &= 8191;
      for (this.h[0] += g * 5, g = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += g, g = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += g, k2[0] = this.h[0] + 5, g = k2[0] >>> 13, k2[0] &= 8191, he = 1; he < 10; he++)
        k2[he] = this.h[he] + g, g = k2[he] >>> 13, k2[he] &= 8191;
      for (k2[9] -= 1 << 13, O2 = (g ^ 1) - 1, he = 0; he < 10; he++)
        k2[he] &= O2;
      for (O2 = ~O2, he = 0; he < 10; he++)
        this.h[he] = this.h[he] & O2 | k2[he];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Q = this.h[0] + this.pad[0], this.h[0] = Q & 65535, he = 1; he < 8; he++)
        Q = (this.h[he] + this.pad[he] | 0) + (Q >>> 16) | 0, this.h[he] = Q & 65535;
      S2[D2 + 0] = this.h[0] >>> 0 & 255, S2[D2 + 1] = this.h[0] >>> 8 & 255, S2[D2 + 2] = this.h[1] >>> 0 & 255, S2[D2 + 3] = this.h[1] >>> 8 & 255, S2[D2 + 4] = this.h[2] >>> 0 & 255, S2[D2 + 5] = this.h[2] >>> 8 & 255, S2[D2 + 6] = this.h[3] >>> 0 & 255, S2[D2 + 7] = this.h[3] >>> 8 & 255, S2[D2 + 8] = this.h[4] >>> 0 & 255, S2[D2 + 9] = this.h[4] >>> 8 & 255, S2[D2 + 10] = this.h[5] >>> 0 & 255, S2[D2 + 11] = this.h[5] >>> 8 & 255, S2[D2 + 12] = this.h[6] >>> 0 & 255, S2[D2 + 13] = this.h[6] >>> 8 & 255, S2[D2 + 14] = this.h[7] >>> 0 & 255, S2[D2 + 15] = this.h[7] >>> 8 & 255;
    }, N3.prototype.update = function(S2, D2, k2) {
      var g, O2;
      if (this.leftover) {
        for (O2 = 16 - this.leftover, O2 > k2 && (O2 = k2), g = 0; g < O2; g++)
          this.buffer[this.leftover + g] = S2[D2 + g];
        if (k2 -= O2, D2 += O2, this.leftover += O2, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (k2 >= 16 && (O2 = k2 - k2 % 16, this.blocks(S2, D2, O2), D2 += O2, k2 -= O2), k2) {
        for (g = 0; g < k2; g++)
          this.buffer[this.leftover + g] = S2[D2 + g];
        this.leftover += k2;
      }
    };
    function c2(S2, D2, k2, g, O2, Q) {
      var he = new N3(Q);
      return he.update(k2, g, O2), he.finish(S2, D2), 0;
    }
    function p2(S2, D2, k2, g, O2, Q) {
      var he = new Uint8Array(16);
      return c2(he, 0, k2, g, O2, Q), re(S2, D2, he, 0);
    }
    function h2(S2, D2, k2, g, O2) {
      var Q;
      if (k2 < 32)
        return -1;
      for (se(S2, 0, D2, 0, k2, g, O2), c2(S2, 16, S2, 32, k2 - 32, S2), Q = 0; Q < 16; Q++)
        S2[Q] = 0;
      return 0;
    }
    function a(S2, D2, k2, g, O2) {
      var Q, he = new Uint8Array(32);
      if (k2 < 32 || (ie(he, 0, 32, g, O2), p2(D2, 16, D2, 32, k2 - 32, he) !== 0))
        return -1;
      for (se(S2, 0, D2, 0, k2, g, O2), Q = 0; Q < 32; Q++)
        S2[Q] = 0;
      return 0;
    }
    function d2(S2, D2) {
      var k2;
      for (k2 = 0; k2 < 16; k2++)
        S2[k2] = D2[k2] | 0;
    }
    function b2(S2) {
      var D2, k2, g = 1;
      for (D2 = 0; D2 < 16; D2++)
        k2 = S2[D2] + g + 65535, g = Math.floor(k2 / 65536), S2[D2] = k2 - g * 65536;
      S2[0] += g - 1 + 37 * (g - 1);
    }
    function _2(S2, D2, k2) {
      for (var g, O2 = ~(k2 - 1), Q = 0; Q < 16; Q++)
        g = O2 & (S2[Q] ^ D2[Q]), S2[Q] ^= g, D2[Q] ^= g;
    }
    function v(S2, D2) {
      var k2, g, O2, Q = e(), he = e();
      for (k2 = 0; k2 < 16; k2++)
        he[k2] = D2[k2];
      for (b2(he), b2(he), b2(he), g = 0; g < 2; g++) {
        for (Q[0] = he[0] - 65517, k2 = 1; k2 < 15; k2++)
          Q[k2] = he[k2] - 65535 - (Q[k2 - 1] >> 16 & 1), Q[k2 - 1] &= 65535;
        Q[15] = he[15] - 32767 - (Q[14] >> 16 & 1), O2 = Q[15] >> 16 & 1, Q[14] &= 65535, _2(he, Q, 1 - O2);
      }
      for (k2 = 0; k2 < 16; k2++)
        S2[2 * k2] = he[k2] & 255, S2[2 * k2 + 1] = he[k2] >> 8;
    }
    function u(S2, D2) {
      var k2 = new Uint8Array(32), g = new Uint8Array(32);
      return v(k2, S2), v(g, D2), W2(k2, 0, g, 0);
    }
    function E2(S2) {
      var D2 = new Uint8Array(32);
      return v(D2, S2), D2[0] & 1;
    }
    function B(S2, D2) {
      var k2;
      for (k2 = 0; k2 < 16; k2++)
        S2[k2] = D2[2 * k2] + (D2[2 * k2 + 1] << 8);
      S2[15] &= 32767;
    }
    function y2(S2, D2, k2) {
      for (var g = 0; g < 16; g++)
        S2[g] = D2[g] + k2[g];
    }
    function M(S2, D2, k2) {
      for (var g = 0; g < 16; g++)
        S2[g] = D2[g] - k2[g];
    }
    function de2(S2, D2, k2) {
      var g, O2, Q = 0, he = 0, ye = 0, Ae = 0, Ye = 0, Ne2 = 0, rt = 0, $e = 0, nt = 0, st = 0, lt = 0, dt = 0, ot = 0, ft = 0, at = 0, Ke = 0, Je = 0, ze = 0, We = 0, Ve = 0, qe = 0, ve = 0, we = 0, De = 0, Te = 0, Fe = 0, Ce = 0, ct2 = 0, vt = 0, _t = 0, wt = 0, J2 = k2[0], It = k2[1], jt = k2[2], Lt = k2[3], Et = k2[4], Nt = k2[5], Ct = k2[6], fr2 = k2[7], Gt = k2[8], ir = k2[9], nr = k2[10], sr = k2[11], ur2 = k2[12], Ar = k2[13], Er = k2[14], Sr2 = k2[15];
      g = D2[0], Q += g * J2, he += g * It, ye += g * jt, Ae += g * Lt, Ye += g * Et, Ne2 += g * Nt, rt += g * Ct, $e += g * fr2, nt += g * Gt, st += g * ir, lt += g * nr, dt += g * sr, ot += g * ur2, ft += g * Ar, at += g * Er, Ke += g * Sr2, g = D2[1], he += g * J2, ye += g * It, Ae += g * jt, Ye += g * Lt, Ne2 += g * Et, rt += g * Nt, $e += g * Ct, nt += g * fr2, st += g * Gt, lt += g * ir, dt += g * nr, ot += g * sr, ft += g * ur2, at += g * Ar, Ke += g * Er, Je += g * Sr2, g = D2[2], ye += g * J2, Ae += g * It, Ye += g * jt, Ne2 += g * Lt, rt += g * Et, $e += g * Nt, nt += g * Ct, st += g * fr2, lt += g * Gt, dt += g * ir, ot += g * nr, ft += g * sr, at += g * ur2, Ke += g * Ar, Je += g * Er, ze += g * Sr2, g = D2[3], Ae += g * J2, Ye += g * It, Ne2 += g * jt, rt += g * Lt, $e += g * Et, nt += g * Nt, st += g * Ct, lt += g * fr2, dt += g * Gt, ot += g * ir, ft += g * nr, at += g * sr, Ke += g * ur2, Je += g * Ar, ze += g * Er, We += g * Sr2, g = D2[4], Ye += g * J2, Ne2 += g * It, rt += g * jt, $e += g * Lt, nt += g * Et, st += g * Nt, lt += g * Ct, dt += g * fr2, ot += g * Gt, ft += g * ir, at += g * nr, Ke += g * sr, Je += g * ur2, ze += g * Ar, We += g * Er, Ve += g * Sr2, g = D2[5], Ne2 += g * J2, rt += g * It, $e += g * jt, nt += g * Lt, st += g * Et, lt += g * Nt, dt += g * Ct, ot += g * fr2, ft += g * Gt, at += g * ir, Ke += g * nr, Je += g * sr, ze += g * ur2, We += g * Ar, Ve += g * Er, qe += g * Sr2, g = D2[6], rt += g * J2, $e += g * It, nt += g * jt, st += g * Lt, lt += g * Et, dt += g * Nt, ot += g * Ct, ft += g * fr2, at += g * Gt, Ke += g * ir, Je += g * nr, ze += g * sr, We += g * ur2, Ve += g * Ar, qe += g * Er, ve += g * Sr2, g = D2[7], $e += g * J2, nt += g * It, st += g * jt, lt += g * Lt, dt += g * Et, ot += g * Nt, ft += g * Ct, at += g * fr2, Ke += g * Gt, Je += g * ir, ze += g * nr, We += g * sr, Ve += g * ur2, qe += g * Ar, ve += g * Er, we += g * Sr2, g = D2[8], nt += g * J2, st += g * It, lt += g * jt, dt += g * Lt, ot += g * Et, ft += g * Nt, at += g * Ct, Ke += g * fr2, Je += g * Gt, ze += g * ir, We += g * nr, Ve += g * sr, qe += g * ur2, ve += g * Ar, we += g * Er, De += g * Sr2, g = D2[9], st += g * J2, lt += g * It, dt += g * jt, ot += g * Lt, ft += g * Et, at += g * Nt, Ke += g * Ct, Je += g * fr2, ze += g * Gt, We += g * ir, Ve += g * nr, qe += g * sr, ve += g * ur2, we += g * Ar, De += g * Er, Te += g * Sr2, g = D2[10], lt += g * J2, dt += g * It, ot += g * jt, ft += g * Lt, at += g * Et, Ke += g * Nt, Je += g * Ct, ze += g * fr2, We += g * Gt, Ve += g * ir, qe += g * nr, ve += g * sr, we += g * ur2, De += g * Ar, Te += g * Er, Fe += g * Sr2, g = D2[11], dt += g * J2, ot += g * It, ft += g * jt, at += g * Lt, Ke += g * Et, Je += g * Nt, ze += g * Ct, We += g * fr2, Ve += g * Gt, qe += g * ir, ve += g * nr, we += g * sr, De += g * ur2, Te += g * Ar, Fe += g * Er, Ce += g * Sr2, g = D2[12], ot += g * J2, ft += g * It, at += g * jt, Ke += g * Lt, Je += g * Et, ze += g * Nt, We += g * Ct, Ve += g * fr2, qe += g * Gt, ve += g * ir, we += g * nr, De += g * sr, Te += g * ur2, Fe += g * Ar, Ce += g * Er, ct2 += g * Sr2, g = D2[13], ft += g * J2, at += g * It, Ke += g * jt, Je += g * Lt, ze += g * Et, We += g * Nt, Ve += g * Ct, qe += g * fr2, ve += g * Gt, we += g * ir, De += g * nr, Te += g * sr, Fe += g * ur2, Ce += g * Ar, ct2 += g * Er, vt += g * Sr2, g = D2[14], at += g * J2, Ke += g * It, Je += g * jt, ze += g * Lt, We += g * Et, Ve += g * Nt, qe += g * Ct, ve += g * fr2, we += g * Gt, De += g * ir, Te += g * nr, Fe += g * sr, Ce += g * ur2, ct2 += g * Ar, vt += g * Er, _t += g * Sr2, g = D2[15], Ke += g * J2, Je += g * It, ze += g * jt, We += g * Lt, Ve += g * Et, qe += g * Nt, ve += g * Ct, we += g * fr2, De += g * Gt, Te += g * ir, Fe += g * nr, Ce += g * sr, ct2 += g * ur2, vt += g * Ar, _t += g * Er, wt += g * Sr2, Q += 38 * Je, he += 38 * ze, ye += 38 * We, Ae += 38 * Ve, Ye += 38 * qe, Ne2 += 38 * ve, rt += 38 * we, $e += 38 * De, nt += 38 * Te, st += 38 * Fe, lt += 38 * Ce, dt += 38 * ct2, ot += 38 * vt, ft += 38 * _t, at += 38 * wt, O2 = 1, g = Q + O2 + 65535, O2 = Math.floor(g / 65536), Q = g - O2 * 65536, g = he + O2 + 65535, O2 = Math.floor(g / 65536), he = g - O2 * 65536, g = ye + O2 + 65535, O2 = Math.floor(g / 65536), ye = g - O2 * 65536, g = Ae + O2 + 65535, O2 = Math.floor(g / 65536), Ae = g - O2 * 65536, g = Ye + O2 + 65535, O2 = Math.floor(g / 65536), Ye = g - O2 * 65536, g = Ne2 + O2 + 65535, O2 = Math.floor(g / 65536), Ne2 = g - O2 * 65536, g = rt + O2 + 65535, O2 = Math.floor(g / 65536), rt = g - O2 * 65536, g = $e + O2 + 65535, O2 = Math.floor(g / 65536), $e = g - O2 * 65536, g = nt + O2 + 65535, O2 = Math.floor(g / 65536), nt = g - O2 * 65536, g = st + O2 + 65535, O2 = Math.floor(g / 65536), st = g - O2 * 65536, g = lt + O2 + 65535, O2 = Math.floor(g / 65536), lt = g - O2 * 65536, g = dt + O2 + 65535, O2 = Math.floor(g / 65536), dt = g - O2 * 65536, g = ot + O2 + 65535, O2 = Math.floor(g / 65536), ot = g - O2 * 65536, g = ft + O2 + 65535, O2 = Math.floor(g / 65536), ft = g - O2 * 65536, g = at + O2 + 65535, O2 = Math.floor(g / 65536), at = g - O2 * 65536, g = Ke + O2 + 65535, O2 = Math.floor(g / 65536), Ke = g - O2 * 65536, Q += O2 - 1 + 37 * (O2 - 1), O2 = 1, g = Q + O2 + 65535, O2 = Math.floor(g / 65536), Q = g - O2 * 65536, g = he + O2 + 65535, O2 = Math.floor(g / 65536), he = g - O2 * 65536, g = ye + O2 + 65535, O2 = Math.floor(g / 65536), ye = g - O2 * 65536, g = Ae + O2 + 65535, O2 = Math.floor(g / 65536), Ae = g - O2 * 65536, g = Ye + O2 + 65535, O2 = Math.floor(g / 65536), Ye = g - O2 * 65536, g = Ne2 + O2 + 65535, O2 = Math.floor(g / 65536), Ne2 = g - O2 * 65536, g = rt + O2 + 65535, O2 = Math.floor(g / 65536), rt = g - O2 * 65536, g = $e + O2 + 65535, O2 = Math.floor(g / 65536), $e = g - O2 * 65536, g = nt + O2 + 65535, O2 = Math.floor(g / 65536), nt = g - O2 * 65536, g = st + O2 + 65535, O2 = Math.floor(g / 65536), st = g - O2 * 65536, g = lt + O2 + 65535, O2 = Math.floor(g / 65536), lt = g - O2 * 65536, g = dt + O2 + 65535, O2 = Math.floor(g / 65536), dt = g - O2 * 65536, g = ot + O2 + 65535, O2 = Math.floor(g / 65536), ot = g - O2 * 65536, g = ft + O2 + 65535, O2 = Math.floor(g / 65536), ft = g - O2 * 65536, g = at + O2 + 65535, O2 = Math.floor(g / 65536), at = g - O2 * 65536, g = Ke + O2 + 65535, O2 = Math.floor(g / 65536), Ke = g - O2 * 65536, Q += O2 - 1 + 37 * (O2 - 1), S2[0] = Q, S2[1] = he, S2[2] = ye, S2[3] = Ae, S2[4] = Ye, S2[5] = Ne2, S2[6] = rt, S2[7] = $e, S2[8] = nt, S2[9] = st, S2[10] = lt, S2[11] = dt, S2[12] = ot, S2[13] = ft, S2[14] = at, S2[15] = Ke;
    }
    function Ee(S2, D2) {
      de2(S2, D2, D2);
    }
    function Me(S2, D2) {
      var k2 = e(), g;
      for (g = 0; g < 16; g++)
        k2[g] = D2[g];
      for (g = 253; g >= 0; g--)
        Ee(k2, k2), g !== 2 && g !== 4 && de2(k2, k2, D2);
      for (g = 0; g < 16; g++)
        S2[g] = k2[g];
    }
    function Oe(S2, D2) {
      var k2 = e(), g;
      for (g = 0; g < 16; g++)
        k2[g] = D2[g];
      for (g = 250; g >= 0; g--)
        Ee(k2, k2), g !== 1 && de2(k2, k2, D2);
      for (g = 0; g < 16; g++)
        S2[g] = k2[g];
    }
    function be(S2, D2, k2) {
      var g = new Uint8Array(32), O2 = new Float64Array(80), Q, he, ye = e(), Ae = e(), Ye = e(), Ne2 = e(), rt = e(), $e = e();
      for (he = 0; he < 31; he++)
        g[he] = D2[he];
      for (g[31] = D2[31] & 127 | 64, g[0] &= 248, B(O2, k2), he = 0; he < 16; he++)
        Ae[he] = O2[he], Ne2[he] = ye[he] = Ye[he] = 0;
      for (ye[0] = Ne2[0] = 1, he = 254; he >= 0; --he)
        Q = g[he >>> 3] >>> (he & 7) & 1, _2(ye, Ae, Q), _2(Ye, Ne2, Q), y2(rt, ye, Ye), M(ye, ye, Ye), y2(Ye, Ae, Ne2), M(Ae, Ae, Ne2), Ee(Ne2, rt), Ee($e, ye), de2(ye, Ye, ye), de2(Ye, Ae, rt), y2(rt, ye, Ye), M(ye, ye, Ye), Ee(Ae, ye), M(Ye, Ne2, $e), de2(ye, Ye, f), y2(ye, ye, Ne2), de2(Ye, Ye, ye), de2(ye, Ne2, $e), de2(Ne2, Ae, O2), Ee(Ae, rt), _2(ye, Ae, Q), _2(Ye, Ne2, Q);
      for (he = 0; he < 16; he++)
        O2[he + 16] = ye[he], O2[he + 32] = Ye[he], O2[he + 48] = Ae[he], O2[he + 64] = Ne2[he];
      var nt = O2.subarray(32), st = O2.subarray(16);
      return Me(nt, nt), de2(st, st, nt), v(S2, st), 0;
    }
    function I(S2, D2) {
      return be(S2, D2, n);
    }
    function j3(S2, D2) {
      return r(D2, 32), I(S2, D2);
    }
    function P5(S2, D2, k2) {
      var g = new Uint8Array(32);
      return be(g, k2, D2), Se(S2, i, g, pe2);
    }
    var ee2 = h2, oe = a;
    function te(S2, D2, k2, g, O2, Q) {
      var he = new Uint8Array(32);
      return P5(he, O2, Q), ee2(S2, D2, k2, g, he);
    }
    function ae(S2, D2, k2, g, O2, Q) {
      var he = new Uint8Array(32);
      return P5(he, O2, Q), oe(S2, D2, k2, g, he);
    }
    var ne = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function X2(S2, D2, k2, g) {
      for (var O2 = new Int32Array(16), Q = new Int32Array(16), he, ye, Ae, Ye, Ne2, rt, $e, nt, st, lt, dt, ot, ft, at, Ke, Je, ze, We, Ve, qe, ve, we, De, Te, Fe, Ce, ct2 = S2[0], vt = S2[1], _t = S2[2], wt = S2[3], J2 = S2[4], It = S2[5], jt = S2[6], Lt = S2[7], Et = D2[0], Nt = D2[1], Ct = D2[2], fr2 = D2[3], Gt = D2[4], ir = D2[5], nr = D2[6], sr = D2[7], ur2 = 0; g >= 128; ) {
        for (Ve = 0; Ve < 16; Ve++)
          qe = 8 * Ve + ur2, O2[Ve] = k2[qe + 0] << 24 | k2[qe + 1] << 16 | k2[qe + 2] << 8 | k2[qe + 3], Q[Ve] = k2[qe + 4] << 24 | k2[qe + 5] << 16 | k2[qe + 6] << 8 | k2[qe + 7];
        for (Ve = 0; Ve < 80; Ve++)
          if (he = ct2, ye = vt, Ae = _t, Ye = wt, Ne2 = J2, rt = It, $e = jt, nt = Lt, st = Et, lt = Nt, dt = Ct, ot = fr2, ft = Gt, at = ir, Ke = nr, Je = sr, ve = Lt, we = sr, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = (J2 >>> 14 | Gt << 32 - 14) ^ (J2 >>> 18 | Gt << 32 - 18) ^ (Gt >>> 41 - 32 | J2 << 32 - (41 - 32)), we = (Gt >>> 14 | J2 << 32 - 14) ^ (Gt >>> 18 | J2 << 32 - 18) ^ (J2 >>> 41 - 32 | Gt << 32 - (41 - 32)), De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, ve = J2 & It ^ ~J2 & jt, we = Gt & ir ^ ~Gt & nr, De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, ve = ne[Ve * 2], we = ne[Ve * 2 + 1], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, ve = O2[Ve % 16], we = Q[Ve % 16], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, ze = Fe & 65535 | Ce << 16, We = De & 65535 | Te << 16, ve = ze, we = We, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = (ct2 >>> 28 | Et << 32 - 28) ^ (Et >>> 34 - 32 | ct2 << 32 - (34 - 32)) ^ (Et >>> 39 - 32 | ct2 << 32 - (39 - 32)), we = (Et >>> 28 | ct2 << 32 - 28) ^ (ct2 >>> 34 - 32 | Et << 32 - (34 - 32)) ^ (ct2 >>> 39 - 32 | Et << 32 - (39 - 32)), De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, ve = ct2 & vt ^ ct2 & _t ^ vt & _t, we = Et & Nt ^ Et & Ct ^ Nt & Ct, De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, nt = Fe & 65535 | Ce << 16, Je = De & 65535 | Te << 16, ve = Ye, we = ot, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = ze, we = We, De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, Ye = Fe & 65535 | Ce << 16, ot = De & 65535 | Te << 16, vt = he, _t = ye, wt = Ae, J2 = Ye, It = Ne2, jt = rt, Lt = $e, ct2 = nt, Nt = st, Ct = lt, fr2 = dt, Gt = ot, ir = ft, nr = at, sr = Ke, Et = Je, Ve % 16 === 15)
            for (qe = 0; qe < 16; qe++)
              ve = O2[qe], we = Q[qe], De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = O2[(qe + 9) % 16], we = Q[(qe + 9) % 16], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, ze = O2[(qe + 1) % 16], We = Q[(qe + 1) % 16], ve = (ze >>> 1 | We << 32 - 1) ^ (ze >>> 8 | We << 32 - 8) ^ ze >>> 7, we = (We >>> 1 | ze << 32 - 1) ^ (We >>> 8 | ze << 32 - 8) ^ (We >>> 7 | ze << 32 - 7), De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, ze = O2[(qe + 14) % 16], We = Q[(qe + 14) % 16], ve = (ze >>> 19 | We << 32 - 19) ^ (We >>> 61 - 32 | ze << 32 - (61 - 32)) ^ ze >>> 6, we = (We >>> 19 | ze << 32 - 19) ^ (ze >>> 61 - 32 | We << 32 - (61 - 32)) ^ (We >>> 6 | ze << 32 - 6), De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, O2[qe] = Fe & 65535 | Ce << 16, Q[qe] = De & 65535 | Te << 16;
        ve = ct2, we = Et, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[0], we = D2[0], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[0] = ct2 = Fe & 65535 | Ce << 16, D2[0] = Et = De & 65535 | Te << 16, ve = vt, we = Nt, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[1], we = D2[1], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[1] = vt = Fe & 65535 | Ce << 16, D2[1] = Nt = De & 65535 | Te << 16, ve = _t, we = Ct, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[2], we = D2[2], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[2] = _t = Fe & 65535 | Ce << 16, D2[2] = Ct = De & 65535 | Te << 16, ve = wt, we = fr2, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[3], we = D2[3], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[3] = wt = Fe & 65535 | Ce << 16, D2[3] = fr2 = De & 65535 | Te << 16, ve = J2, we = Gt, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[4], we = D2[4], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[4] = J2 = Fe & 65535 | Ce << 16, D2[4] = Gt = De & 65535 | Te << 16, ve = It, we = ir, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[5], we = D2[5], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[5] = It = Fe & 65535 | Ce << 16, D2[5] = ir = De & 65535 | Te << 16, ve = jt, we = nr, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[6], we = D2[6], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[6] = jt = Fe & 65535 | Ce << 16, D2[6] = nr = De & 65535 | Te << 16, ve = Lt, we = sr, De = we & 65535, Te = we >>> 16, Fe = ve & 65535, Ce = ve >>> 16, ve = S2[7], we = D2[7], De += we & 65535, Te += we >>> 16, Fe += ve & 65535, Ce += ve >>> 16, Te += De >>> 16, Fe += Te >>> 16, Ce += Fe >>> 16, S2[7] = Lt = Fe & 65535 | Ce << 16, D2[7] = sr = De & 65535 | Te << 16, ur2 += 128, g -= 128;
      }
      return g;
    }
    function R3(S2, D2, k2) {
      var g = new Int32Array(8), O2 = new Int32Array(8), Q = new Uint8Array(256), he, ye = k2;
      for (g[0] = 1779033703, g[1] = 3144134277, g[2] = 1013904242, g[3] = 2773480762, g[4] = 1359893119, g[5] = 2600822924, g[6] = 528734635, g[7] = 1541459225, O2[0] = 4089235720, O2[1] = 2227873595, O2[2] = 4271175723, O2[3] = 1595750129, O2[4] = 2917565137, O2[5] = 725511199, O2[6] = 4215389547, O2[7] = 327033209, X2(g, O2, D2, k2), k2 %= 128, he = 0; he < k2; he++)
        Q[he] = D2[ye - k2 + he];
      for (Q[k2] = 128, k2 = 256 - 128 * (k2 < 112 ? 1 : 0), Q[k2 - 9] = 0, V(Q, k2 - 8, ye / 536870912 | 0, ye << 3), X2(g, O2, Q, k2), he = 0; he < 8; he++)
        V(S2, 8 * he, g[he], O2[he]);
      return 0;
    }
    function w(S2, D2) {
      var k2 = e(), g = e(), O2 = e(), Q = e(), he = e(), ye = e(), Ae = e(), Ye = e(), Ne2 = e();
      M(k2, S2[1], S2[0]), M(Ne2, D2[1], D2[0]), de2(k2, k2, Ne2), y2(g, S2[0], S2[1]), y2(Ne2, D2[0], D2[1]), de2(g, g, Ne2), de2(O2, S2[3], D2[3]), de2(O2, O2, m3), de2(Q, S2[2], D2[2]), y2(Q, Q, Q), M(he, g, k2), M(ye, Q, O2), y2(Ae, Q, O2), y2(Ye, g, k2), de2(S2[0], he, ye), de2(S2[1], Ye, Ae), de2(S2[2], Ae, ye), de2(S2[3], he, Ye);
    }
    function T2(S2, D2, k2) {
      var g;
      for (g = 0; g < 4; g++)
        _2(S2[g], D2[g], k2);
    }
    function q2(S2, D2) {
      var k2 = e(), g = e(), O2 = e();
      Me(O2, D2[2]), de2(k2, D2[0], O2), de2(g, D2[1], O2), v(S2, g), S2[31] ^= E2(k2) << 7;
    }
    function L2(S2, D2, k2) {
      var g, O2;
      for (d2(S2[0], s2), d2(S2[1], o), d2(S2[2], o), d2(S2[3], s2), O2 = 255; O2 >= 0; --O2)
        g = k2[O2 / 8 | 0] >> (O2 & 7) & 1, T2(S2, D2, g), w(D2, S2), w(S2, S2), T2(S2, D2, g);
    }
    function G2(S2, D2) {
      var k2 = [e(), e(), e(), e()];
      d2(k2[0], A2), d2(k2[1], F3), d2(k2[2], o), de2(k2[3], A2, F3), L2(S2, k2, D2);
    }
    function K5(S2, D2, k2) {
      var g = new Uint8Array(64), O2 = [e(), e(), e(), e()], Q;
      for (k2 || r(D2, 32), R3(g, D2, 32), g[0] &= 248, g[31] &= 127, g[31] |= 64, G2(O2, g), q2(S2, O2), Q = 0; Q < 32; Q++)
        D2[Q + 32] = S2[Q];
      return 0;
    }
    var xe = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function me2(S2, D2) {
      var k2, g, O2, Q;
      for (g = 63; g >= 32; --g) {
        for (k2 = 0, O2 = g - 32, Q = g - 12; O2 < Q; ++O2)
          D2[O2] += k2 - 16 * D2[g] * xe[O2 - (g - 32)], k2 = Math.floor((D2[O2] + 128) / 256), D2[O2] -= k2 * 256;
        D2[O2] += k2, D2[g] = 0;
      }
      for (k2 = 0, O2 = 0; O2 < 32; O2++)
        D2[O2] += k2 - (D2[31] >> 4) * xe[O2], k2 = D2[O2] >> 8, D2[O2] &= 255;
      for (O2 = 0; O2 < 32; O2++)
        D2[O2] -= k2 * xe[O2];
      for (g = 0; g < 32; g++)
        D2[g + 1] += D2[g] >> 8, S2[g] = D2[g] & 255;
    }
    function _e2(S2) {
      var D2 = new Float64Array(64), k2;
      for (k2 = 0; k2 < 64; k2++)
        D2[k2] = S2[k2];
      for (k2 = 0; k2 < 64; k2++)
        S2[k2] = 0;
      me2(S2, D2);
    }
    function fe(S2, D2, k2, g) {
      var O2 = new Uint8Array(64), Q = new Uint8Array(64), he = new Uint8Array(64), ye, Ae, Ye = new Float64Array(64), Ne2 = [e(), e(), e(), e()];
      R3(O2, g, 32), O2[0] &= 248, O2[31] &= 127, O2[31] |= 64;
      var rt = k2 + 64;
      for (ye = 0; ye < k2; ye++)
        S2[64 + ye] = D2[ye];
      for (ye = 0; ye < 32; ye++)
        S2[32 + ye] = O2[32 + ye];
      for (R3(he, S2.subarray(32), k2 + 32), _e2(he), G2(Ne2, he), q2(S2, Ne2), ye = 32; ye < 64; ye++)
        S2[ye] = g[ye];
      for (R3(Q, S2, k2 + 64), _e2(Q), ye = 0; ye < 64; ye++)
        Ye[ye] = 0;
      for (ye = 0; ye < 32; ye++)
        Ye[ye] = he[ye];
      for (ye = 0; ye < 32; ye++)
        for (Ae = 0; Ae < 32; Ae++)
          Ye[ye + Ae] += Q[ye] * O2[Ae];
      return me2(S2.subarray(32), Ye), rt;
    }
    function ke(S2, D2) {
      var k2 = e(), g = e(), O2 = e(), Q = e(), he = e(), ye = e(), Ae = e();
      return d2(S2[2], o), B(S2[1], D2), Ee(O2, S2[1]), de2(Q, O2, l), M(O2, O2, S2[2]), y2(Q, S2[2], Q), Ee(he, Q), Ee(ye, he), de2(Ae, ye, he), de2(k2, Ae, O2), de2(k2, k2, Q), Oe(k2, k2), de2(k2, k2, O2), de2(k2, k2, Q), de2(k2, k2, Q), de2(S2[0], k2, Q), Ee(g, S2[0]), de2(g, g, Q), u(g, O2) && de2(S2[0], S2[0], z3), Ee(g, S2[0]), de2(g, g, Q), u(g, O2) ? -1 : (E2(S2[0]) === D2[31] >> 7 && M(S2[0], s2, S2[0]), de2(S2[3], S2[0], S2[1]), 0);
    }
    function Be(S2, D2, k2, g) {
      var O2, Q = new Uint8Array(32), he = new Uint8Array(64), ye = [e(), e(), e(), e()], Ae = [e(), e(), e(), e()];
      if (k2 < 64 || ke(Ae, g))
        return -1;
      for (O2 = 0; O2 < k2; O2++)
        S2[O2] = D2[O2];
      for (O2 = 0; O2 < 32; O2++)
        S2[O2 + 32] = g[O2];
      if (R3(he, S2, k2), _e2(he), L2(ye, Ae, he), G2(Ae, D2.subarray(32)), w(ye, Ae), q2(Q, ye), k2 -= 64, W2(D2, 0, Q, 0)) {
        for (O2 = 0; O2 < k2; O2++)
          S2[O2] = 0;
        return -1;
      }
      for (O2 = 0; O2 < k2; O2++)
        S2[O2] = D2[O2 + 64];
      return k2;
    }
    var gt = 32, je2 = 24, Ge = 32, xt = 16, Pe = 32, Le = 32, Zt = 32, Xe = 32, Qe = 32, er = je2, et = Ge, tt = xt, zt = 64, ht = 32, pt$1 = 64, nn = 32, mt = 64;
    t.lowlevel = { crypto_core_hsalsa20: Se, crypto_stream_xor: se, crypto_stream: ie, crypto_stream_salsa20_xor: H2, crypto_stream_salsa20: le, crypto_onetimeauth: c2, crypto_onetimeauth_verify: p2, crypto_verify_16: re, crypto_verify_32: W2, crypto_secretbox: h2, crypto_secretbox_open: a, crypto_scalarmult: be, crypto_scalarmult_base: I, crypto_box_beforenm: P5, crypto_box_afternm: ee2, crypto_box: te, crypto_box_open: ae, crypto_box_keypair: j3, crypto_hash: R3, crypto_sign: fe, crypto_sign_keypair: K5, crypto_sign_open: Be, crypto_secretbox_KEYBYTES: gt, crypto_secretbox_NONCEBYTES: je2, crypto_secretbox_ZEROBYTES: Ge, crypto_secretbox_BOXZEROBYTES: xt, crypto_scalarmult_BYTES: Pe, crypto_scalarmult_SCALARBYTES: Le, crypto_box_PUBLICKEYBYTES: Zt, crypto_box_SECRETKEYBYTES: Xe, crypto_box_BEFORENMBYTES: Qe, crypto_box_NONCEBYTES: er, crypto_box_ZEROBYTES: et, crypto_box_BOXZEROBYTES: tt, crypto_sign_BYTES: zt, crypto_sign_PUBLICKEYBYTES: ht, crypto_sign_SECRETKEYBYTES: pt$1, crypto_sign_SEEDBYTES: nn, crypto_hash_BYTES: mt, gf: e, D: l, L: xe, pack25519: v, unpack25519: B, M: de2, A: y2, S: Ee, Z: M, pow2523: Oe, add: w, set25519: d2, modL: me2, scalarmult: L2, scalarbase: G2 };
    function yt(S2, D2) {
      if (S2.length !== gt)
        throw new Error("bad key size");
      if (D2.length !== je2)
        throw new Error("bad nonce size");
    }
    function ms(S2, D2) {
      if (S2.length !== Zt)
        throw new Error("bad public key size");
      if (D2.length !== Xe)
        throw new Error("bad secret key size");
    }
    function it() {
      for (var S2 = 0; S2 < arguments.length; S2++)
        if (!(arguments[S2] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function bt(S2) {
      for (var D2 = 0; D2 < S2.length; D2++)
        S2[D2] = 0;
    }
    t.randomBytes = function(S2) {
      var D2 = new Uint8Array(S2);
      return r(D2, S2), D2;
    }, t.secretbox = function(S2, D2, k2) {
      it(S2, D2, k2), yt(k2, D2);
      for (var g = new Uint8Array(Ge + S2.length), O2 = new Uint8Array(g.length), Q = 0; Q < S2.length; Q++)
        g[Q + Ge] = S2[Q];
      return h2(O2, g, g.length, D2, k2), O2.subarray(xt);
    }, t.secretbox.open = function(S2, D2, k2) {
      it(S2, D2, k2), yt(k2, D2);
      for (var g = new Uint8Array(xt + S2.length), O2 = new Uint8Array(g.length), Q = 0; Q < S2.length; Q++)
        g[Q + xt] = S2[Q];
      return g.length < 32 || a(O2, g, g.length, D2, k2) !== 0 ? null : O2.subarray(Ge);
    }, t.secretbox.keyLength = gt, t.secretbox.nonceLength = je2, t.secretbox.overheadLength = xt, t.scalarMult = function(S2, D2) {
      if (it(S2, D2), S2.length !== Le)
        throw new Error("bad n size");
      if (D2.length !== Pe)
        throw new Error("bad p size");
      var k2 = new Uint8Array(Pe);
      return be(k2, S2, D2), k2;
    }, t.scalarMult.base = function(S2) {
      if (it(S2), S2.length !== Le)
        throw new Error("bad n size");
      var D2 = new Uint8Array(Pe);
      return I(D2, S2), D2;
    }, t.scalarMult.scalarLength = Le, t.scalarMult.groupElementLength = Pe, t.box = function(S2, D2, k2, g) {
      var O2 = t.box.before(k2, g);
      return t.secretbox(S2, D2, O2);
    }, t.box.before = function(S2, D2) {
      it(S2, D2), ms(S2, D2);
      var k2 = new Uint8Array(Qe);
      return P5(k2, S2, D2), k2;
    }, t.box.after = t.secretbox, t.box.open = function(S2, D2, k2, g) {
      var O2 = t.box.before(k2, g);
      return t.secretbox.open(S2, D2, O2);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var S2 = new Uint8Array(Zt), D2 = new Uint8Array(Xe);
      return j3(S2, D2), { publicKey: S2, secretKey: D2 };
    }, t.box.keyPair.fromSecretKey = function(S2) {
      if (it(S2), S2.length !== Xe)
        throw new Error("bad secret key size");
      var D2 = new Uint8Array(Zt);
      return I(D2, S2), { publicKey: D2, secretKey: new Uint8Array(S2) };
    }, t.box.publicKeyLength = Zt, t.box.secretKeyLength = Xe, t.box.sharedKeyLength = Qe, t.box.nonceLength = er, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(S2, D2) {
      if (it(S2, D2), D2.length !== pt$1)
        throw new Error("bad secret key size");
      var k2 = new Uint8Array(zt + S2.length);
      return fe(k2, S2, S2.length, D2), k2;
    }, t.sign.open = function(S2, D2) {
      if (it(S2, D2), D2.length !== ht)
        throw new Error("bad public key size");
      var k2 = new Uint8Array(S2.length), g = Be(k2, S2, S2.length, D2);
      if (g < 0)
        return null;
      for (var O2 = new Uint8Array(g), Q = 0; Q < O2.length; Q++)
        O2[Q] = k2[Q];
      return O2;
    }, t.sign.detached = function(S2, D2) {
      for (var k2 = t.sign(S2, D2), g = new Uint8Array(zt), O2 = 0; O2 < g.length; O2++)
        g[O2] = k2[O2];
      return g;
    }, t.sign.detached.verify = function(S2, D2, k2) {
      if (it(S2, D2, k2), D2.length !== zt)
        throw new Error("bad signature size");
      if (k2.length !== ht)
        throw new Error("bad public key size");
      var g = new Uint8Array(zt + S2.length), O2 = new Uint8Array(zt + S2.length), Q;
      for (Q = 0; Q < zt; Q++)
        g[Q] = D2[Q];
      for (Q = 0; Q < S2.length; Q++)
        g[Q + zt] = S2[Q];
      return Be(O2, g, g.length, k2) >= 0;
    }, t.sign.keyPair = function() {
      var S2 = new Uint8Array(ht), D2 = new Uint8Array(pt$1);
      return K5(S2, D2), { publicKey: S2, secretKey: D2 };
    }, t.sign.keyPair.fromSecretKey = function(S2) {
      if (it(S2), S2.length !== pt$1)
        throw new Error("bad secret key size");
      for (var D2 = new Uint8Array(ht), k2 = 0; k2 < D2.length; k2++)
        D2[k2] = S2[32 + k2];
      return { publicKey: D2, secretKey: new Uint8Array(S2) };
    }, t.sign.keyPair.fromSeed = function(S2) {
      if (it(S2), S2.length !== nn)
        throw new Error("bad seed size");
      for (var D2 = new Uint8Array(ht), k2 = new Uint8Array(pt$1), g = 0; g < 32; g++)
        k2[g] = S2[g];
      return K5(D2, k2, true), { publicKey: D2, secretKey: k2 };
    }, t.sign.publicKeyLength = ht, t.sign.secretKeyLength = pt$1, t.sign.seedLength = nn, t.sign.signatureLength = zt, t.hash = function(S2) {
      it(S2);
      var D2 = new Uint8Array(mt);
      return R3(D2, S2, S2.length), D2;
    }, t.hash.hashLength = mt, t.verify = function(S2, D2) {
      return it(S2, D2), S2.length === 0 || D2.length === 0 || S2.length !== D2.length ? false : $(S2, 0, D2, 0, S2.length) === 0;
    }, t.setPRNG = function(S2) {
      r = S2;
    }, function() {
      var S2 = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (S2 && S2.getRandomValues) {
        var D2 = 65536;
        t.setPRNG(function(k2, g) {
          var O2, Q = new Uint8Array(g);
          for (O2 = 0; O2 < g; O2 += D2)
            S2.getRandomValues(Q.subarray(O2, O2 + Math.min(g - O2, D2)));
          for (O2 = 0; O2 < g; O2++)
            k2[O2] = Q[O2];
          bt(Q);
        });
      } else
        typeof pt < "u" && (S2 = b1(), S2 && S2.randomBytes && t.setPRNG(function(k2, g) {
          var O2, Q = S2.randomBytes(g);
          for (O2 = 0; O2 < g; O2++)
            k2[O2] = Q[O2];
          bt(Q);
        }));
    }();
  })(typeof Fh < "u" && Fh.exports ? Fh.exports : self.nacl = self.nacl || {});
});
var q3 = k((tC, Rh) => {
  U();
  (function() {
    var t = "input is invalid type", e = "finalize already called", r = typeof window == "object", i = r ? window : {};
    i.JS_SHA512_NO_WINDOW && (r = false);
    var n = !r && typeof self == "object", s2 = !i.JS_SHA512_NO_NODE_JS && typeof W.default == "object" && W.default.versions && W.default.versions.node;
    s2 ? i = N : n && (i = self);
    var o = !i.JS_SHA512_NO_COMMON_JS && typeof Rh == "object" && Rh.exports, f = typeof define == "function" && define.amd, l = !i.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", m3 = "0123456789abcdef".split(""), A2 = [-2147483648, 8388608, 32768, 128], F3 = [24, 16, 8, 0], z3 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], V = ["hex", "array", "digest", "arrayBuffer"], $ = [];
    (i.JS_SHA512_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(H2) {
      return Object.prototype.toString.call(H2) === "[object Array]";
    }), l && (i.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(H2) {
      return typeof H2 == "object" && H2.buffer && H2.buffer.constructor === ArrayBuffer;
    });
    var re = function(H2, le) {
      return function(ie) {
        return new ge(le, true).update(ie)[H2]();
      };
    }, W$12 = function(H2) {
      var le = re("hex", H2);
      le.create = function() {
        return new ge(H2);
      }, le.update = function(N3) {
        return le.create().update(N3);
      };
      for (var ie = 0; ie < V.length; ++ie) {
        var se = V[ie];
        le[se] = re(se, H2);
      }
      return le;
    }, Z2 = function(H2, le) {
      return function(ie, se) {
        return new Se(ie, le, true).update(se)[H2]();
      };
    }, ue = function(H2) {
      var le = Z2("hex", H2);
      le.create = function(N3) {
        return new Se(N3, H2);
      }, le.update = function(N3, c2) {
        return le.create(N3).update(c2);
      };
      for (var ie = 0; ie < V.length; ++ie) {
        var se = V[ie];
        le[se] = Z2(se, H2);
      }
      return le;
    };
    function ge(H2, le) {
      le ? ($[0] = $[1] = $[2] = $[3] = $[4] = $[5] = $[6] = $[7] = $[8] = $[9] = $[10] = $[11] = $[12] = $[13] = $[14] = $[15] = $[16] = $[17] = $[18] = $[19] = $[20] = $[21] = $[22] = $[23] = $[24] = $[25] = $[26] = $[27] = $[28] = $[29] = $[30] = $[31] = $[32] = 0, this.blocks = $) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], H2 == 384 ? (this.h0h = 3418070365, this.h0l = 3238371032, this.h1h = 1654270250, this.h1l = 914150663, this.h2h = 2438529370, this.h2l = 812702999, this.h3h = 355462360, this.h3l = 4144912697, this.h4h = 1731405415, this.h4l = 4290775857, this.h5h = 2394180231, this.h5l = 1750603025, this.h6h = 3675008525, this.h6l = 1694076839, this.h7h = 1203062813, this.h7l = 3204075428) : H2 == 256 ? (this.h0h = 573645204, this.h0l = 4230739756, this.h1h = 2673172387, this.h1l = 3360449730, this.h2h = 596883563, this.h2l = 1867755857, this.h3h = 2520282905, this.h3l = 1497426621, this.h4h = 2519219938, this.h4l = 2827943907, this.h5h = 3193839141, this.h5l = 1401305490, this.h6h = 721525244, this.h6l = 746961066, this.h7h = 246885852, this.h7l = 2177182882) : H2 == 224 ? (this.h0h = 2352822216, this.h0l = 424955298, this.h1h = 1944164710, this.h1l = 2312950998, this.h2h = 502970286, this.h2l = 855612546, this.h3h = 1738396948, this.h3l = 1479516111, this.h4h = 258812777, this.h4l = 2077511080, this.h5h = 2011393907, this.h5l = 79989058, this.h6h = 1067287976, this.h6l = 1780299464, this.h7h = 286451373, this.h7l = 2446758561) : (this.h0h = 1779033703, this.h0l = 4089235720, this.h1h = 3144134277, this.h1l = 2227873595, this.h2h = 1013904242, this.h2l = 4271175723, this.h3h = 2773480762, this.h3l = 1595750129, this.h4h = 1359893119, this.h4l = 2917565137, this.h5h = 2600822924, this.h5l = 725511199, this.h6h = 528734635, this.h6l = 4215389547, this.h7h = 1541459225, this.h7l = 327033209), this.bits = H2, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false;
    }
    ge.prototype.update = function(H2) {
      if (this.finalized)
        throw new Error(e);
      var le, ie = typeof H2;
      if (ie !== "string") {
        if (ie === "object") {
          if (H2 === null)
            throw new Error(t);
          if (l && H2.constructor === ArrayBuffer)
            H2 = new Uint8Array(H2);
          else if (!Array.isArray(H2) && (!l || !ArrayBuffer.isView(H2)))
            throw new Error(t);
        } else
          throw new Error(t);
        le = true;
      }
      for (var se, N3 = 0, c2, p2 = H2.length, h2 = this.blocks; N3 < p2; ) {
        if (this.hashed && (this.hashed = false, h2[0] = this.block, h2[1] = h2[2] = h2[3] = h2[4] = h2[5] = h2[6] = h2[7] = h2[8] = h2[9] = h2[10] = h2[11] = h2[12] = h2[13] = h2[14] = h2[15] = h2[16] = h2[17] = h2[18] = h2[19] = h2[20] = h2[21] = h2[22] = h2[23] = h2[24] = h2[25] = h2[26] = h2[27] = h2[28] = h2[29] = h2[30] = h2[31] = h2[32] = 0), le)
          for (c2 = this.start; N3 < p2 && c2 < 128; ++N3)
            h2[c2 >> 2] |= H2[N3] << F3[c2++ & 3];
        else
          for (c2 = this.start; N3 < p2 && c2 < 128; ++N3)
            se = H2.charCodeAt(N3), se < 128 ? h2[c2 >> 2] |= se << F3[c2++ & 3] : se < 2048 ? (h2[c2 >> 2] |= (192 | se >> 6) << F3[c2++ & 3], h2[c2 >> 2] |= (128 | se & 63) << F3[c2++ & 3]) : se < 55296 || se >= 57344 ? (h2[c2 >> 2] |= (224 | se >> 12) << F3[c2++ & 3], h2[c2 >> 2] |= (128 | se >> 6 & 63) << F3[c2++ & 3], h2[c2 >> 2] |= (128 | se & 63) << F3[c2++ & 3]) : (se = 65536 + ((se & 1023) << 10 | H2.charCodeAt(++N3) & 1023), h2[c2 >> 2] |= (240 | se >> 18) << F3[c2++ & 3], h2[c2 >> 2] |= (128 | se >> 12 & 63) << F3[c2++ & 3], h2[c2 >> 2] |= (128 | se >> 6 & 63) << F3[c2++ & 3], h2[c2 >> 2] |= (128 | se & 63) << F3[c2++ & 3]);
        this.lastByteIndex = c2, this.bytes += c2 - this.start, c2 >= 128 ? (this.block = h2[32], this.start = c2 - 128, this.hash(), this.hashed = true) : this.start = c2;
      }
      return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
    }, ge.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var H2 = this.blocks, le = this.lastByteIndex;
        H2[32] = this.block, H2[le >> 2] |= A2[le & 3], this.block = H2[32], le >= 112 && (this.hashed || this.hash(), H2[0] = this.block, H2[1] = H2[2] = H2[3] = H2[4] = H2[5] = H2[6] = H2[7] = H2[8] = H2[9] = H2[10] = H2[11] = H2[12] = H2[13] = H2[14] = H2[15] = H2[16] = H2[17] = H2[18] = H2[19] = H2[20] = H2[21] = H2[22] = H2[23] = H2[24] = H2[25] = H2[26] = H2[27] = H2[28] = H2[29] = H2[30] = H2[31] = H2[32] = 0), H2[30] = this.hBytes << 3 | this.bytes >>> 29, H2[31] = this.bytes << 3, this.hash();
      }
    }, ge.prototype.hash = function() {
      var H2 = this.h0h, le = this.h0l, ie = this.h1h, se = this.h1l, N3 = this.h2h, c2 = this.h2l, p2 = this.h3h, h2 = this.h3l, a = this.h4h, d2 = this.h4l, b2 = this.h5h, _2 = this.h5l, v = this.h6h, u = this.h6l, E2 = this.h7h, B = this.h7l, y2 = this.blocks, M, de2, Ee, Me, Oe, be, I, j3, P5, ee2, oe, te, ae, ne, X2, R3, w, T2, q2, L2, G2, K5, xe, me2, _e2;
      for (M = 32; M < 160; M += 2)
        L2 = y2[M - 30], G2 = y2[M - 29], de2 = (L2 >>> 1 | G2 << 31) ^ (L2 >>> 8 | G2 << 24) ^ L2 >>> 7, Ee = (G2 >>> 1 | L2 << 31) ^ (G2 >>> 8 | L2 << 24) ^ (G2 >>> 7 | L2 << 25), L2 = y2[M - 4], G2 = y2[M - 3], Me = (L2 >>> 19 | G2 << 13) ^ (G2 >>> 29 | L2 << 3) ^ L2 >>> 6, Oe = (G2 >>> 19 | L2 << 13) ^ (L2 >>> 29 | G2 << 3) ^ (G2 >>> 6 | L2 << 26), L2 = y2[M - 32], G2 = y2[M - 31], K5 = y2[M - 14], xe = y2[M - 13], be = (xe & 65535) + (G2 & 65535) + (Ee & 65535) + (Oe & 65535), I = (xe >>> 16) + (G2 >>> 16) + (Ee >>> 16) + (Oe >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (de2 & 65535) + (Me & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (de2 >>> 16) + (Me >>> 16) + (j3 >>> 16), y2[M] = P5 << 16 | j3 & 65535, y2[M + 1] = I << 16 | be & 65535;
      var fe = H2, ke = le, Be = ie, gt = se, je2 = N3, Ge = c2, xt = p2, Pe = h2, Le = a, Zt = d2, Xe = b2, Qe = _2, er = v, et = u, tt = E2, zt = B;
      for (R3 = Be & je2, w = gt & Ge, M = 0; M < 160; M += 8)
        de2 = (fe >>> 28 | ke << 4) ^ (ke >>> 2 | fe << 30) ^ (ke >>> 7 | fe << 25), Ee = (ke >>> 28 | fe << 4) ^ (fe >>> 2 | ke << 30) ^ (fe >>> 7 | ke << 25), Me = (Le >>> 14 | Zt << 18) ^ (Le >>> 18 | Zt << 14) ^ (Zt >>> 9 | Le << 23), Oe = (Zt >>> 14 | Le << 18) ^ (Zt >>> 18 | Le << 14) ^ (Le >>> 9 | Zt << 23), ee2 = fe & Be, oe = ke & gt, T2 = ee2 ^ fe & je2 ^ R3, q2 = oe ^ ke & Ge ^ w, me2 = Le & Xe ^ ~Le & er, _e2 = Zt & Qe ^ ~Zt & et, L2 = y2[M], G2 = y2[M + 1], K5 = z3[M], xe = z3[M + 1], be = (xe & 65535) + (G2 & 65535) + (_e2 & 65535) + (Oe & 65535) + (zt & 65535), I = (xe >>> 16) + (G2 >>> 16) + (_e2 >>> 16) + (Oe >>> 16) + (zt >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (me2 & 65535) + (Me & 65535) + (tt & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (me2 >>> 16) + (Me >>> 16) + (tt >>> 16) + (j3 >>> 16), L2 = P5 << 16 | j3 & 65535, G2 = I << 16 | be & 65535, be = (q2 & 65535) + (Ee & 65535), I = (q2 >>> 16) + (Ee >>> 16) + (be >>> 16), j3 = (T2 & 65535) + (de2 & 65535) + (I >>> 16), P5 = (T2 >>> 16) + (de2 >>> 16) + (j3 >>> 16), K5 = P5 << 16 | j3 & 65535, xe = I << 16 | be & 65535, be = (Pe & 65535) + (G2 & 65535), I = (Pe >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (xt & 65535) + (L2 & 65535) + (I >>> 16), P5 = (xt >>> 16) + (L2 >>> 16) + (j3 >>> 16), tt = P5 << 16 | j3 & 65535, zt = I << 16 | be & 65535, be = (xe & 65535) + (G2 & 65535), I = (xe >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (j3 >>> 16), xt = P5 << 16 | j3 & 65535, Pe = I << 16 | be & 65535, de2 = (xt >>> 28 | Pe << 4) ^ (Pe >>> 2 | xt << 30) ^ (Pe >>> 7 | xt << 25), Ee = (Pe >>> 28 | xt << 4) ^ (xt >>> 2 | Pe << 30) ^ (xt >>> 7 | Pe << 25), Me = (tt >>> 14 | zt << 18) ^ (tt >>> 18 | zt << 14) ^ (zt >>> 9 | tt << 23), Oe = (zt >>> 14 | tt << 18) ^ (zt >>> 18 | tt << 14) ^ (tt >>> 9 | zt << 23), te = xt & fe, ae = Pe & ke, T2 = te ^ xt & Be ^ ee2, q2 = ae ^ Pe & gt ^ oe, me2 = tt & Le ^ ~tt & Xe, _e2 = zt & Zt ^ ~zt & Qe, L2 = y2[M + 2], G2 = y2[M + 3], K5 = z3[M + 2], xe = z3[M + 3], be = (xe & 65535) + (G2 & 65535) + (_e2 & 65535) + (Oe & 65535) + (et & 65535), I = (xe >>> 16) + (G2 >>> 16) + (_e2 >>> 16) + (Oe >>> 16) + (et >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (me2 & 65535) + (Me & 65535) + (er & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (me2 >>> 16) + (Me >>> 16) + (er >>> 16) + (j3 >>> 16), L2 = P5 << 16 | j3 & 65535, G2 = I << 16 | be & 65535, be = (q2 & 65535) + (Ee & 65535), I = (q2 >>> 16) + (Ee >>> 16) + (be >>> 16), j3 = (T2 & 65535) + (de2 & 65535) + (I >>> 16), P5 = (T2 >>> 16) + (de2 >>> 16) + (j3 >>> 16), K5 = P5 << 16 | j3 & 65535, xe = I << 16 | be & 65535, be = (Ge & 65535) + (G2 & 65535), I = (Ge >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (je2 & 65535) + (L2 & 65535) + (I >>> 16), P5 = (je2 >>> 16) + (L2 >>> 16) + (j3 >>> 16), er = P5 << 16 | j3 & 65535, et = I << 16 | be & 65535, be = (xe & 65535) + (G2 & 65535), I = (xe >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (j3 >>> 16), je2 = P5 << 16 | j3 & 65535, Ge = I << 16 | be & 65535, de2 = (je2 >>> 28 | Ge << 4) ^ (Ge >>> 2 | je2 << 30) ^ (Ge >>> 7 | je2 << 25), Ee = (Ge >>> 28 | je2 << 4) ^ (je2 >>> 2 | Ge << 30) ^ (je2 >>> 7 | Ge << 25), Me = (er >>> 14 | et << 18) ^ (er >>> 18 | et << 14) ^ (et >>> 9 | er << 23), Oe = (et >>> 14 | er << 18) ^ (et >>> 18 | er << 14) ^ (er >>> 9 | et << 23), ne = je2 & xt, X2 = Ge & Pe, T2 = ne ^ je2 & fe ^ te, q2 = X2 ^ Ge & ke ^ ae, me2 = er & tt ^ ~er & Le, _e2 = et & zt ^ ~et & Zt, L2 = y2[M + 4], G2 = y2[M + 5], K5 = z3[M + 4], xe = z3[M + 5], be = (xe & 65535) + (G2 & 65535) + (_e2 & 65535) + (Oe & 65535) + (Qe & 65535), I = (xe >>> 16) + (G2 >>> 16) + (_e2 >>> 16) + (Oe >>> 16) + (Qe >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (me2 & 65535) + (Me & 65535) + (Xe & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (me2 >>> 16) + (Me >>> 16) + (Xe >>> 16) + (j3 >>> 16), L2 = P5 << 16 | j3 & 65535, G2 = I << 16 | be & 65535, be = (q2 & 65535) + (Ee & 65535), I = (q2 >>> 16) + (Ee >>> 16) + (be >>> 16), j3 = (T2 & 65535) + (de2 & 65535) + (I >>> 16), P5 = (T2 >>> 16) + (de2 >>> 16) + (j3 >>> 16), K5 = P5 << 16 | j3 & 65535, xe = I << 16 | be & 65535, be = (gt & 65535) + (G2 & 65535), I = (gt >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (Be & 65535) + (L2 & 65535) + (I >>> 16), P5 = (Be >>> 16) + (L2 >>> 16) + (j3 >>> 16), Xe = P5 << 16 | j3 & 65535, Qe = I << 16 | be & 65535, be = (xe & 65535) + (G2 & 65535), I = (xe >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (j3 >>> 16), Be = P5 << 16 | j3 & 65535, gt = I << 16 | be & 65535, de2 = (Be >>> 28 | gt << 4) ^ (gt >>> 2 | Be << 30) ^ (gt >>> 7 | Be << 25), Ee = (gt >>> 28 | Be << 4) ^ (Be >>> 2 | gt << 30) ^ (Be >>> 7 | gt << 25), Me = (Xe >>> 14 | Qe << 18) ^ (Xe >>> 18 | Qe << 14) ^ (Qe >>> 9 | Xe << 23), Oe = (Qe >>> 14 | Xe << 18) ^ (Qe >>> 18 | Xe << 14) ^ (Xe >>> 9 | Qe << 23), R3 = Be & je2, w = gt & Ge, T2 = R3 ^ Be & xt ^ ne, q2 = w ^ gt & Pe ^ X2, me2 = Xe & er ^ ~Xe & tt, _e2 = Qe & et ^ ~Qe & zt, L2 = y2[M + 6], G2 = y2[M + 7], K5 = z3[M + 6], xe = z3[M + 7], be = (xe & 65535) + (G2 & 65535) + (_e2 & 65535) + (Oe & 65535) + (Zt & 65535), I = (xe >>> 16) + (G2 >>> 16) + (_e2 >>> 16) + (Oe >>> 16) + (Zt >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (me2 & 65535) + (Me & 65535) + (Le & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (me2 >>> 16) + (Me >>> 16) + (Le >>> 16) + (j3 >>> 16), L2 = P5 << 16 | j3 & 65535, G2 = I << 16 | be & 65535, be = (q2 & 65535) + (Ee & 65535), I = (q2 >>> 16) + (Ee >>> 16) + (be >>> 16), j3 = (T2 & 65535) + (de2 & 65535) + (I >>> 16), P5 = (T2 >>> 16) + (de2 >>> 16) + (j3 >>> 16), K5 = P5 << 16 | j3 & 65535, xe = I << 16 | be & 65535, be = (ke & 65535) + (G2 & 65535), I = (ke >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (fe & 65535) + (L2 & 65535) + (I >>> 16), P5 = (fe >>> 16) + (L2 >>> 16) + (j3 >>> 16), Le = P5 << 16 | j3 & 65535, Zt = I << 16 | be & 65535, be = (xe & 65535) + (G2 & 65535), I = (xe >>> 16) + (G2 >>> 16) + (be >>> 16), j3 = (K5 & 65535) + (L2 & 65535) + (I >>> 16), P5 = (K5 >>> 16) + (L2 >>> 16) + (j3 >>> 16), fe = P5 << 16 | j3 & 65535, ke = I << 16 | be & 65535;
      be = (le & 65535) + (ke & 65535), I = (le >>> 16) + (ke >>> 16) + (be >>> 16), j3 = (H2 & 65535) + (fe & 65535) + (I >>> 16), P5 = (H2 >>> 16) + (fe >>> 16) + (j3 >>> 16), this.h0h = P5 << 16 | j3 & 65535, this.h0l = I << 16 | be & 65535, be = (se & 65535) + (gt & 65535), I = (se >>> 16) + (gt >>> 16) + (be >>> 16), j3 = (ie & 65535) + (Be & 65535) + (I >>> 16), P5 = (ie >>> 16) + (Be >>> 16) + (j3 >>> 16), this.h1h = P5 << 16 | j3 & 65535, this.h1l = I << 16 | be & 65535, be = (c2 & 65535) + (Ge & 65535), I = (c2 >>> 16) + (Ge >>> 16) + (be >>> 16), j3 = (N3 & 65535) + (je2 & 65535) + (I >>> 16), P5 = (N3 >>> 16) + (je2 >>> 16) + (j3 >>> 16), this.h2h = P5 << 16 | j3 & 65535, this.h2l = I << 16 | be & 65535, be = (h2 & 65535) + (Pe & 65535), I = (h2 >>> 16) + (Pe >>> 16) + (be >>> 16), j3 = (p2 & 65535) + (xt & 65535) + (I >>> 16), P5 = (p2 >>> 16) + (xt >>> 16) + (j3 >>> 16), this.h3h = P5 << 16 | j3 & 65535, this.h3l = I << 16 | be & 65535, be = (d2 & 65535) + (Zt & 65535), I = (d2 >>> 16) + (Zt >>> 16) + (be >>> 16), j3 = (a & 65535) + (Le & 65535) + (I >>> 16), P5 = (a >>> 16) + (Le >>> 16) + (j3 >>> 16), this.h4h = P5 << 16 | j3 & 65535, this.h4l = I << 16 | be & 65535, be = (_2 & 65535) + (Qe & 65535), I = (_2 >>> 16) + (Qe >>> 16) + (be >>> 16), j3 = (b2 & 65535) + (Xe & 65535) + (I >>> 16), P5 = (b2 >>> 16) + (Xe >>> 16) + (j3 >>> 16), this.h5h = P5 << 16 | j3 & 65535, this.h5l = I << 16 | be & 65535, be = (u & 65535) + (et & 65535), I = (u >>> 16) + (et >>> 16) + (be >>> 16), j3 = (v & 65535) + (er & 65535) + (I >>> 16), P5 = (v >>> 16) + (er >>> 16) + (j3 >>> 16), this.h6h = P5 << 16 | j3 & 65535, this.h6l = I << 16 | be & 65535, be = (B & 65535) + (zt & 65535), I = (B >>> 16) + (zt >>> 16) + (be >>> 16), j3 = (E2 & 65535) + (tt & 65535) + (I >>> 16), P5 = (E2 >>> 16) + (tt >>> 16) + (j3 >>> 16), this.h7h = P5 << 16 | j3 & 65535, this.h7l = I << 16 | be & 65535;
    }, ge.prototype.hex = function() {
      this.finalize();
      var H2 = this.h0h, le = this.h0l, ie = this.h1h, se = this.h1l, N3 = this.h2h, c2 = this.h2l, p2 = this.h3h, h2 = this.h3l, a = this.h4h, d2 = this.h4l, b2 = this.h5h, _2 = this.h5l, v = this.h6h, u = this.h6l, E2 = this.h7h, B = this.h7l, y2 = this.bits, M = m3[H2 >> 28 & 15] + m3[H2 >> 24 & 15] + m3[H2 >> 20 & 15] + m3[H2 >> 16 & 15] + m3[H2 >> 12 & 15] + m3[H2 >> 8 & 15] + m3[H2 >> 4 & 15] + m3[H2 & 15] + m3[le >> 28 & 15] + m3[le >> 24 & 15] + m3[le >> 20 & 15] + m3[le >> 16 & 15] + m3[le >> 12 & 15] + m3[le >> 8 & 15] + m3[le >> 4 & 15] + m3[le & 15] + m3[ie >> 28 & 15] + m3[ie >> 24 & 15] + m3[ie >> 20 & 15] + m3[ie >> 16 & 15] + m3[ie >> 12 & 15] + m3[ie >> 8 & 15] + m3[ie >> 4 & 15] + m3[ie & 15] + m3[se >> 28 & 15] + m3[se >> 24 & 15] + m3[se >> 20 & 15] + m3[se >> 16 & 15] + m3[se >> 12 & 15] + m3[se >> 8 & 15] + m3[se >> 4 & 15] + m3[se & 15] + m3[N3 >> 28 & 15] + m3[N3 >> 24 & 15] + m3[N3 >> 20 & 15] + m3[N3 >> 16 & 15] + m3[N3 >> 12 & 15] + m3[N3 >> 8 & 15] + m3[N3 >> 4 & 15] + m3[N3 & 15] + m3[c2 >> 28 & 15] + m3[c2 >> 24 & 15] + m3[c2 >> 20 & 15] + m3[c2 >> 16 & 15] + m3[c2 >> 12 & 15] + m3[c2 >> 8 & 15] + m3[c2 >> 4 & 15] + m3[c2 & 15] + m3[p2 >> 28 & 15] + m3[p2 >> 24 & 15] + m3[p2 >> 20 & 15] + m3[p2 >> 16 & 15] + m3[p2 >> 12 & 15] + m3[p2 >> 8 & 15] + m3[p2 >> 4 & 15] + m3[p2 & 15];
      return y2 >= 256 && (M += m3[h2 >> 28 & 15] + m3[h2 >> 24 & 15] + m3[h2 >> 20 & 15] + m3[h2 >> 16 & 15] + m3[h2 >> 12 & 15] + m3[h2 >> 8 & 15] + m3[h2 >> 4 & 15] + m3[h2 & 15]), y2 >= 384 && (M += m3[a >> 28 & 15] + m3[a >> 24 & 15] + m3[a >> 20 & 15] + m3[a >> 16 & 15] + m3[a >> 12 & 15] + m3[a >> 8 & 15] + m3[a >> 4 & 15] + m3[a & 15] + m3[d2 >> 28 & 15] + m3[d2 >> 24 & 15] + m3[d2 >> 20 & 15] + m3[d2 >> 16 & 15] + m3[d2 >> 12 & 15] + m3[d2 >> 8 & 15] + m3[d2 >> 4 & 15] + m3[d2 & 15] + m3[b2 >> 28 & 15] + m3[b2 >> 24 & 15] + m3[b2 >> 20 & 15] + m3[b2 >> 16 & 15] + m3[b2 >> 12 & 15] + m3[b2 >> 8 & 15] + m3[b2 >> 4 & 15] + m3[b2 & 15] + m3[_2 >> 28 & 15] + m3[_2 >> 24 & 15] + m3[_2 >> 20 & 15] + m3[_2 >> 16 & 15] + m3[_2 >> 12 & 15] + m3[_2 >> 8 & 15] + m3[_2 >> 4 & 15] + m3[_2 & 15]), y2 == 512 && (M += m3[v >> 28 & 15] + m3[v >> 24 & 15] + m3[v >> 20 & 15] + m3[v >> 16 & 15] + m3[v >> 12 & 15] + m3[v >> 8 & 15] + m3[v >> 4 & 15] + m3[v & 15] + m3[u >> 28 & 15] + m3[u >> 24 & 15] + m3[u >> 20 & 15] + m3[u >> 16 & 15] + m3[u >> 12 & 15] + m3[u >> 8 & 15] + m3[u >> 4 & 15] + m3[u & 15] + m3[E2 >> 28 & 15] + m3[E2 >> 24 & 15] + m3[E2 >> 20 & 15] + m3[E2 >> 16 & 15] + m3[E2 >> 12 & 15] + m3[E2 >> 8 & 15] + m3[E2 >> 4 & 15] + m3[E2 & 15] + m3[B >> 28 & 15] + m3[B >> 24 & 15] + m3[B >> 20 & 15] + m3[B >> 16 & 15] + m3[B >> 12 & 15] + m3[B >> 8 & 15] + m3[B >> 4 & 15] + m3[B & 15]), M;
    }, ge.prototype.toString = ge.prototype.hex, ge.prototype.digest = function() {
      this.finalize();
      var H2 = this.h0h, le = this.h0l, ie = this.h1h, se = this.h1l, N3 = this.h2h, c2 = this.h2l, p2 = this.h3h, h2 = this.h3l, a = this.h4h, d2 = this.h4l, b2 = this.h5h, _2 = this.h5l, v = this.h6h, u = this.h6l, E2 = this.h7h, B = this.h7l, y2 = this.bits, M = [H2 >> 24 & 255, H2 >> 16 & 255, H2 >> 8 & 255, H2 & 255, le >> 24 & 255, le >> 16 & 255, le >> 8 & 255, le & 255, ie >> 24 & 255, ie >> 16 & 255, ie >> 8 & 255, ie & 255, se >> 24 & 255, se >> 16 & 255, se >> 8 & 255, se & 255, N3 >> 24 & 255, N3 >> 16 & 255, N3 >> 8 & 255, N3 & 255, c2 >> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, c2 & 255, p2 >> 24 & 255, p2 >> 16 & 255, p2 >> 8 & 255, p2 & 255];
      return y2 >= 256 && M.push(h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255), y2 >= 384 && M.push(a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255, d2 >> 24 & 255, d2 >> 16 & 255, d2 >> 8 & 255, d2 & 255, b2 >> 24 & 255, b2 >> 16 & 255, b2 >> 8 & 255, b2 & 255, _2 >> 24 & 255, _2 >> 16 & 255, _2 >> 8 & 255, _2 & 255), y2 == 512 && M.push(v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, u & 255, E2 >> 24 & 255, E2 >> 16 & 255, E2 >> 8 & 255, E2 & 255, B >> 24 & 255, B >> 16 & 255, B >> 8 & 255, B & 255), M;
    }, ge.prototype.array = ge.prototype.digest, ge.prototype.arrayBuffer = function() {
      this.finalize();
      var H2 = this.bits, le = new ArrayBuffer(H2 / 8), ie = new DataView(le);
      return ie.setUint32(0, this.h0h), ie.setUint32(4, this.h0l), ie.setUint32(8, this.h1h), ie.setUint32(12, this.h1l), ie.setUint32(16, this.h2h), ie.setUint32(20, this.h2l), ie.setUint32(24, this.h3h), H2 >= 256 && ie.setUint32(28, this.h3l), H2 >= 384 && (ie.setUint32(32, this.h4h), ie.setUint32(36, this.h4l), ie.setUint32(40, this.h5h), ie.setUint32(44, this.h5l)), H2 == 512 && (ie.setUint32(48, this.h6h), ie.setUint32(52, this.h6l), ie.setUint32(56, this.h7h), ie.setUint32(60, this.h7l)), le;
    }, ge.prototype.clone = function() {
      var H2 = new ge(this.bits, false);
      return this.copyTo(H2), H2;
    }, ge.prototype.copyTo = function(H2) {
      var le = 0, ie = ["h0h", "h0l", "h1h", "h1l", "h2h", "h2l", "h3h", "h3l", "h4h", "h4l", "h5h", "h5l", "h6h", "h6l", "h7h", "h7l", "start", "bytes", "hBytes", "finalized", "hashed", "lastByteIndex"];
      for (le = 0; le < ie.length; ++le)
        H2[ie[le]] = this[ie[le]];
      for (le = 0; le < this.blocks.length; ++le)
        H2.blocks[le] = this.blocks[le];
    };
    function Se(H2, le, ie) {
      var se, N3 = typeof H2;
      if (N3 !== "string") {
        if (N3 === "object") {
          if (H2 === null)
            throw new Error(t);
          if (l && H2.constructor === ArrayBuffer)
            H2 = new Uint8Array(H2);
          else if (!Array.isArray(H2) && (!l || !ArrayBuffer.isView(H2)))
            throw new Error(t);
        } else
          throw new Error(t);
        se = true;
      }
      var c2 = H2.length;
      if (!se) {
        for (var p2 = [], c2 = H2.length, h2 = 0, a, d2 = 0; d2 < c2; ++d2)
          a = H2.charCodeAt(d2), a < 128 ? p2[h2++] = a : a < 2048 ? (p2[h2++] = 192 | a >> 6, p2[h2++] = 128 | a & 63) : a < 55296 || a >= 57344 ? (p2[h2++] = 224 | a >> 12, p2[h2++] = 128 | a >> 6 & 63, p2[h2++] = 128 | a & 63) : (a = 65536 + ((a & 1023) << 10 | H2.charCodeAt(++d2) & 1023), p2[h2++] = 240 | a >> 18, p2[h2++] = 128 | a >> 12 & 63, p2[h2++] = 128 | a >> 6 & 63, p2[h2++] = 128 | a & 63);
        H2 = p2;
      }
      H2.length > 128 && (H2 = new ge(le, true).update(H2).array());
      for (var b2 = [], _2 = [], d2 = 0; d2 < 128; ++d2) {
        var v = H2[d2] || 0;
        b2[d2] = 92 ^ v, _2[d2] = 54 ^ v;
      }
      ge.call(this, le, ie), this.update(_2), this.oKeyPad = b2, this.inner = true, this.sharedMemory = ie;
    }
    Se.prototype = new ge(), Se.prototype.finalize = function() {
      if (ge.prototype.finalize.call(this), this.inner) {
        this.inner = false;
        var H2 = this.array();
        ge.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(H2), ge.prototype.finalize.call(this);
      }
    }, Se.prototype.clone = function() {
      var H2 = new Se([], this.bits, false);
      this.copyTo(H2), H2.inner = this.inner;
      for (var le = 0; le < this.oKeyPad.length; ++le)
        H2.oKeyPad[le] = this.oKeyPad[le];
      return H2;
    };
    var pe2 = W$12(512);
    pe2.sha512 = pe2, pe2.sha384 = W$12(384), pe2.sha512_256 = W$12(256), pe2.sha512_224 = W$12(224), pe2.sha512.hmac = ue(512), pe2.sha384.hmac = ue(384), pe2.sha512_256.hmac = ue(256), pe2.sha512_224.hmac = ue(224), o ? Rh.exports = pe2 : (i.sha512 = pe2.sha512, i.sha384 = pe2.sha384, i.sha512_256 = pe2.sha512_256, i.sha512_224 = pe2.sha512_224, f && define(function() {
      return pe2;
    }));
  })();
});
var xg = k((iC, Nh) => {
  U();
  (function() {
    var t = typeof window == "object" ? window : {}, e = !t.HI_BASE32_NO_NODE_JS && typeof W.default == "object" && W.default.versions && W.default.versions.node;
    e && (t = N);
    var r = !t.HI_BASE32_NO_COMMON_JS && typeof Nh == "object" && Nh.exports, i = typeof define == "function" && define.amd, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""), s2 = { A: 0, B: 1, C: 2, D: 3, E: 4, F: 5, G: 6, H: 7, I: 8, J: 9, K: 10, L: 11, M: 12, N: 13, O: 14, P: 15, Q: 16, R: 17, S: 18, T: 19, U: 20, V: 21, W: 22, X: 23, Y: 24, Z: 25, 2: 26, 3: 27, 4: 28, 5: 29, 6: 30, 7: 31 }, o = [0, 0, 0, 0, 0, 0, 0, 0], f = function(W2, Z2) {
      Z2.length > 10 && (Z2 = "..." + Z2.substr(-10));
      var ue = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + W2 + " bytes: " + Z2 + " <-");
      throw ue.position = W2, ue;
    }, l = function(W2) {
      for (var Z2 = "", ue = W2.length, ge = 0, Se = 0, pe2, H2; ge < ue; ) {
        if (pe2 = W2[ge++], pe2 <= 127) {
          Z2 += String.fromCharCode(pe2);
          continue;
        } else
          pe2 > 191 && pe2 <= 223 ? (H2 = pe2 & 31, Se = 1) : pe2 <= 239 ? (H2 = pe2 & 15, Se = 2) : pe2 <= 247 ? (H2 = pe2 & 7, Se = 3) : f(ge, Z2);
        for (var le = 0; le < Se; ++le)
          pe2 = W2[ge++], (pe2 < 128 || pe2 > 191) && f(ge, Z2), H2 <<= 6, H2 += pe2 & 63;
        H2 >= 55296 && H2 <= 57343 && f(ge, Z2), H2 > 1114111 && f(ge, Z2), H2 <= 65535 ? Z2 += String.fromCharCode(H2) : (H2 -= 65536, Z2 += String.fromCharCode((H2 >> 10) + 55296), Z2 += String.fromCharCode((H2 & 1023) + 56320));
      }
      return Z2;
    }, m3 = function(W2) {
      if (W2 === "")
        return [];
      if (!/^[A-Z2-7=]+$/.test(W2))
        throw new Error("Invalid base32 characters");
      W2 = W2.replace(/=/g, "");
      for (var Z2, ue, ge, Se, pe2, H2, le, ie, se = [], N3 = 0, c2 = W2.length, p2 = 0, h2 = c2 >> 3 << 3; p2 < h2; )
        Z2 = s2[W2.charAt(p2++)], ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], pe2 = s2[W2.charAt(p2++)], H2 = s2[W2.charAt(p2++)], le = s2[W2.charAt(p2++)], ie = s2[W2.charAt(p2++)], se[N3++] = (Z2 << 3 | ue >>> 2) & 255, se[N3++] = (ue << 6 | ge << 1 | Se >>> 4) & 255, se[N3++] = (Se << 4 | pe2 >>> 1) & 255, se[N3++] = (pe2 << 7 | H2 << 2 | le >>> 3) & 255, se[N3++] = (le << 5 | ie) & 255;
      var a = c2 - h2;
      return a === 2 ? (Z2 = s2[W2.charAt(p2++)], ue = s2[W2.charAt(p2++)], se[N3++] = (Z2 << 3 | ue >>> 2) & 255) : a === 4 ? (Z2 = s2[W2.charAt(p2++)], ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], se[N3++] = (Z2 << 3 | ue >>> 2) & 255, se[N3++] = (ue << 6 | ge << 1 | Se >>> 4) & 255) : a === 5 ? (Z2 = s2[W2.charAt(p2++)], ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], pe2 = s2[W2.charAt(p2++)], se[N3++] = (Z2 << 3 | ue >>> 2) & 255, se[N3++] = (ue << 6 | ge << 1 | Se >>> 4) & 255, se[N3++] = (Se << 4 | pe2 >>> 1) & 255) : a === 7 && (Z2 = s2[W2.charAt(p2++)], ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], pe2 = s2[W2.charAt(p2++)], H2 = s2[W2.charAt(p2++)], le = s2[W2.charAt(p2++)], se[N3++] = (Z2 << 3 | ue >>> 2) & 255, se[N3++] = (ue << 6 | ge << 1 | Se >>> 4) & 255, se[N3++] = (Se << 4 | pe2 >>> 1) & 255, se[N3++] = (pe2 << 7 | H2 << 2 | le >>> 3) & 255), se;
    }, A2 = function(W2) {
      for (var Z2, ue, ge, Se, pe2, H2 = "", le = W2.length, ie = 0, se = parseInt(le / 5) * 5; ie < se; )
        Z2 = W2.charCodeAt(ie++), ue = W2.charCodeAt(ie++), ge = W2.charCodeAt(ie++), Se = W2.charCodeAt(ie++), pe2 = W2.charCodeAt(ie++), H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[(ge << 1 | Se >>> 7) & 31] + n[Se >>> 2 & 31] + n[(Se << 3 | pe2 >>> 5) & 31] + n[pe2 & 31];
      var N3 = le - se;
      return N3 === 1 ? (Z2 = W2.charCodeAt(ie), H2 += n[Z2 >>> 3] + n[Z2 << 2 & 31] + "======") : N3 === 2 ? (Z2 = W2.charCodeAt(ie++), ue = W2.charCodeAt(ie), H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[ue << 4 & 31] + "====") : N3 === 3 ? (Z2 = W2.charCodeAt(ie++), ue = W2.charCodeAt(ie++), ge = W2.charCodeAt(ie), H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[ge << 1 & 31] + "===") : N3 === 4 && (Z2 = W2.charCodeAt(ie++), ue = W2.charCodeAt(ie++), ge = W2.charCodeAt(ie++), Se = W2.charCodeAt(ie), H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[(ge << 1 | Se >>> 7) & 31] + n[Se >>> 2 & 31] + n[Se << 3 & 31] + "="), H2;
    }, F3 = function(W2) {
      var Z2, ue, ge, Se, pe2, H2, le = false, ie = "", se = 0, N3, c2 = 0, h2 = W2.length;
      if (W2 === "")
        return ie;
      do {
        for (o[0] = o[5], o[1] = o[6], o[2] = o[7], N3 = c2; se < h2 && N3 < 5; ++se)
          H2 = W2.charCodeAt(se), H2 < 128 ? o[N3++] = H2 : H2 < 2048 ? (o[N3++] = 192 | H2 >> 6, o[N3++] = 128 | H2 & 63) : H2 < 55296 || H2 >= 57344 ? (o[N3++] = 224 | H2 >> 12, o[N3++] = 128 | H2 >> 6 & 63, o[N3++] = 128 | H2 & 63) : (H2 = 65536 + ((H2 & 1023) << 10 | W2.charCodeAt(++se) & 1023), o[N3++] = 240 | H2 >> 18, o[N3++] = 128 | H2 >> 12 & 63, o[N3++] = 128 | H2 >> 6 & 63, o[N3++] = 128 | H2 & 63);
        c2 = N3 - 5, se === h2 && ++se, se > h2 && N3 < 6 && (le = true), Z2 = o[0], N3 > 4 ? (ue = o[1], ge = o[2], Se = o[3], pe2 = o[4], ie += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[(ge << 1 | Se >>> 7) & 31] + n[Se >>> 2 & 31] + n[(Se << 3 | pe2 >>> 5) & 31] + n[pe2 & 31]) : N3 === 1 ? ie += n[Z2 >>> 3] + n[Z2 << 2 & 31] + "======" : N3 === 2 ? (ue = o[1], ie += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[ue << 4 & 31] + "====") : N3 === 3 ? (ue = o[1], ge = o[2], ie += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[ge << 1 & 31] + "===") : (ue = o[1], ge = o[2], Se = o[3], ie += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[(ge << 1 | Se >>> 7) & 31] + n[Se >>> 2 & 31] + n[Se << 3 & 31] + "=");
      } while (!le);
      return ie;
    }, z3 = function(W2) {
      for (var Z2, ue, ge, Se, pe2, H2 = "", le = W2.length, ie = 0, se = parseInt(le / 5) * 5; ie < se; )
        Z2 = W2[ie++], ue = W2[ie++], ge = W2[ie++], Se = W2[ie++], pe2 = W2[ie++], H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[(ge << 1 | Se >>> 7) & 31] + n[Se >>> 2 & 31] + n[(Se << 3 | pe2 >>> 5) & 31] + n[pe2 & 31];
      var N3 = le - se;
      return N3 === 1 ? (Z2 = W2[ie], H2 += n[Z2 >>> 3] + n[Z2 << 2 & 31] + "======") : N3 === 2 ? (Z2 = W2[ie++], ue = W2[ie], H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[ue << 4 & 31] + "====") : N3 === 3 ? (Z2 = W2[ie++], ue = W2[ie++], ge = W2[ie], H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[ge << 1 & 31] + "===") : N3 === 4 && (Z2 = W2[ie++], ue = W2[ie++], ge = W2[ie++], Se = W2[ie], H2 += n[Z2 >>> 3] + n[(Z2 << 2 | ue >>> 6) & 31] + n[ue >>> 1 & 31] + n[(ue << 4 | ge >>> 4) & 31] + n[(ge << 1 | Se >>> 7) & 31] + n[Se >>> 2 & 31] + n[Se << 3 & 31] + "="), H2;
    }, V = function(W2, Z2) {
      var ue = typeof W2 != "string";
      return ue && W2.constructor === ArrayBuffer && (W2 = new Uint8Array(W2)), ue ? z3(W2) : Z2 ? A2(W2) : F3(W2);
    }, $ = function(W2, Z2) {
      if (!Z2)
        return l(m3(W2));
      if (W2 === "")
        return "";
      if (!/^[A-Z2-7=]+$/.test(W2))
        throw new Error("Invalid base32 characters");
      var ue, ge, Se, pe2, H2, le, ie, se, N3 = "", c2 = W2.indexOf("=");
      c2 === -1 && (c2 = W2.length);
      for (var p2 = 0, h2 = c2 >> 3 << 3; p2 < h2; )
        ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], pe2 = s2[W2.charAt(p2++)], H2 = s2[W2.charAt(p2++)], le = s2[W2.charAt(p2++)], ie = s2[W2.charAt(p2++)], se = s2[W2.charAt(p2++)], N3 += String.fromCharCode((ue << 3 | ge >>> 2) & 255) + String.fromCharCode((ge << 6 | Se << 1 | pe2 >>> 4) & 255) + String.fromCharCode((pe2 << 4 | H2 >>> 1) & 255) + String.fromCharCode((H2 << 7 | le << 2 | ie >>> 3) & 255) + String.fromCharCode((ie << 5 | se) & 255);
      var a = c2 - h2;
      return a === 2 ? (ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], N3 += String.fromCharCode((ue << 3 | ge >>> 2) & 255)) : a === 4 ? (ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], pe2 = s2[W2.charAt(p2++)], N3 += String.fromCharCode((ue << 3 | ge >>> 2) & 255) + String.fromCharCode((ge << 6 | Se << 1 | pe2 >>> 4) & 255)) : a === 5 ? (ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], pe2 = s2[W2.charAt(p2++)], H2 = s2[W2.charAt(p2++)], N3 += String.fromCharCode((ue << 3 | ge >>> 2) & 255) + String.fromCharCode((ge << 6 | Se << 1 | pe2 >>> 4) & 255) + String.fromCharCode((pe2 << 4 | H2 >>> 1) & 255)) : a === 7 && (ue = s2[W2.charAt(p2++)], ge = s2[W2.charAt(p2++)], Se = s2[W2.charAt(p2++)], pe2 = s2[W2.charAt(p2++)], H2 = s2[W2.charAt(p2++)], le = s2[W2.charAt(p2++)], ie = s2[W2.charAt(p2++)], N3 += String.fromCharCode((ue << 3 | ge >>> 2) & 255) + String.fromCharCode((ge << 6 | Se << 1 | pe2 >>> 4) & 255) + String.fromCharCode((pe2 << 4 | H2 >>> 1) & 255) + String.fromCharCode((H2 << 7 | le << 2 | ie >>> 3) & 255)), N3;
    }, re = { encode: V, decode: $ };
    $.asBytes = m3, r ? Nh.exports = re : (t.base32 = re, i && define(function() {
      return re;
    }));
  })();
});
var _g2 = k((z3, Ch) => {
  U();
  (function(t) {
    var e, r = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i = Math.ceil, n = Math.floor, s2 = "[BigNumber Error] ", o = s2 + "Number primitive has more than 15 significant digits: ", f = 1e14, l = 14, m3 = 9007199254740991, A2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], F3 = 1e7, z5 = 1e9;
    function V(pe2) {
      var H2, le, ie, se = M.prototype = { constructor: M, toString: null, valueOf: null }, N3 = new M(1), c2 = 20, p2 = 4, h2 = -7, a = 21, d2 = -1e7, b2 = 1e7, _2 = false, v = 1, u = 0, E2 = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, B = "0123456789abcdefghijklmnopqrstuvwxyz", y2 = true;
      function M(I, j3) {
        var P5, ee2, oe, te, ae, ne, X2, R3, w = this;
        if (!(w instanceof M))
          return new M(I, j3);
        if (j3 == null) {
          if (I && I._isBigNumber === true) {
            w.s = I.s, !I.c || I.e > b2 ? w.c = w.e = null : I.e < d2 ? w.c = [w.e = 0] : (w.e = I.e, w.c = I.c.slice());
            return;
          }
          if ((ne = typeof I == "number") && I * 0 == 0) {
            if (w.s = 1 / I < 0 ? (I = -I, -1) : 1, I === ~~I) {
              for (te = 0, ae = I; ae >= 10; ae /= 10, te++)
                ;
              te > b2 ? w.c = w.e = null : (w.e = te, w.c = [I]);
              return;
            }
            R3 = String(I);
          } else {
            if (!r.test(R3 = String(I)))
              return ie(w, R3, ne);
            w.s = R3.charCodeAt(0) == 45 ? (R3 = R3.slice(1), -1) : 1;
          }
          (te = R3.indexOf(".")) > -1 && (R3 = R3.replace(".", "")), (ae = R3.search(/e/i)) > 0 ? (te < 0 && (te = ae), te += +R3.slice(ae + 1), R3 = R3.substring(0, ae)) : te < 0 && (te = R3.length);
        } else {
          if (Z2(j3, 2, B.length, "Base"), j3 == 10 && y2)
            return w = new M(I), Oe(w, c2 + w.e + 1, p2);
          if (R3 = String(I), ne = typeof I == "number") {
            if (I * 0 != 0)
              return ie(w, R3, ne, j3);
            if (w.s = 1 / I < 0 ? (R3 = R3.slice(1), -1) : 1, M.DEBUG && R3.replace(/^0\.0*|\./, "").length > 15)
              throw Error(o + I);
          } else
            w.s = R3.charCodeAt(0) === 45 ? (R3 = R3.slice(1), -1) : 1;
          for (P5 = B.slice(0, j3), te = ae = 0, X2 = R3.length; ae < X2; ae++)
            if (P5.indexOf(ee2 = R3.charAt(ae)) < 0) {
              if (ee2 == ".") {
                if (ae > te) {
                  te = X2;
                  continue;
                }
              } else if (!oe && (R3 == R3.toUpperCase() && (R3 = R3.toLowerCase()) || R3 == R3.toLowerCase() && (R3 = R3.toUpperCase()))) {
                oe = true, ae = -1, te = 0;
                continue;
              }
              return ie(w, String(I), ne, j3);
            }
          ne = false, R3 = le(R3, j3, 10, w.s), (te = R3.indexOf(".")) > -1 ? R3 = R3.replace(".", "") : te = R3.length;
        }
        for (ae = 0; R3.charCodeAt(ae) === 48; ae++)
          ;
        for (X2 = R3.length; R3.charCodeAt(--X2) === 48; )
          ;
        if (R3 = R3.slice(ae, ++X2)) {
          if (X2 -= ae, ne && M.DEBUG && X2 > 15 && (I > m3 || I !== n(I)))
            throw Error(o + w.s * I);
          if ((te = te - ae - 1) > b2)
            w.c = w.e = null;
          else if (te < d2)
            w.c = [w.e = 0];
          else {
            if (w.e = te, w.c = [], ae = (te + 1) % l, te < 0 && (ae += l), ae < X2) {
              for (ae && w.c.push(+R3.slice(0, ae)), X2 -= l; ae < X2; )
                w.c.push(+R3.slice(ae, ae += l));
              ae = l - (R3 = R3.slice(ae)).length;
            } else
              ae -= X2;
            for (; ae--; R3 += "0")
              ;
            w.c.push(+R3);
          }
        } else
          w.c = [w.e = 0];
      }
      M.clone = V, M.ROUND_UP = 0, M.ROUND_DOWN = 1, M.ROUND_CEIL = 2, M.ROUND_FLOOR = 3, M.ROUND_HALF_UP = 4, M.ROUND_HALF_DOWN = 5, M.ROUND_HALF_EVEN = 6, M.ROUND_HALF_CEIL = 7, M.ROUND_HALF_FLOOR = 8, M.EUCLID = 9, M.config = M.set = function(I) {
        var j3, P5;
        if (I != null)
          if (typeof I == "object") {
            if (I.hasOwnProperty(j3 = "DECIMAL_PLACES") && (P5 = I[j3], Z2(P5, 0, z5, j3), c2 = P5), I.hasOwnProperty(j3 = "ROUNDING_MODE") && (P5 = I[j3], Z2(P5, 0, 8, j3), p2 = P5), I.hasOwnProperty(j3 = "EXPONENTIAL_AT") && (P5 = I[j3], P5 && P5.pop ? (Z2(P5[0], -z5, 0, j3), Z2(P5[1], 0, z5, j3), h2 = P5[0], a = P5[1]) : (Z2(P5, -z5, z5, j3), h2 = -(a = P5 < 0 ? -P5 : P5))), I.hasOwnProperty(j3 = "RANGE"))
              if (P5 = I[j3], P5 && P5.pop)
                Z2(P5[0], -z5, -1, j3), Z2(P5[1], 1, z5, j3), d2 = P5[0], b2 = P5[1];
              else if (Z2(P5, -z5, z5, j3), P5)
                d2 = -(b2 = P5 < 0 ? -P5 : P5);
              else
                throw Error(s2 + j3 + " cannot be zero: " + P5);
            if (I.hasOwnProperty(j3 = "CRYPTO"))
              if (P5 = I[j3], P5 === !!P5)
                if (P5)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    _2 = P5;
                  else
                    throw _2 = !P5, Error(s2 + "crypto unavailable");
                else
                  _2 = P5;
              else
                throw Error(s2 + j3 + " not true or false: " + P5);
            if (I.hasOwnProperty(j3 = "MODULO_MODE") && (P5 = I[j3], Z2(P5, 0, 9, j3), v = P5), I.hasOwnProperty(j3 = "POW_PRECISION") && (P5 = I[j3], Z2(P5, 0, z5, j3), u = P5), I.hasOwnProperty(j3 = "FORMAT"))
              if (P5 = I[j3], typeof P5 == "object")
                E2 = P5;
              else
                throw Error(s2 + j3 + " not an object: " + P5);
            if (I.hasOwnProperty(j3 = "ALPHABET"))
              if (P5 = I[j3], typeof P5 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(P5))
                y2 = P5.slice(0, 10) == "0123456789", B = P5;
              else
                throw Error(s2 + j3 + " invalid: " + P5);
          } else
            throw Error(s2 + "Object expected: " + I);
        return { DECIMAL_PLACES: c2, ROUNDING_MODE: p2, EXPONENTIAL_AT: [h2, a], RANGE: [d2, b2], CRYPTO: _2, MODULO_MODE: v, POW_PRECISION: u, FORMAT: E2, ALPHABET: B };
      }, M.isBigNumber = function(I) {
        if (!I || I._isBigNumber !== true)
          return false;
        if (!M.DEBUG)
          return true;
        var j3, P5, ee2 = I.c, oe = I.e, te = I.s;
        e:
          if ({}.toString.call(ee2) == "[object Array]") {
            if ((te === 1 || te === -1) && oe >= -z5 && oe <= z5 && oe === n(oe)) {
              if (ee2[0] === 0) {
                if (oe === 0 && ee2.length === 1)
                  return true;
                break e;
              }
              if (j3 = (oe + 1) % l, j3 < 1 && (j3 += l), String(ee2[0]).length == j3) {
                for (j3 = 0; j3 < ee2.length; j3++)
                  if (P5 = ee2[j3], P5 < 0 || P5 >= f || P5 !== n(P5))
                    break e;
                if (P5 !== 0)
                  return true;
              }
            }
          } else if (ee2 === null && oe === null && (te === null || te === 1 || te === -1))
            return true;
        throw Error(s2 + "Invalid BigNumber: " + I);
      }, M.maximum = M.max = function() {
        return Ee(arguments, se.lt);
      }, M.minimum = M.min = function() {
        return Ee(arguments, se.gt);
      }, M.random = function() {
        var I = 9007199254740992, j3 = Math.random() * I & 2097151 ? function() {
          return n(Math.random() * I);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(P5) {
          var ee2, oe, te, ae, ne, X2 = 0, R3 = [], w = new M(N3);
          if (P5 == null ? P5 = c2 : Z2(P5, 0, z5), ae = i(P5 / l), _2)
            if (crypto.getRandomValues) {
              for (ee2 = crypto.getRandomValues(new Uint32Array(ae *= 2)); X2 < ae; )
                ne = ee2[X2] * 131072 + (ee2[X2 + 1] >>> 11), ne >= 9e15 ? (oe = crypto.getRandomValues(new Uint32Array(2)), ee2[X2] = oe[0], ee2[X2 + 1] = oe[1]) : (R3.push(ne % 1e14), X2 += 2);
              X2 = ae / 2;
            } else if (crypto.randomBytes) {
              for (ee2 = crypto.randomBytes(ae *= 7); X2 < ae; )
                ne = (ee2[X2] & 31) * 281474976710656 + ee2[X2 + 1] * 1099511627776 + ee2[X2 + 2] * 4294967296 + ee2[X2 + 3] * 16777216 + (ee2[X2 + 4] << 16) + (ee2[X2 + 5] << 8) + ee2[X2 + 6], ne >= 9e15 ? crypto.randomBytes(7).copy(ee2, X2) : (R3.push(ne % 1e14), X2 += 7);
              X2 = ae / 7;
            } else
              throw _2 = false, Error(s2 + "crypto unavailable");
          if (!_2)
            for (; X2 < ae; )
              ne = j3(), ne < 9e15 && (R3[X2++] = ne % 1e14);
          for (ae = R3[--X2], P5 %= l, ae && P5 && (ne = A2[l - P5], R3[X2] = n(ae / ne) * ne); R3[X2] === 0; R3.pop(), X2--)
            ;
          if (X2 < 0)
            R3 = [te = 0];
          else {
            for (te = -1; R3[0] === 0; R3.splice(0, 1), te -= l)
              ;
            for (X2 = 1, ne = R3[0]; ne >= 10; ne /= 10, X2++)
              ;
            X2 < l && (te -= l - X2);
          }
          return w.e = te, w.c = R3, w;
        };
      }(), M.sum = function() {
        for (var I = 1, j3 = arguments, P5 = new M(j3[0]); I < j3.length; )
          P5 = P5.plus(j3[I++]);
        return P5;
      }, le = function() {
        var I = "0123456789";
        function j3(P5, ee2, oe, te) {
          for (var ae, ne = [0], X2, R3 = 0, w = P5.length; R3 < w; ) {
            for (X2 = ne.length; X2--; ne[X2] *= ee2)
              ;
            for (ne[0] += te.indexOf(P5.charAt(R3++)), ae = 0; ae < ne.length; ae++)
              ne[ae] > oe - 1 && (ne[ae + 1] == null && (ne[ae + 1] = 0), ne[ae + 1] += ne[ae] / oe | 0, ne[ae] %= oe);
          }
          return ne.reverse();
        }
        return function(P5, ee2, oe, te, ae) {
          var ne, X2, R3, w, T2, q2, L2, G2, K5 = P5.indexOf("."), xe = c2, me2 = p2;
          for (K5 >= 0 && (w = u, u = 0, P5 = P5.replace(".", ""), G2 = new M(ee2), q2 = G2.pow(P5.length - K5), u = w, G2.c = j3(Se(re(q2.c), q2.e, "0"), 10, oe, I), G2.e = G2.c.length), L2 = j3(P5, ee2, oe, ae ? (ne = B, I) : (ne = I, B)), R3 = w = L2.length; L2[--w] == 0; L2.pop())
            ;
          if (!L2[0])
            return ne.charAt(0);
          if (K5 < 0 ? --R3 : (q2.c = L2, q2.e = R3, q2.s = te, q2 = H2(q2, G2, xe, me2, oe), L2 = q2.c, T2 = q2.r, R3 = q2.e), X2 = R3 + xe + 1, K5 = L2[X2], w = oe / 2, T2 = T2 || X2 < 0 || L2[X2 + 1] != null, T2 = me2 < 4 ? (K5 != null || T2) && (me2 == 0 || me2 == (q2.s < 0 ? 3 : 2)) : K5 > w || K5 == w && (me2 == 4 || T2 || me2 == 6 && L2[X2 - 1] & 1 || me2 == (q2.s < 0 ? 8 : 7)), X2 < 1 || !L2[0])
            P5 = T2 ? Se(ne.charAt(1), -xe, ne.charAt(0)) : ne.charAt(0);
          else {
            if (L2.length = X2, T2)
              for (--oe; ++L2[--X2] > oe; )
                L2[X2] = 0, X2 || (++R3, L2 = [1].concat(L2));
            for (w = L2.length; !L2[--w]; )
              ;
            for (K5 = 0, P5 = ""; K5 <= w; P5 += ne.charAt(L2[K5++]))
              ;
            P5 = Se(P5, R3, ne.charAt(0));
          }
          return P5;
        };
      }(), H2 = function() {
        function I(ee2, oe, te) {
          var ae, ne, X2, R3, w = 0, T2 = ee2.length, q2 = oe % F3, L2 = oe / F3 | 0;
          for (ee2 = ee2.slice(); T2--; )
            X2 = ee2[T2] % F3, R3 = ee2[T2] / F3 | 0, ae = L2 * X2 + R3 * q2, ne = q2 * X2 + ae % F3 * F3 + w, w = (ne / te | 0) + (ae / F3 | 0) + L2 * R3, ee2[T2] = ne % te;
          return w && (ee2 = [w].concat(ee2)), ee2;
        }
        function j3(ee2, oe, te, ae) {
          var ne, X2;
          if (te != ae)
            X2 = te > ae ? 1 : -1;
          else
            for (ne = X2 = 0; ne < te; ne++)
              if (ee2[ne] != oe[ne]) {
                X2 = ee2[ne] > oe[ne] ? 1 : -1;
                break;
              }
          return X2;
        }
        function P5(ee2, oe, te, ae) {
          for (var ne = 0; te--; )
            ee2[te] -= ne, ne = ee2[te] < oe[te] ? 1 : 0, ee2[te] = ne * ae + ee2[te] - oe[te];
          for (; !ee2[0] && ee2.length > 1; ee2.splice(0, 1))
            ;
        }
        return function(ee2, oe, te, ae, ne) {
          var X2, R3, w, T2, q2, L2, G2, K5, xe, me2, _e2, fe, ke, Be, gt, je2, Ge, xt = ee2.s == oe.s ? 1 : -1, Pe = ee2.c, Le = oe.c;
          if (!Pe || !Pe[0] || !Le || !Le[0])
            return new M(!ee2.s || !oe.s || (Pe ? Le && Pe[0] == Le[0] : !Le) ? NaN : Pe && Pe[0] == 0 || !Le ? xt * 0 : xt / 0);
          for (K5 = new M(xt), xe = K5.c = [], R3 = ee2.e - oe.e, xt = te + R3 + 1, ne || (ne = f, R3 = $(ee2.e / l) - $(oe.e / l), xt = xt / l | 0), w = 0; Le[w] == (Pe[w] || 0); w++)
            ;
          if (Le[w] > (Pe[w] || 0) && R3--, xt < 0)
            xe.push(1), T2 = true;
          else {
            for (Be = Pe.length, je2 = Le.length, w = 0, xt += 2, q2 = n(ne / (Le[0] + 1)), q2 > 1 && (Le = I(Le, q2, ne), Pe = I(Pe, q2, ne), je2 = Le.length, Be = Pe.length), ke = je2, me2 = Pe.slice(0, je2), _e2 = me2.length; _e2 < je2; me2[_e2++] = 0)
              ;
            Ge = Le.slice(), Ge = [0].concat(Ge), gt = Le[0], Le[1] >= ne / 2 && gt++;
            do {
              if (q2 = 0, X2 = j3(Le, me2, je2, _e2), X2 < 0) {
                if (fe = me2[0], je2 != _e2 && (fe = fe * ne + (me2[1] || 0)), q2 = n(fe / gt), q2 > 1)
                  for (q2 >= ne && (q2 = ne - 1), L2 = I(Le, q2, ne), G2 = L2.length, _e2 = me2.length; j3(L2, me2, G2, _e2) == 1; )
                    q2--, P5(L2, je2 < G2 ? Ge : Le, G2, ne), G2 = L2.length, X2 = 1;
                else
                  q2 == 0 && (X2 = q2 = 1), L2 = Le.slice(), G2 = L2.length;
                if (G2 < _e2 && (L2 = [0].concat(L2)), P5(me2, L2, _e2, ne), _e2 = me2.length, X2 == -1)
                  for (; j3(Le, me2, je2, _e2) < 1; )
                    q2++, P5(me2, je2 < _e2 ? Ge : Le, _e2, ne), _e2 = me2.length;
              } else
                X2 === 0 && (q2++, me2 = [0]);
              xe[w++] = q2, me2[0] ? me2[_e2++] = Pe[ke] || 0 : (me2 = [Pe[ke]], _e2 = 1);
            } while ((ke++ < Be || me2[0] != null) && xt--);
            T2 = me2[0] != null, xe[0] || xe.splice(0, 1);
          }
          if (ne == f) {
            for (w = 1, xt = xe[0]; xt >= 10; xt /= 10, w++)
              ;
            Oe(K5, te + (K5.e = w + R3 * l - 1) + 1, ae, T2);
          } else
            K5.e = R3, K5.r = +T2;
          return K5;
        };
      }();
      function de2(I, j3, P5, ee2) {
        var oe, te, ae, ne, X2;
        if (P5 == null ? P5 = p2 : Z2(P5, 0, 8), !I.c)
          return I.toString();
        if (oe = I.c[0], ae = I.e, j3 == null)
          X2 = re(I.c), X2 = ee2 == 1 || ee2 == 2 && (ae <= h2 || ae >= a) ? ge(X2, ae) : Se(X2, ae, "0");
        else if (I = Oe(new M(I), j3, P5), te = I.e, X2 = re(I.c), ne = X2.length, ee2 == 1 || ee2 == 2 && (j3 <= te || te <= h2)) {
          for (; ne < j3; X2 += "0", ne++)
            ;
          X2 = ge(X2, te);
        } else if (j3 -= ae, X2 = Se(X2, te, "0"), te + 1 > ne) {
          if (--j3 > 0)
            for (X2 += "."; j3--; X2 += "0")
              ;
        } else if (j3 += te - ne, j3 > 0)
          for (te + 1 == ne && (X2 += "."); j3--; X2 += "0")
            ;
        return I.s < 0 && oe ? "-" + X2 : X2;
      }
      function Ee(I, j3) {
        for (var P5, ee2 = 1, oe = new M(I[0]); ee2 < I.length; ee2++)
          if (P5 = new M(I[ee2]), P5.s)
            j3.call(oe, P5) && (oe = P5);
          else {
            oe = P5;
            break;
          }
        return oe;
      }
      function Me(I, j3, P5) {
        for (var ee2 = 1, oe = j3.length; !j3[--oe]; j3.pop())
          ;
        for (oe = j3[0]; oe >= 10; oe /= 10, ee2++)
          ;
        return (P5 = ee2 + P5 * l - 1) > b2 ? I.c = I.e = null : P5 < d2 ? I.c = [I.e = 0] : (I.e = P5, I.c = j3), I;
      }
      ie = function() {
        var I = /^(-?)0([xbo])(?=\w[\w.]*$)/i, j3 = /^([^.]+)\.$/, P5 = /^\.([^.]+)$/, ee2 = /^-?(Infinity|NaN)$/, oe = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(te, ae, ne, X2) {
          var R3, w = ne ? ae : ae.replace(oe, "");
          if (ee2.test(w))
            te.s = isNaN(w) ? null : w < 0 ? -1 : 1;
          else {
            if (!ne && (w = w.replace(I, function(T2, q2, L2) {
              return R3 = (L2 = L2.toLowerCase()) == "x" ? 16 : L2 == "b" ? 2 : 8, !X2 || X2 == R3 ? q2 : T2;
            }), X2 && (R3 = X2, w = w.replace(j3, "$1").replace(P5, "0.$1")), ae != w))
              return new M(w, R3);
            if (M.DEBUG)
              throw Error(s2 + "Not a" + (X2 ? " base " + X2 : "") + " number: " + ae);
            te.s = null;
          }
          te.c = te.e = null;
        };
      }();
      function Oe(I, j3, P5, ee2) {
        var oe, te, ae, ne, X2, R3, w, T2 = I.c, q2 = A2;
        if (T2) {
          e: {
            for (oe = 1, ne = T2[0]; ne >= 10; ne /= 10, oe++)
              ;
            if (te = j3 - oe, te < 0)
              te += l, ae = j3, X2 = T2[R3 = 0], w = X2 / q2[oe - ae - 1] % 10 | 0;
            else if (R3 = i((te + 1) / l), R3 >= T2.length)
              if (ee2) {
                for (; T2.length <= R3; T2.push(0))
                  ;
                X2 = w = 0, oe = 1, te %= l, ae = te - l + 1;
              } else
                break e;
            else {
              for (X2 = ne = T2[R3], oe = 1; ne >= 10; ne /= 10, oe++)
                ;
              te %= l, ae = te - l + oe, w = ae < 0 ? 0 : X2 / q2[oe - ae - 1] % 10 | 0;
            }
            if (ee2 = ee2 || j3 < 0 || T2[R3 + 1] != null || (ae < 0 ? X2 : X2 % q2[oe - ae - 1]), ee2 = P5 < 4 ? (w || ee2) && (P5 == 0 || P5 == (I.s < 0 ? 3 : 2)) : w > 5 || w == 5 && (P5 == 4 || ee2 || P5 == 6 && (te > 0 ? ae > 0 ? X2 / q2[oe - ae] : 0 : T2[R3 - 1]) % 10 & 1 || P5 == (I.s < 0 ? 8 : 7)), j3 < 1 || !T2[0])
              return T2.length = 0, ee2 ? (j3 -= I.e + 1, T2[0] = q2[(l - j3 % l) % l], I.e = -j3 || 0) : T2[0] = I.e = 0, I;
            if (te == 0 ? (T2.length = R3, ne = 1, R3--) : (T2.length = R3 + 1, ne = q2[l - te], T2[R3] = ae > 0 ? n(X2 / q2[oe - ae] % q2[ae]) * ne : 0), ee2)
              for (; ; )
                if (R3 == 0) {
                  for (te = 1, ae = T2[0]; ae >= 10; ae /= 10, te++)
                    ;
                  for (ae = T2[0] += ne, ne = 1; ae >= 10; ae /= 10, ne++)
                    ;
                  te != ne && (I.e++, T2[0] == f && (T2[0] = 1));
                  break;
                } else {
                  if (T2[R3] += ne, T2[R3] != f)
                    break;
                  T2[R3--] = 0, ne = 1;
                }
            for (te = T2.length; T2[--te] === 0; T2.pop())
              ;
          }
          I.e > b2 ? I.c = I.e = null : I.e < d2 && (I.c = [I.e = 0]);
        }
        return I;
      }
      function be(I) {
        var j3, P5 = I.e;
        return P5 === null ? I.toString() : (j3 = re(I.c), j3 = P5 <= h2 || P5 >= a ? ge(j3, P5) : Se(j3, P5, "0"), I.s < 0 ? "-" + j3 : j3);
      }
      return se.absoluteValue = se.abs = function() {
        var I = new M(this);
        return I.s < 0 && (I.s = 1), I;
      }, se.comparedTo = function(I, j3) {
        return W2(this, new M(I, j3));
      }, se.decimalPlaces = se.dp = function(I, j3) {
        var P5, ee2, oe, te = this;
        if (I != null)
          return Z2(I, 0, z5), j3 == null ? j3 = p2 : Z2(j3, 0, 8), Oe(new M(te), I + te.e + 1, j3);
        if (!(P5 = te.c))
          return null;
        if (ee2 = ((oe = P5.length - 1) - $(this.e / l)) * l, oe = P5[oe])
          for (; oe % 10 == 0; oe /= 10, ee2--)
            ;
        return ee2 < 0 && (ee2 = 0), ee2;
      }, se.dividedBy = se.div = function(I, j3) {
        return H2(this, new M(I, j3), c2, p2);
      }, se.dividedToIntegerBy = se.idiv = function(I, j3) {
        return H2(this, new M(I, j3), 0, 1);
      }, se.exponentiatedBy = se.pow = function(I, j3) {
        var P5, ee2, oe, te, ae, ne, X2, R3, w, T2 = this;
        if (I = new M(I), I.c && !I.isInteger())
          throw Error(s2 + "Exponent not an integer: " + be(I));
        if (j3 != null && (j3 = new M(j3)), ne = I.e > 14, !T2.c || !T2.c[0] || T2.c[0] == 1 && !T2.e && T2.c.length == 1 || !I.c || !I.c[0])
          return w = new M(Math.pow(+be(T2), ne ? I.s * (2 - ue(I)) : +be(I))), j3 ? w.mod(j3) : w;
        if (X2 = I.s < 0, j3) {
          if (j3.c ? !j3.c[0] : !j3.s)
            return new M(NaN);
          ee2 = !X2 && T2.isInteger() && j3.isInteger(), ee2 && (T2 = T2.mod(j3));
        } else {
          if (I.e > 9 && (T2.e > 0 || T2.e < -1 || (T2.e == 0 ? T2.c[0] > 1 || ne && T2.c[1] >= 24e7 : T2.c[0] < 8e13 || ne && T2.c[0] <= 9999975e7)))
            return te = T2.s < 0 && ue(I) ? -0 : 0, T2.e > -1 && (te = 1 / te), new M(X2 ? 1 / te : te);
          u && (te = i(u / l + 2));
        }
        for (ne ? (P5 = new M(0.5), X2 && (I.s = 1), R3 = ue(I)) : (oe = Math.abs(+be(I)), R3 = oe % 2), w = new M(N3); ; ) {
          if (R3) {
            if (w = w.times(T2), !w.c)
              break;
            te ? w.c.length > te && (w.c.length = te) : ee2 && (w = w.mod(j3));
          }
          if (oe) {
            if (oe = n(oe / 2), oe === 0)
              break;
            R3 = oe % 2;
          } else if (I = I.times(P5), Oe(I, I.e + 1, 1), I.e > 14)
            R3 = ue(I);
          else {
            if (oe = +be(I), oe === 0)
              break;
            R3 = oe % 2;
          }
          T2 = T2.times(T2), te ? T2.c && T2.c.length > te && (T2.c.length = te) : ee2 && (T2 = T2.mod(j3));
        }
        return ee2 ? w : (X2 && (w = N3.div(w)), j3 ? w.mod(j3) : te ? Oe(w, u, p2, ae) : w);
      }, se.integerValue = function(I) {
        var j3 = new M(this);
        return I == null ? I = p2 : Z2(I, 0, 8), Oe(j3, j3.e + 1, I);
      }, se.isEqualTo = se.eq = function(I, j3) {
        return W2(this, new M(I, j3)) === 0;
      }, se.isFinite = function() {
        return !!this.c;
      }, se.isGreaterThan = se.gt = function(I, j3) {
        return W2(this, new M(I, j3)) > 0;
      }, se.isGreaterThanOrEqualTo = se.gte = function(I, j3) {
        return (j3 = W2(this, new M(I, j3))) === 1 || j3 === 0;
      }, se.isInteger = function() {
        return !!this.c && $(this.e / l) > this.c.length - 2;
      }, se.isLessThan = se.lt = function(I, j3) {
        return W2(this, new M(I, j3)) < 0;
      }, se.isLessThanOrEqualTo = se.lte = function(I, j3) {
        return (j3 = W2(this, new M(I, j3))) === -1 || j3 === 0;
      }, se.isNaN = function() {
        return !this.s;
      }, se.isNegative = function() {
        return this.s < 0;
      }, se.isPositive = function() {
        return this.s > 0;
      }, se.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, se.minus = function(I, j3) {
        var P5, ee2, oe, te, ae = this, ne = ae.s;
        if (I = new M(I, j3), j3 = I.s, !ne || !j3)
          return new M(NaN);
        if (ne != j3)
          return I.s = -j3, ae.plus(I);
        var X2 = ae.e / l, R3 = I.e / l, w = ae.c, T2 = I.c;
        if (!X2 || !R3) {
          if (!w || !T2)
            return w ? (I.s = -j3, I) : new M(T2 ? ae : NaN);
          if (!w[0] || !T2[0])
            return T2[0] ? (I.s = -j3, I) : new M(w[0] ? ae : p2 == 3 ? -0 : 0);
        }
        if (X2 = $(X2), R3 = $(R3), w = w.slice(), ne = X2 - R3) {
          for ((te = ne < 0) ? (ne = -ne, oe = w) : (R3 = X2, oe = T2), oe.reverse(), j3 = ne; j3--; oe.push(0))
            ;
          oe.reverse();
        } else
          for (ee2 = (te = (ne = w.length) < (j3 = T2.length)) ? ne : j3, ne = j3 = 0; j3 < ee2; j3++)
            if (w[j3] != T2[j3]) {
              te = w[j3] < T2[j3];
              break;
            }
        if (te && (oe = w, w = T2, T2 = oe, I.s = -I.s), j3 = (ee2 = T2.length) - (P5 = w.length), j3 > 0)
          for (; j3--; w[P5++] = 0)
            ;
        for (j3 = f - 1; ee2 > ne; ) {
          if (w[--ee2] < T2[ee2]) {
            for (P5 = ee2; P5 && !w[--P5]; w[P5] = j3)
              ;
            --w[P5], w[ee2] += f;
          }
          w[ee2] -= T2[ee2];
        }
        for (; w[0] == 0; w.splice(0, 1), --R3)
          ;
        return w[0] ? Me(I, w, R3) : (I.s = p2 == 3 ? -1 : 1, I.c = [I.e = 0], I);
      }, se.modulo = se.mod = function(I, j3) {
        var P5, ee2, oe = this;
        return I = new M(I, j3), !oe.c || !I.s || I.c && !I.c[0] ? new M(NaN) : !I.c || oe.c && !oe.c[0] ? new M(oe) : (v == 9 ? (ee2 = I.s, I.s = 1, P5 = H2(oe, I, 0, 3), I.s = ee2, P5.s *= ee2) : P5 = H2(oe, I, 0, v), I = oe.minus(P5.times(I)), !I.c[0] && v == 1 && (I.s = oe.s), I);
      }, se.multipliedBy = se.times = function(I, j3) {
        var P5, ee2, oe, te, ae, ne, X2, R3, w, T2, q2, L2, G2, K5, xe, me2 = this, _e2 = me2.c, fe = (I = new M(I, j3)).c;
        if (!_e2 || !fe || !_e2[0] || !fe[0])
          return !me2.s || !I.s || _e2 && !_e2[0] && !fe || fe && !fe[0] && !_e2 ? I.c = I.e = I.s = null : (I.s *= me2.s, !_e2 || !fe ? I.c = I.e = null : (I.c = [0], I.e = 0)), I;
        for (ee2 = $(me2.e / l) + $(I.e / l), I.s *= me2.s, X2 = _e2.length, T2 = fe.length, X2 < T2 && (G2 = _e2, _e2 = fe, fe = G2, oe = X2, X2 = T2, T2 = oe), oe = X2 + T2, G2 = []; oe--; G2.push(0))
          ;
        for (K5 = f, xe = F3, oe = T2; --oe >= 0; ) {
          for (P5 = 0, q2 = fe[oe] % xe, L2 = fe[oe] / xe | 0, ae = X2, te = oe + ae; te > oe; )
            R3 = _e2[--ae] % xe, w = _e2[ae] / xe | 0, ne = L2 * R3 + w * q2, R3 = q2 * R3 + ne % xe * xe + G2[te] + P5, P5 = (R3 / K5 | 0) + (ne / xe | 0) + L2 * w, G2[te--] = R3 % K5;
          G2[te] = P5;
        }
        return P5 ? ++ee2 : G2.splice(0, 1), Me(I, G2, ee2);
      }, se.negated = function() {
        var I = new M(this);
        return I.s = -I.s || null, I;
      }, se.plus = function(I, j3) {
        var P5, ee2 = this, oe = ee2.s;
        if (I = new M(I, j3), j3 = I.s, !oe || !j3)
          return new M(NaN);
        if (oe != j3)
          return I.s = -j3, ee2.minus(I);
        var te = ee2.e / l, ae = I.e / l, ne = ee2.c, X2 = I.c;
        if (!te || !ae) {
          if (!ne || !X2)
            return new M(oe / 0);
          if (!ne[0] || !X2[0])
            return X2[0] ? I : new M(ne[0] ? ee2 : oe * 0);
        }
        if (te = $(te), ae = $(ae), ne = ne.slice(), oe = te - ae) {
          for (oe > 0 ? (ae = te, P5 = X2) : (oe = -oe, P5 = ne), P5.reverse(); oe--; P5.push(0))
            ;
          P5.reverse();
        }
        for (oe = ne.length, j3 = X2.length, oe - j3 < 0 && (P5 = X2, X2 = ne, ne = P5, j3 = oe), oe = 0; j3; )
          oe = (ne[--j3] = ne[j3] + X2[j3] + oe) / f | 0, ne[j3] = f === ne[j3] ? 0 : ne[j3] % f;
        return oe && (ne = [oe].concat(ne), ++ae), Me(I, ne, ae);
      }, se.precision = se.sd = function(I, j3) {
        var P5, ee2, oe, te = this;
        if (I != null && I !== !!I)
          return Z2(I, 1, z5), j3 == null ? j3 = p2 : Z2(j3, 0, 8), Oe(new M(te), I, j3);
        if (!(P5 = te.c))
          return null;
        if (oe = P5.length - 1, ee2 = oe * l + 1, oe = P5[oe]) {
          for (; oe % 10 == 0; oe /= 10, ee2--)
            ;
          for (oe = P5[0]; oe >= 10; oe /= 10, ee2++)
            ;
        }
        return I && te.e + 1 > ee2 && (ee2 = te.e + 1), ee2;
      }, se.shiftedBy = function(I) {
        return Z2(I, -m3, m3), this.times("1e" + I);
      }, se.squareRoot = se.sqrt = function() {
        var I, j3, P5, ee2, oe, te = this, ae = te.c, ne = te.s, X2 = te.e, R3 = c2 + 4, w = new M("0.5");
        if (ne !== 1 || !ae || !ae[0])
          return new M(!ne || ne < 0 && (!ae || ae[0]) ? NaN : ae ? te : 1 / 0);
        if (ne = Math.sqrt(+be(te)), ne == 0 || ne == 1 / 0 ? (j3 = re(ae), (j3.length + X2) % 2 == 0 && (j3 += "0"), ne = Math.sqrt(+j3), X2 = $((X2 + 1) / 2) - (X2 < 0 || X2 % 2), ne == 1 / 0 ? j3 = "5e" + X2 : (j3 = ne.toExponential(), j3 = j3.slice(0, j3.indexOf("e") + 1) + X2), P5 = new M(j3)) : P5 = new M(ne + ""), P5.c[0]) {
          for (X2 = P5.e, ne = X2 + R3, ne < 3 && (ne = 0); ; )
            if (oe = P5, P5 = w.times(oe.plus(H2(te, oe, R3, 1))), re(oe.c).slice(0, ne) === (j3 = re(P5.c)).slice(0, ne))
              if (P5.e < X2 && --ne, j3 = j3.slice(ne - 3, ne + 1), j3 == "9999" || !ee2 && j3 == "4999") {
                if (!ee2 && (Oe(oe, oe.e + c2 + 2, 0), oe.times(oe).eq(te))) {
                  P5 = oe;
                  break;
                }
                R3 += 4, ne += 4, ee2 = 1;
              } else {
                (!+j3 || !+j3.slice(1) && j3.charAt(0) == "5") && (Oe(P5, P5.e + c2 + 2, 1), I = !P5.times(P5).eq(te));
                break;
              }
        }
        return Oe(P5, P5.e + c2 + 1, p2, I);
      }, se.toExponential = function(I, j3) {
        return I != null && (Z2(I, 0, z5), I++), de2(this, I, j3, 1);
      }, se.toFixed = function(I, j3) {
        return I != null && (Z2(I, 0, z5), I = I + this.e + 1), de2(this, I, j3);
      }, se.toFormat = function(I, j3, P5) {
        var ee2, oe = this;
        if (P5 == null)
          I != null && j3 && typeof j3 == "object" ? (P5 = j3, j3 = null) : I && typeof I == "object" ? (P5 = I, I = j3 = null) : P5 = E2;
        else if (typeof P5 != "object")
          throw Error(s2 + "Argument not an object: " + P5);
        if (ee2 = oe.toFixed(I, j3), oe.c) {
          var te, ae = ee2.split("."), ne = +P5.groupSize, X2 = +P5.secondaryGroupSize, R3 = P5.groupSeparator || "", w = ae[0], T2 = ae[1], q2 = oe.s < 0, L2 = q2 ? w.slice(1) : w, G2 = L2.length;
          if (X2 && (te = ne, ne = X2, X2 = te, G2 -= te), ne > 0 && G2 > 0) {
            for (te = G2 % ne || ne, w = L2.substr(0, te); te < G2; te += ne)
              w += R3 + L2.substr(te, ne);
            X2 > 0 && (w += R3 + L2.slice(te)), q2 && (w = "-" + w);
          }
          ee2 = T2 ? w + (P5.decimalSeparator || "") + ((X2 = +P5.fractionGroupSize) ? T2.replace(new RegExp("\\d{" + X2 + "}\\B", "g"), "$&" + (P5.fractionGroupSeparator || "")) : T2) : w;
        }
        return (P5.prefix || "") + ee2 + (P5.suffix || "");
      }, se.toFraction = function(I) {
        var j3, P5, ee2, oe, te, ae, ne, X2, R3, w, T2, q2, L2 = this, G2 = L2.c;
        if (I != null && (ne = new M(I), !ne.isInteger() && (ne.c || ne.s !== 1) || ne.lt(N3)))
          throw Error(s2 + "Argument " + (ne.isInteger() ? "out of range: " : "not an integer: ") + be(ne));
        if (!G2)
          return new M(L2);
        for (j3 = new M(N3), R3 = P5 = new M(N3), ee2 = X2 = new M(N3), q2 = re(G2), te = j3.e = q2.length - L2.e - 1, j3.c[0] = A2[(ae = te % l) < 0 ? l + ae : ae], I = !I || ne.comparedTo(j3) > 0 ? te > 0 ? j3 : R3 : ne, ae = b2, b2 = 1 / 0, ne = new M(q2), X2.c[0] = 0; w = H2(ne, j3, 0, 1), oe = P5.plus(w.times(ee2)), oe.comparedTo(I) != 1; )
          P5 = ee2, ee2 = oe, R3 = X2.plus(w.times(oe = R3)), X2 = oe, j3 = ne.minus(w.times(oe = j3)), ne = oe;
        return oe = H2(I.minus(P5), ee2, 0, 1), X2 = X2.plus(oe.times(R3)), P5 = P5.plus(oe.times(ee2)), X2.s = R3.s = L2.s, te = te * 2, T2 = H2(R3, ee2, te, p2).minus(L2).abs().comparedTo(H2(X2, P5, te, p2).minus(L2).abs()) < 1 ? [R3, ee2] : [X2, P5], b2 = ae, T2;
      }, se.toNumber = function() {
        return +be(this);
      }, se.toPrecision = function(I, j3) {
        return I != null && Z2(I, 1, z5), de2(this, I, j3, 2);
      }, se.toString = function(I) {
        var j3, P5 = this, ee2 = P5.s, oe = P5.e;
        return oe === null ? ee2 ? (j3 = "Infinity", ee2 < 0 && (j3 = "-" + j3)) : j3 = "NaN" : (I == null ? j3 = oe <= h2 || oe >= a ? ge(re(P5.c), oe) : Se(re(P5.c), oe, "0") : I === 10 && y2 ? (P5 = Oe(new M(P5), c2 + oe + 1, p2), j3 = Se(re(P5.c), P5.e, "0")) : (Z2(I, 2, B.length, "Base"), j3 = le(Se(re(P5.c), oe, "0"), 10, I, ee2, true)), ee2 < 0 && P5.c[0] && (j3 = "-" + j3)), j3;
      }, se.valueOf = se.toJSON = function() {
        return be(this);
      }, se._isBigNumber = true, pe2 != null && M.set(pe2), M;
    }
    function $(pe2) {
      var H2 = pe2 | 0;
      return pe2 > 0 || pe2 === H2 ? H2 : H2 - 1;
    }
    function re(pe2) {
      for (var H2, le, ie = 1, se = pe2.length, N3 = pe2[0] + ""; ie < se; ) {
        for (H2 = pe2[ie++] + "", le = l - H2.length; le--; H2 = "0" + H2)
          ;
        N3 += H2;
      }
      for (se = N3.length; N3.charCodeAt(--se) === 48; )
        ;
      return N3.slice(0, se + 1 || 1);
    }
    function W2(pe2, H2) {
      var le, ie, se = pe2.c, N3 = H2.c, c2 = pe2.s, p2 = H2.s, h2 = pe2.e, a = H2.e;
      if (!c2 || !p2)
        return null;
      if (le = se && !se[0], ie = N3 && !N3[0], le || ie)
        return le ? ie ? 0 : -p2 : c2;
      if (c2 != p2)
        return c2;
      if (le = c2 < 0, ie = h2 == a, !se || !N3)
        return ie ? 0 : !se ^ le ? 1 : -1;
      if (!ie)
        return h2 > a ^ le ? 1 : -1;
      for (p2 = (h2 = se.length) < (a = N3.length) ? h2 : a, c2 = 0; c2 < p2; c2++)
        if (se[c2] != N3[c2])
          return se[c2] > N3[c2] ^ le ? 1 : -1;
      return h2 == a ? 0 : h2 > a ^ le ? 1 : -1;
    }
    function Z2(pe2, H2, le, ie) {
      if (pe2 < H2 || pe2 > le || pe2 !== n(pe2))
        throw Error(s2 + (ie || "Argument") + (typeof pe2 == "number" ? pe2 < H2 || pe2 > le ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(pe2));
    }
    function ue(pe2) {
      var H2 = pe2.c.length - 1;
      return $(pe2.e / l) == H2 && pe2.c[H2] % 2 != 0;
    }
    function ge(pe2, H2) {
      return (pe2.length > 1 ? pe2.charAt(0) + "." + pe2.slice(1) : pe2) + (H2 < 0 ? "e" : "e+") + H2;
    }
    function Se(pe2, H2, le) {
      var ie, se;
      if (H2 < 0) {
        for (se = le + "."; ++H2; se += le)
          ;
        pe2 = se + pe2;
      } else if (ie = pe2.length, ++H2 > ie) {
        for (se = le, H2 -= ie; --H2; se += le)
          ;
        pe2 += se;
      } else
        H2 < ie && (pe2 = pe2.slice(0, H2) + "." + pe2.slice(H2));
      return pe2;
    }
    e = V(), e.default = e.BigNumber = e, typeof define == "function" && define.amd ? define(function() {
      return e;
    }) : typeof Ch < "u" && Ch.exports ? Ch.exports = e : (t || (t = typeof self < "u" && self ? self : window), t.BigNumber = e);
  })(z3);
});
var K3 = k((nC, G3) => {
  U();
  var H3 = _g2(), $3 = G3.exports;
  (function() {
    var r = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, i, n, s2 = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, o;
    function f(m3) {
      return r.lastIndex = 0, r.test(m3) ? '"' + m3.replace(r, function(A2) {
        var F3 = s2[A2];
        return typeof F3 == "string" ? F3 : "\\u" + ("0000" + A2.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + m3 + '"';
    }
    function l(m3, A2) {
      var F3, z3, V, $, re = i, W2, Z2 = A2[m3], ue = Z2 != null && (Z2 instanceof H3 || H3.isBigNumber(Z2));
      switch (Z2 && typeof Z2 == "object" && typeof Z2.toJSON == "function" && (Z2 = Z2.toJSON(m3)), typeof o == "function" && (Z2 = o.call(A2, m3, Z2)), typeof Z2) {
        case "string":
          return ue ? Z2 : f(Z2);
        case "number":
          return isFinite(Z2) ? String(Z2) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(Z2);
        case "object":
          if (!Z2)
            return "null";
          if (i += n, W2 = [], Object.prototype.toString.apply(Z2) === "[object Array]") {
            for ($ = Z2.length, F3 = 0; F3 < $; F3 += 1)
              W2[F3] = l(F3, Z2) || "null";
            return V = W2.length === 0 ? "[]" : i ? `[
` + i + W2.join(`,
` + i) + `
` + re + "]" : "[" + W2.join(",") + "]", i = re, V;
          }
          if (o && typeof o == "object")
            for ($ = o.length, F3 = 0; F3 < $; F3 += 1)
              typeof o[F3] == "string" && (z3 = o[F3], V = l(z3, Z2), V && W2.push(f(z3) + (i ? ": " : ":") + V));
          else
            Object.keys(Z2).forEach(function(ge) {
              var Se = l(ge, Z2);
              Se && W2.push(f(ge) + (i ? ": " : ":") + Se);
            });
          return V = W2.length === 0 ? "{}" : i ? `{
` + i + W2.join(`,
` + i) + `
` + re + "}" : "{" + W2.join(",") + "}", i = re, V;
      }
    }
    typeof $3.stringify != "function" && ($3.stringify = function(m3, A2, F3) {
      var z3;
      if (i = "", n = "", typeof F3 == "number")
        for (z3 = 0; z3 < F3; z3 += 1)
          n += " ";
      else
        typeof F3 == "string" && (n = F3);
      if (o = A2, A2 && typeof A2 != "function" && (typeof A2 != "object" || typeof A2.length != "number"))
        throw new Error("JSON.stringify");
      return l("", { "": m3 });
    });
  })();
});
var V3 = k((sC, W3) => {
  U();
  var Oh = null, IF = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, TF = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/, FF = function(t) {
    var e = { strict: false, storeAsString: false, alwaysParseAsBig: false, useNativeBigInt: false, protoAction: "error", constructorAction: "error" };
    if (t != null) {
      if (t.strict === true && (e.strict = true), t.storeAsString === true && (e.storeAsString = true), e.alwaysParseAsBig = t.alwaysParseAsBig === true ? t.alwaysParseAsBig : false, e.useNativeBigInt = t.useNativeBigInt === true ? t.useNativeBigInt : false, typeof t.constructorAction < "u")
        if (t.constructorAction === "error" || t.constructorAction === "ignore" || t.constructorAction === "preserve")
          e.constructorAction = t.constructorAction;
        else
          throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${t.constructorAction}`);
      if (typeof t.protoAction < "u")
        if (t.protoAction === "error" || t.protoAction === "ignore" || t.protoAction === "preserve")
          e.protoAction = t.protoAction;
        else
          throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${t.protoAction}`);
    }
    var r, i, n = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: `
`, r: "\r", t: "	" }, s2, o = function(re) {
      throw { name: "SyntaxError", message: re, at: r, text: s2 };
    }, f = function(re) {
      return re && re !== i && o("Expected '" + re + "' instead of '" + i + "'"), i = s2.charAt(r), r += 1, i;
    }, l = function() {
      var re, W2 = "";
      for (i === "-" && (W2 = "-", f("-")); i >= "0" && i <= "9"; )
        W2 += i, f();
      if (i === ".")
        for (W2 += "."; f() && i >= "0" && i <= "9"; )
          W2 += i;
      if (i === "e" || i === "E")
        for (W2 += i, f(), (i === "-" || i === "+") && (W2 += i, f()); i >= "0" && i <= "9"; )
          W2 += i, f();
      if (re = +W2, !isFinite(re))
        o("Bad number");
      else
        return Oh == null && (Oh = _g2()), W2.length > 15 ? e.storeAsString ? W2 : e.useNativeBigInt ? BigInt(W2) : new Oh(W2) : e.alwaysParseAsBig ? e.useNativeBigInt ? BigInt(re) : new Oh(re) : re;
    }, m3 = function() {
      var re, W2, Z2 = "", ue;
      if (i === '"')
        for (var ge = r; f(); ) {
          if (i === '"')
            return r - 1 > ge && (Z2 += s2.substring(ge, r - 1)), f(), Z2;
          if (i === "\\") {
            if (r - 1 > ge && (Z2 += s2.substring(ge, r - 1)), f(), i === "u") {
              for (ue = 0, W2 = 0; W2 < 4 && (re = parseInt(f(), 16), !!isFinite(re)); W2 += 1)
                ue = ue * 16 + re;
              Z2 += String.fromCharCode(ue);
            } else if (typeof n[i] == "string")
              Z2 += n[i];
            else
              break;
            ge = r;
          }
        }
      o("Bad string");
    }, A2 = function() {
      for (; i && i <= " "; )
        f();
    }, F3 = function() {
      switch (i) {
        case "t":
          return f("t"), f("r"), f("u"), f("e"), true;
        case "f":
          return f("f"), f("a"), f("l"), f("s"), f("e"), false;
        case "n":
          return f("n"), f("u"), f("l"), f("l"), null;
      }
      o("Unexpected '" + i + "'");
    }, z3, V = function() {
      var re = [];
      if (i === "[") {
        if (f("["), A2(), i === "]")
          return f("]"), re;
        for (; i; ) {
          if (re.push(z3()), A2(), i === "]")
            return f("]"), re;
          f(","), A2();
        }
      }
      o("Bad array");
    }, $ = function() {
      var re, W2 = /* @__PURE__ */ Object.create(null);
      if (i === "{") {
        if (f("{"), A2(), i === "}")
          return f("}"), W2;
        for (; i; ) {
          if (re = m3(), A2(), f(":"), e.strict === true && Object.hasOwnProperty.call(W2, re) && o('Duplicate key "' + re + '"'), IF.test(re) === true ? e.protoAction === "error" ? o("Object contains forbidden prototype property") : e.protoAction === "ignore" ? z3() : W2[re] = z3() : TF.test(re) === true ? e.constructorAction === "error" ? o("Object contains forbidden constructor property") : e.constructorAction === "ignore" ? z3() : W2[re] = z3() : W2[re] = z3(), A2(), i === "}")
            return f("}"), W2;
          f(","), A2();
        }
      }
      o("Bad object");
    };
    return z3 = function() {
      switch (A2(), i) {
        case "{":
          return $();
        case "[":
          return V();
        case '"':
          return m3();
        case "-":
          return l();
        default:
          return i >= "0" && i <= "9" ? l() : F3();
      }
    }, function(re, W2) {
      var Z2;
      return s2 = re + "", r = 0, i = " ", Z2 = z3(), A2(), i && o("Syntax error"), typeof W2 == "function" ? function ue(ge, Se) {
        var H2, le = ge[Se];
        return le && typeof le == "object" && Object.keys(le).forEach(function(ie) {
          H2 = ue(le, ie), H2 !== void 0 ? le[ie] = H2 : delete le[ie];
        }), W2.call(ge, Se, le);
      }({ "": Z2 }, "") : Z2;
    };
  };
  W3.exports = FF;
});
var Z3 = k((oC, jh) => {
  U();
  var Y3 = K3().stringify, J3 = V3();
  jh.exports = function(t) {
    return { parse: J3(t), stringify: Y3 };
  };
  jh.exports.parse = J3();
  jh.exports.stringify = Y3;
});
var o4 = k((Ic, Mg) => {
  U();
  (function(t, e) {
    typeof Ic == "object" && typeof Mg == "object" ? Mg.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof Ic == "object" ? Ic.MessagePack = e() : t.MessagePack = e();
  })(Ic, function() {
    return function(t) {
      var e = {};
      function r(i) {
        if (e[i])
          return e[i].exports;
        var n = e[i] = { i, l: false, exports: {} };
        return t[i].call(n.exports, n, n.exports, r), n.l = true, n.exports;
      }
      return r.m = t, r.c = e, r.d = function(i, n, s2) {
        r.o(i, n) || Object.defineProperty(i, n, { enumerable: true, get: s2 });
      }, r.r = function(i) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: true });
      }, r.t = function(i, n) {
        if (1 & n && (i = r(i)), 8 & n || 4 & n && typeof i == "object" && i && i.__esModule)
          return i;
        var s2 = /* @__PURE__ */ Object.create(null);
        if (r.r(s2), Object.defineProperty(s2, "default", { enumerable: true, value: i }), 2 & n && typeof i != "string")
          for (var o in i)
            r.d(s2, o, function(f) {
              return i[f];
            }.bind(null, o));
        return s2;
      }, r.n = function(i) {
        var n = i && i.__esModule ? function() {
          return i.default;
        } : function() {
          return i;
        };
        return r.d(n, "a", n), n;
      }, r.o = function(i, n) {
        return Object.prototype.hasOwnProperty.call(i, n);
      }, r.p = "", r(r.s = 0);
    }([function(t, e, r) {
      r.r(e), r.d(e, "encode", function() {
        return p2;
      }), r.d(e, "decode", function() {
        return Oe;
      }), r.d(e, "decodeAsync", function() {
        return ae;
      }), r.d(e, "decodeArrayStream", function() {
        return ne;
      }), r.d(e, "decodeStream", function() {
        return X2;
      }), r.d(e, "Decoder", function() {
        return Ee;
      }), r.d(e, "Encoder", function() {
        return N3;
      }), r.d(e, "ExtensionCodec", function() {
        return le;
      }), r.d(e, "ExtData", function() {
        return V;
      }), r.d(e, "EXT_TIMESTAMP", function() {
        return W$12;
      }), r.d(e, "encodeDateToTimeSpec", function() {
        return ue;
      }), r.d(e, "encodeTimeSpecToTimestamp", function() {
        return Z2;
      }), r.d(e, "decodeTimestampToTimeSpec", function() {
        return Se;
      }), r.d(e, "encodeTimestampExtension", function() {
        return ge;
      }), r.d(e, "decodeTimestampExtension", function() {
        return pe2;
      });
      var i = function(R3, w) {
        var T2 = typeof Symbol == "function" && R3[Symbol.iterator];
        if (!T2)
          return R3;
        var q2, L2, G2 = T2.call(R3), K5 = [];
        try {
          for (; (w === void 0 || w-- > 0) && !(q2 = G2.next()).done; )
            K5.push(q2.value);
        } catch (xe) {
          L2 = { error: xe };
        } finally {
          try {
            q2 && !q2.done && (T2 = G2.return) && T2.call(G2);
          } finally {
            if (L2)
              throw L2.error;
          }
        }
        return K5;
      }, n = function() {
        for (var R3 = [], w = 0; w < arguments.length; w++)
          R3 = R3.concat(i(arguments[w]));
        return R3;
      }, s2 = typeof W.default < "u" && typeof TextEncoder < "u" && typeof TextDecoder < "u";
      function o(R3) {
        for (var w = R3.length, T2 = 0, q2 = 0; q2 < w; ) {
          var L2 = R3.charCodeAt(q2++);
          if ((4294967168 & L2) != 0)
            if ((4294965248 & L2) == 0)
              T2 += 2;
            else {
              if (L2 >= 55296 && L2 <= 56319 && q2 < w) {
                var G2 = R3.charCodeAt(q2);
                (64512 & G2) == 56320 && (++q2, L2 = ((1023 & L2) << 10) + (1023 & G2) + 65536);
              }
              T2 += (4294901760 & L2) == 0 ? 3 : 4;
            }
          else
            T2++;
        }
        return T2;
      }
      var f = s2 ? new TextEncoder() : void 0, l = typeof W.default < "u" ? 200 : 0, m3 = (f == null ? void 0 : f.encodeInto) ? function(R3, w, T2) {
        f.encodeInto(R3, w.subarray(T2));
      } : function(R3, w, T2) {
        w.set(f.encode(R3), T2);
      };
      function A2(R3, w, T2) {
        for (var q2 = w, L2 = q2 + T2, G2 = [], K5 = ""; q2 < L2; ) {
          var xe = R3[q2++];
          if ((128 & xe) == 0)
            G2.push(xe);
          else if ((224 & xe) == 192) {
            var me2 = 63 & R3[q2++];
            G2.push((31 & xe) << 6 | me2);
          } else if ((240 & xe) == 224) {
            me2 = 63 & R3[q2++];
            var _e2 = 63 & R3[q2++];
            G2.push((31 & xe) << 12 | me2 << 6 | _e2);
          } else if ((248 & xe) == 240) {
            var fe = (7 & xe) << 18 | (me2 = 63 & R3[q2++]) << 12 | (_e2 = 63 & R3[q2++]) << 6 | 63 & R3[q2++];
            fe > 65535 && (fe -= 65536, G2.push(fe >>> 10 & 1023 | 55296), fe = 56320 | 1023 & fe), G2.push(fe);
          } else
            G2.push(xe);
          G2.length >= 4096 && (K5 += String.fromCharCode.apply(String, n(G2)), G2.length = 0);
        }
        return G2.length > 0 && (K5 += String.fromCharCode.apply(String, n(G2))), K5;
      }
      var F3 = s2 ? new TextDecoder() : null, z3 = typeof W.default < "u" ? 200 : 0, V = function(R3, w) {
        this.type = R3, this.data = w;
      };
      function $(R3, w, T2) {
        var q2 = Math.floor(T2 / 4294967296), L2 = T2;
        R3.setUint32(w, q2), R3.setUint32(w + 4, L2);
      }
      function re(R3, w) {
        var T2 = R3.getInt32(w), q2 = R3.getUint32(w + 4), L2 = T2 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || T2 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && q2 === 0, G2 = T2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        return L2 || G2 ? BigInt(T2) * BigInt(4294967296) + BigInt(q2) : 4294967296 * T2 + q2;
      }
      var W$12 = -1;
      function Z2(R3) {
        var w = R3.sec, T2 = R3.nsec;
        if (w >= 0 && T2 >= 0 && w <= 17179869183) {
          if (T2 === 0 && w <= 4294967295) {
            var q2 = new Uint8Array(4);
            return (K5 = new DataView(q2.buffer)).setUint32(0, w), q2;
          }
          var L2 = w / 4294967296, G2 = 4294967295 & w;
          return q2 = new Uint8Array(8), (K5 = new DataView(q2.buffer)).setUint32(0, T2 << 2 | 3 & L2), K5.setUint32(4, G2), q2;
        }
        var K5;
        return q2 = new Uint8Array(12), (K5 = new DataView(q2.buffer)).setUint32(0, T2), $(K5, 4, w), q2;
      }
      function ue(R3) {
        var w = R3.getTime(), T2 = Math.floor(w / 1e3), q2 = 1e6 * (w - 1e3 * T2), L2 = Math.floor(q2 / 1e9);
        return { sec: T2 + L2, nsec: q2 - 1e9 * L2 };
      }
      function ge(R3) {
        return R3 instanceof Date ? Z2(ue(R3)) : null;
      }
      function Se(R3) {
        var w = new DataView(R3.buffer, R3.byteOffset, R3.byteLength);
        switch (R3.byteLength) {
          case 4:
            return { sec: w.getUint32(0), nsec: 0 };
          case 8:
            var T2 = w.getUint32(0);
            return { sec: 4294967296 * (3 & T2) + w.getUint32(4), nsec: T2 >>> 2 };
          case 12:
            return { sec: re(w, 4), nsec: w.getUint32(0) };
          default:
            throw new Error("Unrecognized data size for timestamp: " + R3.length);
        }
      }
      function pe2(R3) {
        var w = Se(R3);
        return new Date(1e3 * w.sec + w.nsec / 1e6);
      }
      var H2 = { type: W$12, encode: ge, decode: pe2 }, le = function() {
        function R3() {
          this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(H2);
        }
        return R3.prototype.register = function(w) {
          var T2 = w.type, q2 = w.encode, L2 = w.decode;
          if (T2 >= 0)
            this.encoders[T2] = q2, this.decoders[T2] = L2;
          else {
            var G2 = 1 + T2;
            this.builtInEncoders[G2] = q2, this.builtInDecoders[G2] = L2;
          }
        }, R3.prototype.tryToEncode = function(w, T2) {
          for (var q2 = 0; q2 < this.builtInEncoders.length; q2++)
            if ((L2 = this.builtInEncoders[q2]) != null && (G2 = L2(w, T2)) != null)
              return new V(-1 - q2, G2);
          for (q2 = 0; q2 < this.encoders.length; q2++) {
            var L2, G2;
            if ((L2 = this.encoders[q2]) != null && (G2 = L2(w, T2)) != null)
              return new V(q2, G2);
          }
          return w instanceof V ? w : null;
        }, R3.prototype.decode = function(w, T2, q2) {
          var L2 = T2 < 0 ? this.builtInDecoders[-1 - T2] : this.decoders[T2];
          return L2 ? L2(w, T2, q2) : new V(T2, w);
        }, R3.defaultCodec = new R3(), R3;
      }();
      function ie(R3) {
        return R3 instanceof Uint8Array ? R3 : ArrayBuffer.isView(R3) ? new Uint8Array(R3.buffer, R3.byteOffset, R3.byteLength) : R3 instanceof ArrayBuffer ? new Uint8Array(R3) : Uint8Array.from(R3);
      }
      var se = function(R3) {
        var w = typeof Symbol == "function" && Symbol.iterator, T2 = w && R3[w], q2 = 0;
        if (T2)
          return T2.call(R3);
        if (R3 && typeof R3.length == "number")
          return { next: function() {
            return R3 && q2 >= R3.length && (R3 = void 0), { value: R3 && R3[q2++], done: !R3 };
          } };
        throw new TypeError(w ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, N3 = function() {
        function R3(w, T2, q2, L2, G2, K5, xe, me2) {
          w === void 0 && (w = le.defaultCodec), T2 === void 0 && (T2 = void 0), q2 === void 0 && (q2 = 100), L2 === void 0 && (L2 = 2048), G2 === void 0 && (G2 = false), K5 === void 0 && (K5 = false), xe === void 0 && (xe = false), me2 === void 0 && (me2 = false), this.extensionCodec = w, this.context = T2, this.maxDepth = q2, this.initialBufferSize = L2, this.sortKeys = G2, this.forceFloat32 = K5, this.ignoreUndefined = xe, this.forceIntegerToFloat = me2, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
        }
        return R3.prototype.getUint8Array = function() {
          return this.bytes.subarray(0, this.pos);
        }, R3.prototype.reinitializeState = function() {
          this.pos = 0;
        }, R3.prototype.encode = function(w) {
          return this.reinitializeState(), this.doEncode(w, 1), this.getUint8Array();
        }, R3.prototype.doEncode = function(w, T2) {
          if (T2 > this.maxDepth)
            throw new Error("Too deep objects in depth " + T2);
          w == null ? this.encodeNil() : typeof w == "boolean" ? this.encodeBoolean(w) : typeof w == "number" ? this.encodeNumber(w) : typeof w == "string" ? this.encodeString(w) : typeof w == "bigint" ? this.encodebigint(w) : this.encodeObject(w, T2);
        }, R3.prototype.ensureBufferSizeToWrite = function(w) {
          var T2 = this.pos + w;
          this.view.byteLength < T2 && this.resizeBuffer(2 * T2);
        }, R3.prototype.resizeBuffer = function(w) {
          var T2 = new ArrayBuffer(w), q2 = new Uint8Array(T2), L2 = new DataView(T2);
          q2.set(this.bytes), this.view = L2, this.bytes = q2;
        }, R3.prototype.encodeNil = function() {
          this.writeU8(192);
        }, R3.prototype.encodeBoolean = function(w) {
          w === false ? this.writeU8(194) : this.writeU8(195);
        }, R3.prototype.encodeNumber = function(w) {
          Number.isSafeInteger(w) && !this.forceIntegerToFloat ? w >= 0 ? w < 128 ? this.writeU8(w) : w < 256 ? (this.writeU8(204), this.writeU8(w)) : w < 65536 ? (this.writeU8(205), this.writeU16(w)) : w < 4294967296 ? (this.writeU8(206), this.writeU32(w)) : (this.writeU8(207), this.writeU64(w)) : w >= -32 ? this.writeU8(224 | w + 32) : w >= -128 ? (this.writeU8(208), this.writeI8(w)) : w >= -32768 ? (this.writeU8(209), this.writeI16(w)) : w >= -2147483648 ? (this.writeU8(210), this.writeI32(w)) : (this.writeU8(211), this.writeI64(w)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(w)) : (this.writeU8(203), this.writeF64(w));
        }, R3.prototype.encodebigint = function(w) {
          w >= BigInt(0) ? w < BigInt(128) ? this.writeU8(Number(w)) : w < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(w))) : w < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(w))) : w < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(w))) : (this.writeU8(207), this.writeBig64(w)) : w >= BigInt(-32) ? this.writeU8(224 | Number(w) + 32) : w >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(w))) : w >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(w))) : w >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(w))) : (this.writeU8(211), this.writeBig64(w));
        }, R3.prototype.writeStringHeader = function(w) {
          if (w < 32)
            this.writeU8(160 + w);
          else if (w < 256)
            this.writeU8(217), this.writeU8(w);
          else if (w < 65536)
            this.writeU8(218), this.writeU16(w);
          else {
            if (!(w < 4294967296))
              throw new Error("Too long string: " + w + " bytes in UTF-8");
            this.writeU8(219), this.writeU32(w);
          }
        }, R3.prototype.encodeString = function(w) {
          var T2 = w.length;
          if (s2 && T2 > l) {
            var q2 = o(w);
            this.ensureBufferSizeToWrite(5 + q2), this.writeStringHeader(q2), m3(w, this.bytes, this.pos), this.pos += q2;
          } else
            q2 = o(w), this.ensureBufferSizeToWrite(5 + q2), this.writeStringHeader(q2), function(L2, G2, K5) {
              for (var xe = L2.length, me2 = K5, _e2 = 0; _e2 < xe; ) {
                var fe = L2.charCodeAt(_e2++);
                if ((4294967168 & fe) != 0) {
                  if ((4294965248 & fe) == 0)
                    G2[me2++] = fe >> 6 & 31 | 192;
                  else {
                    if (fe >= 55296 && fe <= 56319 && _e2 < xe) {
                      var ke = L2.charCodeAt(_e2);
                      (64512 & ke) == 56320 && (++_e2, fe = ((1023 & fe) << 10) + (1023 & ke) + 65536);
                    }
                    (4294901760 & fe) == 0 ? (G2[me2++] = fe >> 12 & 15 | 224, G2[me2++] = fe >> 6 & 63 | 128) : (G2[me2++] = fe >> 18 & 7 | 240, G2[me2++] = fe >> 12 & 63 | 128, G2[me2++] = fe >> 6 & 63 | 128);
                  }
                  G2[me2++] = 63 & fe | 128;
                } else
                  G2[me2++] = fe;
              }
            }(w, this.bytes, this.pos), this.pos += q2;
        }, R3.prototype.encodeObject = function(w, T2) {
          var q2 = this.extensionCodec.tryToEncode(w, this.context);
          if (q2 != null)
            this.encodeExtension(q2);
          else if (Array.isArray(w))
            this.encodeArray(w, T2);
          else if (ArrayBuffer.isView(w))
            this.encodeBinary(w);
          else {
            if (typeof w != "object")
              throw new Error("Unrecognized object: " + Object.prototype.toString.apply(w));
            this.encodeMap(w, T2);
          }
        }, R3.prototype.encodeBinary = function(w) {
          var T2 = w.byteLength;
          if (T2 < 256)
            this.writeU8(196), this.writeU8(T2);
          else if (T2 < 65536)
            this.writeU8(197), this.writeU16(T2);
          else {
            if (!(T2 < 4294967296))
              throw new Error("Too large binary: " + T2);
            this.writeU8(198), this.writeU32(T2);
          }
          var q2 = ie(w);
          this.writeU8a(q2);
        }, R3.prototype.encodeArray = function(w, T2) {
          var q2, L2, G2 = w.length;
          if (G2 < 16)
            this.writeU8(144 + G2);
          else if (G2 < 65536)
            this.writeU8(220), this.writeU16(G2);
          else {
            if (!(G2 < 4294967296))
              throw new Error("Too large array: " + G2);
            this.writeU8(221), this.writeU32(G2);
          }
          try {
            for (var K5 = se(w), xe = K5.next(); !xe.done; xe = K5.next()) {
              var me2 = xe.value;
              this.doEncode(me2, T2 + 1);
            }
          } catch (_e2) {
            q2 = { error: _e2 };
          } finally {
            try {
              xe && !xe.done && (L2 = K5.return) && L2.call(K5);
            } finally {
              if (q2)
                throw q2.error;
            }
          }
        }, R3.prototype.countWithoutUndefined = function(w, T2) {
          var q2, L2, G2 = 0;
          try {
            for (var K5 = se(T2), xe = K5.next(); !xe.done; xe = K5.next())
              w[xe.value] !== void 0 && G2++;
          } catch (me2) {
            q2 = { error: me2 };
          } finally {
            try {
              xe && !xe.done && (L2 = K5.return) && L2.call(K5);
            } finally {
              if (q2)
                throw q2.error;
            }
          }
          return G2;
        }, R3.prototype.encodeMap = function(w, T2) {
          var q2, L2, G2 = Object.keys(w);
          this.sortKeys && G2.sort();
          var K5 = this.ignoreUndefined ? this.countWithoutUndefined(w, G2) : G2.length;
          if (K5 < 16)
            this.writeU8(128 + K5);
          else if (K5 < 65536)
            this.writeU8(222), this.writeU16(K5);
          else {
            if (!(K5 < 4294967296))
              throw new Error("Too large map object: " + K5);
            this.writeU8(223), this.writeU32(K5);
          }
          try {
            for (var xe = se(G2), me2 = xe.next(); !me2.done; me2 = xe.next()) {
              var _e2 = me2.value, fe = w[_e2];
              this.ignoreUndefined && fe === void 0 || (this.encodeString(_e2), this.doEncode(fe, T2 + 1));
            }
          } catch (ke) {
            q2 = { error: ke };
          } finally {
            try {
              me2 && !me2.done && (L2 = xe.return) && L2.call(xe);
            } finally {
              if (q2)
                throw q2.error;
            }
          }
        }, R3.prototype.encodeExtension = function(w) {
          var T2 = w.data.length;
          if (T2 === 1)
            this.writeU8(212);
          else if (T2 === 2)
            this.writeU8(213);
          else if (T2 === 4)
            this.writeU8(214);
          else if (T2 === 8)
            this.writeU8(215);
          else if (T2 === 16)
            this.writeU8(216);
          else if (T2 < 256)
            this.writeU8(199), this.writeU8(T2);
          else if (T2 < 65536)
            this.writeU8(200), this.writeU16(T2);
          else {
            if (!(T2 < 4294967296))
              throw new Error("Too large extension object: " + T2);
            this.writeU8(201), this.writeU32(T2);
          }
          this.writeI8(w.type), this.writeU8a(w.data);
        }, R3.prototype.writeU8 = function(w) {
          this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, w), this.pos++;
        }, R3.prototype.writeU8a = function(w) {
          var T2 = w.length;
          this.ensureBufferSizeToWrite(T2), this.bytes.set(w, this.pos), this.pos += T2;
        }, R3.prototype.writeI8 = function(w) {
          this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, w), this.pos++;
        }, R3.prototype.writeU16 = function(w) {
          this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, w), this.pos += 2;
        }, R3.prototype.writeI16 = function(w) {
          this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, w), this.pos += 2;
        }, R3.prototype.writeU32 = function(w) {
          this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, w), this.pos += 4;
        }, R3.prototype.writeI32 = function(w) {
          this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, w), this.pos += 4;
        }, R3.prototype.writeF32 = function(w) {
          this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, w), this.pos += 4;
        }, R3.prototype.writeF64 = function(w) {
          this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, w), this.pos += 8;
        }, R3.prototype.writeU64 = function(w) {
          this.ensureBufferSizeToWrite(8), function(T2, q2, L2) {
            var G2 = L2 / 4294967296, K5 = L2;
            T2.setUint32(q2, G2), T2.setUint32(q2 + 4, K5);
          }(this.view, this.pos, w), this.pos += 8;
        }, R3.prototype.writeI64 = function(w) {
          this.ensureBufferSizeToWrite(8), $(this.view, this.pos, w), this.pos += 8;
        }, R3.prototype.writeBig64 = function(w) {
          this.ensureBufferSizeToWrite(8), function(T2, q2, L2) {
            var G2 = Number(L2 / BigInt(4294967296)), K5 = Number(L2 % BigInt(4294967296));
            G2 < 0 && K5 !== 0 && (G2 -= 1), T2.setUint32(q2, G2), T2.setUint32(q2 + 4, K5);
          }(this.view, this.pos, w), this.pos += 8;
        }, R3;
      }(), c2 = {};
      function p2(R3, w) {
        return w === void 0 && (w = c2), new N3(w.extensionCodec, w.context, w.maxDepth, w.initialBufferSize, w.sortKeys, w.forceFloat32, w.ignoreUndefined, w.forceIntegerToFloat).encode(R3);
      }
      function h2(R3) {
        return (R3 < 0 ? "-" : "") + "0x" + Math.abs(R3).toString(16).padStart(2, "0");
      }
      var a = function() {
        function R3(w, T2) {
          w === void 0 && (w = 16), T2 === void 0 && (T2 = 16), this.maxKeyLength = w, this.maxLengthPerKey = T2, this.hit = 0, this.miss = 0, this.caches = [];
          for (var q2 = 0; q2 < this.maxKeyLength; q2++)
            this.caches.push([]);
        }
        return R3.prototype.canBeCached = function(w) {
          return w > 0 && w <= this.maxKeyLength;
        }, R3.prototype.get = function(w, T2, q2) {
          var L2 = this.caches[q2 - 1], G2 = L2.length;
          e:
            for (var K5 = 0; K5 < G2; K5++) {
              for (var xe = L2[K5], me2 = xe.bytes, _e2 = 0; _e2 < q2; _e2++)
                if (me2[_e2] !== w[T2 + _e2])
                  continue e;
              return xe.value;
            }
          return null;
        }, R3.prototype.store = function(w, T2) {
          var q2 = this.caches[w.length - 1], L2 = { bytes: w, value: T2 };
          q2.length >= this.maxLengthPerKey ? q2[Math.random() * q2.length | 0] = L2 : q2.push(L2);
        }, R3.prototype.decode = function(w, T2, q2) {
          var L2 = this.get(w, T2, q2);
          if (L2 != null)
            return this.hit++, L2;
          this.miss++;
          var G2 = A2(w, T2, q2), K5 = Uint8Array.prototype.slice.call(w, T2, T2 + q2);
          return this.store(K5, G2), G2;
        }, R3;
      }(), d2 = function(R3, w, T2, q2) {
        return new (T2 || (T2 = Promise))(function(L2, G2) {
          function K5(_e2) {
            try {
              me2(q2.next(_e2));
            } catch (fe) {
              G2(fe);
            }
          }
          function xe(_e2) {
            try {
              me2(q2.throw(_e2));
            } catch (fe) {
              G2(fe);
            }
          }
          function me2(_e2) {
            var fe;
            _e2.done ? L2(_e2.value) : (fe = _e2.value, fe instanceof T2 ? fe : new T2(function(ke) {
              ke(fe);
            })).then(K5, xe);
          }
          me2((q2 = q2.apply(R3, w || [])).next());
        });
      }, b2 = function(R3, w) {
        var T2, q2, L2, G2, K5 = { label: 0, sent: function() {
          if (1 & L2[0])
            throw L2[1];
          return L2[1];
        }, trys: [], ops: [] };
        return G2 = { next: xe(0), throw: xe(1), return: xe(2) }, typeof Symbol == "function" && (G2[Symbol.iterator] = function() {
          return this;
        }), G2;
        function xe(me2) {
          return function(_e2) {
            return function(fe) {
              if (T2)
                throw new TypeError("Generator is already executing.");
              for (; K5; )
                try {
                  if (T2 = 1, q2 && (L2 = 2 & fe[0] ? q2.return : fe[0] ? q2.throw || ((L2 = q2.return) && L2.call(q2), 0) : q2.next) && !(L2 = L2.call(q2, fe[1])).done)
                    return L2;
                  switch (q2 = 0, L2 && (fe = [2 & fe[0], L2.value]), fe[0]) {
                    case 0:
                    case 1:
                      L2 = fe;
                      break;
                    case 4:
                      return K5.label++, { value: fe[1], done: false };
                    case 5:
                      K5.label++, q2 = fe[1], fe = [0];
                      continue;
                    case 7:
                      fe = K5.ops.pop(), K5.trys.pop();
                      continue;
                    default:
                      if (L2 = K5.trys, !((L2 = L2.length > 0 && L2[L2.length - 1]) || fe[0] !== 6 && fe[0] !== 2)) {
                        K5 = 0;
                        continue;
                      }
                      if (fe[0] === 3 && (!L2 || fe[1] > L2[0] && fe[1] < L2[3])) {
                        K5.label = fe[1];
                        break;
                      }
                      if (fe[0] === 6 && K5.label < L2[1]) {
                        K5.label = L2[1], L2 = fe;
                        break;
                      }
                      if (L2 && K5.label < L2[2]) {
                        K5.label = L2[2], K5.ops.push(fe);
                        break;
                      }
                      L2[2] && K5.ops.pop(), K5.trys.pop();
                      continue;
                  }
                  fe = w.call(R3, K5);
                } catch (ke) {
                  fe = [6, ke], q2 = 0;
                } finally {
                  T2 = L2 = 0;
                }
              if (5 & fe[0])
                throw fe[1];
              return { value: fe[0] ? fe[1] : void 0, done: true };
            }([me2, _e2]);
          };
        }
      }, _2 = function(R3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var w, T2 = R3[Symbol.asyncIterator];
        return T2 ? T2.call(R3) : (R3 = typeof __values == "function" ? __values(R3) : R3[Symbol.iterator](), w = {}, q2("next"), q2("throw"), q2("return"), w[Symbol.asyncIterator] = function() {
          return this;
        }, w);
        function q2(L2) {
          w[L2] = R3[L2] && function(G2) {
            return new Promise(function(K5, xe) {
              (function(me2, _e2, fe, ke) {
                Promise.resolve(ke).then(function(Be) {
                  me2({ value: Be, done: fe });
                }, _e2);
              })(K5, xe, (G2 = R3[L2](G2)).done, G2.value);
            });
          };
        }
      }, v = function(R3) {
        return this instanceof v ? (this.v = R3, this) : new v(R3);
      }, u = function(R3, w, T2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var q2, L2 = T2.apply(R3, w || []), G2 = [];
        return q2 = {}, K5("next"), K5("throw"), K5("return"), q2[Symbol.asyncIterator] = function() {
          return this;
        }, q2;
        function K5(ke) {
          L2[ke] && (q2[ke] = function(Be) {
            return new Promise(function(gt, je2) {
              G2.push([ke, Be, gt, je2]) > 1 || xe(ke, Be);
            });
          });
        }
        function xe(ke, Be) {
          try {
            (gt = L2[ke](Be)).value instanceof v ? Promise.resolve(gt.value.v).then(me2, _e2) : fe(G2[0][2], gt);
          } catch (je2) {
            fe(G2[0][3], je2);
          }
          var gt;
        }
        function me2(ke) {
          xe("next", ke);
        }
        function _e2(ke) {
          xe("throw", ke);
        }
        function fe(ke, Be) {
          ke(Be), G2.shift(), G2.length && xe(G2[0][0], G2[0][1]);
        }
      }, E2 = new DataView(new ArrayBuffer(0)), B = new Uint8Array(E2.buffer), y2 = function() {
        try {
          E2.getInt8(0);
        } catch (R3) {
          return R3.constructor;
        }
        throw new Error("never reached");
      }(), M = new y2("Insufficient data"), de2 = new a(), Ee = function() {
        function R3(w, T2, q2, L2, G2, K5, xe, me2) {
          w === void 0 && (w = le.defaultCodec), T2 === void 0 && (T2 = void 0), q2 === void 0 && (q2 = 4294967295), L2 === void 0 && (L2 = 4294967295), G2 === void 0 && (G2 = 4294967295), K5 === void 0 && (K5 = 4294967295), xe === void 0 && (xe = 4294967295), me2 === void 0 && (me2 = de2), this.extensionCodec = w, this.context = T2, this.maxStrLength = q2, this.maxBinLength = L2, this.maxArrayLength = G2, this.maxMapLength = K5, this.maxExtLength = xe, this.keyDecoder = me2, this.totalPos = 0, this.pos = 0, this.view = E2, this.bytes = B, this.headByte = -1, this.stack = [];
        }
        return R3.prototype.reinitializeState = function() {
          this.totalPos = 0, this.headByte = -1;
        }, R3.prototype.setBuffer = function(w) {
          this.bytes = ie(w), this.view = function(T2) {
            if (T2 instanceof ArrayBuffer)
              return new DataView(T2);
            var q2 = ie(T2);
            return new DataView(q2.buffer, q2.byteOffset, q2.byteLength);
          }(this.bytes), this.pos = 0;
        }, R3.prototype.appendBuffer = function(w) {
          if (this.headByte !== -1 || this.hasRemaining()) {
            var T2 = this.bytes.subarray(this.pos), q2 = ie(w), L2 = new Uint8Array(T2.length + q2.length);
            L2.set(T2), L2.set(q2, T2.length), this.setBuffer(L2);
          } else
            this.setBuffer(w);
        }, R3.prototype.hasRemaining = function(w) {
          return w === void 0 && (w = 1), this.view.byteLength - this.pos >= w;
        }, R3.prototype.createNoExtraBytesError = function(w) {
          var T2 = this.view, q2 = this.pos;
          return new RangeError("Extra " + (T2.byteLength - q2) + " of " + T2.byteLength + " byte(s) found at buffer[" + w + "]");
        }, R3.prototype.decode = function(w) {
          return this.reinitializeState(), this.setBuffer(w), this.doDecodeSingleSync();
        }, R3.prototype.doDecodeSingleSync = function() {
          var w = this.doDecodeSync();
          if (this.hasRemaining())
            throw this.createNoExtraBytesError(this.pos);
          return w;
        }, R3.prototype.decodeAsync = function(w) {
          var T2, q2, L2, G2;
          return d2(this, void 0, void 0, function() {
            var K5, xe, me2, _e2, fe, ke, Be, gt;
            return b2(this, function(je2) {
              switch (je2.label) {
                case 0:
                  K5 = false, je2.label = 1;
                case 1:
                  je2.trys.push([1, 6, 7, 12]), T2 = _2(w), je2.label = 2;
                case 2:
                  return [4, T2.next()];
                case 3:
                  if ((q2 = je2.sent()).done)
                    return [3, 5];
                  if (me2 = q2.value, K5)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(me2);
                  try {
                    xe = this.doDecodeSync(), K5 = true;
                  } catch (Ge) {
                    if (!(Ge instanceof y2))
                      throw Ge;
                  }
                  this.totalPos += this.pos, je2.label = 4;
                case 4:
                  return [3, 2];
                case 5:
                  return [3, 12];
                case 6:
                  return _e2 = je2.sent(), L2 = { error: _e2 }, [3, 12];
                case 7:
                  return je2.trys.push([7, , 10, 11]), q2 && !q2.done && (G2 = T2.return) ? [4, G2.call(T2)] : [3, 9];
                case 8:
                  je2.sent(), je2.label = 9;
                case 9:
                  return [3, 11];
                case 10:
                  if (L2)
                    throw L2.error;
                  return [7];
                case 11:
                  return [7];
                case 12:
                  if (K5) {
                    if (this.hasRemaining())
                      throw this.createNoExtraBytesError(this.totalPos);
                    return [2, xe];
                  }
                  throw ke = (fe = this).headByte, Be = fe.pos, gt = fe.totalPos, new RangeError("Insufficient data in parcing " + h2(ke) + " at " + gt + " (" + Be + " in the current buffer)");
              }
            });
          });
        }, R3.prototype.decodeArrayStream = function(w) {
          return this.decodeMultiAsync(w, true);
        }, R3.prototype.decodeStream = function(w) {
          return this.decodeMultiAsync(w, false);
        }, R3.prototype.decodeMultiAsync = function(w, T2) {
          return u(this, arguments, function() {
            var q2, L2, G2, K5, xe, me2, _e2, fe, ke;
            return b2(this, function(Be) {
              switch (Be.label) {
                case 0:
                  q2 = T2, L2 = -1, Be.label = 1;
                case 1:
                  Be.trys.push([1, 13, 14, 19]), G2 = _2(w), Be.label = 2;
                case 2:
                  return [4, v(G2.next())];
                case 3:
                  if ((K5 = Be.sent()).done)
                    return [3, 12];
                  if (xe = K5.value, T2 && L2 === 0)
                    throw this.createNoExtraBytesError(this.totalPos);
                  this.appendBuffer(xe), q2 && (L2 = this.readArraySize(), q2 = false, this.complete()), Be.label = 4;
                case 4:
                  Be.trys.push([4, 9, , 10]), Be.label = 5;
                case 5:
                  return [4, v(this.doDecodeSync())];
                case 6:
                  return [4, Be.sent()];
                case 7:
                  return Be.sent(), --L2 == 0 ? [3, 8] : [3, 5];
                case 8:
                  return [3, 10];
                case 9:
                  if (!((me2 = Be.sent()) instanceof y2))
                    throw me2;
                  return [3, 10];
                case 10:
                  this.totalPos += this.pos, Be.label = 11;
                case 11:
                  return [3, 2];
                case 12:
                  return [3, 19];
                case 13:
                  return _e2 = Be.sent(), fe = { error: _e2 }, [3, 19];
                case 14:
                  return Be.trys.push([14, , 17, 18]), K5 && !K5.done && (ke = G2.return) ? [4, v(ke.call(G2))] : [3, 16];
                case 15:
                  Be.sent(), Be.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  if (fe)
                    throw fe.error;
                  return [7];
                case 18:
                  return [7];
                case 19:
                  return [2];
              }
            });
          });
        }, R3.prototype.doDecodeSync = function() {
          e:
            for (; ; ) {
              var w = this.readHeadByte(), T2 = void 0;
              if (w >= 224)
                T2 = w - 256;
              else if (w < 192)
                if (w < 128)
                  T2 = w;
                else if (w < 144) {
                  if ((L2 = w - 128) !== 0) {
                    this.pushMapState(L2), this.complete();
                    continue e;
                  }
                  T2 = {};
                } else if (w < 160) {
                  if ((L2 = w - 144) !== 0) {
                    this.pushArrayState(L2), this.complete();
                    continue e;
                  }
                  T2 = [];
                } else {
                  var q2 = w - 160;
                  T2 = this.decodeUtf8String(q2, 0);
                }
              else if (w === 192)
                T2 = null;
              else if (w === 194)
                T2 = false;
              else if (w === 195)
                T2 = true;
              else if (w === 202)
                T2 = this.readF32();
              else if (w === 203)
                T2 = this.readF64();
              else if (w === 204)
                T2 = this.readU8();
              else if (w === 205)
                T2 = this.readU16();
              else if (w === 206)
                T2 = this.readU32();
              else if (w === 207)
                T2 = this.readU64();
              else if (w === 208)
                T2 = this.readI8();
              else if (w === 209)
                T2 = this.readI16();
              else if (w === 210)
                T2 = this.readI32();
              else if (w === 211)
                T2 = this.readI64();
              else if (w === 217)
                q2 = this.lookU8(), T2 = this.decodeUtf8String(q2, 1);
              else if (w === 218)
                q2 = this.lookU16(), T2 = this.decodeUtf8String(q2, 2);
              else if (w === 219)
                q2 = this.lookU32(), T2 = this.decodeUtf8String(q2, 4);
              else if (w === 220) {
                if ((L2 = this.readU16()) !== 0) {
                  this.pushArrayState(L2), this.complete();
                  continue e;
                }
                T2 = [];
              } else if (w === 221) {
                if ((L2 = this.readU32()) !== 0) {
                  this.pushArrayState(L2), this.complete();
                  continue e;
                }
                T2 = [];
              } else if (w === 222) {
                if ((L2 = this.readU16()) !== 0) {
                  this.pushMapState(L2), this.complete();
                  continue e;
                }
                T2 = {};
              } else if (w === 223) {
                if ((L2 = this.readU32()) !== 0) {
                  this.pushMapState(L2), this.complete();
                  continue e;
                }
                T2 = {};
              } else if (w === 196) {
                var L2 = this.lookU8();
                T2 = this.decodeBinary(L2, 1);
              } else if (w === 197)
                L2 = this.lookU16(), T2 = this.decodeBinary(L2, 2);
              else if (w === 198)
                L2 = this.lookU32(), T2 = this.decodeBinary(L2, 4);
              else if (w === 212)
                T2 = this.decodeExtension(1, 0);
              else if (w === 213)
                T2 = this.decodeExtension(2, 0);
              else if (w === 214)
                T2 = this.decodeExtension(4, 0);
              else if (w === 215)
                T2 = this.decodeExtension(8, 0);
              else if (w === 216)
                T2 = this.decodeExtension(16, 0);
              else if (w === 199)
                L2 = this.lookU8(), T2 = this.decodeExtension(L2, 1);
              else if (w === 200)
                L2 = this.lookU16(), T2 = this.decodeExtension(L2, 2);
              else {
                if (w !== 201)
                  throw new Error("Unrecognized type byte: " + h2(w));
                L2 = this.lookU32(), T2 = this.decodeExtension(L2, 4);
              }
              this.complete();
              for (var G2 = this.stack; G2.length > 0; ) {
                var K5 = G2[G2.length - 1];
                if (K5.type === 0) {
                  if (K5.array[K5.position] = T2, K5.position++, K5.position !== K5.size)
                    continue e;
                  G2.pop(), T2 = K5.array;
                } else {
                  if (K5.type === 1) {
                    if (xe = void 0, (xe = typeof T2) != "string" && xe !== "number")
                      throw new Error("The type of key must be string or number but " + typeof T2);
                    K5.key = T2, K5.type = 2;
                    continue e;
                  }
                  if (K5.map[K5.key] = T2, K5.readCount++, K5.readCount !== K5.size) {
                    K5.key = null, K5.type = 1;
                    continue e;
                  }
                  G2.pop(), T2 = K5.map;
                }
              }
              return T2;
            }
          var xe;
        }, R3.prototype.readHeadByte = function() {
          return this.headByte === -1 && (this.headByte = this.readU8()), this.headByte;
        }, R3.prototype.complete = function() {
          this.headByte = -1;
        }, R3.prototype.readArraySize = function() {
          var w = this.readHeadByte();
          switch (w) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default:
              if (w < 160)
                return w - 144;
              throw new Error("Unrecognized array type byte: " + h2(w));
          }
        }, R3.prototype.pushMapState = function(w) {
          if (w > this.maxMapLength)
            throw new Error("Max length exceeded: map length (" + w + ") > maxMapLengthLength (" + this.maxMapLength + ")");
          this.stack.push({ type: 1, size: w, key: null, readCount: 0, map: {} });
        }, R3.prototype.pushArrayState = function(w) {
          if (w > this.maxArrayLength)
            throw new Error("Max length exceeded: array length (" + w + ") > maxArrayLength (" + this.maxArrayLength + ")");
          this.stack.push({ type: 0, size: w, array: new Array(w), position: 0 });
        }, R3.prototype.decodeUtf8String = function(w, T2) {
          var q2;
          if (w > this.maxStrLength)
            throw new Error("Max length exceeded: UTF-8 byte length (" + w + ") > maxStrLength (" + this.maxStrLength + ")");
          if (this.bytes.byteLength < this.pos + T2 + w)
            throw M;
          var L2, G2 = this.pos + T2;
          return L2 = this.stateIsMapKey() && ((q2 = this.keyDecoder) === null || q2 === void 0 ? void 0 : q2.canBeCached(w)) ? this.keyDecoder.decode(this.bytes, G2, w) : s2 && w > z3 ? function(K5, xe, me2) {
            var _e2 = K5.subarray(xe, xe + me2);
            return F3.decode(_e2);
          }(this.bytes, G2, w) : A2(this.bytes, G2, w), this.pos += T2 + w, L2;
        }, R3.prototype.stateIsMapKey = function() {
          return this.stack.length > 0 && this.stack[this.stack.length - 1].type === 1;
        }, R3.prototype.decodeBinary = function(w, T2) {
          if (w > this.maxBinLength)
            throw new Error("Max length exceeded: bin length (" + w + ") > maxBinLength (" + this.maxBinLength + ")");
          if (!this.hasRemaining(w + T2))
            throw M;
          var q2 = this.pos + T2, L2 = this.bytes.subarray(q2, q2 + w);
          return this.pos += T2 + w, L2;
        }, R3.prototype.decodeExtension = function(w, T2) {
          if (w > this.maxExtLength)
            throw new Error("Max length exceeded: ext length (" + w + ") > maxExtLength (" + this.maxExtLength + ")");
          var q2 = this.view.getInt8(this.pos + T2), L2 = this.decodeBinary(w, T2 + 1);
          return this.extensionCodec.decode(L2, q2, this.context);
        }, R3.prototype.lookU8 = function() {
          return this.view.getUint8(this.pos);
        }, R3.prototype.lookU16 = function() {
          return this.view.getUint16(this.pos);
        }, R3.prototype.lookU32 = function() {
          return this.view.getUint32(this.pos);
        }, R3.prototype.readU8 = function() {
          var w = this.view.getUint8(this.pos);
          return this.pos++, w;
        }, R3.prototype.readI8 = function() {
          var w = this.view.getInt8(this.pos);
          return this.pos++, w;
        }, R3.prototype.readU16 = function() {
          var w = this.view.getUint16(this.pos);
          return this.pos += 2, w;
        }, R3.prototype.readI16 = function() {
          var w = this.view.getInt16(this.pos);
          return this.pos += 2, w;
        }, R3.prototype.readU32 = function() {
          var w = this.view.getUint32(this.pos);
          return this.pos += 4, w;
        }, R3.prototype.readI32 = function() {
          var w = this.view.getInt32(this.pos);
          return this.pos += 4, w;
        }, R3.prototype.readU64 = function() {
          var w, T2, q2, L2, G2 = (w = this.view, T2 = this.pos, q2 = w.getUint32(T2), L2 = w.getUint32(T2 + 4), q2 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(q2) * BigInt(4294967296) + BigInt(L2) : 4294967296 * q2 + L2);
          return this.pos += 8, G2;
        }, R3.prototype.readI64 = function() {
          var w = re(this.view, this.pos);
          return this.pos += 8, w;
        }, R3.prototype.readF32 = function() {
          var w = this.view.getFloat32(this.pos);
          return this.pos += 4, w;
        }, R3.prototype.readF64 = function() {
          var w = this.view.getFloat64(this.pos);
          return this.pos += 8, w;
        }, R3;
      }(), Me = {};
      function Oe(R3, w) {
        return w === void 0 && (w = Me), new Ee(w.extensionCodec, w.context, w.maxStrLength, w.maxBinLength, w.maxArrayLength, w.maxMapLength, w.maxExtLength).decode(R3);
      }
      var be = function(R3, w) {
        var T2, q2, L2, G2, K5 = { label: 0, sent: function() {
          if (1 & L2[0])
            throw L2[1];
          return L2[1];
        }, trys: [], ops: [] };
        return G2 = { next: xe(0), throw: xe(1), return: xe(2) }, typeof Symbol == "function" && (G2[Symbol.iterator] = function() {
          return this;
        }), G2;
        function xe(me2) {
          return function(_e2) {
            return function(fe) {
              if (T2)
                throw new TypeError("Generator is already executing.");
              for (; K5; )
                try {
                  if (T2 = 1, q2 && (L2 = 2 & fe[0] ? q2.return : fe[0] ? q2.throw || ((L2 = q2.return) && L2.call(q2), 0) : q2.next) && !(L2 = L2.call(q2, fe[1])).done)
                    return L2;
                  switch (q2 = 0, L2 && (fe = [2 & fe[0], L2.value]), fe[0]) {
                    case 0:
                    case 1:
                      L2 = fe;
                      break;
                    case 4:
                      return K5.label++, { value: fe[1], done: false };
                    case 5:
                      K5.label++, q2 = fe[1], fe = [0];
                      continue;
                    case 7:
                      fe = K5.ops.pop(), K5.trys.pop();
                      continue;
                    default:
                      if (L2 = K5.trys, !((L2 = L2.length > 0 && L2[L2.length - 1]) || fe[0] !== 6 && fe[0] !== 2)) {
                        K5 = 0;
                        continue;
                      }
                      if (fe[0] === 3 && (!L2 || fe[1] > L2[0] && fe[1] < L2[3])) {
                        K5.label = fe[1];
                        break;
                      }
                      if (fe[0] === 6 && K5.label < L2[1]) {
                        K5.label = L2[1], L2 = fe;
                        break;
                      }
                      if (L2 && K5.label < L2[2]) {
                        K5.label = L2[2], K5.ops.push(fe);
                        break;
                      }
                      L2[2] && K5.ops.pop(), K5.trys.pop();
                      continue;
                  }
                  fe = w.call(R3, K5);
                } catch (ke) {
                  fe = [6, ke], q2 = 0;
                } finally {
                  T2 = L2 = 0;
                }
              if (5 & fe[0])
                throw fe[1];
              return { value: fe[0] ? fe[1] : void 0, done: true };
            }([me2, _e2]);
          };
        }
      }, I = function(R3) {
        return this instanceof I ? (this.v = R3, this) : new I(R3);
      }, j3 = function(R3, w, T2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var q2, L2 = T2.apply(R3, w || []), G2 = [];
        return q2 = {}, K5("next"), K5("throw"), K5("return"), q2[Symbol.asyncIterator] = function() {
          return this;
        }, q2;
        function K5(ke) {
          L2[ke] && (q2[ke] = function(Be) {
            return new Promise(function(gt, je2) {
              G2.push([ke, Be, gt, je2]) > 1 || xe(ke, Be);
            });
          });
        }
        function xe(ke, Be) {
          try {
            (gt = L2[ke](Be)).value instanceof I ? Promise.resolve(gt.value.v).then(me2, _e2) : fe(G2[0][2], gt);
          } catch (je2) {
            fe(G2[0][3], je2);
          }
          var gt;
        }
        function me2(ke) {
          xe("next", ke);
        }
        function _e2(ke) {
          xe("throw", ke);
        }
        function fe(ke, Be) {
          ke(Be), G2.shift(), G2.length && xe(G2[0][0], G2[0][1]);
        }
      };
      function P5(R3) {
        if (R3 == null)
          throw new Error("Assertion Failure: value must not be null nor undefined");
      }
      function ee2(R3) {
        return R3[Symbol.asyncIterator] != null ? R3 : function(w) {
          return j3(this, arguments, function() {
            var T2, q2, L2, G2;
            return be(this, function(K5) {
              switch (K5.label) {
                case 0:
                  T2 = w.getReader(), K5.label = 1;
                case 1:
                  K5.trys.push([1, , 9, 10]), K5.label = 2;
                case 2:
                  return [4, I(T2.read())];
                case 3:
                  return q2 = K5.sent(), L2 = q2.done, G2 = q2.value, L2 ? [4, I(void 0)] : [3, 5];
                case 4:
                  return [2, K5.sent()];
                case 5:
                  return P5(G2), [4, I(G2)];
                case 6:
                  return [4, K5.sent()];
                case 7:
                  return K5.sent(), [3, 2];
                case 8:
                  return [3, 10];
                case 9:
                  return T2.releaseLock(), [7];
                case 10:
                  return [2];
              }
            });
          });
        }(R3);
      }
      var oe = function(R3, w, T2, q2) {
        return new (T2 || (T2 = Promise))(function(L2, G2) {
          function K5(_e2) {
            try {
              me2(q2.next(_e2));
            } catch (fe) {
              G2(fe);
            }
          }
          function xe(_e2) {
            try {
              me2(q2.throw(_e2));
            } catch (fe) {
              G2(fe);
            }
          }
          function me2(_e2) {
            var fe;
            _e2.done ? L2(_e2.value) : (fe = _e2.value, fe instanceof T2 ? fe : new T2(function(ke) {
              ke(fe);
            })).then(K5, xe);
          }
          me2((q2 = q2.apply(R3, w || [])).next());
        });
      }, te = function(R3, w) {
        var T2, q2, L2, G2, K5 = { label: 0, sent: function() {
          if (1 & L2[0])
            throw L2[1];
          return L2[1];
        }, trys: [], ops: [] };
        return G2 = { next: xe(0), throw: xe(1), return: xe(2) }, typeof Symbol == "function" && (G2[Symbol.iterator] = function() {
          return this;
        }), G2;
        function xe(me2) {
          return function(_e2) {
            return function(fe) {
              if (T2)
                throw new TypeError("Generator is already executing.");
              for (; K5; )
                try {
                  if (T2 = 1, q2 && (L2 = 2 & fe[0] ? q2.return : fe[0] ? q2.throw || ((L2 = q2.return) && L2.call(q2), 0) : q2.next) && !(L2 = L2.call(q2, fe[1])).done)
                    return L2;
                  switch (q2 = 0, L2 && (fe = [2 & fe[0], L2.value]), fe[0]) {
                    case 0:
                    case 1:
                      L2 = fe;
                      break;
                    case 4:
                      return K5.label++, { value: fe[1], done: false };
                    case 5:
                      K5.label++, q2 = fe[1], fe = [0];
                      continue;
                    case 7:
                      fe = K5.ops.pop(), K5.trys.pop();
                      continue;
                    default:
                      if (L2 = K5.trys, !((L2 = L2.length > 0 && L2[L2.length - 1]) || fe[0] !== 6 && fe[0] !== 2)) {
                        K5 = 0;
                        continue;
                      }
                      if (fe[0] === 3 && (!L2 || fe[1] > L2[0] && fe[1] < L2[3])) {
                        K5.label = fe[1];
                        break;
                      }
                      if (fe[0] === 6 && K5.label < L2[1]) {
                        K5.label = L2[1], L2 = fe;
                        break;
                      }
                      if (L2 && K5.label < L2[2]) {
                        K5.label = L2[2], K5.ops.push(fe);
                        break;
                      }
                      L2[2] && K5.ops.pop(), K5.trys.pop();
                      continue;
                  }
                  fe = w.call(R3, K5);
                } catch (ke) {
                  fe = [6, ke], q2 = 0;
                } finally {
                  T2 = L2 = 0;
                }
              if (5 & fe[0])
                throw fe[1];
              return { value: fe[0] ? fe[1] : void 0, done: true };
            }([me2, _e2]);
          };
        }
      };
      function ae(R3, w) {
        return w === void 0 && (w = Me), oe(this, void 0, void 0, function() {
          var T2;
          return te(this, function(q2) {
            return T2 = ee2(R3), [2, new Ee(w.extensionCodec, w.context, w.maxStrLength, w.maxBinLength, w.maxArrayLength, w.maxMapLength, w.maxExtLength).decodeAsync(T2)];
          });
        });
      }
      function ne(R3, w) {
        w === void 0 && (w = Me);
        var T2 = ee2(R3);
        return new Ee(w.extensionCodec, w.context, w.maxStrLength, w.maxBinLength, w.maxArrayLength, w.maxMapLength, w.maxExtLength).decodeArrayStream(T2);
      }
      function X2(R3, w) {
        w === void 0 && (w = Me);
        var T2 = ee2(R3);
        return new Ee(w.extensionCodec, w.context, w.maxStrLength, w.maxBinLength, w.maxArrayLength, w.maxMapLength, w.maxExtLength).decodeStream(T2);
      }
    }]);
  });
});
var p4 = k((Qn, h4) => {
  U();
  var zh = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof N < "u" && N, Hh = function() {
    function t() {
      this.fetch = false, this.DOMException = zh.DOMException;
    }
    return t.prototype = zh, new t();
  }();
  (function(t) {
    (function(r) {
      var i = typeof t < "u" && t || typeof self < "u" && self || typeof i < "u" && i, n = { searchParams: "URLSearchParams" in i, iterable: "Symbol" in i && "iterator" in Symbol, blob: "FileReader" in i && "Blob" in i && function() {
        try {
          return new Blob(), true;
        } catch {
          return false;
        }
      }(), formData: "FormData" in i, arrayBuffer: "ArrayBuffer" in i };
      function s2(c2) {
        return c2 && DataView.prototype.isPrototypeOf(c2);
      }
      if (n.arrayBuffer)
        var o = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], f = ArrayBuffer.isView || function(c2) {
          return c2 && o.indexOf(Object.prototype.toString.call(c2)) > -1;
        };
      function l(c2) {
        if (typeof c2 != "string" && (c2 = String(c2)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(c2) || c2 === "")
          throw new TypeError('Invalid character in header field name: "' + c2 + '"');
        return c2.toLowerCase();
      }
      function m3(c2) {
        return typeof c2 != "string" && (c2 = String(c2)), c2;
      }
      function A2(c2) {
        var p2 = { next: function() {
          var h2 = c2.shift();
          return { done: h2 === void 0, value: h2 };
        } };
        return n.iterable && (p2[Symbol.iterator] = function() {
          return p2;
        }), p2;
      }
      function F3(c2) {
        this.map = {}, c2 instanceof F3 ? c2.forEach(function(p2, h2) {
          this.append(h2, p2);
        }, this) : Array.isArray(c2) ? c2.forEach(function(p2) {
          this.append(p2[0], p2[1]);
        }, this) : c2 && Object.getOwnPropertyNames(c2).forEach(function(p2) {
          this.append(p2, c2[p2]);
        }, this);
      }
      F3.prototype.append = function(c2, p2) {
        c2 = l(c2), p2 = m3(p2);
        var h2 = this.map[c2];
        this.map[c2] = h2 ? h2 + ", " + p2 : p2;
      }, F3.prototype.delete = function(c2) {
        delete this.map[l(c2)];
      }, F3.prototype.get = function(c2) {
        return c2 = l(c2), this.has(c2) ? this.map[c2] : null;
      }, F3.prototype.has = function(c2) {
        return this.map.hasOwnProperty(l(c2));
      }, F3.prototype.set = function(c2, p2) {
        this.map[l(c2)] = m3(p2);
      }, F3.prototype.forEach = function(c2, p2) {
        for (var h2 in this.map)
          this.map.hasOwnProperty(h2) && c2.call(p2, this.map[h2], h2, this);
      }, F3.prototype.keys = function() {
        var c2 = [];
        return this.forEach(function(p2, h2) {
          c2.push(h2);
        }), A2(c2);
      }, F3.prototype.values = function() {
        var c2 = [];
        return this.forEach(function(p2) {
          c2.push(p2);
        }), A2(c2);
      }, F3.prototype.entries = function() {
        var c2 = [];
        return this.forEach(function(p2, h2) {
          c2.push([h2, p2]);
        }), A2(c2);
      }, n.iterable && (F3.prototype[Symbol.iterator] = F3.prototype.entries);
      function z3(c2) {
        if (c2.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        c2.bodyUsed = true;
      }
      function V(c2) {
        return new Promise(function(p2, h2) {
          c2.onload = function() {
            p2(c2.result);
          }, c2.onerror = function() {
            h2(c2.error);
          };
        });
      }
      function $(c2) {
        var p2 = new FileReader(), h2 = V(p2);
        return p2.readAsArrayBuffer(c2), h2;
      }
      function re(c2) {
        var p2 = new FileReader(), h2 = V(p2);
        return p2.readAsText(c2), h2;
      }
      function W2(c2) {
        for (var p2 = new Uint8Array(c2), h2 = new Array(p2.length), a = 0; a < p2.length; a++)
          h2[a] = String.fromCharCode(p2[a]);
        return h2.join("");
      }
      function Z2(c2) {
        if (c2.slice)
          return c2.slice(0);
        var p2 = new Uint8Array(c2.byteLength);
        return p2.set(new Uint8Array(c2)), p2.buffer;
      }
      function ue() {
        return this.bodyUsed = false, this._initBody = function(c2) {
          this.bodyUsed = this.bodyUsed, this._bodyInit = c2, c2 ? typeof c2 == "string" ? this._bodyText = c2 : n.blob && Blob.prototype.isPrototypeOf(c2) ? this._bodyBlob = c2 : n.formData && FormData.prototype.isPrototypeOf(c2) ? this._bodyFormData = c2 : n.searchParams && URLSearchParams.prototype.isPrototypeOf(c2) ? this._bodyText = c2.toString() : n.arrayBuffer && n.blob && s2(c2) ? (this._bodyArrayBuffer = Z2(c2.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : n.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(c2) || f(c2)) ? this._bodyArrayBuffer = Z2(c2) : this._bodyText = c2 = Object.prototype.toString.call(c2) : this._bodyText = "", this.headers.get("content-type") || (typeof c2 == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : n.searchParams && URLSearchParams.prototype.isPrototypeOf(c2) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, n.blob && (this.blob = function() {
          var c2 = z3(this);
          if (c2)
            return c2;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            var c2 = z3(this);
            return c2 || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer));
          } else
            return this.blob().then($);
        }), this.text = function() {
          var c2 = z3(this);
          if (c2)
            return c2;
          if (this._bodyBlob)
            return re(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(W2(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, n.formData && (this.formData = function() {
          return this.text().then(H2);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var ge = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function Se(c2) {
        var p2 = c2.toUpperCase();
        return ge.indexOf(p2) > -1 ? p2 : c2;
      }
      function pe2(c2, p2) {
        if (!(this instanceof pe2))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        p2 = p2 || {};
        var h2 = p2.body;
        if (c2 instanceof pe2) {
          if (c2.bodyUsed)
            throw new TypeError("Already read");
          this.url = c2.url, this.credentials = c2.credentials, p2.headers || (this.headers = new F3(c2.headers)), this.method = c2.method, this.mode = c2.mode, this.signal = c2.signal, !h2 && c2._bodyInit != null && (h2 = c2._bodyInit, c2.bodyUsed = true);
        } else
          this.url = String(c2);
        if (this.credentials = p2.credentials || this.credentials || "same-origin", (p2.headers || !this.headers) && (this.headers = new F3(p2.headers)), this.method = Se(p2.method || this.method || "GET"), this.mode = p2.mode || this.mode || null, this.signal = p2.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && h2)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(h2), (this.method === "GET" || this.method === "HEAD") && (p2.cache === "no-store" || p2.cache === "no-cache")) {
          var a = /([?&])_=[^&]*/;
          if (a.test(this.url))
            this.url = this.url.replace(a, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
          else {
            var d2 = /\?/;
            this.url += (d2.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
          }
        }
      }
      pe2.prototype.clone = function() {
        return new pe2(this, { body: this._bodyInit });
      };
      function H2(c2) {
        var p2 = new FormData();
        return c2.trim().split("&").forEach(function(h2) {
          if (h2) {
            var a = h2.split("="), d2 = a.shift().replace(/\+/g, " "), b2 = a.join("=").replace(/\+/g, " ");
            p2.append(decodeURIComponent(d2), decodeURIComponent(b2));
          }
        }), p2;
      }
      function le(c2) {
        var p2 = new F3(), h2 = c2.replace(/\r?\n[\t ]+/g, " ");
        return h2.split("\r").map(function(a) {
          return a.indexOf(`
`) === 0 ? a.substr(1, a.length) : a;
        }).forEach(function(a) {
          var d2 = a.split(":"), b2 = d2.shift().trim();
          if (b2) {
            var _2 = d2.join(":").trim();
            p2.append(b2, _2);
          }
        }), p2;
      }
      ue.call(pe2.prototype);
      function ie(c2, p2) {
        if (!(this instanceof ie))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        p2 || (p2 = {}), this.type = "default", this.status = p2.status === void 0 ? 200 : p2.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = p2.statusText === void 0 ? "" : "" + p2.statusText, this.headers = new F3(p2.headers), this.url = p2.url || "", this._initBody(c2);
      }
      ue.call(ie.prototype), ie.prototype.clone = function() {
        return new ie(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new F3(this.headers), url: this.url });
      }, ie.error = function() {
        var c2 = new ie(null, { status: 0, statusText: "" });
        return c2.type = "error", c2;
      };
      var se = [301, 302, 303, 307, 308];
      ie.redirect = function(c2, p2) {
        if (se.indexOf(p2) === -1)
          throw new RangeError("Invalid status code");
        return new ie(null, { status: p2, headers: { location: c2 } });
      }, r.DOMException = i.DOMException;
      try {
        new r.DOMException();
      } catch {
        r.DOMException = function(p2, h2) {
          this.message = p2, this.name = h2;
          var a = Error(p2);
          this.stack = a.stack;
        }, r.DOMException.prototype = Object.create(Error.prototype), r.DOMException.prototype.constructor = r.DOMException;
      }
      function N3(c2, p2) {
        return new Promise(function(h2, a) {
          var d2 = new pe2(c2, p2);
          if (d2.signal && d2.signal.aborted)
            return a(new r.DOMException("Aborted", "AbortError"));
          var b2 = new XMLHttpRequest();
          function _2() {
            b2.abort();
          }
          b2.onload = function() {
            var u = { status: b2.status, statusText: b2.statusText, headers: le(b2.getAllResponseHeaders() || "") };
            u.url = "responseURL" in b2 ? b2.responseURL : u.headers.get("X-Request-URL");
            var E2 = "response" in b2 ? b2.response : b2.responseText;
            setTimeout(function() {
              h2(new ie(E2, u));
            }, 0);
          }, b2.onerror = function() {
            setTimeout(function() {
              a(new TypeError("Network request failed"));
            }, 0);
          }, b2.ontimeout = function() {
            setTimeout(function() {
              a(new TypeError("Network request failed"));
            }, 0);
          }, b2.onabort = function() {
            setTimeout(function() {
              a(new r.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function v(u) {
            try {
              return u === "" && i.location.href ? i.location.href : u;
            } catch {
              return u;
            }
          }
          b2.open(d2.method, v(d2.url), true), d2.credentials === "include" ? b2.withCredentials = true : d2.credentials === "omit" && (b2.withCredentials = false), "responseType" in b2 && (n.blob ? b2.responseType = "blob" : n.arrayBuffer && d2.headers.get("Content-Type") && d2.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (b2.responseType = "arraybuffer")), p2 && typeof p2.headers == "object" && !(p2.headers instanceof F3) ? Object.getOwnPropertyNames(p2.headers).forEach(function(u) {
            b2.setRequestHeader(u, m3(p2.headers[u]));
          }) : d2.headers.forEach(function(u, E2) {
            b2.setRequestHeader(E2, u);
          }), d2.signal && (d2.signal.addEventListener("abort", _2), b2.onreadystatechange = function() {
            b2.readyState === 4 && d2.signal.removeEventListener("abort", _2);
          }), b2.send(typeof d2._bodyInit > "u" ? null : d2._bodyInit);
        });
      }
      return N3.polyfill = true, i.fetch || (i.fetch = N3, i.Headers = F3, i.Request = pe2, i.Response = ie), r.Headers = F3, r.Request = pe2, r.Response = ie, r.fetch = N3, r;
    })({});
  })(Hh);
  Hh.fetch.ponyfill = true;
  delete Hh.fetch.polyfill;
  var _a2 = zh.fetch ? zh : Hh;
  Qn = _a2.fetch;
  Qn.default = _a2.fetch;
  Qn.fetch = _a2.fetch;
  Qn.Headers = _a2.Headers;
  Qn.Request = _a2.Request;
  Qn.Response = _a2.Response;
  h4.exports = Qn;
});
U();
var $r = rr$1(or(), 1);
U();
var em = {};
ct(em, { ABIAddressType: () => as, ABIArrayDynamicType: () => Af, ABIArrayStaticType: () => _f2, ABIBoolType: () => Ci, ABIByteType: () => wf, ABIContract: () => Jg, ABIInterface: () => Zg, ABIMethod: () => en, ABIReferenceType: () => Qi, ABIStringType: () => xf, ABITransactionType: () => Oi, ABITupleType: () => Yr, ABIType: () => pr, ABIUfixedType: () => vf, ABIUintType: () => Xi, ADDR_BYTE_SIZE: () => n8, ALGORAND_MIN_TX_FEE: () => Fg, Algodv2: () => mo, AtomicTransactionComposer: () => mi, AtomicTransactionComposerStatus: () => Nr, DryrunResult: () => $g, ERROR_INVALID_MICROALGOS: () => $R, ERROR_MULTISIG_BAD_SENDER: () => HR, INVALID_MICROALGOS_ERROR_MSG: () => Rc, Indexer: () => Io, IntDecoding: () => Yn, Kmd: () => ku, LENGTH_ENCODE_BYTE_SIZE: () => Or, LogicSig: () => Ni, LogicSigAccount: () => Zi, MAX_LEN: () => Ro, MULTISIG_BAD_SENDER_ERROR_MSG: () => f8, OnApplicationComplete: () => hr, SINGLE_BOOL_SIZE: () => o8, SINGLE_BYTE_SIZE: () => s8, SourceMap: () => t0, Transaction: () => Ht, TransactionType: () => Pt, abiCheckTransactionType: () => Yg, abiTypeIsReference: () => vd, abiTypeIsTransaction: () => Ef, algosToMicroalgos: () => l4, appendSignMultisigTransaction: () => j4, appendSignRawMultisigSignature: () => L4, assignGroupID: () => Xh, bigIntToBytes: () => Tn, bytesToBigInt: () => pd, computeGroupID: () => jg, createDryrun: () => bR, createMultisigTransaction: () => Lg, decodeAddress: () => ut, decodeObj: () => jr, decodeSignedTransaction: () => xn, decodeUint64: () => t4, decodeUnsignedTransaction: () => eo, encodeAddress: () => Ue, encodeObj: () => zR, encodeUint64: () => Xs, encodeUnsignedSimulateTransaction: () => Rg, encodeUnsignedTransaction: () => VF, generateAccount: () => gd, getApplicationAddress: () => Qs, getMethodByName: () => wd, indexerModels: () => Ng, instantiateTxnIfNeeded: () => hi, isTransactionWithSigner: () => c0, isValidAddress: () => Zn, logicSigFromByte: () => z4, makeApplicationCallTxnFromObject: () => Vg, makeApplicationClearStateTxn: () => r8, makeApplicationClearStateTxnFromObject: () => TR, makeApplicationCloseOutTxn: () => t8, makeApplicationCloseOutTxnFromObject: () => Wg, makeApplicationCreateTxn: () => yd, makeApplicationCreateTxnFromObject: () => Gg, makeApplicationDeleteTxn: () => a0, makeApplicationDeleteTxnFromObject: () => IR, makeApplicationNoOpTxn: () => i8, makeApplicationNoOpTxnFromObject: () => f0, makeApplicationOptInTxn: () => e8, makeApplicationOptInTxnFromObject: () => Kg, makeApplicationUpdateTxn: () => o0, makeApplicationUpdateTxnFromObject: () => MR, makeAssetConfigTxnWithSuggestedParams: () => Z4, makeAssetConfigTxnWithSuggestedParamsFromObject: () => AR, makeAssetCreateTxnWithSuggestedParams: () => n0, makeAssetCreateTxnWithSuggestedParamsFromObject: () => _R, makeAssetDestroyTxnWithSuggestedParams: () => s0, makeAssetDestroyTxnWithSuggestedParamsFromObject: () => ER, makeAssetFreezeTxnWithSuggestedParams: () => X4, makeAssetFreezeTxnWithSuggestedParamsFromObject: () => SR, makeAssetTransferTxnWithSuggestedParams: () => Q4, makeAssetTransferTxnWithSuggestedParamsFromObject: () => md, makeBasicAccountTransactionSigner: () => FR, makeEmptyTransactionSigner: () => DR, makeKeyRegistrationTxnWithSuggestedParams: () => J4, makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => xR, makeLogicSigAccountTransactionSigner: () => RR, makeMultiSigAccountTransactionSigner: () => kR, makePaymentTxnWithSuggestedParams: () => Y4, makePaymentTxnWithSuggestedParamsFromObject: () => i0, masterDerivationKeyToMnemonic: () => D4, mergeMultisigTransactions: () => gf, microalgosToAlgos: () => Uh, mnemonicFromSeed: () => Yh, mnemonicToMasterDerivationKey: () => k4, mnemonicToSecretKey: () => To, modelsv2: () => Kh, multisigAddress: () => q4, secretKeyToMnemonic: () => Zh, seedFromMnemonic: () => Jh, signBid: () => qR, signBytes: () => PR, signLogicSigTransaction: () => U4, signLogicSigTransactionObject: () => Fo, signMultisigTransaction: () => e0, signTransaction: () => LR, tealSign: () => qg, tealSignFromProgram: () => G4, verifyBytes: () => UR, verifyMultisig: () => Qh, verifyTealSign: () => $4, waitForConfirmation: () => Wh });
U();
var u0 = rr$1(or());
U();
var Bi = rr$1(L3()), P3 = rr$1(q3());
function Dr(t) {
  return P3.default.sha512_256.array(t);
}
function MF(t) {
  return Bi.default.randomBytes(t);
}
function vg(t) {
  return Bi.default.sign.keyPair.fromSeed(t);
}
function U3() {
  let t = MF(Bi.default.box.secretKeyLength);
  return vg(t);
}
function kh(t) {
  return t === Bi.default.sign.signatureLength;
}
function bn(t) {
  return Bi.default.sign.keyPair.fromSecretKey(t);
}
function vn(t, e) {
  return Bi.default.sign.detached(t, e);
}
function Dh(t, e) {
  return Bi.default.verify(t, e);
}
function Js(t, e, r) {
  return Bi.default.sign.detached.verify(t, e, r);
}
var Sc = Bi.default.sign.publicKeyLength;
Bi.default.sign.secretKeyLength;
var wg = 32, Bh = 32;
U();
var i4 = rr$1(or()), Eg = rr$1(xg());
U();
var X3 = rr$1(Z3());
U();
var Ag;
(function(t) {
  t.DEFAULT = "default", t.SAFE = "safe", t.MIXED = "mixed", t.BIGINT = "bigint";
})(Ag || (Ag = {}));
var Yn = Ag;
var RF = (0, X3.default)({ useNativeBigInt: true, strict: true });
function Q3(t, e) {
  let r = e && e.intDecoding ? e.intDecoding : Yn.DEFAULT;
  return RF.parse(t, (i, n) => {
    if (n != null && typeof n == "object" && Object.getPrototypeOf(n) == null && Object.setPrototypeOf(n, Object.prototype), typeof n == "bigint") {
      if (r === "safe" && n > Number.MAX_SAFE_INTEGER)
        throw new Error(`Integer exceeds maximum safe integer: ${n.toString()}. Try parsing with a different intDecoding option.`);
      return r === "bigint" || r === "mixed" && n > Number.MAX_SAFE_INTEGER ? n : Number(n);
    }
    return typeof n == "number" && r === "bigint" && Number.isInteger(n) ? BigInt(n) : n;
  });
}
function Zs(t, e) {
  return t.length !== e.length ? false : Array.from(t).every((r, i) => r === e[i]);
}
function Jt(...t) {
  let e = t.reduce((n, s2) => n + s2.length, 0), r = new Uint8Array(e), i = 0;
  for (let n = 0; n < t.length; n++)
    r.set(t[n], i), i += t[n].length;
  return r;
}
function e4(t) {
  let e = { ...t };
  return Object.keys(e).forEach((r) => {
    typeof e[r] > "u" && delete e[r];
  }), e;
}
U();
function Xs(t) {
  if (!(typeof t == "bigint" || Number.isInteger(t)) || t < 0 || t > BigInt("0xffffffffffffffff"))
    throw new Error("Input is not a 64-bit unsigned integer");
  let r = new Uint8Array(8);
  return new DataView(r.buffer).setBigUint64(0, BigInt(t)), r;
}
function t4(t, e = "safe") {
  if (e !== "safe" && e !== "mixed" && e !== "bigint")
    throw new Error(`Unknown decodingMode option: ${e}`);
  if (t.byteLength === 0 || t.byteLength > 8)
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${t.byteLength}`);
  let r = new Uint8Array(8 - t.byteLength), i = Jt(r, t), s2 = new DataView(i.buffer).getBigUint64(0), o = s2 > BigInt(Number.MAX_SAFE_INTEGER);
  if (e === "safe") {
    if (o)
      throw new Error(`Integer exceeds maximum safe integer: ${s2.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    return Number(s2);
  }
  return e === "mixed" && !o ? Number(s2) : s2;
}
var Lh = 36, qh = 4, n4 = 58, s4 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ", Mc = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]), kF = i4.Buffer.from("appID"), r4 = "address seems to be malformed", DF = "wrong checksum for address", BF = "invalid multisig version", NF = "bad multisig threshold", CF = "bad multisig public key - wrong length", OF = "nacl public key length is not 32 bytes";
function ut(t) {
  if (typeof t != "string" || t.length !== n4)
    throw new Error(r4);
  let e = Eg.default.decode.asBytes(t.toString());
  if (e.length !== Lh)
    throw new Error(r4);
  let r = new Uint8Array(e.slice(0, Lh - qh)), i = new Uint8Array(e.slice(Sc, Lh)), n = Dr(r).slice(wg - qh, wg);
  if (!Zs(n, i))
    throw new Error(DF);
  return { publicKey: r, checksum: i };
}
function Zn(t) {
  try {
    ut(t);
  } catch {
    return false;
  }
  return true;
}
function Ue(t) {
  let e = Dr(t).slice(Sc - qh, Sc);
  return Eg.default.encode(Jt(t, e)).toString().slice(0, n4);
}
function Vi({ version: t, threshold: e, pks: r }) {
  if (t !== 1 || t > 255 || t < 0)
    throw new Error(BF);
  if (e === 0 || r.length === 0 || e > r.length || e > 255)
    throw new Error(NF);
  let i = Lh - qh;
  if (i !== Sc)
    throw new Error(OF);
  let n = new Uint8Array(Mc.length + 2 + i * r.length);
  n.set(Mc, 0), n.set([t], Mc.length), n.set([e], Mc.length + 1);
  for (let s2 = 0; s2 < r.length; s2++) {
    if (r[s2].length !== i)
      throw new Error(CF);
    n.set(r[s2], Mc.length + 2 + s2 * i);
  }
  return new Uint8Array(Dr(n));
}
function Sg({ version: t, threshold: e, addrs: r }) {
  let i = r.map((n) => ut(n).publicKey);
  return Ue(Vi({ version: t, threshold: e, pks: i }));
}
function Qs(t) {
  let e = Jt(kF, Xs(t)), r = Dr(e);
  return Ue(new Uint8Array(r));
}
U();
var Ph = rr$1(o4()), jF = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function LF(t) {
  for (let e in t)
    if (Object.prototype.hasOwnProperty.call(t, e) && (!t[e] || t[e].length === 0))
      return { containsEmpty: true, firstEmptyKey: e };
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function Ig(t) {
  return Ph.encode(t, { sortKeys: true });
}
function tr(t) {
  let e = LF(t);
  if (e.containsEmpty)
    throw new Error(jF + e.firstEmptyKey);
  return Ig(t);
}
function Kt(t) {
  return Ph.decode(t);
}
U();
var Ze = rr$1(or()), d4 = rr$1(xg());
U();
function qF(t, e, r) {
  let i = t.appIndex, n = t.name, s2 = i === 0 || i === r, o = 0;
  if (e != null && (o = e.indexOf(i) + 1), o === 0 && !s2)
    throw new Error(`Box ref with appId ${i} not in foreign-apps`);
  return { i: o, n };
}
function a4(t, e, r) {
  return t == null ? [] : t.map((i) => qF(i, e, r));
}
U();
var Pt;
(function(t) {
  t.pay = "pay", t.keyreg = "keyreg", t.acfg = "acfg", t.axfer = "axfer", t.afrz = "afrz", t.appl = "appl", t.stpf = "stpf";
})(Pt || (Pt = {}));
function f4(t) {
  return t === Pt.pay || t === Pt.keyreg || t === Pt.acfg || t === Pt.axfer || t === Pt.afrz || t === Pt.appl || t === Pt.stpf;
}
var hr;
(function(t) {
  t[t.NoOpOC = 0] = "NoOpOC", t[t.OptInOC = 1] = "OptInOC", t[t.CloseOutOC = 2] = "CloseOutOC", t[t.ClearStateOC = 3] = "ClearStateOC", t[t.UpdateApplicationOC = 4] = "UpdateApplicationOC", t[t.DeleteApplicationOC = 5] = "DeleteApplicationOC";
})(hr || (hr = {}));
var PF = 52, Fg = 1e3, Tc = 32, c4 = 19, UF = 75, zF = 5, HF = 32, $F = 5, u4 = 32, GF = 32, KF = 32, WF = 64;
function Tg(t, e, r) {
  if (t == null)
    return;
  let i;
  if (typeof t == "string" ? i = Ze.Buffer.from(t, "base64") : t.constructor === Uint8Array ? i = Ze.Buffer.from(t) : Ze.Buffer.isBuffer(t) && (i = t), i == null || i.byteLength !== r)
    throw Error(`${e} must be a ${r} byte Uint8Array or Buffer or base64 string.`);
  return i;
}
var Ht = class {
  constructor({ ...e }) {
    this.name = "Transaction", this.tag = Ze.Buffer.from("TX");
    let r = { type: Pt.pay, flatFee: false, nonParticipation: false };
    if (typeof e.type > "u" && (e.type = r.type), typeof e.flatFee > "u" && (e.flatFee = r.flatFee), e.type === Pt.keyreg && typeof e.voteKey < "u" && typeof e.nonParticipation > "u" && (e.nonParticipation = r.nonParticipation), e.suggestedParams !== void 0) {
      let n = e;
      n.genesisHash = n.suggestedParams.genesisHash, n.fee = n.suggestedParams.fee, n.suggestedParams.flatFee !== void 0 && (n.flatFee = n.suggestedParams.flatFee), n.firstRound = n.suggestedParams.firstRound, n.lastRound = n.suggestedParams.lastRound, n.genesisID = n.suggestedParams.genesisID;
    }
    let i = e;
    if (i.from = ut(i.from), i.to !== void 0 && (i.to = ut(i.to)), i.closeRemainderTo !== void 0 && (i.closeRemainderTo = ut(i.closeRemainderTo)), i.assetManager !== void 0 && (i.assetManager = ut(i.assetManager)), i.assetReserve !== void 0 && (i.assetReserve = ut(i.assetReserve)), i.assetFreeze !== void 0 && (i.assetFreeze = ut(i.assetFreeze)), i.assetClawback !== void 0 && (i.assetClawback = ut(i.assetClawback)), i.assetRevocationTarget !== void 0 && (i.assetRevocationTarget = ut(i.assetRevocationTarget)), i.freezeAccount !== void 0 && (i.freezeAccount = ut(i.freezeAccount)), i.reKeyTo !== void 0 && (i.reKeyTo = ut(i.reKeyTo)), i.genesisHash === void 0)
      throw Error("genesis hash must be specified and in a base64 string.");
    if (i.genesisHash = Ze.Buffer.from(i.genesisHash, "base64"), i.amount !== void 0 && (!(Number.isSafeInteger(i.amount) || typeof i.amount == "bigint" && i.amount <= BigInt("0xffffffffffffffff")) || i.amount < 0))
      throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (!Number.isSafeInteger(i.fee) || i.fee < 0)
      throw Error("fee must be a positive number and smaller than 2^53-1");
    if (!Number.isSafeInteger(i.firstRound) || i.firstRound < 0)
      throw Error("firstRound must be a positive number");
    if (!Number.isSafeInteger(i.lastRound) || i.lastRound < 0)
      throw Error("lastRound must be a positive number");
    if (i.extraPages !== void 0 && (!Number.isInteger(i.extraPages) || i.extraPages < 0 || i.extraPages > 3))
      throw Error("extraPages must be an Integer between and including 0 to 3");
    if (i.assetTotal !== void 0 && (!(Number.isSafeInteger(i.assetTotal) || typeof i.assetTotal == "bigint" && i.assetTotal <= BigInt("0xffffffffffffffff")) || i.assetTotal < 0))
      throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
    if (i.assetDecimals !== void 0 && (!Number.isSafeInteger(i.assetDecimals) || i.assetDecimals < 0 || i.assetDecimals > c4))
      throw Error(`assetDecimals must be a positive number and smaller than ${c4.toString()}`);
    if (i.assetIndex !== void 0 && (!Number.isSafeInteger(i.assetIndex) || i.assetIndex < 0))
      throw Error("Asset index must be a positive number and smaller than 2^53-1");
    if (i.appIndex !== void 0 && (!Number.isSafeInteger(i.appIndex) || i.appIndex < 0))
      throw Error("Application index must be a positive number and smaller than 2^53-1");
    if (i.appLocalInts !== void 0 && (!Number.isSafeInteger(i.appLocalInts) || i.appLocalInts < 0))
      throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
    if (i.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(i.appLocalByteSlices) || i.appLocalByteSlices < 0))
      throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
    if (i.appGlobalInts !== void 0 && (!Number.isSafeInteger(i.appGlobalInts) || i.appGlobalInts < 0))
      throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
    if (i.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(i.appGlobalByteSlices) || i.appGlobalByteSlices < 0))
      throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
    if (i.appApprovalProgram !== void 0 && i.appApprovalProgram.constructor !== Uint8Array)
      throw Error("appApprovalProgram must be a Uint8Array.");
    if (i.appClearProgram !== void 0 && i.appClearProgram.constructor !== Uint8Array)
      throw Error("appClearProgram must be a Uint8Array.");
    if (i.appArgs !== void 0) {
      if (!Array.isArray(i.appArgs))
        throw Error("appArgs must be an Array of Uint8Array.");
      i.appArgs = i.appArgs.slice(), i.appArgs.forEach((n) => {
        if (n.constructor !== Uint8Array)
          throw Error("each element of AppArgs must be a Uint8Array.");
      });
    } else
      i.appArgs = [];
    if (i.appAccounts !== void 0) {
      if (!Array.isArray(i.appAccounts))
        throw Error("appAccounts must be an Array of addresses.");
      i.appAccounts = i.appAccounts.map((n) => ut(n));
    }
    if (i.appForeignApps !== void 0) {
      if (!Array.isArray(i.appForeignApps))
        throw Error("appForeignApps must be an Array of integers.");
      i.appForeignApps = i.appForeignApps.slice(), i.appForeignApps.forEach((n) => {
        if (!Number.isSafeInteger(n) || n < 0)
          throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
      });
    }
    if (i.appForeignAssets !== void 0) {
      if (!Array.isArray(i.appForeignAssets))
        throw Error("appForeignAssets must be an Array of integers.");
      i.appForeignAssets = i.appForeignAssets.slice(), i.appForeignAssets.forEach((n) => {
        if (!Number.isSafeInteger(n) || n < 0)
          throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
      });
    }
    if (i.boxes !== void 0) {
      if (!Array.isArray(i.boxes))
        throw Error("boxes must be an Array of BoxReference.");
      i.boxes = i.boxes.slice(), i.boxes.forEach((n) => {
        if (!Number.isSafeInteger(n.appIndex) || n.name.constructor !== Uint8Array)
          throw Error("box app index must be a number and name must be an Uint8Array.");
      });
    }
    if (i.assetMetadataHash !== void 0 && i.assetMetadataHash.length !== 0) {
      if (typeof i.assetMetadataHash == "string" && (i.assetMetadataHash = new Uint8Array(Ze.Buffer.from(i.assetMetadataHash))), i.assetMetadataHash.constructor !== Uint8Array || i.assetMetadataHash.byteLength !== u4)
        throw Error(`assetMetadataHash must be a ${u4} byte Uint8Array or string.`);
      i.assetMetadataHash.every((n) => n === 0) && (i.assetMetadataHash = void 0);
    } else
      i.assetMetadataHash = void 0;
    if (i.note !== void 0) {
      if (i.note.constructor !== Uint8Array)
        throw Error("note must be a Uint8Array.");
    } else
      i.note = new Uint8Array(0);
    if (i.lease !== void 0) {
      if (i.lease.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (i.lease.length !== Tc)
        throw Error(`lease must be of length ${Tc.toString()}.`);
      i.lease.every((n) => n === 0) && (i.lease = new Uint8Array(0));
    } else
      i.lease = new Uint8Array(0);
    if (i.voteKey = Tg(i.voteKey, "voteKey", GF), i.selectionKey = Tg(i.selectionKey, "selectionKey", KF), i.stateProofKey = Tg(i.stateProofKey, "stateProofKey", WF), i.nonParticipation && (i.voteKey || i.selectionKey || i.voteFirst || i.stateProofKey || i.voteLast || i.voteKeyDilution))
      throw new Error("nonParticipation is true but participation params are present.");
    if (!i.nonParticipation && (i.voteKey || i.selectionKey || i.stateProofKey || i.voteFirst || i.voteLast || i.voteKeyDilution) && !(i.voteKey && i.selectionKey && i.voteFirst && i.voteLast && i.voteKeyDilution))
      throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
    if (delete i.suggestedParams, Object.assign(this, e4(i)), i.flatFee || (this.fee *= this.estimateSize(), this.fee < Fg && (this.fee = Fg)), this.group = void 0, i.stateProofType !== void 0 && (!Number.isSafeInteger(i.stateProofType) || i.stateProofType < 0))
      throw Error("State Proof type must be a positive number and smaller than 2^53-1");
    if (i.stateProofMessage !== void 0) {
      if (i.stateProofMessage.constructor !== Uint8Array)
        throw Error("stateProofMessage must be a Uint8Array.");
    } else
      i.stateProofMessage = new Uint8Array(0);
    if (i.stateProof !== void 0) {
      if (i.stateProof.constructor !== Uint8Array)
        throw Error("stateProof must be a Uint8Array.");
    } else
      i.stateProof = new Uint8Array(0);
  }
  get_obj_for_encoding() {
    if (this.type === "pay") {
      let e = { amt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: "pay", gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group };
      return this.closeRemainderTo !== void 0 && Ue(this.closeRemainderTo.publicKey) !== s4 && (e.close = Ze.Buffer.from(this.closeRemainderTo.publicKey)), this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), this.to !== void 0 && (e.rcv = Ze.Buffer.from(this.to.publicKey)), e.note.length || delete e.note, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, e.lx.length || delete e.lx, e.rekey || delete e.rekey, e;
    }
    if (this.type === "keyreg") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, votekey: this.voteKey, selkey: this.selectionKey, sprfkey: this.stateProofKey, votefst: this.voteFirst, votelst: this.voteLast, votekd: this.voteKeyDilution };
      return e.note.length || delete e.note, e.lx.length || delete e.lx, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), this.nonParticipation && (e.nonpart = true), e.selkey || delete e.selkey, e.votekey || delete e.votekey, e.sprfkey || delete e.sprfkey, e.votefst || delete e.votefst, e.votelst || delete e.votelst, e.votekd || delete e.votekd, e;
    }
    if (this.type === "acfg") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, caid: this.assetIndex, apar: { t: this.assetTotal, df: this.assetDefaultFrozen, dc: this.assetDecimals } };
      return this.assetManager !== void 0 && (e.apar.m = Ze.Buffer.from(this.assetManager.publicKey)), this.assetReserve !== void 0 && (e.apar.r = Ze.Buffer.from(this.assetReserve.publicKey)), this.assetFreeze !== void 0 && (e.apar.f = Ze.Buffer.from(this.assetFreeze.publicKey)), this.assetClawback !== void 0 && (e.apar.c = Ze.Buffer.from(this.assetClawback.publicKey)), this.assetName !== void 0 && (e.apar.an = this.assetName), this.assetUnitName !== void 0 && (e.apar.un = this.assetUnitName), this.assetURL !== void 0 && (e.apar.au = this.assetURL), this.assetMetadataHash !== void 0 && (e.apar.am = Ze.Buffer.from(this.assetMetadataHash)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), e.caid || delete e.caid, !e.apar.t && !e.apar.un && !e.apar.an && !e.apar.df && !e.apar.m && !e.apar.r && !e.apar.f && !e.apar.c && !e.apar.au && !e.apar.am && !e.apar.dc ? delete e.apar : (e.apar.t || delete e.apar.t, e.apar.dc || delete e.apar.dc, e.apar.un || delete e.apar.un, e.apar.an || delete e.apar.an, e.apar.df || delete e.apar.df, e.apar.m || delete e.apar.m, e.apar.r || delete e.apar.r, e.apar.f || delete e.apar.f, e.apar.c || delete e.apar.c, e.apar.au || delete e.apar.au, e.apar.am || delete e.apar.am), e.grp === void 0 && delete e.grp, e;
    }
    if (this.type === "axfer") {
      let e = { aamt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), arcv: Ze.Buffer.from(this.to.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, xaid: this.assetIndex };
      return this.closeRemainderTo !== void 0 && (e.aclose = Ze.Buffer.from(this.closeRemainderTo.publicKey)), this.assetRevocationTarget !== void 0 && (e.asnd = Ze.Buffer.from(this.assetRevocationTarget.publicKey)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.aamt || delete e.aamt, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.grp === void 0 && delete e.grp, e.aclose || delete e.aclose, e.asnd || delete e.asnd, e.rekey || delete e.rekey, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), e;
    }
    if (this.type === "afrz") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, faid: this.assetIndex, afrz: this.freezeState };
      return this.freezeAccount !== void 0 && (e.fadd = Ze.Buffer.from(this.freezeAccount.publicKey)), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.afrz || delete e.afrz, e.grp === void 0 && delete e.grp, this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), e;
    }
    if (this.type === "appl") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), grp: this.group, apid: this.appIndex, apan: this.appOnComplete, apls: { nui: this.appLocalInts, nbs: this.appLocalByteSlices }, apgs: { nui: this.appGlobalInts, nbs: this.appGlobalByteSlices }, apfa: this.appForeignApps, apas: this.appForeignAssets, apep: this.extraPages, apbx: a4(this.boxes, this.appForeignApps, this.appIndex) };
      this.reKeyTo !== void 0 && (e.rekey = Ze.Buffer.from(this.reKeyTo.publicKey)), this.appApprovalProgram !== void 0 && (e.apap = Ze.Buffer.from(this.appApprovalProgram)), this.appClearProgram !== void 0 && (e.apsu = Ze.Buffer.from(this.appClearProgram)), this.appArgs !== void 0 && (e.apaa = this.appArgs.map((r) => Ze.Buffer.from(r))), this.appAccounts !== void 0 && (e.apat = this.appAccounts.map((r) => Ze.Buffer.from(r.publicKey))), e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.apid || delete e.apid, e.apls.nui || delete e.apls.nui, e.apls.nbs || delete e.apls.nbs, !e.apls.nui && !e.apls.nbs && delete e.apls, e.apgs.nui || delete e.apgs.nui, e.apgs.nbs || delete e.apgs.nbs, (!e.apaa || !e.apaa.length) && delete e.apaa, !e.apgs.nui && !e.apgs.nbs && delete e.apgs, e.apap || delete e.apap, e.apsu || delete e.apsu, e.apan || delete e.apan, (!e.apfa || !e.apfa.length) && delete e.apfa, (!e.apas || !e.apas.length) && delete e.apas;
      for (let r of e.apbx)
        r.i || delete r.i, (!r.n || !r.n.length) && delete r.n;
      return (!e.apbx || !e.apbx.length) && delete e.apbx, (!e.apat || !e.apat.length) && delete e.apat, e.apep || delete e.apep, e.grp === void 0 && delete e.grp, e;
    }
    if (this.type === "stpf") {
      let e = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: Ze.Buffer.from(this.note), snd: Ze.Buffer.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: Ze.Buffer.from(this.lease), sptype: this.stateProofType, spmsg: Ze.Buffer.from(this.stateProofMessage), sp: Ze.Buffer.from(this.stateProof) };
      return e.sptype || delete e.sptype, e.note.length || delete e.note, e.lx.length || delete e.lx, e.amt || delete e.amt, e.fee || delete e.fee, e.fv || delete e.fv, e.gen || delete e.gen, e.apid || delete e.apid, (!e.apaa || !e.apaa.length) && delete e.apaa, e.apap || delete e.apap, e.apsu || delete e.apsu, e.apan || delete e.apan, (!e.apfa || !e.apfa.length) && delete e.apfa, (!e.apas || !e.apas.length) && delete e.apas, (!e.apat || !e.apat.length) && delete e.apat, e.apep || delete e.apep, e.grp === void 0 && delete e.grp, e;
    }
  }
  static from_obj_for_encoding(e) {
    let r = Object.create(this.prototype);
    if (r.name = "Transaction", r.tag = Ze.Buffer.from("TX"), r.genesisID = e.gen, r.genesisHash = Ze.Buffer.from(e.gh), !f4(e.type))
      throw new Error(`Unrecognized transaction type: ${e.type}`);
    return r.type = e.type, r.fee = e.fee, r.firstRound = e.fv, r.lastRound = e.lv, r.note = new Uint8Array(e.note), r.lease = new Uint8Array(e.lx), r.from = ut(Ue(new Uint8Array(e.snd))), e.grp !== void 0 && (r.group = Ze.Buffer.from(e.grp)), e.rekey !== void 0 && (r.reKeyTo = ut(Ue(new Uint8Array(e.rekey)))), e.type === "pay" ? (r.amount = e.amt, r.to = ut(Ue(new Uint8Array(e.rcv))), e.close !== void 0 && (r.closeRemainderTo = ut(Ue(e.close)))) : e.type === "keyreg" ? (e.votekey !== void 0 && (r.voteKey = Ze.Buffer.from(e.votekey)), e.selkey !== void 0 && (r.selectionKey = Ze.Buffer.from(e.selkey)), e.sprfkey !== void 0 && (r.stateProofKey = Ze.Buffer.from(e.sprfkey)), e.votekd !== void 0 && (r.voteKeyDilution = e.votekd), e.votefst !== void 0 && (r.voteFirst = e.votefst), e.votelst !== void 0 && (r.voteLast = e.votelst), e.nonpart !== void 0 && (r.nonParticipation = e.nonpart)) : e.type === "acfg" ? (e.caid !== void 0 && (r.assetIndex = e.caid), e.apar !== void 0 && (r.assetTotal = e.apar.t, r.assetDefaultFrozen = e.apar.df, e.apar.dc !== void 0 && (r.assetDecimals = e.apar.dc), e.apar.m !== void 0 && (r.assetManager = ut(Ue(new Uint8Array(e.apar.m)))), e.apar.r !== void 0 && (r.assetReserve = ut(Ue(new Uint8Array(e.apar.r)))), e.apar.f !== void 0 && (r.assetFreeze = ut(Ue(new Uint8Array(e.apar.f)))), e.apar.c !== void 0 && (r.assetClawback = ut(Ue(new Uint8Array(e.apar.c)))), e.apar.un !== void 0 && (r.assetUnitName = e.apar.un), e.apar.an !== void 0 && (r.assetName = e.apar.an), e.apar.au !== void 0 && (r.assetURL = e.apar.au), e.apar.am !== void 0 && (r.assetMetadataHash = e.apar.am))) : e.type === "axfer" ? (e.xaid !== void 0 && (r.assetIndex = e.xaid), e.aamt !== void 0 && (r.amount = e.aamt), e.aclose !== void 0 && (r.closeRemainderTo = ut(Ue(new Uint8Array(e.aclose)))), e.asnd !== void 0 && (r.assetRevocationTarget = ut(Ue(new Uint8Array(e.asnd)))), r.to = ut(Ue(new Uint8Array(e.arcv)))) : e.type === "afrz" ? (e.afrz !== void 0 && (r.freezeState = e.afrz), e.faid !== void 0 && (r.assetIndex = e.faid), r.freezeAccount = ut(Ue(new Uint8Array(e.fadd)))) : e.type === "appl" ? (e.apid !== void 0 && (r.appIndex = e.apid), e.apan !== void 0 && (r.appOnComplete = e.apan), e.apls !== void 0 && (e.apls.nui !== void 0 && (r.appLocalInts = e.apls.nui), e.apls.nbs !== void 0 && (r.appLocalByteSlices = e.apls.nbs)), e.apgs !== void 0 && (e.apgs.nui !== void 0 && (r.appGlobalInts = e.apgs.nui), e.apgs.nbs !== void 0 && (r.appGlobalByteSlices = e.apgs.nbs)), e.apep !== void 0 && (r.extraPages = e.apep), e.apap !== void 0 && (r.appApprovalProgram = new Uint8Array(e.apap)), e.apsu !== void 0 && (r.appClearProgram = new Uint8Array(e.apsu)), e.apaa !== void 0 && (r.appArgs = e.apaa.map((i) => new Uint8Array(i))), e.apat !== void 0 && (r.appAccounts = e.apat.map((i) => ut(Ue(new Uint8Array(i))))), e.apfa !== void 0 && (r.appForeignApps = e.apfa), e.apas !== void 0 && (r.appForeignAssets = e.apas), e.apbx !== void 0 && (r.boxes = e.apbx.map((i) => ({ appIndex: i.i ? r.appForeignApps[i.i - 1] : 0, name: i.n })))) : e.type === "stpf" && (e.sptype !== void 0 && (r.stateProofType = e.sptype), e.sp !== void 0 && (r.stateProof = e.sp), e.spmsg !== void 0 && (r.stateProofMessage = e.spmsg)), r;
  }
  estimateSize() {
    return this.toByte().length + UF;
  }
  bytesToSign() {
    let e = this.toByte();
    return Ze.Buffer.from(Jt(this.tag, e));
  }
  toByte() {
    return tr(this.get_obj_for_encoding());
  }
  rawSignTxn(e) {
    let r = this.bytesToSign(), i = vn(r, e);
    return Ze.Buffer.from(i);
  }
  signTxn(e) {
    let r = { sig: this.rawSignTxn(e), txn: this.get_obj_for_encoding() }, n = bn(e).publicKey;
    return Ue(n) !== Ue(this.from.publicKey) && (r.sgnr = Ze.Buffer.from(n)), new Uint8Array(tr(r));
  }
  attachSignature(e, r) {
    if (!kh(r.length))
      throw new Error("Invalid signature length");
    let i = { sig: Ze.Buffer.from(r), txn: this.get_obj_for_encoding() };
    if (e !== Ue(this.from.publicKey)) {
      let n = ut(e).publicKey;
      i.sgnr = Ze.Buffer.from(n);
    }
    return new Uint8Array(tr(i));
  }
  rawTxID() {
    let e = this.toByte(), r = Ze.Buffer.from(Jt(this.tag, e));
    return Ze.Buffer.from(Dr(r));
  }
  txID() {
    let e = this.rawTxID();
    return d4.default.encode(e).slice(0, PF);
  }
  addLease(e, r = 0) {
    let i;
    if (e !== void 0) {
      if (e.constructor !== Uint8Array)
        throw Error("lease must be a Uint8Array.");
      if (e.length !== Tc)
        throw Error(`lease must be of length ${Tc.toString()}.`);
      i = new Uint8Array(e);
    } else
      i = new Uint8Array(0);
    this.lease = i, r !== 0 && (this.fee += (zF + Tc) * r);
  }
  addRekey(e, r = 0) {
    e !== void 0 && (this.reKeyTo = ut(e)), r !== 0 && (this.fee += ($F + HF) * r);
  }
  _getDictForDisplay() {
    let e = { ...this };
    return e.tag = e.tag.toString(), e.from = Ue(e.from.publicKey), e.to !== void 0 && (e.to = Ue(e.to.publicKey)), e.freezeAccount !== void 0 && (e.freezeAccount = Ue(e.freezeAccount.publicKey)), e.closeRemainderTo !== void 0 && (e.closeRemainderTo = Ue(e.closeRemainderTo.publicKey)), e.assetManager !== void 0 && (e.assetManager = Ue(e.assetManager.publicKey)), e.assetReserve !== void 0 && (e.assetReserve = Ue(e.assetReserve.publicKey)), e.assetFreeze !== void 0 && (e.assetFreeze = Ue(e.assetFreeze.publicKey)), e.assetClawback !== void 0 && (e.assetClawback = Ue(e.assetClawback.publicKey)), e.assetRevocationTarget !== void 0 && (e.assetRevocationTarget = Ue(e.assetRevocationTarget.publicKey)), e.reKeyTo !== void 0 && (e.reKeyTo = Ue(e.reKeyTo.publicKey)), e.genesisHash = e.genesisHash.toString("base64"), e;
  }
  prettyPrint() {
    console.log(this._getDictForDisplay());
  }
  toString() {
    return JSON.stringify(this._getDictForDisplay());
  }
};
function Rg(t) {
  let e = { txn: t.get_obj_for_encoding() };
  return tr(e);
}
function VF(t) {
  let e = t.get_obj_for_encoding();
  return tr(e);
}
function eo(t) {
  let e = Kt(t);
  return Ht.from_obj_for_encoding(e);
}
function xn(t) {
  let e = Kt(t);
  return { ...e, txn: Ht.from_obj_for_encoding(e.txn) };
}
function hi(t) {
  return t instanceof Ht ? t : new Ht(t);
}
U();
var xa = rr$1(or());
var Fc = class {
  constructor({ bidderKey: e, bidAmount: r, bidID: i, auctionKey: n, auctionID: s2, maxPrice: o }) {
    this.name = "Bid", this.tag = xa.Buffer.from([97, 66]);
    let f = ut(e), l = ut(n);
    if (!Number.isSafeInteger(r) || r < 0)
      throw Error("Bid amount must be positive and 2^53-1");
    if (!Number.isSafeInteger(i) || i < 0)
      throw Error("BidID must be positive and 2^53-1");
    if (!Number.isSafeInteger(s2) || s2 < 0)
      throw Error("auctionID must be positive");
    Object.assign(this, { bidderKey: f, bidAmount: r, bidID: i, auctionKey: l, auctionID: s2, maxPrice: o });
  }
  get_obj_for_encoding() {
    return { bidder: xa.Buffer.from(this.bidderKey.publicKey), cur: this.bidAmount, price: this.maxPrice, id: this.bidID, auc: xa.Buffer.from(this.auctionKey.publicKey), aid: this.auctionID };
  }
  signBid(e) {
    let r = tr(this.get_obj_for_encoding()), i = xa.Buffer.from(Jt(this.tag, r)), n = vn(i, e), s2 = { sig: xa.Buffer.from(n), bid: this.get_obj_for_encoding() }, o = { t: "b", b: s2 };
    return new Uint8Array(tr(o));
  }
};
U();
var Rc = "Microalgos should be positive and less than 2^53 - 1.";
function Uh(t) {
  if (t < 0 || !Number.isSafeInteger(t))
    throw new Error(Rc);
  return t / 1e6;
}
function l4(t) {
  let e = t * 1e6;
  return Math.round(e);
}
U();
U();
U();
var Gh = rr$1(or());
U();
var g4 = rr$1(or()), $h = rr$1(p4()), kg = class extends Error {
  constructor(e, r) {
    super(e), this.response = r, this.name = "URLTokenBaseHTTPError", this.response = r;
  }
}, Yi = class {
  constructor(e, r, i, n = {}) {
    this.defaultHeaders = n;
    let s2 = r.endsWith("/") ? r : `${r}/`, o = new URL(s2);
    if (typeof i < "u" && (o.port = i.toString()), o.protocol.length === 0)
      throw new Error("Invalid base server URL, protocol must be defined.");
    this.baseURL = o, this.tokenHeader = e;
  }
  getURL(e, r) {
    let i;
    e.startsWith("./") ? i = e : e.startsWith("/") ? i = `.${e}` : i = `./${e}`;
    let n = new URL(i, this.baseURL);
    if (r)
      for (let [s2, o] of Object.entries(r))
        n.searchParams.set(s2, o);
    return n.toString();
  }
  static formatFetchResponseHeaders(e) {
    let r = {};
    return e.forEach((i, n) => {
      r[i] = n;
    }), r;
  }
  static async checkHttpError(e) {
    if (e.ok)
      return;
    let r = null, i = null;
    try {
      r = new Uint8Array(await e.arrayBuffer());
      let s2 = JSON.parse(g4.Buffer.from(r).toString());
      s2.message && (i = s2.message);
    } catch {
    }
    let n = `Network request error. Received status ${e.status} (${e.statusText})`;
    throw i && (n += `: ${i}`), new kg(n, { body: r, status: e.status, headers: Yi.formatFetchResponseHeaders(e.headers) });
  }
  static async formatFetchResponse(e) {
    return await this.checkHttpError(e), { body: new Uint8Array(await e.arrayBuffer()), status: e.status, headers: Yi.formatFetchResponseHeaders(e.headers) };
  }
  async get(e, r, i = {}) {
    let n = { ...this.tokenHeader, ...this.defaultHeaders, ...i }, s2 = await (0, $h.fetch)(this.getURL(e, r), { headers: n });
    return Yi.formatFetchResponse(s2);
  }
  async post(e, r, i, n = {}) {
    let s2 = { ...this.tokenHeader, ...this.defaultHeaders, ...n }, o = await (0, $h.fetch)(this.getURL(e, i), { method: "POST", body: r, headers: s2 });
    return Yi.formatFetchResponse(o);
  }
  async delete(e, r, i, n = {}) {
    let s2 = { ...this.tokenHeader, ...this.defaultHeaders, ...n }, o = await (0, $h.fetch)(this.getURL(e, i), { method: "DELETE", body: r, headers: s2 });
    return Yi.formatFetchResponse(o);
  }
};
function JF(t) {
  for (let e in t)
    Object.prototype.hasOwnProperty.call(t, e) && (!t[e] || t[e].length === 0) && delete t[e];
  return t;
}
function m4(t) {
  return Object.keys(t).reduce((e, r) => (e[r.toLowerCase()] = t[r], e), {});
}
function ZF(t) {
  if (t !== void 0 && Object.prototype.hasOwnProperty.call(t, "format"))
    switch (t.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  else
    return "application/json";
}
var Br = class {
  constructor(e, r, i, n = {}) {
    r !== void 0 ? this.bc = new Yi(e, r, i, n) : this.bc = e;
  }
  static parseJSON(e, r, i = {}) {
    try {
      return Object.keys(i).length === 0 ? e && JSON.parse(e) : e && Q3(e, i);
    } catch (n) {
      let s2 = n;
      throw s2.rawResponse = e || null, s2.statusCode = r, s2;
    }
  }
  static serializeData(e, r) {
    if (!e)
      return new Uint8Array(0);
    if (r["content-type"] === "application/json")
      return new Uint8Array(Gh.Buffer.from(JSON.stringify(e)));
    if (typeof e == "string")
      return new Uint8Array(Gh.Buffer.from(e));
    if (e instanceof Uint8Array)
      return e;
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  static prepareResponse(e, r, i, n = {}) {
    let { body: s2 } = e, o;
    return r !== "application/msgpack" && (o = s2 && Gh.Buffer.from(s2).toString() || ""), i && r === "application/json" && (s2 = Br.parseJSON(o, e.status, n)), { ...e, body: s2, text: o, ok: Math.trunc(e.status / 100) === 2 };
  }
  static prepareResponseError(e) {
    return e.response && (e.response = Br.prepareResponse(e.response, "application/json", true), e.status = e.response.status), e;
  }
  async get(e, r, i = {}, n = {}, s2 = true) {
    let o = ZF(r), f = { ...i, accept: o };
    try {
      let l = await this.bc.get(e, JF(r), f);
      return Br.prepareResponse(l, o, s2, n);
    } catch (l) {
      throw Br.prepareResponseError(l);
    }
  }
  async post(e, r, i = {}, n, s2 = true) {
    let o = { "content-type": "application/json", ...m4(i) };
    try {
      let f = await this.bc.post(e, Br.serializeData(r, o), n, o);
      return Br.prepareResponse(f, "application/json", s2);
    } catch (f) {
      throw Br.prepareResponseError(f);
    }
  }
  async delete(e, r, i = {}, n = true) {
    let s2 = { "content-type": "application/json", ...m4(i) }, o = await this.bc.delete(e, Br.serializeData(r, s2), void 0, s2);
    return Br.prepareResponse(o, "application/json", n);
  }
};
function XF(t = "", e) {
  let r = {};
  return t === "" || (r[e] = t), r;
}
function QF(t) {
  return typeof t.get == "function";
}
var _n = class {
  constructor(e, r, i, n, s2 = {}) {
    if (QF(r))
      this.c = new Br(r);
    else {
      let o;
      typeof r == "string" ? o = XF(r, e) : o = r, this.c = new Br(o, i, n, s2);
    }
    this.intDecoding = Yn.DEFAULT;
  }
  setIntEncoding(e) {
    this.intDecoding = e;
  }
  getIntEncoding() {
    return this.intDecoding;
  }
};
var Kh = {};
ct(Kh, { Account: () => Aa, AccountApplicationResponse: () => kc, AccountAssetResponse: () => Dc, AccountParticipation: () => Ea, AccountStateDelta: () => to, Application: () => An, ApplicationLocalState: () => ro, ApplicationParams: () => En, ApplicationStateSchema: () => pi, Asset: () => Sa, AssetHolding: () => io, AssetParams: () => no, BlockHashResponse: () => Bc, BlockResponse: () => Nc, Box: () => so, BoxDescriptor: () => Ma, BoxesResponse: () => oo, BuildVersion: () => Ia, CompileResponse: () => Cc, DisassembleResponse: () => Oc, DryrunRequest: () => ao, DryrunResponse: () => jc, DryrunSource: () => Ta, DryrunState: () => fo, DryrunTxnResult: () => Fa, ErrorResponse: () => Lc, EvalDelta: () => Ra, EvalDeltaKeyValue: () => es, GetBlockTimeStampOffsetResponse: () => co, GetSyncRoundResponse: () => uo, KvDelta: () => qc, LedgerStateDeltaForTransactionGroup: () => ka, LightBlockHeaderProof: () => Pc, NodeStatusResponse: () => Uc, PendingTransactionResponse: () => lo, PendingTransactionsResponse: () => zc, PostTransactionsResponse: () => Hc, SimulateRequest: () => Sn, SimulateRequestTransactionGroup: () => Ji, SimulateResponse: () => ho, SimulateTransactionGroupResult: () => Da, SimulateTransactionResult: () => Ba, SimulationEvalOverrides: () => Na, StateProof: () => $c, StateProofMessage: () => Ca, SupplyResponse: () => Gc, TealKeyValue: () => po, TealValue: () => ts, TransactionGroupLedgerStateDeltasForRoundResponse: () => go, TransactionParametersResponse: () => Kc, TransactionProofResponse: () => Wc, Version: () => Vc });
U();
var rr = rr$1(or());
U();
var y4 = rr$1(or());
function eR(t) {
  return t === void 0 || t == null || typeof t != "object" && typeof t != "function";
}
function Dg(t, e) {
  let r;
  if (t instanceof Uint8Array)
    r = e ? t : y4.Buffer.from(t).toString("base64");
  else if (typeof t.get_obj_for_encoding == "function")
    r = t.get_obj_for_encoding(e);
  else if (Array.isArray(t)) {
    r = [];
    for (let i of t)
      r.push(Dg(i, e));
  } else if (typeof t == "object") {
    let i = {};
    for (let n of Object.keys(t))
      i[n] = Dg(t[n], e);
    r = i;
  } else if (eR(t))
    r = t;
  else
    throw new Error(`Unsupported value: ${String(t)}`);
  return r;
}
var Ie = class {
  get_obj_for_encoding(e = false) {
    let r = {};
    for (let i of Object.keys(this.attribute_map)) {
      let n = this.attribute_map[i], s2 = this[i];
      typeof s2 < "u" && (r[n] = s2 === null ? null : Dg(s2, e));
    }
    return r;
  }
};
var Aa = class extends Ie {
  constructor({ address: e, amount: r, amountWithoutPendingRewards: i, minBalance: n, pendingRewards: s2, rewards: o, round: f, status: l, totalAppsOptedIn: m3, totalAssetsOptedIn: A2, totalCreatedApps: F3, totalCreatedAssets: z3, appsLocalState: V, appsTotalExtraPages: $, appsTotalSchema: re, assets: W2, authAddr: Z2, createdApps: ue, createdAssets: ge, participation: Se, rewardBase: pe2, sigType: H2, totalBoxBytes: le, totalBoxes: ie }) {
    super(), this.address = e, this.amount = r, this.amountWithoutPendingRewards = i, this.minBalance = n, this.pendingRewards = s2, this.rewards = o, this.round = f, this.status = l, this.totalAppsOptedIn = m3, this.totalAssetsOptedIn = A2, this.totalCreatedApps = F3, this.totalCreatedAssets = z3, this.appsLocalState = V, this.appsTotalExtraPages = $, this.appsTotalSchema = re, this.assets = W2, this.authAddr = Z2, this.createdApps = ue, this.createdAssets = ge, this.participation = Se, this.rewardBase = pe2, this.sigType = H2, this.totalBoxBytes = le, this.totalBoxes = ie, this.attribute_map = { address: "address", amount: "amount", amountWithoutPendingRewards: "amount-without-pending-rewards", minBalance: "min-balance", pendingRewards: "pending-rewards", rewards: "rewards", round: "round", status: "status", totalAppsOptedIn: "total-apps-opted-in", totalAssetsOptedIn: "total-assets-opted-in", totalCreatedApps: "total-created-apps", totalCreatedAssets: "total-created-assets", appsLocalState: "apps-local-state", appsTotalExtraPages: "apps-total-extra-pages", appsTotalSchema: "apps-total-schema", assets: "assets", authAddr: "auth-addr", createdApps: "created-apps", createdAssets: "created-assets", participation: "participation", rewardBase: "reward-base", sigType: "sig-type", totalBoxBytes: "total-box-bytes", totalBoxes: "total-boxes" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["amount-without-pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${e}`);
    if (typeof e["min-balance"] > "u")
      throw new Error(`Response is missing required field 'min-balance': ${e}`);
    if (typeof e["pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'pending-rewards': ${e}`);
    if (typeof e.rewards > "u")
      throw new Error(`Response is missing required field 'rewards': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.status > "u")
      throw new Error(`Response is missing required field 'status': ${e}`);
    if (typeof e["total-apps-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${e}`);
    if (typeof e["total-assets-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${e}`);
    if (typeof e["total-created-apps"] > "u")
      throw new Error(`Response is missing required field 'total-created-apps': ${e}`);
    if (typeof e["total-created-assets"] > "u")
      throw new Error(`Response is missing required field 'total-created-assets': ${e}`);
    return new Aa({ address: e.address, amount: e.amount, amountWithoutPendingRewards: e["amount-without-pending-rewards"], minBalance: e["min-balance"], pendingRewards: e["pending-rewards"], rewards: e.rewards, round: e.round, status: e.status, totalAppsOptedIn: e["total-apps-opted-in"], totalAssetsOptedIn: e["total-assets-opted-in"], totalCreatedApps: e["total-created-apps"], totalCreatedAssets: e["total-created-assets"], appsLocalState: typeof e["apps-local-state"] < "u" ? e["apps-local-state"].map(ro.from_obj_for_encoding) : void 0, appsTotalExtraPages: e["apps-total-extra-pages"], appsTotalSchema: typeof e["apps-total-schema"] < "u" ? pi.from_obj_for_encoding(e["apps-total-schema"]) : void 0, assets: typeof e.assets < "u" ? e.assets.map(io.from_obj_for_encoding) : void 0, authAddr: e["auth-addr"], createdApps: typeof e["created-apps"] < "u" ? e["created-apps"].map(An.from_obj_for_encoding) : void 0, createdAssets: typeof e["created-assets"] < "u" ? e["created-assets"].map(Sa.from_obj_for_encoding) : void 0, participation: typeof e.participation < "u" ? Ea.from_obj_for_encoding(e.participation) : void 0, rewardBase: e["reward-base"], sigType: e["sig-type"], totalBoxBytes: e["total-box-bytes"], totalBoxes: e["total-boxes"] });
  }
}, kc = class extends Ie {
  constructor({ round: e, appLocalState: r, createdApp: i }) {
    super(), this.round = e, this.appLocalState = r, this.createdApp = i, this.attribute_map = { round: "round", appLocalState: "app-local-state", createdApp: "created-app" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new kc({ round: e.round, appLocalState: typeof e["app-local-state"] < "u" ? ro.from_obj_for_encoding(e["app-local-state"]) : void 0, createdApp: typeof e["created-app"] < "u" ? En.from_obj_for_encoding(e["created-app"]) : void 0 });
  }
}, Dc = class extends Ie {
  constructor({ round: e, assetHolding: r, createdAsset: i }) {
    super(), this.round = e, this.assetHolding = r, this.createdAsset = i, this.attribute_map = { round: "round", assetHolding: "asset-holding", createdAsset: "created-asset" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new Dc({ round: e.round, assetHolding: typeof e["asset-holding"] < "u" ? io.from_obj_for_encoding(e["asset-holding"]) : void 0, createdAsset: typeof e["created-asset"] < "u" ? no.from_obj_for_encoding(e["created-asset"]) : void 0 });
  }
}, Ea = class extends Ie {
  constructor({ selectionParticipationKey: e, voteFirstValid: r, voteKeyDilution: i, voteLastValid: n, voteParticipationKey: s2, stateProofKey: o }) {
    super(), this.selectionParticipationKey = typeof e == "string" ? new Uint8Array(rr.Buffer.from(e, "base64")) : e, this.voteFirstValid = r, this.voteKeyDilution = i, this.voteLastValid = n, this.voteParticipationKey = typeof s2 == "string" ? new Uint8Array(rr.Buffer.from(s2, "base64")) : s2, this.stateProofKey = typeof o == "string" ? new Uint8Array(rr.Buffer.from(o, "base64")) : o, this.attribute_map = { selectionParticipationKey: "selection-participation-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key", stateProofKey: "state-proof-key" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["selection-participation-key"] > "u")
      throw new Error(`Response is missing required field 'selection-participation-key': ${e}`);
    if (typeof e["vote-first-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-first-valid': ${e}`);
    if (typeof e["vote-key-dilution"] > "u")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${e}`);
    if (typeof e["vote-last-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-last-valid': ${e}`);
    if (typeof e["vote-participation-key"] > "u")
      throw new Error(`Response is missing required field 'vote-participation-key': ${e}`);
    return new Ea({ selectionParticipationKey: e["selection-participation-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"], stateProofKey: e["state-proof-key"] });
  }
}, to = class extends Ie {
  constructor({ address: e, delta: r }) {
    super(), this.address = e, this.delta = r, this.attribute_map = { address: "address", delta: "delta" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (!Array.isArray(e.delta))
      throw new Error(`Response is missing required array field 'delta': ${e}`);
    return new to({ address: e.address, delta: e.delta.map(es.from_obj_for_encoding) });
  }
}, An = class extends Ie {
  constructor({ id: e, params: r }) {
    super(), this.id = e, this.params = r, this.attribute_map = { id: "id", params: "params" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new An({ id: e.id, params: En.from_obj_for_encoding(e.params) });
  }
}, ro = class extends Ie {
  constructor({ id: e, schema: r, keyValue: i }) {
    super(), this.id = e, this.schema = r, this.keyValue = i, this.attribute_map = { id: "id", schema: "schema", keyValue: "key-value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.schema > "u")
      throw new Error(`Response is missing required field 'schema': ${e}`);
    return new ro({ id: e.id, schema: pi.from_obj_for_encoding(e.schema), keyValue: typeof e["key-value"] < "u" ? e["key-value"].map(po.from_obj_for_encoding) : void 0 });
  }
}, En = class extends Ie {
  constructor({ approvalProgram: e, clearStateProgram: r, creator: i, extraProgramPages: n, globalState: s2, globalStateSchema: o, localStateSchema: f }) {
    super(), this.approvalProgram = typeof e == "string" ? new Uint8Array(rr.Buffer.from(e, "base64")) : e, this.clearStateProgram = typeof r == "string" ? new Uint8Array(rr.Buffer.from(r, "base64")) : r, this.creator = i, this.extraProgramPages = n, this.globalState = s2, this.globalStateSchema = o, this.localStateSchema = f, this.attribute_map = { approvalProgram: "approval-program", clearStateProgram: "clear-state-program", creator: "creator", extraProgramPages: "extra-program-pages", globalState: "global-state", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["approval-program"] > "u")
      throw new Error(`Response is missing required field 'approval-program': ${e}`);
    if (typeof e["clear-state-program"] > "u")
      throw new Error(`Response is missing required field 'clear-state-program': ${e}`);
    if (typeof e.creator > "u")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    return new En({ approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], creator: e.creator, extraProgramPages: e["extra-program-pages"], globalState: typeof e["global-state"] < "u" ? e["global-state"].map(po.from_obj_for_encoding) : void 0, globalStateSchema: typeof e["global-state-schema"] < "u" ? pi.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] < "u" ? pi.from_obj_for_encoding(e["local-state-schema"]) : void 0 });
  }
}, pi = class extends Ie {
  constructor({ numUint: e, numByteSlice: r }) {
    super(), this.numUint = e, this.numByteSlice = r, this.attribute_map = { numUint: "num-uint", numByteSlice: "num-byte-slice" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-uint"] > "u")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    if (typeof e["num-byte-slice"] > "u")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    return new pi({ numUint: e["num-uint"], numByteSlice: e["num-byte-slice"] });
  }
}, Sa = class extends Ie {
  constructor({ index: e, params: r }) {
    super(), this.index = e, this.params = r, this.attribute_map = { index: "index", params: "params" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index > "u")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new Sa({ index: e.index, params: no.from_obj_for_encoding(e.params) });
  }
}, io = class extends Ie {
  constructor({ amount: e, assetId: r, isFrozen: i }) {
    super(), this.amount = e, this.assetId = r, this.isFrozen = i, this.attribute_map = { amount: "amount", assetId: "asset-id", isFrozen: "is-frozen" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["is-frozen"] > "u")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new io({ amount: e.amount, assetId: e["asset-id"], isFrozen: e["is-frozen"] });
  }
}, no = class extends Ie {
  constructor({ creator: e, decimals: r, total: i, clawback: n, defaultFrozen: s2, freeze: o, manager: f, metadataHash: l, name: m3, nameB64: A2, reserve: F3, unitName: z3, unitNameB64: V, url: $, urlB64: re }) {
    super(), this.creator = e, this.decimals = r, this.total = i, this.clawback = n, this.defaultFrozen = s2, this.freeze = o, this.manager = f, this.metadataHash = typeof l == "string" ? new Uint8Array(rr.Buffer.from(l, "base64")) : l, this.name = m3, this.nameB64 = typeof A2 == "string" ? new Uint8Array(rr.Buffer.from(A2, "base64")) : A2, this.reserve = F3, this.unitName = z3, this.unitNameB64 = typeof V == "string" ? new Uint8Array(rr.Buffer.from(V, "base64")) : V, this.url = $, this.urlB64 = typeof re == "string" ? new Uint8Array(rr.Buffer.from(re, "base64")) : re, this.attribute_map = { creator: "creator", decimals: "decimals", total: "total", clawback: "clawback", defaultFrozen: "default-frozen", freeze: "freeze", manager: "manager", metadataHash: "metadata-hash", name: "name", nameB64: "name-b64", reserve: "reserve", unitName: "unit-name", unitNameB64: "unit-name-b64", url: "url", urlB64: "url-b64" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.creator > "u")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    if (typeof e.decimals > "u")
      throw new Error(`Response is missing required field 'decimals': ${e}`);
    if (typeof e.total > "u")
      throw new Error(`Response is missing required field 'total': ${e}`);
    return new no({ creator: e.creator, decimals: e.decimals, total: e.total, clawback: e.clawback, defaultFrozen: e["default-frozen"], freeze: e.freeze, manager: e.manager, metadataHash: e["metadata-hash"], name: e.name, nameB64: e["name-b64"], reserve: e.reserve, unitName: e["unit-name"], unitNameB64: e["unit-name-b64"], url: e.url, urlB64: e["url-b64"] });
  }
}, Bc = class extends Ie {
  constructor({ blockhash: e }) {
    super(), this.blockhash = e, this.attribute_map = { blockhash: "blockHash" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.blockHash > "u")
      throw new Error(`Response is missing required field 'blockHash': ${e}`);
    return new Bc({ blockhash: e.blockHash });
  }
}, Nc = class extends Ie {
  constructor({ block: e, cert: r }) {
    super(), this.block = e, this.cert = r, this.attribute_map = { block: "block", cert: "cert" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.block > "u")
      throw new Error(`Response is missing required field 'block': ${e}`);
    return new Nc({ block: e.block, cert: e.cert });
  }
}, so = class extends Ie {
  constructor({ name: e, value: r }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(rr.Buffer.from(e, "base64")) : e, this.value = typeof r == "string" ? new Uint8Array(rr.Buffer.from(r, "base64")) : r, this.attribute_map = { name: "name", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new so({ name: e.name, value: e.value });
  }
}, Ma = class extends Ie {
  constructor({ name: e }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(rr.Buffer.from(e, "base64")) : e, this.attribute_map = { name: "name" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    return new Ma({ name: e.name });
  }
}, oo = class extends Ie {
  constructor({ boxes: e }) {
    super(), this.boxes = e, this.attribute_map = { boxes: "boxes" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.boxes))
      throw new Error(`Response is missing required array field 'boxes': ${e}`);
    return new oo({ boxes: e.boxes.map(Ma.from_obj_for_encoding) });
  }
}, Ia = class extends Ie {
  constructor({ branch: e, buildNumber: r, channel: i, commitHash: n, major: s2, minor: o }) {
    super(), this.branch = e, this.buildNumber = r, this.channel = i, this.commitHash = n, this.major = s2, this.minor = o, this.attribute_map = { branch: "branch", buildNumber: "build_number", channel: "channel", commitHash: "commit_hash", major: "major", minor: "minor" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.branch > "u")
      throw new Error(`Response is missing required field 'branch': ${e}`);
    if (typeof e.build_number > "u")
      throw new Error(`Response is missing required field 'build_number': ${e}`);
    if (typeof e.channel > "u")
      throw new Error(`Response is missing required field 'channel': ${e}`);
    if (typeof e.commit_hash > "u")
      throw new Error(`Response is missing required field 'commit_hash': ${e}`);
    if (typeof e.major > "u")
      throw new Error(`Response is missing required field 'major': ${e}`);
    if (typeof e.minor > "u")
      throw new Error(`Response is missing required field 'minor': ${e}`);
    return new Ia({ branch: e.branch, buildNumber: e.build_number, channel: e.channel, commitHash: e.commit_hash, major: e.major, minor: e.minor });
  }
}, Cc = class extends Ie {
  constructor({ hash: e, result: r, sourcemap: i }) {
    super(), this.hash = e, this.result = r, this.sourcemap = i, this.attribute_map = { hash: "hash", result: "result", sourcemap: "sourcemap" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.hash > "u")
      throw new Error(`Response is missing required field 'hash': ${e}`);
    if (typeof e.result > "u")
      throw new Error(`Response is missing required field 'result': ${e}`);
    return new Cc({ hash: e.hash, result: e.result, sourcemap: e.sourcemap });
  }
}, Oc = class extends Ie {
  constructor({ result: e }) {
    super(), this.result = e, this.attribute_map = { result: "result" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.result > "u")
      throw new Error(`Response is missing required field 'result': ${e}`);
    return new Oc({ result: e.result });
  }
}, ao = class extends Ie {
  constructor({ accounts: e, apps: r, latestTimestamp: i, protocolVersion: n, round: s2, sources: o, txns: f }) {
    super(), this.accounts = e, this.apps = r, this.latestTimestamp = i, this.protocolVersion = n, this.round = s2, this.sources = o, this.txns = f, this.attribute_map = { accounts: "accounts", apps: "apps", latestTimestamp: "latest-timestamp", protocolVersion: "protocol-version", round: "round", sources: "sources", txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.accounts))
      throw new Error(`Response is missing required array field 'accounts': ${e}`);
    if (!Array.isArray(e.apps))
      throw new Error(`Response is missing required array field 'apps': ${e}`);
    if (typeof e["latest-timestamp"] > "u")
      throw new Error(`Response is missing required field 'latest-timestamp': ${e}`);
    if (typeof e["protocol-version"] > "u")
      throw new Error(`Response is missing required field 'protocol-version': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (!Array.isArray(e.sources))
      throw new Error(`Response is missing required array field 'sources': ${e}`);
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new ao({ accounts: e.accounts.map(Aa.from_obj_for_encoding), apps: e.apps.map(An.from_obj_for_encoding), latestTimestamp: e["latest-timestamp"], protocolVersion: e["protocol-version"], round: e.round, sources: e.sources.map(Ta.from_obj_for_encoding), txns: e.txns });
  }
}, jc = class extends Ie {
  constructor({ error: e, protocolVersion: r, txns: i }) {
    super(), this.error = e, this.protocolVersion = r, this.txns = i, this.attribute_map = { error: "error", protocolVersion: "protocol-version", txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.error > "u")
      throw new Error(`Response is missing required field 'error': ${e}`);
    if (typeof e["protocol-version"] > "u")
      throw new Error(`Response is missing required field 'protocol-version': ${e}`);
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new jc({ error: e.error, protocolVersion: e["protocol-version"], txns: e.txns.map(Fa.from_obj_for_encoding) });
  }
}, Ta = class extends Ie {
  constructor({ fieldName: e, source: r, txnIndex: i, appIndex: n }) {
    super(), this.fieldName = e, this.source = r, this.txnIndex = i, this.appIndex = n, this.attribute_map = { fieldName: "field-name", source: "source", txnIndex: "txn-index", appIndex: "app-index" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["field-name"] > "u")
      throw new Error(`Response is missing required field 'field-name': ${e}`);
    if (typeof e.source > "u")
      throw new Error(`Response is missing required field 'source': ${e}`);
    if (typeof e["txn-index"] > "u")
      throw new Error(`Response is missing required field 'txn-index': ${e}`);
    if (typeof e["app-index"] > "u")
      throw new Error(`Response is missing required field 'app-index': ${e}`);
    return new Ta({ fieldName: e["field-name"], source: e.source, txnIndex: e["txn-index"], appIndex: e["app-index"] });
  }
}, fo = class extends Ie {
  constructor({ line: e, pc: r, stack: i, error: n, scratch: s2 }) {
    super(), this.line = e, this.pc = r, this.stack = i, this.error = n, this.scratch = s2, this.attribute_map = { line: "line", pc: "pc", stack: "stack", error: "error", scratch: "scratch" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.line > "u")
      throw new Error(`Response is missing required field 'line': ${e}`);
    if (typeof e.pc > "u")
      throw new Error(`Response is missing required field 'pc': ${e}`);
    if (!Array.isArray(e.stack))
      throw new Error(`Response is missing required array field 'stack': ${e}`);
    return new fo({ line: e.line, pc: e.pc, stack: e.stack.map(ts.from_obj_for_encoding), error: e.error, scratch: typeof e.scratch < "u" ? e.scratch.map(ts.from_obj_for_encoding) : void 0 });
  }
}, Fa = class extends Ie {
  constructor({ disassembly: e, appCallMessages: r, appCallTrace: i, budgetAdded: n, budgetConsumed: s2, globalDelta: o, localDeltas: f, logicSigDisassembly: l, logicSigMessages: m3, logicSigTrace: A2, logs: F3 }) {
    super(), this.disassembly = e, this.appCallMessages = r, this.appCallTrace = i, this.budgetAdded = n, this.budgetConsumed = s2, this.globalDelta = o, this.localDeltas = f, this.logicSigDisassembly = l, this.logicSigMessages = m3, this.logicSigTrace = A2, this.logs = F3, this.attribute_map = { disassembly: "disassembly", appCallMessages: "app-call-messages", appCallTrace: "app-call-trace", budgetAdded: "budget-added", budgetConsumed: "budget-consumed", globalDelta: "global-delta", localDeltas: "local-deltas", logicSigDisassembly: "logic-sig-disassembly", logicSigMessages: "logic-sig-messages", logicSigTrace: "logic-sig-trace", logs: "logs" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.disassembly))
      throw new Error(`Response is missing required array field 'disassembly': ${e}`);
    return new Fa({ disassembly: e.disassembly, appCallMessages: e["app-call-messages"], appCallTrace: typeof e["app-call-trace"] < "u" ? e["app-call-trace"].map(fo.from_obj_for_encoding) : void 0, budgetAdded: e["budget-added"], budgetConsumed: e["budget-consumed"], globalDelta: typeof e["global-delta"] < "u" ? e["global-delta"].map(es.from_obj_for_encoding) : void 0, localDeltas: typeof e["local-deltas"] < "u" ? e["local-deltas"].map(to.from_obj_for_encoding) : void 0, logicSigDisassembly: e["logic-sig-disassembly"], logicSigMessages: e["logic-sig-messages"], logicSigTrace: typeof e["logic-sig-trace"] < "u" ? e["logic-sig-trace"].map(fo.from_obj_for_encoding) : void 0, logs: e.logs });
  }
}, Lc = class extends Ie {
  constructor({ message: e, data: r }) {
    super(), this.message = e, this.data = r, this.attribute_map = { message: "message", data: "data" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.message > "u")
      throw new Error(`Response is missing required field 'message': ${e}`);
    return new Lc({ message: e.message, data: e.data });
  }
}, Ra = class extends Ie {
  constructor({ action: e, bytes: r, uint: i }) {
    super(), this.action = e, this.bytes = r, this.uint = i, this.attribute_map = { action: "action", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.action > "u")
      throw new Error(`Response is missing required field 'action': ${e}`);
    return new Ra({ action: e.action, bytes: e.bytes, uint: e.uint });
  }
}, es = class extends Ie {
  constructor({ key: e, value: r }) {
    super(), this.key = e, this.value = r, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new es({ key: e.key, value: Ra.from_obj_for_encoding(e.value) });
  }
}, co = class extends Ie {
  constructor({ offset: e }) {
    super(), this.offset = e, this.attribute_map = { offset: "offset" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.offset > "u")
      throw new Error(`Response is missing required field 'offset': ${e}`);
    return new co({ offset: e.offset });
  }
}, uo = class extends Ie {
  constructor({ round: e }) {
    super(), this.round = e, this.attribute_map = { round: "round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    return new uo({ round: e.round });
  }
}, qc = class extends Ie {
  constructor({ key: e, value: r }) {
    super(), this.key = typeof e == "string" ? new Uint8Array(rr.Buffer.from(e, "base64")) : e, this.value = typeof r == "string" ? new Uint8Array(rr.Buffer.from(r, "base64")) : r, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    return new qc({ key: e.key, value: e.value });
  }
}, ka = class extends Ie {
  constructor({ delta: e, ids: r }) {
    super(), this.delta = e, this.ids = r, this.attribute_map = { delta: "delta", ids: "ids" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.delta > "u")
      throw new Error(`Response is missing required field 'delta': ${e}`);
    if (!Array.isArray(e.ids))
      throw new Error(`Response is missing required array field 'ids': ${e}`);
    return new ka({ delta: e.delta, ids: e.ids });
  }
}, Pc = class extends Ie {
  constructor({ index: e, proof: r, treedepth: i }) {
    super(), this.index = e, this.proof = typeof r == "string" ? new Uint8Array(rr.Buffer.from(r, "base64")) : r, this.treedepth = i, this.attribute_map = { index: "index", proof: "proof", treedepth: "treedepth" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index > "u")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.proof > "u")
      throw new Error(`Response is missing required field 'proof': ${e}`);
    if (typeof e.treedepth > "u")
      throw new Error(`Response is missing required field 'treedepth': ${e}`);
    return new Pc({ index: e.index, proof: e.proof, treedepth: e.treedepth });
  }
}, Uc = class extends Ie {
  constructor({ catchupTime: e, lastRound: r, lastVersion: i, nextVersion: n, nextVersionRound: s2, nextVersionSupported: o, stoppedAtUnsupportedRound: f, timeSinceLastRound: l, catchpoint: m3, catchpointAcquiredBlocks: A2, catchpointProcessedAccounts: F3, catchpointProcessedKvs: z3, catchpointTotalAccounts: V, catchpointTotalBlocks: $, catchpointTotalKvs: re, catchpointVerifiedAccounts: W2, catchpointVerifiedKvs: Z2, lastCatchpoint: ue, upgradeDelay: ge, upgradeNextProtocolVoteBefore: Se, upgradeNoVotes: pe2, upgradeNodeVote: H2, upgradeVoteRounds: le, upgradeVotes: ie, upgradeVotesRequired: se, upgradeYesVotes: N3 }) {
    super(), this.catchupTime = e, this.lastRound = r, this.lastVersion = i, this.nextVersion = n, this.nextVersionRound = s2, this.nextVersionSupported = o, this.stoppedAtUnsupportedRound = f, this.timeSinceLastRound = l, this.catchpoint = m3, this.catchpointAcquiredBlocks = A2, this.catchpointProcessedAccounts = F3, this.catchpointProcessedKvs = z3, this.catchpointTotalAccounts = V, this.catchpointTotalBlocks = $, this.catchpointTotalKvs = re, this.catchpointVerifiedAccounts = W2, this.catchpointVerifiedKvs = Z2, this.lastCatchpoint = ue, this.upgradeDelay = ge, this.upgradeNextProtocolVoteBefore = Se, this.upgradeNoVotes = pe2, this.upgradeNodeVote = H2, this.upgradeVoteRounds = le, this.upgradeVotes = ie, this.upgradeVotesRequired = se, this.upgradeYesVotes = N3, this.attribute_map = { catchupTime: "catchup-time", lastRound: "last-round", lastVersion: "last-version", nextVersion: "next-version", nextVersionRound: "next-version-round", nextVersionSupported: "next-version-supported", stoppedAtUnsupportedRound: "stopped-at-unsupported-round", timeSinceLastRound: "time-since-last-round", catchpoint: "catchpoint", catchpointAcquiredBlocks: "catchpoint-acquired-blocks", catchpointProcessedAccounts: "catchpoint-processed-accounts", catchpointProcessedKvs: "catchpoint-processed-kvs", catchpointTotalAccounts: "catchpoint-total-accounts", catchpointTotalBlocks: "catchpoint-total-blocks", catchpointTotalKvs: "catchpoint-total-kvs", catchpointVerifiedAccounts: "catchpoint-verified-accounts", catchpointVerifiedKvs: "catchpoint-verified-kvs", lastCatchpoint: "last-catchpoint", upgradeDelay: "upgrade-delay", upgradeNextProtocolVoteBefore: "upgrade-next-protocol-vote-before", upgradeNoVotes: "upgrade-no-votes", upgradeNodeVote: "upgrade-node-vote", upgradeVoteRounds: "upgrade-vote-rounds", upgradeVotes: "upgrade-votes", upgradeVotesRequired: "upgrade-votes-required", upgradeYesVotes: "upgrade-yes-votes" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["catchup-time"] > "u")
      throw new Error(`Response is missing required field 'catchup-time': ${e}`);
    if (typeof e["last-round"] > "u")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (typeof e["last-version"] > "u")
      throw new Error(`Response is missing required field 'last-version': ${e}`);
    if (typeof e["next-version"] > "u")
      throw new Error(`Response is missing required field 'next-version': ${e}`);
    if (typeof e["next-version-round"] > "u")
      throw new Error(`Response is missing required field 'next-version-round': ${e}`);
    if (typeof e["next-version-supported"] > "u")
      throw new Error(`Response is missing required field 'next-version-supported': ${e}`);
    if (typeof e["stopped-at-unsupported-round"] > "u")
      throw new Error(`Response is missing required field 'stopped-at-unsupported-round': ${e}`);
    if (typeof e["time-since-last-round"] > "u")
      throw new Error(`Response is missing required field 'time-since-last-round': ${e}`);
    return new Uc({ catchupTime: e["catchup-time"], lastRound: e["last-round"], lastVersion: e["last-version"], nextVersion: e["next-version"], nextVersionRound: e["next-version-round"], nextVersionSupported: e["next-version-supported"], stoppedAtUnsupportedRound: e["stopped-at-unsupported-round"], timeSinceLastRound: e["time-since-last-round"], catchpoint: e.catchpoint, catchpointAcquiredBlocks: e["catchpoint-acquired-blocks"], catchpointProcessedAccounts: e["catchpoint-processed-accounts"], catchpointProcessedKvs: e["catchpoint-processed-kvs"], catchpointTotalAccounts: e["catchpoint-total-accounts"], catchpointTotalBlocks: e["catchpoint-total-blocks"], catchpointTotalKvs: e["catchpoint-total-kvs"], catchpointVerifiedAccounts: e["catchpoint-verified-accounts"], catchpointVerifiedKvs: e["catchpoint-verified-kvs"], lastCatchpoint: e["last-catchpoint"], upgradeDelay: e["upgrade-delay"], upgradeNextProtocolVoteBefore: e["upgrade-next-protocol-vote-before"], upgradeNoVotes: e["upgrade-no-votes"], upgradeNodeVote: e["upgrade-node-vote"], upgradeVoteRounds: e["upgrade-vote-rounds"], upgradeVotes: e["upgrade-votes"], upgradeVotesRequired: e["upgrade-votes-required"], upgradeYesVotes: e["upgrade-yes-votes"] });
  }
}, lo = class extends Ie {
  constructor({ poolError: e, txn: r, applicationIndex: i, assetClosingAmount: n, assetIndex: s2, closeRewards: o, closingAmount: f, confirmedRound: l, globalStateDelta: m3, innerTxns: A2, localStateDelta: F3, logs: z3, receiverRewards: V, senderRewards: $ }) {
    super(), this.poolError = e, this.txn = r, this.applicationIndex = i, this.assetClosingAmount = n, this.assetIndex = s2, this.closeRewards = o, this.closingAmount = f, this.confirmedRound = l, this.globalStateDelta = m3, this.innerTxns = A2, this.localStateDelta = F3, this.logs = z3, this.receiverRewards = V, this.senderRewards = $, this.attribute_map = { poolError: "pool-error", txn: "txn", applicationIndex: "application-index", assetClosingAmount: "asset-closing-amount", assetIndex: "asset-index", closeRewards: "close-rewards", closingAmount: "closing-amount", confirmedRound: "confirmed-round", globalStateDelta: "global-state-delta", innerTxns: "inner-txns", localStateDelta: "local-state-delta", logs: "logs", receiverRewards: "receiver-rewards", senderRewards: "sender-rewards" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["pool-error"] > "u")
      throw new Error(`Response is missing required field 'pool-error': ${e}`);
    if (typeof e.txn > "u")
      throw new Error(`Response is missing required field 'txn': ${e}`);
    return new lo({ poolError: e["pool-error"], txn: e.txn, applicationIndex: e["application-index"], assetClosingAmount: e["asset-closing-amount"], assetIndex: e["asset-index"], closeRewards: e["close-rewards"], closingAmount: e["closing-amount"], confirmedRound: e["confirmed-round"], globalStateDelta: typeof e["global-state-delta"] < "u" ? e["global-state-delta"].map(es.from_obj_for_encoding) : void 0, innerTxns: typeof e["inner-txns"] < "u" ? e["inner-txns"].map(lo.from_obj_for_encoding) : void 0, localStateDelta: typeof e["local-state-delta"] < "u" ? e["local-state-delta"].map(to.from_obj_for_encoding) : void 0, logs: e.logs, receiverRewards: e["receiver-rewards"], senderRewards: e["sender-rewards"] });
  }
}, zc = class extends Ie {
  constructor({ topTransactions: e, totalTransactions: r }) {
    super(), this.topTransactions = e, this.totalTransactions = r, this.attribute_map = { topTransactions: "top-transactions", totalTransactions: "total-transactions" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["top-transactions"]))
      throw new Error(`Response is missing required array field 'top-transactions': ${e}`);
    if (typeof e["total-transactions"] > "u")
      throw new Error(`Response is missing required field 'total-transactions': ${e}`);
    return new zc({ topTransactions: e["top-transactions"], totalTransactions: e["total-transactions"] });
  }
}, Hc = class extends Ie {
  constructor({ txid: e }) {
    super(), this.txid = e, this.attribute_map = { txid: "txId" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.txId > "u")
      throw new Error(`Response is missing required field 'txId': ${e}`);
    return new Hc({ txid: e.txId });
  }
}, Sn = class extends Ie {
  constructor({ txnGroups: e, allowEmptySignatures: r, allowMoreLogging: i, extraOpcodeBudget: n }) {
    super(), this.txnGroups = e, this.allowEmptySignatures = r, this.allowMoreLogging = i, this.extraOpcodeBudget = n, this.attribute_map = { txnGroups: "txn-groups", allowEmptySignatures: "allow-empty-signatures", allowMoreLogging: "allow-more-logging", extraOpcodeBudget: "extra-opcode-budget" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["txn-groups"]))
      throw new Error(`Response is missing required array field 'txn-groups': ${e}`);
    return new Sn({ txnGroups: e["txn-groups"].map(Ji.from_obj_for_encoding), allowEmptySignatures: e["allow-empty-signatures"], allowMoreLogging: e["allow-more-logging"], extraOpcodeBudget: e["extra-opcode-budget"] });
  }
}, Ji = class extends Ie {
  constructor({ txns: e }) {
    super(), this.txns = e, this.attribute_map = { txns: "txns" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.txns))
      throw new Error(`Response is missing required array field 'txns': ${e}`);
    return new Ji({ txns: e.txns });
  }
}, ho = class extends Ie {
  constructor({ lastRound: e, txnGroups: r, version: i, evalOverrides: n }) {
    super(), this.lastRound = e, this.txnGroups = r, this.version = i, this.evalOverrides = n, this.attribute_map = { lastRound: "last-round", txnGroups: "txn-groups", version: "version", evalOverrides: "eval-overrides" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["last-round"] > "u")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (!Array.isArray(e["txn-groups"]))
      throw new Error(`Response is missing required array field 'txn-groups': ${e}`);
    if (typeof e.version > "u")
      throw new Error(`Response is missing required field 'version': ${e}`);
    return new ho({ lastRound: e["last-round"], txnGroups: e["txn-groups"].map(Da.from_obj_for_encoding), version: e.version, evalOverrides: typeof e["eval-overrides"] < "u" ? Na.from_obj_for_encoding(e["eval-overrides"]) : void 0 });
  }
}, Da = class extends Ie {
  constructor({ txnResults: e, appBudgetAdded: r, appBudgetConsumed: i, failedAt: n, failureMessage: s2 }) {
    super(), this.txnResults = e, this.appBudgetAdded = r, this.appBudgetConsumed = i, this.failedAt = n, this.failureMessage = s2, this.attribute_map = { txnResults: "txn-results", appBudgetAdded: "app-budget-added", appBudgetConsumed: "app-budget-consumed", failedAt: "failed-at", failureMessage: "failure-message" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["txn-results"]))
      throw new Error(`Response is missing required array field 'txn-results': ${e}`);
    return new Da({ txnResults: e["txn-results"].map(Ba.from_obj_for_encoding), appBudgetAdded: e["app-budget-added"], appBudgetConsumed: e["app-budget-consumed"], failedAt: e["failed-at"], failureMessage: e["failure-message"] });
  }
}, Ba = class extends Ie {
  constructor({ txnResult: e, appBudgetConsumed: r, logicSigBudgetConsumed: i }) {
    super(), this.txnResult = e, this.appBudgetConsumed = r, this.logicSigBudgetConsumed = i, this.attribute_map = { txnResult: "txn-result", appBudgetConsumed: "app-budget-consumed", logicSigBudgetConsumed: "logic-sig-budget-consumed" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["txn-result"] > "u")
      throw new Error(`Response is missing required field 'txn-result': ${e}`);
    return new Ba({ txnResult: lo.from_obj_for_encoding(e["txn-result"]), appBudgetConsumed: e["app-budget-consumed"], logicSigBudgetConsumed: e["logic-sig-budget-consumed"] });
  }
}, Na = class extends Ie {
  constructor({ allowEmptySignatures: e, extraOpcodeBudget: r, maxLogCalls: i, maxLogSize: n }) {
    super(), this.allowEmptySignatures = e, this.extraOpcodeBudget = r, this.maxLogCalls = i, this.maxLogSize = n, this.attribute_map = { allowEmptySignatures: "allow-empty-signatures", extraOpcodeBudget: "extra-opcode-budget", maxLogCalls: "max-log-calls", maxLogSize: "max-log-size" };
  }
  static from_obj_for_encoding(e) {
    return new Na({ allowEmptySignatures: e["allow-empty-signatures"], extraOpcodeBudget: e["extra-opcode-budget"], maxLogCalls: e["max-log-calls"], maxLogSize: e["max-log-size"] });
  }
}, $c = class extends Ie {
  constructor({ message: e, stateproof: r }) {
    super(), this.message = e, this.stateproof = typeof r == "string" ? new Uint8Array(rr.Buffer.from(r, "base64")) : r, this.attribute_map = { message: "Message", stateproof: "StateProof" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.Message > "u")
      throw new Error(`Response is missing required field 'Message': ${e}`);
    if (typeof e.StateProof > "u")
      throw new Error(`Response is missing required field 'StateProof': ${e}`);
    return new $c({ message: Ca.from_obj_for_encoding(e.Message), stateproof: e.StateProof });
  }
}, Ca = class extends Ie {
  constructor({ blockheaderscommitment: e, firstattestedround: r, lastattestedround: i, lnprovenweight: n, voterscommitment: s2 }) {
    super(), this.blockheaderscommitment = typeof e == "string" ? new Uint8Array(rr.Buffer.from(e, "base64")) : e, this.firstattestedround = r, this.lastattestedround = i, this.lnprovenweight = n, this.voterscommitment = typeof s2 == "string" ? new Uint8Array(rr.Buffer.from(s2, "base64")) : s2, this.attribute_map = { blockheaderscommitment: "BlockHeadersCommitment", firstattestedround: "FirstAttestedRound", lastattestedround: "LastAttestedRound", lnprovenweight: "LnProvenWeight", voterscommitment: "VotersCommitment" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.BlockHeadersCommitment > "u")
      throw new Error(`Response is missing required field 'BlockHeadersCommitment': ${e}`);
    if (typeof e.FirstAttestedRound > "u")
      throw new Error(`Response is missing required field 'FirstAttestedRound': ${e}`);
    if (typeof e.LastAttestedRound > "u")
      throw new Error(`Response is missing required field 'LastAttestedRound': ${e}`);
    if (typeof e.LnProvenWeight > "u")
      throw new Error(`Response is missing required field 'LnProvenWeight': ${e}`);
    if (typeof e.VotersCommitment > "u")
      throw new Error(`Response is missing required field 'VotersCommitment': ${e}`);
    return new Ca({ blockheaderscommitment: e.BlockHeadersCommitment, firstattestedround: e.FirstAttestedRound, lastattestedround: e.LastAttestedRound, lnprovenweight: e.LnProvenWeight, voterscommitment: e.VotersCommitment });
  }
}, Gc = class extends Ie {
  constructor({ currentRound: e, onlineMoney: r, totalMoney: i }) {
    super(), this.currentRound = e, this.onlineMoney = r, this.totalMoney = i, this.attribute_map = { currentRound: "current_round", onlineMoney: "online-money", totalMoney: "total-money" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.current_round > "u")
      throw new Error(`Response is missing required field 'current_round': ${e}`);
    if (typeof e["online-money"] > "u")
      throw new Error(`Response is missing required field 'online-money': ${e}`);
    if (typeof e["total-money"] > "u")
      throw new Error(`Response is missing required field 'total-money': ${e}`);
    return new Gc({ currentRound: e.current_round, onlineMoney: e["online-money"], totalMoney: e["total-money"] });
  }
}, po = class extends Ie {
  constructor({ key: e, value: r }) {
    super(), this.key = e, this.value = r, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new po({ key: e.key, value: ts.from_obj_for_encoding(e.value) });
  }
}, ts = class extends Ie {
  constructor({ type: e, bytes: r, uint: i }) {
    super(), this.type = e, this.bytes = r, this.uint = i, this.attribute_map = { type: "type", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.type > "u")
      throw new Error(`Response is missing required field 'type': ${e}`);
    if (typeof e.bytes > "u")
      throw new Error(`Response is missing required field 'bytes': ${e}`);
    if (typeof e.uint > "u")
      throw new Error(`Response is missing required field 'uint': ${e}`);
    return new ts({ type: e.type, bytes: e.bytes, uint: e.uint });
  }
}, go = class extends Ie {
  constructor({ deltas: e }) {
    super(), this.deltas = e, this.attribute_map = { deltas: "deltas" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.Deltas))
      throw new Error(`Response is missing required array field 'Deltas': ${e}`);
    return new go({ deltas: e.Deltas.map(ka.from_obj_for_encoding) });
  }
}, Kc = class extends Ie {
  constructor({ consensusVersion: e, fee: r, genesisHash: i, genesisId: n, lastRound: s2, minFee: o }) {
    super(), this.consensusVersion = e, this.fee = r, this.genesisHash = typeof i == "string" ? new Uint8Array(rr.Buffer.from(i, "base64")) : i, this.genesisId = n, this.lastRound = s2, this.minFee = o, this.attribute_map = { consensusVersion: "consensus-version", fee: "fee", genesisHash: "genesis-hash", genesisId: "genesis-id", lastRound: "last-round", minFee: "min-fee" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["consensus-version"] > "u")
      throw new Error(`Response is missing required field 'consensus-version': ${e}`);
    if (typeof e.fee > "u")
      throw new Error(`Response is missing required field 'fee': ${e}`);
    if (typeof e["genesis-hash"] > "u")
      throw new Error(`Response is missing required field 'genesis-hash': ${e}`);
    if (typeof e["genesis-id"] > "u")
      throw new Error(`Response is missing required field 'genesis-id': ${e}`);
    if (typeof e["last-round"] > "u")
      throw new Error(`Response is missing required field 'last-round': ${e}`);
    if (typeof e["min-fee"] > "u")
      throw new Error(`Response is missing required field 'min-fee': ${e}`);
    return new Kc({ consensusVersion: e["consensus-version"], fee: e.fee, genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], lastRound: e["last-round"], minFee: e["min-fee"] });
  }
}, Wc = class extends Ie {
  constructor({ idx: e, proof: r, stibhash: i, treedepth: n, hashtype: s2 }) {
    super(), this.idx = e, this.proof = typeof r == "string" ? new Uint8Array(rr.Buffer.from(r, "base64")) : r, this.stibhash = typeof i == "string" ? new Uint8Array(rr.Buffer.from(i, "base64")) : i, this.treedepth = n, this.hashtype = s2, this.attribute_map = { idx: "idx", proof: "proof", stibhash: "stibhash", treedepth: "treedepth", hashtype: "hashtype" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.idx > "u")
      throw new Error(`Response is missing required field 'idx': ${e}`);
    if (typeof e.proof > "u")
      throw new Error(`Response is missing required field 'proof': ${e}`);
    if (typeof e.stibhash > "u")
      throw new Error(`Response is missing required field 'stibhash': ${e}`);
    if (typeof e.treedepth > "u")
      throw new Error(`Response is missing required field 'treedepth': ${e}`);
    return new Wc({ idx: e.idx, proof: e.proof, stibhash: e.stibhash, treedepth: e.treedepth, hashtype: e.hashtype });
  }
}, Vc = class extends Ie {
  constructor({ build: e, genesisHashB64: r, genesisId: i, versions: n }) {
    super(), this.build = e, this.genesisHashB64 = typeof r == "string" ? new Uint8Array(rr.Buffer.from(r, "base64")) : r, this.genesisId = i, this.versions = n, this.attribute_map = { build: "build", genesisHashB64: "genesis_hash_b64", genesisId: "genesis_id", versions: "versions" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.build > "u")
      throw new Error(`Response is missing required field 'build': ${e}`);
    if (typeof e.genesis_hash_b64 > "u")
      throw new Error(`Response is missing required field 'genesis_hash_b64': ${e}`);
    if (typeof e.genesis_id > "u")
      throw new Error(`Response is missing required field 'genesis_id': ${e}`);
    if (!Array.isArray(e.versions))
      throw new Error(`Response is missing required array field 'versions': ${e}`);
    return new Vc({ build: Ia.from_obj_for_encoding(e.build), genesisHashB64: e.genesis_hash_b64, genesisId: e.genesis_id, versions: e.versions });
  }
};
U();
U();
var Re = class {
  constructor(e, r) {
    this.c = e, this.query = {}, this.intDecoding = r || Yn.DEFAULT;
  }
  prepare(e) {
    return e;
  }
  async do(e = {}) {
    let r = {};
    this.intDecoding !== "default" && (r.intDecoding = this.intDecoding);
    let i = await this.c.get(this.path(), this.query, e, r);
    return this.prepare(i.body);
  }
  async doRaw(e = {}) {
    return (await this.c.get(this.path(), this.query, e, {}, false)).body;
  }
  setIntDecoding(e) {
    if (e !== "default" && e !== "safe" && e !== "mixed" && e !== "bigint")
      throw new Error(`Invalid method for int decoding: ${e}`);
    return this.intDecoding = e, this;
  }
};
var Yc = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
U();
var Jc = class extends Re {
  constructor(e, r, i, n) {
    super(e, r), this.account = i, this.assetID = n, this.account = i, this.assetID = n;
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
};
U();
var Zc = class extends Re {
  constructor(e, r, i, n) {
    super(e, r), this.account = i, this.applicationID = n, this.account = i, this.applicationID = n;
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
};
U();
var Xc = class extends Re {
  constructor(e, r) {
    if (super(e), !Number.isInteger(r))
      throw Error("roundNumber should be an integer");
    this.round = r, this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return Kt(e);
  }
};
U();
var b4 = rr$1(or());
function Bg(t = {}) {
  let e = t;
  return Object.keys(e).every((r) => r.toLowerCase() !== "content-type") && (e = { ...t }, e["Content-Type"] = "text/plain"), e;
}
var Qc = class extends Re {
  constructor(e, r) {
    super(e), this.source = r, this.source = r;
  }
  path() {
    return "/v2/teal/compile";
  }
  sourcemap(e = true) {
    return this.query.sourcemap = e, this;
  }
  async do(e = {}) {
    let r = Bg(e);
    return (await this.c.post(this.path(), b4.Buffer.from(this.source), r, this.query)).body;
  }
};
U();
var v4 = rr$1(or());
var eu = class extends Re {
  constructor(e, r) {
    super(e), this.blob = tr(r.get_obj_for_encoding(true));
  }
  path() {
    return "/v2/teal/dryrun";
  }
  async do(e = {}) {
    let r = Bg(e);
    return (await this.c.post(this.path(), v4.Buffer.from(this.blob), r)).body;
  }
};
U();
var tu = class extends Re {
  path() {
    return "/genesis";
  }
};
U();
var ru = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
};
U();
var iu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
};
U();
var nu = class extends Re {
  constructor(e, r, i) {
    if (super(e, r), !Number.isInteger(i))
      throw Error("roundNumber should be an integer");
    this.round = i;
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
};
U();
var w4 = rr$1(or());
var su = class extends Re {
  constructor(e, r, i, n) {
    super(e, r), this.index = i, this.index = i;
    let s2 = w4.Buffer.from(n).toString("base64");
    this.query.name = encodeURI(`b64:${s2}`);
  }
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  prepare(e) {
    return so.from_obj_for_encoding(e);
  }
};
U();
var ou = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i, this.query.max = 0;
  }
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  max(e) {
    return this.query.max = e, this;
  }
  prepare(e) {
    return oo.from_obj_for_encoding(e);
  }
};
U();
var au = class extends Re {
  path() {
    return "/health";
  }
  async do(e = {}) {
    let r = await this.c.get(this.path(), {}, e);
    if (!r.ok)
      throw new Error(`Health response: ${r.status}`);
    return {};
  }
};
U();
var fu = class extends Re {
  constructor(e, r) {
    super(e), this.txid = r, this.txid = r, this.query.format = "msgpack";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return Kt(e);
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  max(e) {
    return this.query.max = e, this;
  }
};
U();
var cu = class extends Re {
  constructor(e) {
    super(e), this.query.format = "msgpack";
  }
  path() {
    return "/v2/transactions/pending";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return Kt(e);
  }
  max(e) {
    return this.query.max = e, this;
  }
};
U();
var uu = class extends Re {
  constructor(e, r) {
    super(e), this.address = r, this.address = r, this.query.format = "msgpack";
  }
  prepare(e) {
    if (e && e.byteLength > 0)
      return Kt(e);
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  max(e) {
    return this.query.max = e, this;
  }
};
U();
var du = class extends Re {
  constructor(e, r, i, n) {
    super(e, r), this.round = i, this.txID = n, this.round = i, this.txID = n;
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  hashType(e) {
    return this.query.hashtype = e, this;
  }
};
U();
var _4 = rr$1(or());
function tR(t = {}) {
  let e = t;
  return Object.keys(e).every((r) => r.toLowerCase() !== "content-type") && (e = { ...t }, e["Content-Type"] = "application/x-binary"), e;
}
function x4(t) {
  return t && t.byteLength !== void 0;
}
var lu = class extends Re {
  constructor(e, r) {
    super(e);
    let i = r;
    if (Array.isArray(r)) {
      if (!r.every(x4))
        throw new TypeError("Array elements must be byte arrays");
      i = Jt(...r);
    } else if (!x4(i))
      throw new TypeError("Argument must be byte array");
    this.txnBytesToPost = i;
  }
  path() {
    return "/v2/transactions";
  }
  async do(e = {}) {
    let r = tR(e);
    return (await this.c.post(this.path(), _4.Buffer.from(this.txnBytesToPost), r)).body;
  }
};
U();
var hu = class extends Re {
  path() {
    return "/v2/status";
  }
};
U();
var pu = class extends Re {
  constructor(e, r, i) {
    if (super(e, r), this.round = i, !Number.isInteger(i))
      throw Error("round should be an integer");
    this.round = i;
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
};
U();
var gu = class extends Re {
  path() {
    return "/v2/transactions/params";
  }
  prepare(e) {
    return { flatFee: false, fee: e.fee, firstRound: e["last-round"], lastRound: e["last-round"] + 1e3, genesisID: e["genesis-id"], genesisHash: e["genesis-hash"], minFee: e["min-fee"] };
  }
};
U();
var mu = class extends Re {
  path() {
    return "/v2/ledger/supply";
  }
};
U();
var yu = class extends Re {
  path() {
    return "/versions";
  }
};
U();
var bu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.round = i, this.round = i;
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
};
U();
var vu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.round = i, this.round = i;
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
};
U();
var wu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.round = i, this.round = i;
  }
  path() {
    return `/v2/ledger/sync/${this.round}`;
  }
  async do(e = {}) {
    return (await this.c.post(this.path(), e)).body;
  }
};
U();
var xu = class extends Re {
  path() {
    return "/v2/ledger/sync";
  }
  prepare(e) {
    return uo.from_obj_for_encoding(e);
  }
};
U();
var _u = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.offset = i, this.offset = i;
  }
  path() {
    return `/v2/devmode/blocks/offset/${this.offset}`;
  }
  async do(e = {}) {
    return (await this.c.post(this.path(), e)).body;
  }
};
U();
var Au = class extends Re {
  path() {
    return "/v2/devmode/blocks/offset";
  }
  prepare(e) {
    return co.from_obj_for_encoding(e);
  }
};
U();
var A4 = rr$1(or());
function rR(t = {}) {
  let e = t;
  return Object.keys(e).every((r) => r.toLowerCase() !== "content-type") && (e = { ...t }, e["Content-Type"] = "text/plain"), e;
}
var Eu = class extends Re {
  constructor(e, r) {
    super(e), this.source = r, this.source = r;
  }
  path() {
    return "/v2/teal/disassemble";
  }
  async do(e = {}) {
    let r = rR(e);
    return (await this.c.post(this.path(), A4.Buffer.from(this.source), r, this.query)).body;
  }
};
U();
var E4 = rr$1(or());
function iR(t = {}) {
  let e = t;
  return Object.keys(e).every((r) => r.toLowerCase() !== "content-type") && (e = { ...t }, e["Content-Type"] = "application/msgpack"), e;
}
var Su = class extends Re {
  constructor(e, r) {
    super(e), this.query.format = "msgpack", this.requestBytes = Ig(r.get_obj_for_encoding(true));
  }
  path() {
    return "/v2/transactions/simulate";
  }
  async do(e = {}) {
    let r = iR(e), i = await this.c.post(this.path(), E4.Buffer.from(this.requestBytes), r, this.query, false);
    return this.prepare(i.body);
  }
  prepare(e) {
    let r = Kt(e);
    return ho.from_obj_for_encoding(r);
  }
};
U();
var Mu = class extends Re {
  path() {
    return "/ready";
  }
};
U();
var Iu = class extends Re {
  path() {
    return "/v2/ledger/sync";
  }
  async do(e = {}) {
    return (await this.c.delete(this.path(), e)).body;
  }
};
U();
var Tu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.id = i, this.id = i;
  }
  path() {
    return `/v2/deltas/txn/group/${this.id}`;
  }
};
U();
var Fu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.round = i, this.round = i;
  }
  path() {
    return `/v2/deltas/${this.round}`;
  }
};
U();
var Ru = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.round = i, this.round = i;
  }
  path() {
    return `/v2/deltas/${this.round}/txn/group`;
  }
  prepare(e) {
    return go.from_obj_for_encoding(e);
  }
};
var mo = class extends _n {
  constructor(e, r, i, n = {}) {
    super("X-Algo-API-Token", e, r, i, n);
  }
  healthCheck() {
    return new au(this.c);
  }
  versionsCheck() {
    return new yu(this.c);
  }
  sendRawTransaction(e) {
    return new lu(this.c, e);
  }
  accountInformation(e) {
    return new Yc(this.c, this.intDecoding, e);
  }
  accountAssetInformation(e, r) {
    return new Jc(this.c, this.intDecoding, e, r);
  }
  accountApplicationInformation(e, r) {
    return new Zc(this.c, this.intDecoding, e, r);
  }
  block(e) {
    return new Xc(this.c, e);
  }
  getBlockHash(e) {
    return new nu(this.c, this.intDecoding, e);
  }
  pendingTransactionInformation(e) {
    return new fu(this.c, e);
  }
  pendingTransactionsInformation() {
    return new cu(this.c);
  }
  pendingTransactionByAddress(e) {
    return new uu(this.c, e);
  }
  status() {
    return new hu(this.c, this.intDecoding);
  }
  statusAfterBlock(e) {
    return new pu(this.c, this.intDecoding, e);
  }
  getTransactionParams() {
    return new gu(this.c);
  }
  supply() {
    return new mu(this.c, this.intDecoding);
  }
  compile(e) {
    return new Qc(this.c, e);
  }
  disassemble(e) {
    return new Eu(this.c, e);
  }
  dryrun(e) {
    return new eu(this.c, e);
  }
  getAssetByID(e) {
    return new ru(this.c, this.intDecoding, e);
  }
  getApplicationByID(e) {
    return new iu(this.c, this.intDecoding, e);
  }
  getApplicationBoxByName(e, r) {
    return new su(this.c, this.intDecoding, e, r);
  }
  getApplicationBoxes(e) {
    return new ou(this.c, this.intDecoding, e);
  }
  genesis() {
    return new tu(this.c, this.intDecoding);
  }
  getTransactionProof(e, r) {
    return new du(this.c, this.intDecoding, e, r);
  }
  getLightBlockHeaderProof(e) {
    return new bu(this.c, this.intDecoding, e);
  }
  getStateProof(e) {
    return new vu(this.c, this.intDecoding, e);
  }
  simulateRawTransactions(e) {
    let r = [];
    if (Array.isArray(e))
      for (let n of e)
        r.push(Kt(n));
    else
      r.push(Kt(e));
    let i = new Sn({ txnGroups: [new Ji({ txns: r })] });
    return this.simulateTransactions(i);
  }
  simulateTransactions(e) {
    return new Su(this.c, e);
  }
  setBlockOffsetTimestamp(e) {
    return new _u(this.c, this.intDecoding, e);
  }
  getBlockOffsetTimestamp() {
    return new Au(this.c, this.intDecoding);
  }
  setSyncRound(e) {
    return new wu(this.c, this.intDecoding, e);
  }
  unsetSyncRound() {
    return new Iu(this.c, this.intDecoding);
  }
  getSyncRound() {
    return new xu(this.c, this.intDecoding);
  }
  ready() {
    return new Mu(this.c, this.intDecoding);
  }
  getLedgerStateDeltaForTransactionGroup(e) {
    return new Tu(this.c, this.intDecoding, e);
  }
  getLedgerStateDelta(e) {
    return new Fu(this.c, this.intDecoding, e);
  }
  getTransactionGroupLedgerStateDeltasForRound(e) {
    return new Ru(this.c, this.intDecoding, e);
  }
};
U();
var gi = rr$1(or());
var ku = class extends _n {
  constructor(e, r = "http://127.0.0.1", i = 7833, n = {}) {
    super("X-KMD-API-Token", e, r, i, n);
  }
  async versions() {
    return (await this.c.get("/versions")).body;
  }
  async listWallets() {
    return (await this.c.get("/v1/wallets")).body;
  }
  async createWallet(e, r, i = new Uint8Array(), n = "sqlite") {
    let s2 = { wallet_name: e, wallet_driver_name: n, wallet_password: r, master_derivation_key: gi.Buffer.from(i).toString("base64") };
    return (await this.c.post("/v1/wallet", s2)).body;
  }
  async initWalletHandle(e, r) {
    let i = { wallet_id: e, wallet_password: r };
    return (await this.c.post("/v1/wallet/init", i)).body;
  }
  async releaseWalletHandle(e) {
    let r = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/release", r)).body;
  }
  async renewWalletHandle(e) {
    let r = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/renew", r)).body;
  }
  async renameWallet(e, r, i) {
    let n = { wallet_id: e, wallet_password: r, wallet_name: i };
    return (await this.c.post("/v1/wallet/rename", n)).body;
  }
  async getWallet(e) {
    let r = { wallet_handle_token: e };
    return (await this.c.post("/v1/wallet/info", r)).body;
  }
  async exportMasterDerivationKey(e, r) {
    let i = { wallet_handle_token: e, wallet_password: r }, n = await this.c.post("/v1/master-key/export", i);
    return { master_derivation_key: gi.Buffer.from(n.body.master_derivation_key, "base64") };
  }
  async importKey(e, r) {
    let i = { wallet_handle_token: e, private_key: gi.Buffer.from(r).toString("base64") };
    return (await this.c.post("/v1/key/import", i)).body;
  }
  async exportKey(e, r, i) {
    let n = { wallet_handle_token: e, address: i, wallet_password: r }, s2 = await this.c.post("/v1/key/export", n);
    return { private_key: gi.Buffer.from(s2.body.private_key, "base64") };
  }
  async generateKey(e) {
    let r = { wallet_handle_token: e, display_mnemonic: false };
    return (await this.c.post("/v1/key", r)).body;
  }
  async deleteKey(e, r, i) {
    let n = { wallet_handle_token: e, address: i, wallet_password: r };
    return (await this.c.delete("/v1/key", n)).body;
  }
  async listKeys(e) {
    let r = { wallet_handle_token: e };
    return (await this.c.post("/v1/key/list", r)).body;
  }
  async signTransaction(e, r, i) {
    let n = hi(i), s2 = { wallet_handle_token: e, wallet_password: r, transaction: gi.Buffer.from(n.toByte()).toString("base64") }, o = await this.c.post("/v1/transaction/sign", s2);
    return o.status === 200 ? gi.Buffer.from(o.body.signed_transaction, "base64") : o.body;
  }
  async signTransactionWithSpecificPublicKey(e, r, i, n) {
    let s2 = hi(i), o = { wallet_handle_token: e, wallet_password: r, transaction: gi.Buffer.from(s2.toByte()).toString("base64"), public_key: gi.Buffer.from(n).toString("base64") }, f = await this.c.post("/v1/transaction/sign", o);
    return f.status === 200 ? gi.Buffer.from(f.body.signed_transaction, "base64") : f.body;
  }
  async listMultisig(e) {
    let r = { wallet_handle_token: e };
    return (await this.c.post("/v1/multisig/list", r)).body;
  }
  async importMultisig(e, r, i, n) {
    let s2 = { wallet_handle_token: e, multisig_version: r, threshold: i, pks: n };
    return (await this.c.post("/v1/multisig/import", s2)).body;
  }
  async exportMultisig(e, r) {
    let i = { wallet_handle_token: e, address: r };
    return (await this.c.post("/v1/multisig/export", i)).body;
  }
  async signMultisigTransaction(e, r, i, n, s2) {
    let o = hi(i), f = { wallet_handle_token: e, transaction: gi.Buffer.from(o.toByte()).toString("base64"), public_key: gi.Buffer.from(n).toString("base64"), partial_multisig: s2, wallet_password: r };
    return (await this.c.post("/v1/multisig/sign", f)).body;
  }
  async deleteMultisig(e, r, i) {
    let n = { wallet_handle_token: e, address: i, wallet_password: r };
    return (await this.c.delete("/v1/multisig", n)).body;
  }
};
U();
U();
var Du = class extends Re {
  path() {
    return "/health";
  }
};
U();
var Bu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
U();
var S4 = rr$1(or());
function Cu(t) {
  return typeof t == "string" ? t : S4.Buffer.from(t).toString("base64");
}
var Nu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  notePrefix(e) {
    return this.query["note-prefix"] = Cu(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
};
var Ou = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  notePrefix(e) {
    return this.query["note-prefix"] = Cu(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  addressRole(e) {
    return this.query["address-role"] = e, this;
  }
  address(e) {
    return this.query.address = e, this;
  }
  excludeCloseTo(e) {
    return this.query["exclude-close-to"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
};
U();
var ju = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.round = i, this.round = i;
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  headerOnly(e) {
    return this.query["header-only"] = e, this;
  }
};
U();
var Lu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.txID = i, this.txID = i;
  }
  path() {
    return `/v2/transactions/${this.txID}`;
  }
};
U();
var qu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  round(e) {
    return this.query.round = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
U();
var Pu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  assetId(e) {
    return this.query["asset-id"] = e, this;
  }
};
U();
var Uu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
};
U();
var zu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
U();
var Hu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.account = i, this.account = i;
  }
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
U();
var $u = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i;
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var Gu = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i;
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var Ku = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.appID = i, this.appID = i;
  }
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  sender(e) {
    return this.query["sender-address"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
};
U();
var M4 = rr$1(or());
var Ng = {};
ct(Ng, { Account: () => yo, AccountParticipation: () => Oa, AccountResponse: () => Wu, AccountStateDelta: () => ja, AccountsResponse: () => Vu, Application: () => rs, ApplicationLocalState: () => bo, ApplicationLocalStatesResponse: () => Yu, ApplicationLogData: () => La, ApplicationLogsResponse: () => Ju, ApplicationParams: () => qa, ApplicationResponse: () => Zu, ApplicationStateSchema: () => Mn, ApplicationsResponse: () => Xu, Asset: () => is, AssetBalancesResponse: () => Qu, AssetHolding: () => vo, AssetHoldingsResponse: () => ed, AssetParams: () => wo, AssetResponse: () => td, AssetsResponse: () => rd, Block: () => id, BlockRewards: () => Pa, BlockUpgradeState: () => Ua, BlockUpgradeVote: () => za, Box: () => xo, BoxDescriptor: () => Ha, BoxesResponse: () => _o, ErrorResponse: () => nd, EvalDelta: () => $a, EvalDeltaKeyValue: () => Ao, HashFactory: () => Ga, HealthCheck: () => sd, IndexerStateProofMessage: () => Ka, MerkleArrayProof: () => ns, MiniAssetHolding: () => Wa, ParticipationUpdates: () => Va, StateProofFields: () => Ya, StateProofParticipant: () => Ja, StateProofReveal: () => Za, StateProofSigSlot: () => Xa, StateProofSignature: () => Qa, StateProofTracking: () => ef, StateProofVerifier: () => tf, StateSchema: () => Eo, TealKeyValue: () => So, TealValue: () => rf, Transaction: () => In, TransactionApplication: () => nf, TransactionAssetConfig: () => sf, TransactionAssetFreeze: () => of, TransactionAssetTransfer: () => af, TransactionKeyreg: () => ff, TransactionPayment: () => cf, TransactionResponse: () => od, TransactionSignature: () => uf, TransactionSignatureLogicsig: () => df, TransactionSignatureMultisig: () => Mo, TransactionSignatureMultisigSubsignature: () => lf, TransactionStateProof: () => hf, TransactionsResponse: () => ad });
U();
var Tt = rr$1(or());
var yo = class extends Ie {
  constructor({ address: e, amount: r, amountWithoutPendingRewards: i, pendingRewards: n, rewards: s2, round: o, status: f, totalAppsOptedIn: l, totalAssetsOptedIn: m3, totalBoxBytes: A2, totalBoxes: F3, totalCreatedApps: z3, totalCreatedAssets: V, appsLocalState: $, appsTotalExtraPages: re, appsTotalSchema: W2, assets: Z2, authAddr: ue, closedAtRound: ge, createdApps: Se, createdAssets: pe2, createdAtRound: H2, deleted: le, participation: ie, rewardBase: se, sigType: N3 }) {
    super(), this.address = e, this.amount = r, this.amountWithoutPendingRewards = i, this.pendingRewards = n, this.rewards = s2, this.round = o, this.status = f, this.totalAppsOptedIn = l, this.totalAssetsOptedIn = m3, this.totalBoxBytes = A2, this.totalBoxes = F3, this.totalCreatedApps = z3, this.totalCreatedAssets = V, this.appsLocalState = $, this.appsTotalExtraPages = re, this.appsTotalSchema = W2, this.assets = Z2, this.authAddr = ue, this.closedAtRound = ge, this.createdApps = Se, this.createdAssets = pe2, this.createdAtRound = H2, this.deleted = le, this.participation = ie, this.rewardBase = se, this.sigType = N3, this.attribute_map = { address: "address", amount: "amount", amountWithoutPendingRewards: "amount-without-pending-rewards", pendingRewards: "pending-rewards", rewards: "rewards", round: "round", status: "status", totalAppsOptedIn: "total-apps-opted-in", totalAssetsOptedIn: "total-assets-opted-in", totalBoxBytes: "total-box-bytes", totalBoxes: "total-boxes", totalCreatedApps: "total-created-apps", totalCreatedAssets: "total-created-assets", appsLocalState: "apps-local-state", appsTotalExtraPages: "apps-total-extra-pages", appsTotalSchema: "apps-total-schema", assets: "assets", authAddr: "auth-addr", closedAtRound: "closed-at-round", createdApps: "created-apps", createdAssets: "created-assets", createdAtRound: "created-at-round", deleted: "deleted", participation: "participation", rewardBase: "reward-base", sigType: "sig-type" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["amount-without-pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'amount-without-pending-rewards': ${e}`);
    if (typeof e["pending-rewards"] > "u")
      throw new Error(`Response is missing required field 'pending-rewards': ${e}`);
    if (typeof e.rewards > "u")
      throw new Error(`Response is missing required field 'rewards': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.status > "u")
      throw new Error(`Response is missing required field 'status': ${e}`);
    if (typeof e["total-apps-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-apps-opted-in': ${e}`);
    if (typeof e["total-assets-opted-in"] > "u")
      throw new Error(`Response is missing required field 'total-assets-opted-in': ${e}`);
    if (typeof e["total-box-bytes"] > "u")
      throw new Error(`Response is missing required field 'total-box-bytes': ${e}`);
    if (typeof e["total-boxes"] > "u")
      throw new Error(`Response is missing required field 'total-boxes': ${e}`);
    if (typeof e["total-created-apps"] > "u")
      throw new Error(`Response is missing required field 'total-created-apps': ${e}`);
    if (typeof e["total-created-assets"] > "u")
      throw new Error(`Response is missing required field 'total-created-assets': ${e}`);
    return new yo({ address: e.address, amount: e.amount, amountWithoutPendingRewards: e["amount-without-pending-rewards"], pendingRewards: e["pending-rewards"], rewards: e.rewards, round: e.round, status: e.status, totalAppsOptedIn: e["total-apps-opted-in"], totalAssetsOptedIn: e["total-assets-opted-in"], totalBoxBytes: e["total-box-bytes"], totalBoxes: e["total-boxes"], totalCreatedApps: e["total-created-apps"], totalCreatedAssets: e["total-created-assets"], appsLocalState: typeof e["apps-local-state"] < "u" ? e["apps-local-state"].map(bo.from_obj_for_encoding) : void 0, appsTotalExtraPages: e["apps-total-extra-pages"], appsTotalSchema: typeof e["apps-total-schema"] < "u" ? Mn.from_obj_for_encoding(e["apps-total-schema"]) : void 0, assets: typeof e.assets < "u" ? e.assets.map(vo.from_obj_for_encoding) : void 0, authAddr: e["auth-addr"], closedAtRound: e["closed-at-round"], createdApps: typeof e["created-apps"] < "u" ? e["created-apps"].map(rs.from_obj_for_encoding) : void 0, createdAssets: typeof e["created-assets"] < "u" ? e["created-assets"].map(is.from_obj_for_encoding) : void 0, createdAtRound: e["created-at-round"], deleted: e.deleted, participation: typeof e.participation < "u" ? Oa.from_obj_for_encoding(e.participation) : void 0, rewardBase: e["reward-base"], sigType: e["sig-type"] });
  }
}, Oa = class extends Ie {
  constructor({ selectionParticipationKey: e, voteFirstValid: r, voteKeyDilution: i, voteLastValid: n, voteParticipationKey: s2, stateProofKey: o }) {
    super(), this.selectionParticipationKey = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.voteFirstValid = r, this.voteKeyDilution = i, this.voteLastValid = n, this.voteParticipationKey = typeof s2 == "string" ? new Uint8Array(Tt.Buffer.from(s2, "base64")) : s2, this.stateProofKey = typeof o == "string" ? new Uint8Array(Tt.Buffer.from(o, "base64")) : o, this.attribute_map = { selectionParticipationKey: "selection-participation-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key", stateProofKey: "state-proof-key" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["selection-participation-key"] > "u")
      throw new Error(`Response is missing required field 'selection-participation-key': ${e}`);
    if (typeof e["vote-first-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-first-valid': ${e}`);
    if (typeof e["vote-key-dilution"] > "u")
      throw new Error(`Response is missing required field 'vote-key-dilution': ${e}`);
    if (typeof e["vote-last-valid"] > "u")
      throw new Error(`Response is missing required field 'vote-last-valid': ${e}`);
    if (typeof e["vote-participation-key"] > "u")
      throw new Error(`Response is missing required field 'vote-participation-key': ${e}`);
    return new Oa({ selectionParticipationKey: e["selection-participation-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"], stateProofKey: e["state-proof-key"] });
  }
}, Wu = class extends Ie {
  constructor({ account: e, currentRound: r }) {
    super(), this.account = e, this.currentRound = r, this.attribute_map = { account: "account", currentRound: "current-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.account > "u")
      throw new Error(`Response is missing required field 'account': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Wu({ account: yo.from_obj_for_encoding(e.account), currentRound: e["current-round"] });
  }
}, ja = class extends Ie {
  constructor({ address: e, delta: r }) {
    super(), this.address = e, this.delta = r, this.attribute_map = { address: "address", delta: "delta" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (!Array.isArray(e.delta))
      throw new Error(`Response is missing required array field 'delta': ${e}`);
    return new ja({ address: e.address, delta: e.delta.map(Ao.from_obj_for_encoding) });
  }
}, Vu = class extends Ie {
  constructor({ accounts: e, currentRound: r, nextToken: i }) {
    super(), this.accounts = e, this.currentRound = r, this.nextToken = i, this.attribute_map = { accounts: "accounts", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.accounts))
      throw new Error(`Response is missing required array field 'accounts': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Vu({ accounts: e.accounts.map(yo.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, rs = class extends Ie {
  constructor({ id: e, params: r, createdAtRound: i, deleted: n, deletedAtRound: s2 }) {
    super(), this.id = e, this.params = r, this.createdAtRound = i, this.deleted = n, this.deletedAtRound = s2, this.attribute_map = { id: "id", params: "params", createdAtRound: "created-at-round", deleted: "deleted", deletedAtRound: "deleted-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new rs({ id: e.id, params: qa.from_obj_for_encoding(e.params), createdAtRound: e["created-at-round"], deleted: e.deleted, deletedAtRound: e["deleted-at-round"] });
  }
}, bo = class extends Ie {
  constructor({ id: e, schema: r, closedOutAtRound: i, deleted: n, keyValue: s2, optedInAtRound: o }) {
    super(), this.id = e, this.schema = r, this.closedOutAtRound = i, this.deleted = n, this.keyValue = s2, this.optedInAtRound = o, this.attribute_map = { id: "id", schema: "schema", closedOutAtRound: "closed-out-at-round", deleted: "deleted", keyValue: "key-value", optedInAtRound: "opted-in-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.id > "u")
      throw new Error(`Response is missing required field 'id': ${e}`);
    if (typeof e.schema > "u")
      throw new Error(`Response is missing required field 'schema': ${e}`);
    return new bo({ id: e.id, schema: Mn.from_obj_for_encoding(e.schema), closedOutAtRound: e["closed-out-at-round"], deleted: e.deleted, keyValue: typeof e["key-value"] < "u" ? e["key-value"].map(So.from_obj_for_encoding) : void 0, optedInAtRound: e["opted-in-at-round"] });
  }
}, Yu = class extends Ie {
  constructor({ appsLocalStates: e, currentRound: r, nextToken: i }) {
    super(), this.appsLocalStates = e, this.currentRound = r, this.nextToken = i, this.attribute_map = { appsLocalStates: "apps-local-states", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e["apps-local-states"]))
      throw new Error(`Response is missing required array field 'apps-local-states': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Yu({ appsLocalStates: e["apps-local-states"].map(bo.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, La = class extends Ie {
  constructor({ logs: e, txid: r }) {
    super(), this.logs = e, this.txid = r, this.attribute_map = { logs: "logs", txid: "txid" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.logs))
      throw new Error(`Response is missing required array field 'logs': ${e}`);
    if (typeof e.txid > "u")
      throw new Error(`Response is missing required field 'txid': ${e}`);
    return new La({ logs: e.logs, txid: e.txid });
  }
}, Ju = class extends Ie {
  constructor({ applicationId: e, currentRound: r, logData: i, nextToken: n }) {
    super(), this.applicationId = e, this.currentRound = r, this.logData = i, this.nextToken = n, this.attribute_map = { applicationId: "application-id", currentRound: "current-round", logData: "log-data", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] > "u")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Ju({ applicationId: e["application-id"], currentRound: e["current-round"], logData: typeof e["log-data"] < "u" ? e["log-data"].map(La.from_obj_for_encoding) : void 0, nextToken: e["next-token"] });
  }
}, qa = class extends Ie {
  constructor({ approvalProgram: e, clearStateProgram: r, creator: i, extraProgramPages: n, globalState: s2, globalStateSchema: o, localStateSchema: f }) {
    super(), this.approvalProgram = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.clearStateProgram = typeof r == "string" ? new Uint8Array(Tt.Buffer.from(r, "base64")) : r, this.creator = i, this.extraProgramPages = n, this.globalState = s2, this.globalStateSchema = o, this.localStateSchema = f, this.attribute_map = { approvalProgram: "approval-program", clearStateProgram: "clear-state-program", creator: "creator", extraProgramPages: "extra-program-pages", globalState: "global-state", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["approval-program"] > "u")
      throw new Error(`Response is missing required field 'approval-program': ${e}`);
    if (typeof e["clear-state-program"] > "u")
      throw new Error(`Response is missing required field 'clear-state-program': ${e}`);
    return new qa({ approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], creator: e.creator, extraProgramPages: e["extra-program-pages"], globalState: typeof e["global-state"] < "u" ? e["global-state"].map(So.from_obj_for_encoding) : void 0, globalStateSchema: typeof e["global-state-schema"] < "u" ? Mn.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] < "u" ? Mn.from_obj_for_encoding(e["local-state-schema"]) : void 0 });
  }
}, Zu = class extends Ie {
  constructor({ currentRound: e, application: r }) {
    super(), this.currentRound = e, this.application = r, this.attribute_map = { currentRound: "current-round", application: "application" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Zu({ currentRound: e["current-round"], application: typeof e.application < "u" ? rs.from_obj_for_encoding(e.application) : void 0 });
  }
}, Mn = class extends Ie {
  constructor({ numByteSlice: e, numUint: r }) {
    super(), this.numByteSlice = e, this.numUint = r, this.attribute_map = { numByteSlice: "num-byte-slice", numUint: "num-uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-byte-slice"] > "u")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    if (typeof e["num-uint"] > "u")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    return new Mn({ numByteSlice: e["num-byte-slice"], numUint: e["num-uint"] });
  }
}, Xu = class extends Ie {
  constructor({ applications: e, currentRound: r, nextToken: i }) {
    super(), this.applications = e, this.currentRound = r, this.nextToken = i, this.attribute_map = { applications: "applications", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.applications))
      throw new Error(`Response is missing required array field 'applications': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Xu({ applications: e.applications.map(rs.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, is = class extends Ie {
  constructor({ index: e, params: r, createdAtRound: i, deleted: n, destroyedAtRound: s2 }) {
    super(), this.index = e, this.params = r, this.createdAtRound = i, this.deleted = n, this.destroyedAtRound = s2, this.attribute_map = { index: "index", params: "params", createdAtRound: "created-at-round", deleted: "deleted", destroyedAtRound: "destroyed-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.index > "u")
      throw new Error(`Response is missing required field 'index': ${e}`);
    if (typeof e.params > "u")
      throw new Error(`Response is missing required field 'params': ${e}`);
    return new is({ index: e.index, params: wo.from_obj_for_encoding(e.params), createdAtRound: e["created-at-round"], deleted: e.deleted, destroyedAtRound: e["destroyed-at-round"] });
  }
}, Qu = class extends Ie {
  constructor({ balances: e, currentRound: r, nextToken: i }) {
    super(), this.balances = e, this.currentRound = r, this.nextToken = i, this.attribute_map = { balances: "balances", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.balances))
      throw new Error(`Response is missing required array field 'balances': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new Qu({ balances: e.balances.map(Wa.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, vo = class extends Ie {
  constructor({ amount: e, assetId: r, isFrozen: i, deleted: n, optedInAtRound: s2, optedOutAtRound: o }) {
    super(), this.amount = e, this.assetId = r, this.isFrozen = i, this.deleted = n, this.optedInAtRound = s2, this.optedOutAtRound = o, this.attribute_map = { amount: "amount", assetId: "asset-id", isFrozen: "is-frozen", deleted: "deleted", optedInAtRound: "opted-in-at-round", optedOutAtRound: "opted-out-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["is-frozen"] > "u")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new vo({ amount: e.amount, assetId: e["asset-id"], isFrozen: e["is-frozen"], deleted: e.deleted, optedInAtRound: e["opted-in-at-round"], optedOutAtRound: e["opted-out-at-round"] });
  }
}, ed = class extends Ie {
  constructor({ assets: e, currentRound: r, nextToken: i }) {
    super(), this.assets = e, this.currentRound = r, this.nextToken = i, this.attribute_map = { assets: "assets", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.assets))
      throw new Error(`Response is missing required array field 'assets': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new ed({ assets: e.assets.map(vo.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, wo = class extends Ie {
  constructor({ creator: e, decimals: r, total: i, clawback: n, defaultFrozen: s2, freeze: o, manager: f, metadataHash: l, name: m3, nameB64: A2, reserve: F3, unitName: z3, unitNameB64: V, url: $, urlB64: re }) {
    super(), this.creator = e, this.decimals = r, this.total = i, this.clawback = n, this.defaultFrozen = s2, this.freeze = o, this.manager = f, this.metadataHash = typeof l == "string" ? new Uint8Array(Tt.Buffer.from(l, "base64")) : l, this.name = m3, this.nameB64 = typeof A2 == "string" ? new Uint8Array(Tt.Buffer.from(A2, "base64")) : A2, this.reserve = F3, this.unitName = z3, this.unitNameB64 = typeof V == "string" ? new Uint8Array(Tt.Buffer.from(V, "base64")) : V, this.url = $, this.urlB64 = typeof re == "string" ? new Uint8Array(Tt.Buffer.from(re, "base64")) : re, this.attribute_map = { creator: "creator", decimals: "decimals", total: "total", clawback: "clawback", defaultFrozen: "default-frozen", freeze: "freeze", manager: "manager", metadataHash: "metadata-hash", name: "name", nameB64: "name-b64", reserve: "reserve", unitName: "unit-name", unitNameB64: "unit-name-b64", url: "url", urlB64: "url-b64" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.creator > "u")
      throw new Error(`Response is missing required field 'creator': ${e}`);
    if (typeof e.decimals > "u")
      throw new Error(`Response is missing required field 'decimals': ${e}`);
    if (typeof e.total > "u")
      throw new Error(`Response is missing required field 'total': ${e}`);
    return new wo({ creator: e.creator, decimals: e.decimals, total: e.total, clawback: e.clawback, defaultFrozen: e["default-frozen"], freeze: e.freeze, manager: e.manager, metadataHash: e["metadata-hash"], name: e.name, nameB64: e["name-b64"], reserve: e.reserve, unitName: e["unit-name"], unitNameB64: e["unit-name-b64"], url: e.url, urlB64: e["url-b64"] });
  }
}, td = class extends Ie {
  constructor({ asset: e, currentRound: r }) {
    super(), this.asset = e, this.currentRound = r, this.attribute_map = { asset: "asset", currentRound: "current-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.asset > "u")
      throw new Error(`Response is missing required field 'asset': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new td({ asset: is.from_obj_for_encoding(e.asset), currentRound: e["current-round"] });
  }
}, rd = class extends Ie {
  constructor({ assets: e, currentRound: r, nextToken: i }) {
    super(), this.assets = e, this.currentRound = r, this.nextToken = i, this.attribute_map = { assets: "assets", currentRound: "current-round", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (!Array.isArray(e.assets))
      throw new Error(`Response is missing required array field 'assets': ${e}`);
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    return new rd({ assets: e.assets.map(is.from_obj_for_encoding), currentRound: e["current-round"], nextToken: e["next-token"] });
  }
}, id = class extends Ie {
  constructor({ genesisHash: e, genesisId: r, previousBlockHash: i, round: n, seed: s2, timestamp: o, transactionsRoot: f, transactionsRootSha256: l, participationUpdates: m3, rewards: A2, stateProofTracking: F3, transactions: z3, txnCounter: V, upgradeState: $, upgradeVote: re }) {
    super(), this.genesisHash = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.genesisId = r, this.previousBlockHash = typeof i == "string" ? new Uint8Array(Tt.Buffer.from(i, "base64")) : i, this.round = n, this.seed = typeof s2 == "string" ? new Uint8Array(Tt.Buffer.from(s2, "base64")) : s2, this.timestamp = o, this.transactionsRoot = typeof f == "string" ? new Uint8Array(Tt.Buffer.from(f, "base64")) : f, this.transactionsRootSha256 = typeof l == "string" ? new Uint8Array(Tt.Buffer.from(l, "base64")) : l, this.participationUpdates = m3, this.rewards = A2, this.stateProofTracking = F3, this.transactions = z3, this.txnCounter = V, this.upgradeState = $, this.upgradeVote = re, this.attribute_map = { genesisHash: "genesis-hash", genesisId: "genesis-id", previousBlockHash: "previous-block-hash", round: "round", seed: "seed", timestamp: "timestamp", transactionsRoot: "transactions-root", transactionsRootSha256: "transactions-root-sha256", participationUpdates: "participation-updates", rewards: "rewards", stateProofTracking: "state-proof-tracking", transactions: "transactions", txnCounter: "txn-counter", upgradeState: "upgrade-state", upgradeVote: "upgrade-vote" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["genesis-hash"] > "u")
      throw new Error(`Response is missing required field 'genesis-hash': ${e}`);
    if (typeof e["genesis-id"] > "u")
      throw new Error(`Response is missing required field 'genesis-id': ${e}`);
    if (typeof e["previous-block-hash"] > "u")
      throw new Error(`Response is missing required field 'previous-block-hash': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.seed > "u")
      throw new Error(`Response is missing required field 'seed': ${e}`);
    if (typeof e.timestamp > "u")
      throw new Error(`Response is missing required field 'timestamp': ${e}`);
    if (typeof e["transactions-root"] > "u")
      throw new Error(`Response is missing required field 'transactions-root': ${e}`);
    if (typeof e["transactions-root-sha256"] > "u")
      throw new Error(`Response is missing required field 'transactions-root-sha256': ${e}`);
    return new id({ genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], previousBlockHash: e["previous-block-hash"], round: e.round, seed: e.seed, timestamp: e.timestamp, transactionsRoot: e["transactions-root"], transactionsRootSha256: e["transactions-root-sha256"], participationUpdates: typeof e["participation-updates"] < "u" ? Va.from_obj_for_encoding(e["participation-updates"]) : void 0, rewards: typeof e.rewards < "u" ? Pa.from_obj_for_encoding(e.rewards) : void 0, stateProofTracking: typeof e["state-proof-tracking"] < "u" ? e["state-proof-tracking"].map(ef.from_obj_for_encoding) : void 0, transactions: typeof e.transactions < "u" ? e.transactions.map(In.from_obj_for_encoding) : void 0, txnCounter: e["txn-counter"], upgradeState: typeof e["upgrade-state"] < "u" ? Ua.from_obj_for_encoding(e["upgrade-state"]) : void 0, upgradeVote: typeof e["upgrade-vote"] < "u" ? za.from_obj_for_encoding(e["upgrade-vote"]) : void 0 });
  }
}, Pa = class extends Ie {
  constructor({ feeSink: e, rewardsCalculationRound: r, rewardsLevel: i, rewardsPool: n, rewardsRate: s2, rewardsResidue: o }) {
    super(), this.feeSink = e, this.rewardsCalculationRound = r, this.rewardsLevel = i, this.rewardsPool = n, this.rewardsRate = s2, this.rewardsResidue = o, this.attribute_map = { feeSink: "fee-sink", rewardsCalculationRound: "rewards-calculation-round", rewardsLevel: "rewards-level", rewardsPool: "rewards-pool", rewardsRate: "rewards-rate", rewardsResidue: "rewards-residue" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["fee-sink"] > "u")
      throw new Error(`Response is missing required field 'fee-sink': ${e}`);
    if (typeof e["rewards-calculation-round"] > "u")
      throw new Error(`Response is missing required field 'rewards-calculation-round': ${e}`);
    if (typeof e["rewards-level"] > "u")
      throw new Error(`Response is missing required field 'rewards-level': ${e}`);
    if (typeof e["rewards-pool"] > "u")
      throw new Error(`Response is missing required field 'rewards-pool': ${e}`);
    if (typeof e["rewards-rate"] > "u")
      throw new Error(`Response is missing required field 'rewards-rate': ${e}`);
    if (typeof e["rewards-residue"] > "u")
      throw new Error(`Response is missing required field 'rewards-residue': ${e}`);
    return new Pa({ feeSink: e["fee-sink"], rewardsCalculationRound: e["rewards-calculation-round"], rewardsLevel: e["rewards-level"], rewardsPool: e["rewards-pool"], rewardsRate: e["rewards-rate"], rewardsResidue: e["rewards-residue"] });
  }
}, Ua = class extends Ie {
  constructor({ currentProtocol: e, nextProtocol: r, nextProtocolApprovals: i, nextProtocolSwitchOn: n, nextProtocolVoteBefore: s2 }) {
    super(), this.currentProtocol = e, this.nextProtocol = r, this.nextProtocolApprovals = i, this.nextProtocolSwitchOn = n, this.nextProtocolVoteBefore = s2, this.attribute_map = { currentProtocol: "current-protocol", nextProtocol: "next-protocol", nextProtocolApprovals: "next-protocol-approvals", nextProtocolSwitchOn: "next-protocol-switch-on", nextProtocolVoteBefore: "next-protocol-vote-before" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-protocol"] > "u")
      throw new Error(`Response is missing required field 'current-protocol': ${e}`);
    return new Ua({ currentProtocol: e["current-protocol"], nextProtocol: e["next-protocol"], nextProtocolApprovals: e["next-protocol-approvals"], nextProtocolSwitchOn: e["next-protocol-switch-on"], nextProtocolVoteBefore: e["next-protocol-vote-before"] });
  }
}, za = class extends Ie {
  constructor({ upgradeApprove: e, upgradeDelay: r, upgradePropose: i }) {
    super(), this.upgradeApprove = e, this.upgradeDelay = r, this.upgradePropose = i, this.attribute_map = { upgradeApprove: "upgrade-approve", upgradeDelay: "upgrade-delay", upgradePropose: "upgrade-propose" };
  }
  static from_obj_for_encoding(e) {
    return new za({ upgradeApprove: e["upgrade-approve"], upgradeDelay: e["upgrade-delay"], upgradePropose: e["upgrade-propose"] });
  }
}, xo = class extends Ie {
  constructor({ name: e, value: r }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.value = typeof r == "string" ? new Uint8Array(Tt.Buffer.from(r, "base64")) : r, this.attribute_map = { name: "name", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new xo({ name: e.name, value: e.value });
  }
}, Ha = class extends Ie {
  constructor({ name: e }) {
    super(), this.name = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.attribute_map = { name: "name" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.name > "u")
      throw new Error(`Response is missing required field 'name': ${e}`);
    return new Ha({ name: e.name });
  }
}, _o = class extends Ie {
  constructor({ applicationId: e, boxes: r, nextToken: i }) {
    super(), this.applicationId = e, this.boxes = r, this.nextToken = i, this.attribute_map = { applicationId: "application-id", boxes: "boxes", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] > "u")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    if (!Array.isArray(e.boxes))
      throw new Error(`Response is missing required array field 'boxes': ${e}`);
    return new _o({ applicationId: e["application-id"], boxes: e.boxes.map(Ha.from_obj_for_encoding), nextToken: e["next-token"] });
  }
}, nd = class extends Ie {
  constructor({ message: e, data: r }) {
    super(), this.message = e, this.data = r, this.attribute_map = { message: "message", data: "data" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.message > "u")
      throw new Error(`Response is missing required field 'message': ${e}`);
    return new nd({ message: e.message, data: e.data });
  }
}, $a = class extends Ie {
  constructor({ action: e, bytes: r, uint: i }) {
    super(), this.action = e, this.bytes = r, this.uint = i, this.attribute_map = { action: "action", bytes: "bytes", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.action > "u")
      throw new Error(`Response is missing required field 'action': ${e}`);
    return new $a({ action: e.action, bytes: e.bytes, uint: e.uint });
  }
}, Ao = class extends Ie {
  constructor({ key: e, value: r }) {
    super(), this.key = e, this.value = r, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new Ao({ key: e.key, value: $a.from_obj_for_encoding(e.value) });
  }
}, Ga = class extends Ie {
  constructor({ hashType: e }) {
    super(), this.hashType = e, this.attribute_map = { hashType: "hash-type" };
  }
  static from_obj_for_encoding(e) {
    return new Ga({ hashType: e["hash-type"] });
  }
}, sd = class extends Ie {
  constructor({ dbAvailable: e, isMigrating: r, message: i, round: n, version: s2, data: o, errors: f }) {
    super(), this.dbAvailable = e, this.isMigrating = r, this.message = i, this.round = n, this.version = s2, this.data = o, this.errors = f, this.attribute_map = { dbAvailable: "db-available", isMigrating: "is-migrating", message: "message", round: "round", version: "version", data: "data", errors: "errors" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["db-available"] > "u")
      throw new Error(`Response is missing required field 'db-available': ${e}`);
    if (typeof e["is-migrating"] > "u")
      throw new Error(`Response is missing required field 'is-migrating': ${e}`);
    if (typeof e.message > "u")
      throw new Error(`Response is missing required field 'message': ${e}`);
    if (typeof e.round > "u")
      throw new Error(`Response is missing required field 'round': ${e}`);
    if (typeof e.version > "u")
      throw new Error(`Response is missing required field 'version': ${e}`);
    return new sd({ dbAvailable: e["db-available"], isMigrating: e["is-migrating"], message: e.message, round: e.round, version: e.version, data: e.data, errors: e.errors });
  }
}, Ka = class extends Ie {
  constructor({ blockHeadersCommitment: e, firstAttestedRound: r, latestAttestedRound: i, lnProvenWeight: n, votersCommitment: s2 }) {
    super(), this.blockHeadersCommitment = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.firstAttestedRound = r, this.latestAttestedRound = i, this.lnProvenWeight = n, this.votersCommitment = typeof s2 == "string" ? new Uint8Array(Tt.Buffer.from(s2, "base64")) : s2, this.attribute_map = { blockHeadersCommitment: "block-headers-commitment", firstAttestedRound: "first-attested-round", latestAttestedRound: "latest-attested-round", lnProvenWeight: "ln-proven-weight", votersCommitment: "voters-commitment" };
  }
  static from_obj_for_encoding(e) {
    return new Ka({ blockHeadersCommitment: e["block-headers-commitment"], firstAttestedRound: e["first-attested-round"], latestAttestedRound: e["latest-attested-round"], lnProvenWeight: e["ln-proven-weight"], votersCommitment: e["voters-commitment"] });
  }
}, ns = class extends Ie {
  constructor({ hashFactory: e, path: r, treeDepth: i }) {
    super(), this.hashFactory = e, this.path = r, this.treeDepth = i, this.attribute_map = { hashFactory: "hash-factory", path: "path", treeDepth: "tree-depth" };
  }
  static from_obj_for_encoding(e) {
    return new ns({ hashFactory: typeof e["hash-factory"] < "u" ? Ga.from_obj_for_encoding(e["hash-factory"]) : void 0, path: e.path, treeDepth: e["tree-depth"] });
  }
}, Wa = class extends Ie {
  constructor({ address: e, amount: r, isFrozen: i, deleted: n, optedInAtRound: s2, optedOutAtRound: o }) {
    super(), this.address = e, this.amount = r, this.isFrozen = i, this.deleted = n, this.optedInAtRound = s2, this.optedOutAtRound = o, this.attribute_map = { address: "address", amount: "amount", isFrozen: "is-frozen", deleted: "deleted", optedInAtRound: "opted-in-at-round", optedOutAtRound: "opted-out-at-round" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["is-frozen"] > "u")
      throw new Error(`Response is missing required field 'is-frozen': ${e}`);
    return new Wa({ address: e.address, amount: e.amount, isFrozen: e["is-frozen"], deleted: e.deleted, optedInAtRound: e["opted-in-at-round"], optedOutAtRound: e["opted-out-at-round"] });
  }
}, Va = class extends Ie {
  constructor({ expiredParticipationAccounts: e }) {
    super(), this.expiredParticipationAccounts = e, this.attribute_map = { expiredParticipationAccounts: "expired-participation-accounts" };
  }
  static from_obj_for_encoding(e) {
    return new Va({ expiredParticipationAccounts: e["expired-participation-accounts"] });
  }
}, Ya = class extends Ie {
  constructor({ partProofs: e, positionsToReveal: r, reveals: i, saltVersion: n, sigCommit: s2, sigProofs: o, signedWeight: f }) {
    super(), this.partProofs = e, this.positionsToReveal = r, this.reveals = i, this.saltVersion = n, this.sigCommit = typeof s2 == "string" ? new Uint8Array(Tt.Buffer.from(s2, "base64")) : s2, this.sigProofs = o, this.signedWeight = f, this.attribute_map = { partProofs: "part-proofs", positionsToReveal: "positions-to-reveal", reveals: "reveals", saltVersion: "salt-version", sigCommit: "sig-commit", sigProofs: "sig-proofs", signedWeight: "signed-weight" };
  }
  static from_obj_for_encoding(e) {
    return new Ya({ partProofs: typeof e["part-proofs"] < "u" ? ns.from_obj_for_encoding(e["part-proofs"]) : void 0, positionsToReveal: e["positions-to-reveal"], reveals: typeof e.reveals < "u" ? e.reveals.map(Za.from_obj_for_encoding) : void 0, saltVersion: e["salt-version"], sigCommit: e["sig-commit"], sigProofs: typeof e["sig-proofs"] < "u" ? ns.from_obj_for_encoding(e["sig-proofs"]) : void 0, signedWeight: e["signed-weight"] });
  }
}, Ja = class extends Ie {
  constructor({ verifier: e, weight: r }) {
    super(), this.verifier = e, this.weight = r, this.attribute_map = { verifier: "verifier", weight: "weight" };
  }
  static from_obj_for_encoding(e) {
    return new Ja({ verifier: typeof e.verifier < "u" ? tf.from_obj_for_encoding(e.verifier) : void 0, weight: e.weight });
  }
}, Za = class extends Ie {
  constructor({ participant: e, position: r, sigSlot: i }) {
    super(), this.participant = e, this.position = r, this.sigSlot = i, this.attribute_map = { participant: "participant", position: "position", sigSlot: "sig-slot" };
  }
  static from_obj_for_encoding(e) {
    return new Za({ participant: typeof e.participant < "u" ? Ja.from_obj_for_encoding(e.participant) : void 0, position: e.position, sigSlot: typeof e["sig-slot"] < "u" ? Xa.from_obj_for_encoding(e["sig-slot"]) : void 0 });
  }
}, Xa = class extends Ie {
  constructor({ lowerSigWeight: e, signature: r }) {
    super(), this.lowerSigWeight = e, this.signature = r, this.attribute_map = { lowerSigWeight: "lower-sig-weight", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    return new Xa({ lowerSigWeight: e["lower-sig-weight"], signature: typeof e.signature < "u" ? Qa.from_obj_for_encoding(e.signature) : void 0 });
  }
}, Qa = class extends Ie {
  constructor({ falconSignature: e, merkleArrayIndex: r, proof: i, verifyingKey: n }) {
    super(), this.falconSignature = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.merkleArrayIndex = r, this.proof = i, this.verifyingKey = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.attribute_map = { falconSignature: "falcon-signature", merkleArrayIndex: "merkle-array-index", proof: "proof", verifyingKey: "verifying-key" };
  }
  static from_obj_for_encoding(e) {
    return new Qa({ falconSignature: e["falcon-signature"], merkleArrayIndex: e["merkle-array-index"], proof: typeof e.proof < "u" ? ns.from_obj_for_encoding(e.proof) : void 0, verifyingKey: e["verifying-key"] });
  }
}, ef = class extends Ie {
  constructor({ nextRound: e, onlineTotalWeight: r, type: i, votersCommitment: n }) {
    super(), this.nextRound = e, this.onlineTotalWeight = r, this.type = i, this.votersCommitment = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.attribute_map = { nextRound: "next-round", onlineTotalWeight: "online-total-weight", type: "type", votersCommitment: "voters-commitment" };
  }
  static from_obj_for_encoding(e) {
    return new ef({ nextRound: e["next-round"], onlineTotalWeight: e["online-total-weight"], type: e.type, votersCommitment: e["voters-commitment"] });
  }
}, tf = class extends Ie {
  constructor({ commitment: e, keyLifetime: r }) {
    super(), this.commitment = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.keyLifetime = r, this.attribute_map = { commitment: "commitment", keyLifetime: "key-lifetime" };
  }
  static from_obj_for_encoding(e) {
    return new tf({ commitment: e.commitment, keyLifetime: e["key-lifetime"] });
  }
}, Eo = class extends Ie {
  constructor({ numByteSlice: e, numUint: r }) {
    super(), this.numByteSlice = e, this.numUint = r, this.attribute_map = { numByteSlice: "num-byte-slice", numUint: "num-uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["num-byte-slice"] > "u")
      throw new Error(`Response is missing required field 'num-byte-slice': ${e}`);
    if (typeof e["num-uint"] > "u")
      throw new Error(`Response is missing required field 'num-uint': ${e}`);
    return new Eo({ numByteSlice: e["num-byte-slice"], numUint: e["num-uint"] });
  }
}, So = class extends Ie {
  constructor({ key: e, value: r }) {
    super(), this.key = e, this.value = r, this.attribute_map = { key: "key", value: "value" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.key > "u")
      throw new Error(`Response is missing required field 'key': ${e}`);
    if (typeof e.value > "u")
      throw new Error(`Response is missing required field 'value': ${e}`);
    return new So({ key: e.key, value: rf.from_obj_for_encoding(e.value) });
  }
}, rf = class extends Ie {
  constructor({ bytes: e, type: r, uint: i }) {
    super(), this.bytes = e, this.type = r, this.uint = i, this.attribute_map = { bytes: "bytes", type: "type", uint: "uint" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.bytes > "u")
      throw new Error(`Response is missing required field 'bytes': ${e}`);
    if (typeof e.type > "u")
      throw new Error(`Response is missing required field 'type': ${e}`);
    if (typeof e.uint > "u")
      throw new Error(`Response is missing required field 'uint': ${e}`);
    return new rf({ bytes: e.bytes, type: e.type, uint: e.uint });
  }
}, In = class extends Ie {
  constructor({ fee: e, firstValid: r, lastValid: i, sender: n, applicationTransaction: s2, assetConfigTransaction: o, assetFreezeTransaction: f, assetTransferTransaction: l, authAddr: m3, closeRewards: A2, closingAmount: F3, confirmedRound: z3, createdApplicationIndex: V, createdAssetIndex: $, genesisHash: re, genesisId: W2, globalStateDelta: Z2, group: ue, id: ge, innerTxns: Se, intraRoundOffset: pe2, keyregTransaction: H2, lease: le, localStateDelta: ie, logs: se, note: N3, paymentTransaction: c2, receiverRewards: p2, rekeyTo: h2, roundTime: a, senderRewards: d2, signature: b2, stateProofTransaction: _2, txType: v }) {
    super(), this.fee = e, this.firstValid = r, this.lastValid = i, this.sender = n, this.applicationTransaction = s2, this.assetConfigTransaction = o, this.assetFreezeTransaction = f, this.assetTransferTransaction = l, this.authAddr = m3, this.closeRewards = A2, this.closingAmount = F3, this.confirmedRound = z3, this.createdApplicationIndex = V, this.createdAssetIndex = $, this.genesisHash = typeof re == "string" ? new Uint8Array(Tt.Buffer.from(re, "base64")) : re, this.genesisId = W2, this.globalStateDelta = Z2, this.group = typeof ue == "string" ? new Uint8Array(Tt.Buffer.from(ue, "base64")) : ue, this.id = ge, this.innerTxns = Se, this.intraRoundOffset = pe2, this.keyregTransaction = H2, this.lease = typeof le == "string" ? new Uint8Array(Tt.Buffer.from(le, "base64")) : le, this.localStateDelta = ie, this.logs = se, this.note = typeof N3 == "string" ? new Uint8Array(Tt.Buffer.from(N3, "base64")) : N3, this.paymentTransaction = c2, this.receiverRewards = p2, this.rekeyTo = h2, this.roundTime = a, this.senderRewards = d2, this.signature = b2, this.stateProofTransaction = _2, this.txType = v, this.attribute_map = { fee: "fee", firstValid: "first-valid", lastValid: "last-valid", sender: "sender", applicationTransaction: "application-transaction", assetConfigTransaction: "asset-config-transaction", assetFreezeTransaction: "asset-freeze-transaction", assetTransferTransaction: "asset-transfer-transaction", authAddr: "auth-addr", closeRewards: "close-rewards", closingAmount: "closing-amount", confirmedRound: "confirmed-round", createdApplicationIndex: "created-application-index", createdAssetIndex: "created-asset-index", genesisHash: "genesis-hash", genesisId: "genesis-id", globalStateDelta: "global-state-delta", group: "group", id: "id", innerTxns: "inner-txns", intraRoundOffset: "intra-round-offset", keyregTransaction: "keyreg-transaction", lease: "lease", localStateDelta: "local-state-delta", logs: "logs", note: "note", paymentTransaction: "payment-transaction", receiverRewards: "receiver-rewards", rekeyTo: "rekey-to", roundTime: "round-time", senderRewards: "sender-rewards", signature: "signature", stateProofTransaction: "state-proof-transaction", txType: "tx-type" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.fee > "u")
      throw new Error(`Response is missing required field 'fee': ${e}`);
    if (typeof e["first-valid"] > "u")
      throw new Error(`Response is missing required field 'first-valid': ${e}`);
    if (typeof e["last-valid"] > "u")
      throw new Error(`Response is missing required field 'last-valid': ${e}`);
    if (typeof e.sender > "u")
      throw new Error(`Response is missing required field 'sender': ${e}`);
    return new In({ fee: e.fee, firstValid: e["first-valid"], lastValid: e["last-valid"], sender: e.sender, applicationTransaction: typeof e["application-transaction"] < "u" ? nf.from_obj_for_encoding(e["application-transaction"]) : void 0, assetConfigTransaction: typeof e["asset-config-transaction"] < "u" ? sf.from_obj_for_encoding(e["asset-config-transaction"]) : void 0, assetFreezeTransaction: typeof e["asset-freeze-transaction"] < "u" ? of.from_obj_for_encoding(e["asset-freeze-transaction"]) : void 0, assetTransferTransaction: typeof e["asset-transfer-transaction"] < "u" ? af.from_obj_for_encoding(e["asset-transfer-transaction"]) : void 0, authAddr: e["auth-addr"], closeRewards: e["close-rewards"], closingAmount: e["closing-amount"], confirmedRound: e["confirmed-round"], createdApplicationIndex: e["created-application-index"], createdAssetIndex: e["created-asset-index"], genesisHash: e["genesis-hash"], genesisId: e["genesis-id"], globalStateDelta: typeof e["global-state-delta"] < "u" ? e["global-state-delta"].map(Ao.from_obj_for_encoding) : void 0, group: e.group, id: e.id, innerTxns: typeof e["inner-txns"] < "u" ? e["inner-txns"].map(In.from_obj_for_encoding) : void 0, intraRoundOffset: e["intra-round-offset"], keyregTransaction: typeof e["keyreg-transaction"] < "u" ? ff.from_obj_for_encoding(e["keyreg-transaction"]) : void 0, lease: e.lease, localStateDelta: typeof e["local-state-delta"] < "u" ? e["local-state-delta"].map(ja.from_obj_for_encoding) : void 0, logs: e.logs, note: e.note, paymentTransaction: typeof e["payment-transaction"] < "u" ? cf.from_obj_for_encoding(e["payment-transaction"]) : void 0, receiverRewards: e["receiver-rewards"], rekeyTo: e["rekey-to"], roundTime: e["round-time"], senderRewards: e["sender-rewards"], signature: typeof e.signature < "u" ? uf.from_obj_for_encoding(e.signature) : void 0, stateProofTransaction: typeof e["state-proof-transaction"] < "u" ? hf.from_obj_for_encoding(e["state-proof-transaction"]) : void 0, txType: e["tx-type"] });
  }
}, nf = class extends Ie {
  constructor({ applicationId: e, accounts: r, applicationArgs: i, approvalProgram: n, clearStateProgram: s2, extraProgramPages: o, foreignApps: f, foreignAssets: l, globalStateSchema: m3, localStateSchema: A2, onCompletion: F3 }) {
    super(), this.applicationId = e, this.accounts = r, this.applicationArgs = i, this.approvalProgram = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.clearStateProgram = typeof s2 == "string" ? new Uint8Array(Tt.Buffer.from(s2, "base64")) : s2, this.extraProgramPages = o, this.foreignApps = f, this.foreignAssets = l, this.globalStateSchema = m3, this.localStateSchema = A2, this.onCompletion = F3, this.attribute_map = { applicationId: "application-id", accounts: "accounts", applicationArgs: "application-args", approvalProgram: "approval-program", clearStateProgram: "clear-state-program", extraProgramPages: "extra-program-pages", foreignApps: "foreign-apps", foreignAssets: "foreign-assets", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema", onCompletion: "on-completion" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["application-id"] > "u")
      throw new Error(`Response is missing required field 'application-id': ${e}`);
    return new nf({ applicationId: e["application-id"], accounts: e.accounts, applicationArgs: e["application-args"], approvalProgram: e["approval-program"], clearStateProgram: e["clear-state-program"], extraProgramPages: e["extra-program-pages"], foreignApps: e["foreign-apps"], foreignAssets: e["foreign-assets"], globalStateSchema: typeof e["global-state-schema"] < "u" ? Eo.from_obj_for_encoding(e["global-state-schema"]) : void 0, localStateSchema: typeof e["local-state-schema"] < "u" ? Eo.from_obj_for_encoding(e["local-state-schema"]) : void 0, onCompletion: e["on-completion"] });
  }
}, sf = class extends Ie {
  constructor({ assetId: e, params: r }) {
    super(), this.assetId = e, this.params = r, this.attribute_map = { assetId: "asset-id", params: "params" };
  }
  static from_obj_for_encoding(e) {
    return new sf({ assetId: e["asset-id"], params: typeof e.params < "u" ? wo.from_obj_for_encoding(e.params) : void 0 });
  }
}, of = class extends Ie {
  constructor({ address: e, assetId: r, newFreezeStatus: i }) {
    super(), this.address = e, this.assetId = r, this.newFreezeStatus = i, this.attribute_map = { address: "address", assetId: "asset-id", newFreezeStatus: "new-freeze-status" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.address > "u")
      throw new Error(`Response is missing required field 'address': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e["new-freeze-status"] > "u")
      throw new Error(`Response is missing required field 'new-freeze-status': ${e}`);
    return new of({ address: e.address, assetId: e["asset-id"], newFreezeStatus: e["new-freeze-status"] });
  }
}, af = class extends Ie {
  constructor({ amount: e, assetId: r, receiver: i, closeAmount: n, closeTo: s2, sender: o }) {
    super(), this.amount = e, this.assetId = r, this.receiver = i, this.closeAmount = n, this.closeTo = s2, this.sender = o, this.attribute_map = { amount: "amount", assetId: "asset-id", receiver: "receiver", closeAmount: "close-amount", closeTo: "close-to", sender: "sender" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e["asset-id"] > "u")
      throw new Error(`Response is missing required field 'asset-id': ${e}`);
    if (typeof e.receiver > "u")
      throw new Error(`Response is missing required field 'receiver': ${e}`);
    return new af({ amount: e.amount, assetId: e["asset-id"], receiver: e.receiver, closeAmount: e["close-amount"], closeTo: e["close-to"], sender: e.sender });
  }
}, ff = class extends Ie {
  constructor({ nonParticipation: e, selectionParticipationKey: r, stateProofKey: i, voteFirstValid: n, voteKeyDilution: s2, voteLastValid: o, voteParticipationKey: f }) {
    super(), this.nonParticipation = e, this.selectionParticipationKey = typeof r == "string" ? new Uint8Array(Tt.Buffer.from(r, "base64")) : r, this.stateProofKey = typeof i == "string" ? new Uint8Array(Tt.Buffer.from(i, "base64")) : i, this.voteFirstValid = n, this.voteKeyDilution = s2, this.voteLastValid = o, this.voteParticipationKey = typeof f == "string" ? new Uint8Array(Tt.Buffer.from(f, "base64")) : f, this.attribute_map = { nonParticipation: "non-participation", selectionParticipationKey: "selection-participation-key", stateProofKey: "state-proof-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key" };
  }
  static from_obj_for_encoding(e) {
    return new ff({ nonParticipation: e["non-participation"], selectionParticipationKey: e["selection-participation-key"], stateProofKey: e["state-proof-key"], voteFirstValid: e["vote-first-valid"], voteKeyDilution: e["vote-key-dilution"], voteLastValid: e["vote-last-valid"], voteParticipationKey: e["vote-participation-key"] });
  }
}, cf = class extends Ie {
  constructor({ amount: e, receiver: r, closeAmount: i, closeRemainderTo: n }) {
    super(), this.amount = e, this.receiver = r, this.closeAmount = i, this.closeRemainderTo = n, this.attribute_map = { amount: "amount", receiver: "receiver", closeAmount: "close-amount", closeRemainderTo: "close-remainder-to" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.amount > "u")
      throw new Error(`Response is missing required field 'amount': ${e}`);
    if (typeof e.receiver > "u")
      throw new Error(`Response is missing required field 'receiver': ${e}`);
    return new cf({ amount: e.amount, receiver: e.receiver, closeAmount: e["close-amount"], closeRemainderTo: e["close-remainder-to"] });
  }
}, od = class extends Ie {
  constructor({ currentRound: e, transaction: r }) {
    super(), this.currentRound = e, this.transaction = r, this.attribute_map = { currentRound: "current-round", transaction: "transaction" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    if (typeof e.transaction > "u")
      throw new Error(`Response is missing required field 'transaction': ${e}`);
    return new od({ currentRound: e["current-round"], transaction: In.from_obj_for_encoding(e.transaction) });
  }
}, uf = class extends Ie {
  constructor({ logicsig: e, multisig: r, sig: i }) {
    super(), this.logicsig = e, this.multisig = r, this.sig = typeof i == "string" ? new Uint8Array(Tt.Buffer.from(i, "base64")) : i, this.attribute_map = { logicsig: "logicsig", multisig: "multisig", sig: "sig" };
  }
  static from_obj_for_encoding(e) {
    return new uf({ logicsig: typeof e.logicsig < "u" ? df.from_obj_for_encoding(e.logicsig) : void 0, multisig: typeof e.multisig < "u" ? Mo.from_obj_for_encoding(e.multisig) : void 0, sig: e.sig });
  }
}, df = class extends Ie {
  constructor({ logic: e, args: r, multisigSignature: i, signature: n }) {
    super(), this.logic = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.args = r, this.multisigSignature = i, this.signature = typeof n == "string" ? new Uint8Array(Tt.Buffer.from(n, "base64")) : n, this.attribute_map = { logic: "logic", args: "args", multisigSignature: "multisig-signature", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e.logic > "u")
      throw new Error(`Response is missing required field 'logic': ${e}`);
    return new df({ logic: e.logic, args: e.args, multisigSignature: typeof e["multisig-signature"] < "u" ? Mo.from_obj_for_encoding(e["multisig-signature"]) : void 0, signature: e.signature });
  }
}, Mo = class extends Ie {
  constructor({ subsignature: e, threshold: r, version: i }) {
    super(), this.subsignature = e, this.threshold = r, this.version = i, this.attribute_map = { subsignature: "subsignature", threshold: "threshold", version: "version" };
  }
  static from_obj_for_encoding(e) {
    return new Mo({ subsignature: typeof e.subsignature < "u" ? e.subsignature.map(lf.from_obj_for_encoding) : void 0, threshold: e.threshold, version: e.version });
  }
}, lf = class extends Ie {
  constructor({ publicKey: e, signature: r }) {
    super(), this.publicKey = typeof e == "string" ? new Uint8Array(Tt.Buffer.from(e, "base64")) : e, this.signature = typeof r == "string" ? new Uint8Array(Tt.Buffer.from(r, "base64")) : r, this.attribute_map = { publicKey: "public-key", signature: "signature" };
  }
  static from_obj_for_encoding(e) {
    return new lf({ publicKey: e["public-key"], signature: e.signature });
  }
}, hf = class extends Ie {
  constructor({ message: e, stateProof: r, stateProofType: i }) {
    super(), this.message = e, this.stateProof = r, this.stateProofType = i, this.attribute_map = { message: "message", stateProof: "state-proof", stateProofType: "state-proof-type" };
  }
  static from_obj_for_encoding(e) {
    return new hf({ message: typeof e.message < "u" ? Ka.from_obj_for_encoding(e.message) : void 0, stateProof: typeof e["state-proof"] < "u" ? Ya.from_obj_for_encoding(e["state-proof"]) : void 0, stateProofType: e["state-proof-type"] });
  }
}, ad = class extends Ie {
  constructor({ currentRound: e, transactions: r, nextToken: i }) {
    super(), this.currentRound = e, this.transactions = r, this.nextToken = i, this.attribute_map = { currentRound: "current-round", transactions: "transactions", nextToken: "next-token" };
  }
  static from_obj_for_encoding(e) {
    if (typeof e["current-round"] > "u")
      throw new Error(`Response is missing required field 'current-round': ${e}`);
    if (!Array.isArray(e.transactions))
      throw new Error(`Response is missing required array field 'transactions': ${e}`);
    return new ad({ currentRound: e["current-round"], transactions: e.transactions.map(In.from_obj_for_encoding), nextToken: e["next-token"] });
  }
};
var fd = class extends Re {
  constructor(e, r, i, n) {
    super(e, r), this.index = i, this.index = i;
    let s2 = M4.Buffer.from(n).toString("base64");
    this.query.name = encodeURI(`b64:${s2}`);
  }
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  prepare(e) {
    return xo.from_obj_for_encoding(e);
  }
};
U();
var cd = class extends Re {
  path() {
    return "/v2/accounts";
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  authAddr(e) {
    return this.query["auth-addr"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
  exclude(e) {
    return this.query.exclude = e, this;
  }
};
U();
var ud = class extends Re {
  path() {
    return "/v2/transactions";
  }
  notePrefix(e) {
    return this.query["note-prefix"] = Cu(e), this;
  }
  txType(e) {
    return this.query["tx-type"] = e, this;
  }
  sigType(e) {
    return this.query["sig-type"] = e, this;
  }
  txid(e) {
    return this.query.txid = e, this;
  }
  round(e) {
    return this.query.round = e, this;
  }
  minRound(e) {
    return this.query["min-round"] = e, this;
  }
  maxRound(e) {
    return this.query["max-round"] = e, this;
  }
  assetID(e) {
    return this.query["asset-id"] = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  beforeTime(e) {
    return this.query["before-time"] = e, this;
  }
  afterTime(e) {
    return this.query["after-time"] = e, this;
  }
  currencyGreaterThan(e) {
    return this.query["currency-greater-than"] = e, this;
  }
  currencyLessThan(e) {
    return this.query["currency-less-than"] = e, this;
  }
  addressRole(e) {
    return this.query["address-role"] = e, this;
  }
  address(e) {
    return this.query.address = e, this;
  }
  excludeCloseTo(e) {
    return this.query["exclude-close-to"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  rekeyTo(e) {
    return this.query["rekey-to"] = e, this;
  }
  applicationID(e) {
    return this.query["application-id"] = e, this;
  }
};
U();
var dd = class extends Re {
  path() {
    return "/v2/assets";
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  creator(e) {
    return this.query.creator = e, this;
  }
  name(e) {
    return this.query.name = e, this;
  }
  unit(e) {
    return this.query.unit = e, this;
  }
  index(e) {
    return this.query["asset-id"] = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var ld = class extends Re {
  path() {
    return "/v2/applications";
  }
  index(e) {
    return this.query["application-id"] = e, this;
  }
  creator(e) {
    return this.query.creator = e, this;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  includeAll(e = true) {
    return this.query["include-all"] = e, this;
  }
};
U();
var hd = class extends Re {
  constructor(e, r, i) {
    super(e, r), this.index = i, this.index = i;
  }
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  nextToken(e) {
    return this.query.next = e, this;
  }
  limit(e) {
    return this.query.limit = e, this;
  }
  prepare(e) {
    return _o.from_obj_for_encoding(e);
  }
};
var Io = class extends _n {
  constructor(e, r = "http://127.0.0.1", i = 8080, n = {}) {
    super("X-Indexer-API-Token", e, r, i, n);
  }
  makeHealthCheck() {
    return new Du(this.c, this.intDecoding);
  }
  lookupAssetBalances(e) {
    return new Bu(this.c, this.intDecoding, e);
  }
  lookupAssetTransactions(e) {
    return new Ou(this.c, this.intDecoding, e);
  }
  lookupAccountTransactions(e) {
    return new Nu(this.c, this.intDecoding, e);
  }
  lookupBlock(e) {
    return new ju(this.c, this.intDecoding, e);
  }
  lookupTransactionByID(e) {
    return new Lu(this.c, this.intDecoding, e);
  }
  lookupAccountByID(e) {
    return new qu(this.c, this.intDecoding, e);
  }
  lookupAccountAssets(e) {
    return new Pu(this.c, this.intDecoding, e);
  }
  lookupAccountCreatedAssets(e) {
    return new Uu(this.c, this.intDecoding, e);
  }
  lookupAccountAppLocalStates(e) {
    return new zu(this.c, this.intDecoding, e);
  }
  lookupAccountCreatedApplications(e) {
    return new Hu(this.c, this.intDecoding, e);
  }
  lookupAssetByID(e) {
    return new $u(this.c, this.intDecoding, e);
  }
  lookupApplications(e) {
    return new Gu(this.c, this.intDecoding, e);
  }
  lookupApplicationLogs(e) {
    return new Ku(this.c, this.intDecoding, e);
  }
  searchAccounts() {
    return new cd(this.c, this.intDecoding);
  }
  searchForTransactions() {
    return new ud(this.c, this.intDecoding);
  }
  searchForAssets() {
    return new dd(this.c, this.intDecoding);
  }
  searchForApplications() {
    return new ld(this.c, this.intDecoding);
  }
  searchForApplicationBoxes(e) {
    return new hd(this.c, this.intDecoding, e);
  }
  lookupApplicationBoxByIDandName(e, r) {
    return new fd(this.c, this.intDecoding, e, r);
  }
};
U();
async function Wh(t, e, r) {
  let i = await t.status().do();
  if (typeof i > "u")
    throw new Error("Unable to get node status");
  let n = i["last-round"] + 1, s2 = n;
  for (; s2 < n + r; ) {
    let o = false;
    try {
      let f = await t.pendingTransactionInformation(e).do();
      if (f["confirmed-round"])
        return f;
      if (f["pool-error"])
        throw o = true, new Error(`Transaction Rejected: ${f["pool-error"]}`);
    } catch (f) {
      if (o)
        throw f;
    }
    await t.statusAfterBlock(s2).do(), s2 += 1;
  }
  throw new Error(`Transaction not confirmed after ${r} rounds`);
}
U();
var I4 = rr$1(or());
function Tn(t, e) {
  let r = t.toString(16);
  r.length !== e * 2 && (r = r.padStart(e * 2, "0"));
  let i = new Uint8Array(r.length / 2);
  for (let n = 0, s2 = 0; n < r.length / 2; n++, s2 += 2)
    i[n] = parseInt(r.slice(s2, s2 + 2), 16);
  return i;
}
function pd(t) {
  let e = BigInt(0), r = I4.Buffer.from(t);
  for (let i = 0; i < t.length; i++)
    e = BigInt(Number(r.readUIntBE(i, 1))) + e * BigInt(256);
  return e;
}
U();
function gd() {
  let t = U3();
  return { addr: Ue(t.publicKey), sk: t.secretKey };
}
U();
U();
var nR = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"], Vh = nR;
var Cg = "failed to decode mnemonic", sR = "the mnemonic contains a word that is not in the wordlist";
function T4(t) {
  let e = [], r = 0, i = 0;
  function n(o) {
    r |= o << i, i += 8, i >= 11 && (e.push(r & 2047), r >>= 11, i -= 11);
  }
  function s2() {
    i && e.push(r);
  }
  return t.forEach(n), s2(), e;
}
function F4(t) {
  return t.map((e) => Vh[e]);
}
function R4(t) {
  let e = Dr(t), r = T4(e);
  return F4(r)[0];
}
function Yh(t) {
  if (t.length !== Bh)
    throw new RangeError(`Seed length must be ${Bh}`);
  let e = T4(t), r = F4(e), i = R4(t);
  return `${r.join(" ")} ${i}`;
}
function oR(t) {
  let e = [], r = 0, i = 0;
  function n(o) {
    for (r |= o << i, i += 11; i >= 8; )
      e.push(r & 255), r >>= 8, i -= 8;
  }
  function s2() {
    i && e.push(r);
  }
  return t.forEach(n), s2(), new Uint8Array(e);
}
function Jh(t) {
  let e = t.split(" "), r = e.slice(0, 24);
  for (let f of r)
    if (Vh.indexOf(f) === -1)
      throw new Error(sR);
  let i = e[e.length - 1], n = r.map((f) => Vh.indexOf(f)), s2 = oR(n);
  if (s2.length !== 33)
    throw new Error(Cg);
  if (s2[s2.length - 1] !== 0)
    throw new Error(Cg);
  if (s2 = s2.slice(0, s2.length - 1), R4(s2) === i)
    return s2;
  throw new Error(Cg);
}
function To(t) {
  let e = Jh(t), r = vg(e);
  return { addr: Ue(r.publicKey), sk: r.secretKey };
}
function Zh(t) {
  let e = t.slice(0, Bh);
  return Yh(e);
}
function k4(t) {
  return Jh(t);
}
function D4(t) {
  return Yh(t);
}
U();
var pf = rr$1(or());
var B4 = 16, Og = class {
  constructor(e) {
    if (this.name = "Transaction group", this.tag = pf.Buffer.from("TG"), e.length > B4) {
      let r = `${e.length.toString()} transactions grouped together but max group size is ${B4.toString()}`;
      throw Error(r);
    }
    this.txGroupHashes = e;
  }
  get_obj_for_encoding() {
    return { txlist: this.txGroupHashes };
  }
  static from_obj_for_encoding(e) {
    let r = Object.create(this.prototype);
    r.name = "Transaction group", r.tag = pf.Buffer.from("TG"), r.txGroupHashes = [];
    for (let i of e.txlist)
      r.txGroupHashes.push(pf.Buffer.from(i));
    return r;
  }
  toByte() {
    return tr(this.get_obj_for_encoding());
  }
};
function jg(t) {
  let e = [];
  for (let o of t) {
    let f = hi(o);
    e.push(f.rawTxID());
  }
  let r = new Og(e), i = r.toByte(), n = pf.Buffer.from(Jt(r.tag, i)), s2 = Dr(n);
  return pf.Buffer.from(s2);
}
function Xh(t, e) {
  let r = jg(t), i = [];
  for (let n of t) {
    let s2 = hi(n);
    (!e || Ue(s2.from.publicKey) === e) && (s2.group = r, i.push(s2));
  }
  return i;
}
U();
var Fn = rr$1(or());
U();
var ss = rr$1(or());
var aR = "Not enough multisig transactions to merge. Need at least two", fR = "Cannot merge txs. txIDs differ", cR = "Cannot merge txs. Auth addrs differ", N4 = "Cannot merge txs. Multisig preimages differ", uR = "Cannot merge txs. subsigs are mismatched.", dR = "Key does not exist", C4 = "Cannot mutate a multisig field as it would invalidate all existing signatures.", lR = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.", hR = "Cannot add multisig signature. Signature is not of the correct length.";
function Lg(t, { version: e, threshold: r, addrs: i }) {
  let n = i.map((A2) => ut(A2).publicKey), s2 = n.map((A2) => ({ pk: ss.Buffer.from(A2) })), o = { v: e, thr: r, subsig: s2 }, f = t.get_obj_for_encoding(), l = { msig: o, txn: f }, m3 = Vi({ version: e, threshold: r, pks: n });
  return Ue(f.snd) !== Ue(m3) && (l.sgnr = ss.Buffer.from(m3)), new Uint8Array(tr(l));
}
function O4(t, { rawSig: e, myPk: r }, { version: i, threshold: n, pks: s2 }) {
  let o = Lg(t, { version: i, threshold: n, addrs: s2.map((A2) => Ue(A2)) }), f = Kt(o), l = false;
  if (f.msig.subsig.forEach((A2, F3) => {
    Dh(A2.pk, r) && (l = true, f.msig.subsig[F3].s = e);
  }), l === false)
    throw new Error(dR);
  let m3 = Vi({ version: i, threshold: n, pks: s2 });
  return Ue(f.txn.snd) !== Ue(m3) && (f.sgnr = ss.Buffer.from(m3)), new Uint8Array(tr(f));
}
var os = class extends Ht {
  addLease() {
    throw new Error(C4);
  }
  addRekey() {
    throw new Error(C4);
  }
  signTxn(e) {
    throw new Error(lR);
  }
  partialSignTxn({ version: e, threshold: r, pks: i }, n) {
    let s2 = bn(n).publicKey;
    return O4(this, { rawSig: this.rawSignTxn(n), myPk: s2 }, { version: e, threshold: r, pks: i });
  }
  partialSignWithMultisigSignature(e, r, i) {
    if (!kh(i.length))
      throw new Error(hR);
    return O4(this, { rawSig: i, myPk: ut(r).publicKey }, e);
  }
  static from_obj_for_encoding(e) {
    return super.from_obj_for_encoding(e);
  }
};
function gf(t) {
  if (t.length < 2)
    throw new Error(aR);
  let e = Kt(t[0]), r = os.from_obj_for_encoding(e.txn).txID(), i = e.sgnr ? Ue(e.sgnr) : void 0, n = { version: e.msig.v, threshold: e.msig.thr, pks: e.msig.subsig.map((m3) => m3.pk) }, s2 = Ue(Vi(n)), o = e.msig.subsig.map((m3) => ({ ...m3 }));
  for (let m3 = 1; m3 < t.length; m3++) {
    let A2 = Kt(t[m3]);
    if (os.from_obj_for_encoding(A2.txn).txID() !== r)
      throw new Error(fR);
    let z3 = A2.sgnr ? Ue(A2.sgnr) : void 0;
    if (i !== z3)
      throw new Error(cR);
    if (A2.msig.subsig.length !== e.msig.subsig.length)
      throw new Error(N4);
    let V = { version: A2.msig.v, threshold: A2.msig.thr, pks: A2.msig.subsig.map((re) => re.pk) }, $ = Ue(Vi(V));
    if (s2 !== $)
      throw new Error(N4);
    A2.msig.subsig.forEach((re, W2) => {
      if (!re.s)
        return;
      let Z2 = o[W2];
      if (Z2.s && ss.Buffer.compare(ss.Buffer.from(re.s), ss.Buffer.from(Z2.s)) !== 0)
        throw new Error(uR);
      Z2.s = re.s;
    });
  }
  let l = { msig: { v: e.msig.v, thr: e.msig.thr, subsig: o }, txn: e.txn };
  return typeof i < "u" && (l.sgnr = ss.Buffer.from(ut(i).publicKey)), new Uint8Array(tr(l));
}
function Qh(t, e, r) {
  let i = e.v, n = e.thr, s2 = e.subsig, o = s2.map((A2) => A2.pk);
  if (e.subsig.length < n)
    return false;
  let f;
  try {
    f = Vi({ version: i, threshold: n, pks: o });
  } catch {
    return false;
  }
  if (!Zs(f, r))
    return false;
  let l = 0;
  for (let A2 of s2)
    A2.s !== void 0 && (l += 1);
  if (l < n)
    return false;
  let m3 = 0;
  for (let A2 of s2)
    A2.s !== void 0 && Js(t, A2.s, A2.pk) && (m3 += 1);
  return !(m3 < n);
}
function e0(t, { version: e, threshold: r, addrs: i }, n) {
  let s2 = Sg({ version: e, threshold: r, addrs: i });
  Object.prototype.hasOwnProperty.call(t, "from") || (t.from = s2);
  let o = i.map((A2) => ut(A2).publicKey), f = t instanceof Ht, l, m3;
  return f ? (l = t, m3 = os.prototype.partialSignTxn.call(l, { version: e, threshold: r, pks: o }, n)) : (l = new os(t), m3 = l.partialSignTxn({ version: e, threshold: r, pks: o }, n)), { txID: l.txID().toString(), blob: m3 };
}
function j4(t, { version: e, threshold: r, addrs: i }, n) {
  let s2 = i.map((m3) => ut(m3).publicKey), o = Kt(t), f = os.from_obj_for_encoding(o.txn), l = f.partialSignTxn({ version: e, threshold: r, pks: s2 }, n);
  return { txID: f.txID().toString(), blob: gf([t, l]) };
}
function L4(t, { version: e, threshold: r, addrs: i }, n, s2) {
  let o = i.map((A2) => ut(A2).publicKey), f = Kt(t), l = os.from_obj_for_encoding(f.txn), m3 = l.partialSignWithMultisigSignature({ version: e, threshold: r, pks: o }, n, s2);
  return { txID: l.txID().toString(), blob: gf([t, m3]) };
}
function q4({ version: t, threshold: e, addrs: r }) {
  return Sg({ version: t, threshold: e, addrs: r });
}
function P4(t) {
  if (!t || t.length === 0)
    throw new Error("empty program");
  let e = `
`.charCodeAt(0), r = " ".charCodeAt(0), i = "~".charCodeAt(0), n = (o) => r <= o && o <= i;
  if (t.every((o) => o === e || n(o))) {
    let o = Fn.Buffer.from(t).toString();
    throw Zn(o) ? new Error("requesting program bytes, get Algorand address") : Fn.Buffer.from(o, "base64").toString("base64") === o ? new Error("program should not be b64 encoded") : new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
var Ni = class {
  constructor(e, r) {
    if (this.tag = Fn.Buffer.from("Program"), r && (!Array.isArray(r) || !r.every((n) => n.constructor === Uint8Array || Fn.Buffer.isBuffer(n))))
      throw new TypeError("Invalid arguments");
    let i;
    r != null && (i = r.map((n) => new Uint8Array(n))), P4(e), this.logic = e, this.args = i, this.sig = void 0, this.msig = void 0;
  }
  get_obj_for_encoding() {
    let e = { l: this.logic };
    return this.args && (e.arg = this.args), this.sig ? e.sig = this.sig : this.msig && (e.msig = this.msig), e;
  }
  static from_obj_for_encoding(e) {
    let r = new Ni(e.l, e.arg);
    return r.sig = e.sig, r.msig = e.msig, r;
  }
  verify(e) {
    if (this.sig && this.msig)
      return false;
    try {
      P4(this.logic);
    } catch {
      return false;
    }
    let r = Jt(this.tag, this.logic);
    if (!this.sig && !this.msig) {
      let i = Dr(r);
      return Zs(i, e);
    }
    return this.sig ? Js(r, this.sig, e) : Qh(r, this.msig, e);
  }
  address() {
    let e = Jt(this.tag, this.logic), r = Dr(e);
    return Ue(new Uint8Array(r));
  }
  sign(e, r) {
    if (r == null)
      this.sig = this.signProgram(e);
    else {
      let i = r.addrs.map((o) => ({ pk: ut(o).publicKey }));
      this.msig = { v: r.version, thr: r.threshold, subsig: i };
      let [n, s2] = this.singleSignMultisig(e, this.msig);
      this.msig.subsig[s2].s = n;
    }
  }
  appendToMultisig(e) {
    if (this.msig === void 0)
      throw new Error("no multisig present");
    let [r, i] = this.singleSignMultisig(e, this.msig);
    this.msig.subsig[i].s = r;
  }
  signProgram(e) {
    let r = Jt(this.tag, this.logic);
    return vn(r, e);
  }
  singleSignMultisig(e, r) {
    let i = -1, n = bn(e).publicKey;
    for (let o = 0; o < r.subsig.length; o++) {
      let { pk: f } = r.subsig[o];
      if (Zs(f, n)) {
        i = o;
        break;
      }
    }
    if (i === -1)
      throw new Error("invalid secret key");
    return [this.signProgram(e), i];
  }
  toByte() {
    return tr(this.get_obj_for_encoding());
  }
  static fromByte(e) {
    let r = Kt(e);
    return Ni.from_obj_for_encoding(r);
  }
}, Zi = class {
  constructor(e, r) {
    this.lsig = new Ni(e, r), this.sigkey = void 0;
  }
  get_obj_for_encoding() {
    let e = { lsig: this.lsig.get_obj_for_encoding() };
    return this.sigkey && (e.sigkey = this.sigkey), e;
  }
  static from_obj_for_encoding(e) {
    let r = new Zi(e.lsig.l, e.lsig.arg);
    return r.lsig = Ni.from_obj_for_encoding(e.lsig), r.sigkey = e.sigkey, r;
  }
  toByte() {
    return tr(this.get_obj_for_encoding());
  }
  static fromByte(e) {
    let r = Kt(e);
    return Zi.from_obj_for_encoding(r);
  }
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig);
  }
  verify() {
    let e = this.address();
    return this.lsig.verify(ut(e).publicKey);
  }
  address() {
    if (this.lsig.sig && this.lsig.msig)
      throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
    if (this.lsig.sig) {
      if (!this.sigkey)
        throw new Error("Signing key for delegated account is missing");
      return Ue(this.sigkey);
    }
    if (this.lsig.msig) {
      let e = { version: this.lsig.msig.v, threshold: this.lsig.msig.thr, pks: this.lsig.msig.subsig.map((r) => r.pk) };
      return Ue(Vi(e));
    }
    return this.lsig.address();
  }
  signMultisig(e, r) {
    this.lsig.sign(r, e);
  }
  appendToMultisig(e) {
    this.lsig.appendToMultisig(e);
  }
  sign(e) {
    this.lsig.sign(e), this.sigkey = bn(e).publicKey;
  }
};
function pR(t, e, r) {
  if (!e.verify(r))
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  let i = { lsig: e.get_obj_for_encoding(), txn: t.get_obj_for_encoding() };
  return Dh(r, t.from.publicKey) || (i.sgnr = Fn.Buffer.from(r)), { txID: t.txID().toString(), blob: tr(i) };
}
function Fo(t, e) {
  let r, i;
  if (e instanceof Zi)
    r = e.lsig, i = ut(e.address()).publicKey;
  else if (r = e, r.sig)
    i = t.from.publicKey;
  else if (r.msig) {
    let n = { version: r.msig.v, threshold: r.msig.thr, pks: r.msig.subsig.map((s2) => s2.pk) };
    i = Vi(n);
  } else
    i = ut(r.address()).publicKey;
  return pR(t, r, i);
}
function U4(t, e) {
  let r = hi(t);
  return Fo(r, e);
}
function z4(t) {
  return Ni.fromByte(t);
}
var H4 = Fn.Buffer.from("ProgData");
function qg(t, e, r) {
  let i = Jt(ut(r).publicKey, e), n = Fn.Buffer.from(Jt(H4, i));
  return vn(n, t);
}
function $4(t, e, r, i) {
  let n = Jt(ut(e).publicKey, t), s2 = Fn.Buffer.from(Jt(H4, n));
  return Js(s2, r, i);
}
function G4(t, e, r) {
  let n = new Ni(r).address();
  return qg(t, e, n);
}
U();
U();
var K4 = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(t, e) {
  K4[t] = e;
});
function W4(t) {
  let e = [], r = 0, i = 0;
  for (let n = 0; n < t.length; n += 1) {
    let s2 = K4[t[n]];
    if (s2 === void 0)
      throw new Error("Invalid character (" + t[n] + ")");
    let o = s2 & 32;
    if (s2 &= 31, i += s2 << r, o)
      r += 5;
    else {
      let f = i & 1;
      i >>>= 1, f ? e.push(i === 0 ? -2147483648 : -i) : e.push(i), i = r = 0;
    }
  }
  return e;
}
var t0 = class {
  constructor({ version: e, sources: r, names: i, mappings: n }) {
    if (this.version = e, this.sources = r, this.names = i, this.mappings = n, this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    let s2 = this.mappings.split(";").map((f) => {
      let l = W4(f);
      if (l.length > 2)
        return l[2];
    });
    this.pcToLine = {}, this.lineToPc = {};
    let o = 0;
    for (let [f, l] of s2.entries())
      l !== void 0 && (o += l), o in this.lineToPc || (this.lineToPc[o] = []), this.lineToPc[o].push(f), this.pcToLine[f] = o;
  }
  getLineForPc(e) {
    return this.pcToLine[e];
  }
  getPcsForLine(e) {
    return this.lineToPc[e];
  }
};
U();
var mf = rr$1(or());
U();
U();
var yR = 1380011588, Pg = 30;
function V4(t) {
  return t.params["approval-program"] = mf.Buffer.from(t.params["approval-program"].toString(), "base64"), t.params["clear-state-program"] = mf.Buffer.from(t.params["clear-state-program"].toString(), "base64"), t;
}
async function bR({ client: t, txns: e, protocolVersion: r, latestTimestamp: i, round: n, sources: s2 }) {
  let o = [], f = [], l = [], m3 = [], A2 = [];
  for (let $ of e)
    $.txn.type === Pt.appl && (A2.push(Ue($.txn.from.publicKey)), $.txn.appAccounts && A2.push(...$.txn.appAccounts.map((re) => Ue(re.publicKey))), $.txn.appForeignApps && (l.push(...$.txn.appForeignApps), A2.push(...$.txn.appForeignApps.map((re) => Qs(re)))), $.txn.appForeignAssets && m3.push(...$.txn.appForeignAssets), $.txn.appIndex === void 0 || $.txn.appIndex === 0 ? o.push(new An({ id: yR, params: new En({ creator: Ue($.txn.from.publicKey), approvalProgram: $.txn.appApprovalProgram, clearStateProgram: $.txn.appClearProgram, localStateSchema: new pi({ numUint: $.txn.appLocalInts, numByteSlice: $.txn.appLocalByteSlices }), globalStateSchema: new pi({ numUint: $.txn.appGlobalInts, numByteSlice: $.txn.appGlobalByteSlices }) }) })) : (l.push($.txn.appIndex), A2.push(Qs($.txn.appIndex))));
  let F3 = [];
  for (let $ of [...new Set(m3)])
    F3.push(t.getAssetByID($).do().then((re) => {
      A2.push(re.params.creator);
    }));
  await Promise.all(F3);
  let z3 = [];
  for (let $ of [...new Set(l)])
    z3.push(t.getApplicationByID($).do().then((re) => {
      let W2 = V4(re);
      o.push(W2), A2.push(W2.params.creator);
    }));
  await Promise.all(z3);
  let V = [];
  for (let $ of [...new Set(A2)])
    V.push(t.accountInformation($).do().then((re) => {
      "created-apps" in re && (re["created-apps"] = re["created-apps"].map((W2) => V4(W2))), f.push(re);
    }));
  return await Promise.all(V), new ao({ txns: e.map(($) => ({ ...$, txn: $.txn.get_obj_for_encoding() })), accounts: f, apps: o, latestTimestamp: i, round: n, protocolVersion: r, sources: s2 });
}
var zg = class {
  constructor(e) {
    this.type = 0, this.bytes = "", this.uint = 0, this.type = e.type, this.bytes = e.bytes, this.uint = e.uint;
  }
  toString() {
    return this.type === 1 ? `0x${mf.Buffer.from(this.bytes, "base64").toString("hex")}` : this.uint.toString();
  }
}, Hg = class {
  constructor(e) {
    this.error = "", this.line = 0, this.pc = 0, this.scratch = [], this.stack = [], this.error = e.error === void 0 ? "" : e.error, this.line = e.line, this.pc = e.pc, this.scratch = e.scratch, this.stack = e.stack.map((r) => new zg(r));
  }
}, r0 = class {
  constructor(e) {
    this.trace = [], e != null && (this.trace = e.map((r) => new Hg(r)));
  }
};
function Ug(t, e) {
  return t.length > e && e > 0 ? `${t.slice(0, e)}...` : t;
}
function vR(t, e) {
  if (e.length === 0)
    return "";
  let r = null;
  for (let n = 0; n < e.length; n++) {
    if (n > t.length) {
      r = n;
      continue;
    }
    JSON.stringify(t[n]) !== JSON.stringify(e[n]) && (r = n);
  }
  if (r == null)
    return "";
  let i = e[r];
  return i.bytes.length > 0 ? `${r} = 0x${mf.Buffer.from(i.bytes, "base64").toString("hex")}` : `${r} = ${i.uint.toString()}`;
}
function wR(t, e) {
  return `[${(e ? t.reverse() : t).map((i) => {
    switch (i.type) {
      case 1:
        return `0x${mf.Buffer.from(i.bytes, "base64").toString("hex")}`;
      case 2:
        return `${i.uint.toString()}`;
      default:
        return "";
    }
  }).join(", ")}]`;
}
var yf = class {
  constructor(e) {
    this.disassembly = [], this.appCallMessages = [], this.localDeltas = [], this.globalDelta = [], this.cost = 0, this.logicSigMessages = [], this.logicSigDisassembly = [], this.logs = [], this.appCallTrace = void 0, this.logicSigTrace = void 0, this.required = ["disassembly"], this.optionals = ["app-call-messages", "local-deltas", "global-delta", "cost", "logic-sig-messages", "logic-sig-disassembly", "logs"], this.traces = ["app-call-trace", "logic-sig-trace"], this.disassembly = e.disassembly, this.appCallMessages = e["app-call-messages"], this.localDeltas = e["local-deltas"], this.globalDelta = e["global-delta"], this.cost = e.cost, this.logicSigMessages = e["logic-sig-messages"], this.logicSigDisassembly = e["logic-sig-disassembly"], this.logs = e.logs, this.appCallTrace = new r0(e["app-call-trace"]), this.logicSigTrace = new r0(e["logic-sig-trace"]);
  }
  appCallRejected() {
    return this.appCallMessages !== void 0 && this.appCallMessages.includes("REJECT");
  }
  logicSigRejected() {
    return this.logicSigMessages !== void 0 && this.logicSigMessages.includes("REJECT");
  }
  static trace(e, r, i) {
    let n = i.maxValueWidth || Pg, s2 = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let f = 0; f < e.trace.length; f++) {
      let { line: l, error: m3, pc: A2, scratch: F3, stack: z3 } = e.trace[f], V = F3 !== void 0 ? F3 : [], $ = f > 0 && e.trace[f - 1].scratch !== void 0 ? e.trace[f - 1].scratch : [], re = m3 === "" ? r[l] : `!! ${m3} !!`;
      s2.push([A2.toString().padEnd(3, " "), l.toString().padEnd(3, " "), Ug(re, n), Ug(vR($, V), n), Ug(wR(z3, i.topOfStackFirst), n)]);
    }
    let o = s2.reduce((f, l) => {
      let m3 = new Array(s2[0].length).fill(0);
      for (let A2 = 0; A2 < f.length; A2++)
        m3[A2] = l[A2].length > f[A2] ? l[A2].length : f[A2];
      return m3;
    }, new Array(s2[0].length).fill(0));
    return `${s2.map((f) => f.map((l, m3) => l.padEnd(o[m3] + 1, " ")).join("|").trim()).join(`
`)}
`;
  }
  appTrace(e) {
    if (this.appCallTrace === void 0 || !this.disassembly)
      return "";
    let r = e;
    return e === void 0 && (r = { maxValueWidth: Pg, topOfStackFirst: false }), yf.trace(this.appCallTrace, this.disassembly, r);
  }
  lsigTrace(e) {
    if (this.logicSigTrace === void 0 || this.logicSigDisassembly === void 0)
      return "";
    let r = e;
    return e === void 0 && (r = { maxValueWidth: Pg, topOfStackFirst: true }), yf.trace(this.logicSigTrace, this.logicSigDisassembly, r);
  }
}, $g = class {
  constructor(e) {
    this.error = "", this.protocolVersion = "", this.txns = [], this.error = e.error, this.protocolVersion = e["protocol-version"], this.txns = e.txns.map((r) => new yf(r));
  }
};
U();
function Y4(t, e, r, i, n, s2, o) {
  let f = { from: t, to: e, amount: r, closeRemainderTo: i, note: n, suggestedParams: s2, type: Pt.pay, reKeyTo: o };
  return new Ht(f);
}
function i0(t) {
  return Y4(t.from, t.to, t.amount, t.closeRemainderTo, t.note, t.suggestedParams, t.rekeyTo);
}
function J4(t, e, r, i, n, s2, o, f, l, m3 = false, A2 = void 0) {
  let F3 = { from: t, note: e, voteKey: r, selectionKey: i, voteFirst: n, voteLast: s2, voteKeyDilution: o, suggestedParams: f, type: Pt.keyreg, reKeyTo: l, nonParticipation: m3, stateProofKey: A2 };
  return new Ht(F3);
}
function xR(t) {
  return J4(t.from, t.note, t.voteKey, t.selectionKey, t.voteFirst, t.voteLast, t.voteKeyDilution, t.suggestedParams, t.rekeyTo, t.nonParticipation, t.stateProofKey);
}
function n0(t, e, r, i, n, s2, o, f, l, m3, A2, F3, z3, V, $) {
  let re = { from: t, note: e, suggestedParams: V, assetTotal: r, assetDecimals: i, assetDefaultFrozen: n, assetUnitName: m3, assetName: A2, assetURL: F3, assetMetadataHash: z3, assetManager: s2, assetReserve: o, assetFreeze: f, assetClawback: l, type: Pt.acfg, reKeyTo: $ };
  return new Ht(re);
}
function _R(t) {
  return n0(t.from, t.note, t.total, t.decimals, t.defaultFrozen, t.manager, t.reserve, t.freeze, t.clawback, t.unitName, t.assetName, t.assetURL, t.assetMetadataHash, t.suggestedParams, t.rekeyTo);
}
function Z4(t, e, r, i, n, s2, o, f, l = true, m3) {
  if (l && (i === void 0 || n === void 0 || s2 === void 0 || o === void 0))
    throw Error("strict empty address checking was turned on, but at least one empty address was provided");
  let A2 = { from: t, suggestedParams: f, assetIndex: r, assetManager: i, assetReserve: n, assetFreeze: s2, assetClawback: o, type: Pt.acfg, note: e, reKeyTo: m3 };
  return new Ht(A2);
}
function AR(t) {
  return Z4(t.from, t.note, t.assetIndex, t.manager, t.reserve, t.freeze, t.clawback, t.suggestedParams, t.strictEmptyAddressChecking, t.rekeyTo);
}
function s0(t, e, r, i, n) {
  let s2 = { from: t, suggestedParams: i, assetIndex: r, type: Pt.acfg, note: e, reKeyTo: n };
  return new Ht(s2);
}
function ER(t) {
  return s0(t.from, t.note, t.assetIndex, t.suggestedParams, t.rekeyTo);
}
function X4(t, e, r, i, n, s2, o) {
  let f = { from: t, type: Pt.afrz, freezeAccount: i, assetIndex: r, freezeState: n, note: e, suggestedParams: s2, reKeyTo: o };
  return new Ht(f);
}
function SR(t) {
  return X4(t.from, t.note, t.assetIndex, t.freezeTarget, t.freezeState, t.suggestedParams, t.rekeyTo);
}
function Q4(t, e, r, i, n, s2, o, f, l) {
  let m3 = { type: Pt.axfer, from: t, to: e, amount: n, suggestedParams: f, assetIndex: o, note: s2, assetRevocationTarget: i, closeRemainderTo: r, reKeyTo: l };
  return new Ht(m3);
}
function md(t) {
  return Q4(t.from, t.to, t.closeRemainderTo, t.revocationTarget, t.amount, t.note, t.assetIndex, t.suggestedParams, t.rekeyTo);
}
function yd(t, e, r, i, n, s2, o, f, l, m3, A2, F3, z3, V, $, re, W2, Z2) {
  let ue = { type: Pt.appl, from: t, suggestedParams: e, appIndex: 0, appOnComplete: r, appLocalInts: s2, appLocalByteSlices: o, appGlobalInts: f, appGlobalByteSlices: l, appApprovalProgram: i, appClearProgram: n, appArgs: m3, appAccounts: A2, appForeignApps: F3, appForeignAssets: z3, boxes: Z2, note: V, lease: $, reKeyTo: re, extraPages: W2 };
  return new Ht(ue);
}
function Gg(t) {
  return yd(t.from, t.suggestedParams, t.onComplete, t.approvalProgram, t.clearProgram, t.numLocalInts, t.numLocalByteSlices, t.numGlobalInts, t.numGlobalByteSlices, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.extraPages, t.boxes);
}
function o0(t, e, r, i, n, s2, o, f, l, m3, A2, F3, z3) {
  let V = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r, appApprovalProgram: i, appOnComplete: hr.UpdateApplicationOC, appClearProgram: n, appArgs: s2, appAccounts: o, appForeignApps: f, appForeignAssets: l, boxes: z3, note: m3, lease: A2, reKeyTo: F3 };
  return new Ht(V);
}
function MR(t) {
  return o0(t.from, t.suggestedParams, t.appIndex, t.approvalProgram, t.clearProgram, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function a0(t, e, r, i, n, s2, o, f, l, m3, A2) {
  let F3 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r, appOnComplete: hr.DeleteApplicationOC, appArgs: i, appAccounts: n, appForeignApps: s2, appForeignAssets: o, boxes: A2, note: f, lease: l, reKeyTo: m3 };
  return new Ht(F3);
}
function IR(t) {
  return a0(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function e8(t, e, r, i, n, s2, o, f, l, m3, A2) {
  let F3 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r, appOnComplete: hr.OptInOC, appArgs: i, appAccounts: n, appForeignApps: s2, appForeignAssets: o, boxes: A2, note: f, lease: l, reKeyTo: m3 };
  return new Ht(F3);
}
function Kg(t) {
  return e8(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function t8(t, e, r, i, n, s2, o, f, l, m3, A2) {
  let F3 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r, appOnComplete: hr.CloseOutOC, appArgs: i, appAccounts: n, appForeignApps: s2, appForeignAssets: o, boxes: A2, note: f, lease: l, reKeyTo: m3 };
  return new Ht(F3);
}
function Wg(t) {
  return t8(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function r8(t, e, r, i, n, s2, o, f, l, m3, A2) {
  let F3 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r, appOnComplete: hr.ClearStateOC, appArgs: i, appAccounts: n, appForeignApps: s2, appForeignAssets: o, boxes: A2, note: f, lease: l, reKeyTo: m3 };
  return new Ht(F3);
}
function TR(t) {
  return r8(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function i8(t, e, r, i, n, s2, o, f, l, m3, A2) {
  let F3 = { type: Pt.appl, from: t, suggestedParams: e, appIndex: r, appOnComplete: hr.NoOpOC, appArgs: i, appAccounts: n, appForeignApps: s2, appForeignAssets: o, boxes: A2, note: f, lease: l, reKeyTo: m3 };
  return new Ht(F3);
}
function f0(t) {
  return i8(t.from, t.suggestedParams, t.appIndex, t.appArgs, t.accounts, t.foreignApps, t.foreignAssets, t.note, t.lease, t.rekeyTo, t.boxes);
}
function Vg(t) {
  let e = { type: Pt.appl, from: t.from, suggestedParams: t.suggestedParams, appIndex: t.appIndex, appOnComplete: t.onComplete, appLocalInts: t.numLocalInts, appLocalByteSlices: t.numLocalByteSlices, appGlobalInts: t.numGlobalInts, appGlobalByteSlices: t.numGlobalByteSlices, appApprovalProgram: t.approvalProgram, appClearProgram: t.clearProgram, appArgs: t.appArgs, appAccounts: t.accounts, appForeignApps: t.foreignApps, appForeignAssets: t.foreignAssets, boxes: t.boxes, note: t.note, lease: t.lease, reKeyTo: t.rekeyTo, extraPages: t.extraPages };
  return new Ht(e);
}
U();
function FR(t) {
  return (e, r) => {
    let i = [];
    for (let n of r)
      i.push(e[n].signTxn(t.sk));
    return Promise.resolve(i);
  };
}
function RR(t) {
  return (e, r) => {
    let i = [];
    for (let n of r) {
      let { blob: s2 } = Fo(e[n], t);
      i.push(s2);
    }
    return Promise.resolve(i);
  };
}
function kR(t, e) {
  return (r, i) => {
    let n = [];
    for (let s2 of i) {
      let o = r[s2], f = [];
      for (let l of e) {
        let { blob: m3 } = e0(o, t, l);
        f.push(m3);
      }
      n.push(gf(f));
    }
    return Promise.resolve(n);
  };
}
function DR() {
  return (t, e) => {
    let r = [];
    for (let i of e)
      r.push(Rg(t[i]));
    return Promise.resolve(r);
  };
}
function c0(t) {
  return typeof t == "object" && Object.keys(t).length === 2 && typeof t.txn == "object" && typeof t.signer == "function";
}
U();
var Qg = rr$1(or());
U();
U();
var bf = rr$1(or());
var Ro = 2 ** 16 - 1, n8 = 32, s8 = 1, o8 = 1, Or = 2, BR = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/, NR = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/, pr = class {
  static from(e) {
    if (e.endsWith("[]")) {
      let r = pr.from(e.slice(0, e.length - 2));
      return new Af(r);
    }
    if (e.endsWith("]")) {
      let r = e.match(BR);
      if (r.length !== 3)
        throw new Error(`malformed static array string: ${e}`);
      let i = r[2], n = parseInt(i, 10);
      if (n > Ro)
        throw new Error(`array length exceeds limit ${Ro}`);
      let s2 = pr.from(r[1]);
      return new _f2(s2, n);
    }
    if (e.startsWith("uint")) {
      let r = (s2) => [...s2].every((o) => "0123456789".includes(o)), i = e.slice(4, e.length);
      if (!r(i))
        throw new Error(`malformed uint string: ${i}`);
      let n = parseInt(i, 10);
      if (n > Ro)
        throw new Error(`malformed uint string: ${n}`);
      return new Xi(n);
    }
    if (e === "byte")
      return new wf();
    if (e.startsWith("ufixed")) {
      let r = e.match(NR);
      if (r.length !== 3)
        throw new Error(`malformed ufixed type: ${e}`);
      let i = parseInt(r[1], 10), n = parseInt(r[2], 10);
      return new vf(i, n);
    }
    if (e === "bool")
      return new Ci();
    if (e === "address")
      return new as();
    if (e === "string")
      return new xf();
    if (e.length >= 2 && e[0] === "(" && e[e.length - 1] === ")") {
      let r = Yr.parseTupleContent(e.slice(1, e.length - 1)), i = [];
      for (let n = 0; n < r.length; n++) {
        let s2 = pr.from(r[n]);
        i.push(s2);
      }
      return new Yr(i);
    }
    throw new Error(`cannot convert a string ${e} to an ABI type`);
  }
}, Xi = class extends pr {
  constructor(e) {
    if (super(), e % 8 !== 0 || e < 8 || e > 512)
      throw new Error(`unsupported uint type bitSize: ${e}`);
    this.bitSize = e;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(e) {
    return e instanceof Xi && this.bitSize === e.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(e) {
    if (typeof e != "bigint" && typeof e != "number")
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${e}`);
    if (e >= BigInt(2 ** this.bitSize) || e < BigInt(0))
      throw new Error(`${e} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    if (typeof e == "number" && !Number.isSafeInteger(e))
      throw new Error(`${e} should be converted into a BigInt before it is encoded`);
    return Tn(e, this.bitSize / 8);
  }
  decode(e) {
    if (e.length !== this.bitSize / 8)
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    return pd(e);
  }
}, vf = class extends pr {
  constructor(e, r) {
    if (super(), e % 8 !== 0 || e < 8 || e > 512)
      throw new Error(`unsupported ufixed type bitSize: ${e}`);
    if (r > 160 || r < 1)
      throw new Error(`unsupported ufixed type precision: ${r}`);
    this.bitSize = e, this.precision = r;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(e) {
    return e instanceof vf && this.bitSize === e.bitSize && this.precision === e.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(e) {
    if (typeof e != "bigint" && typeof e != "number")
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (e >= BigInt(2 ** this.bitSize) || e < BigInt(0))
      throw new Error(`${e} is not a non-negative int or too big to fit in size ${this.toString()}`);
    if (typeof e == "number" && !Number.isSafeInteger(e))
      throw new Error(`${e} should be converted into a BigInt before it is encoded`);
    return Tn(e, this.bitSize / 8);
  }
  decode(e) {
    if (e.length !== this.bitSize / 8)
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    return pd(e);
  }
}, as = class extends pr {
  toString() {
    return "address";
  }
  equals(e) {
    return e instanceof as;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return n8;
  }
  encode(e) {
    if (typeof e != "string" && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (typeof e == "string")
      return ut(e).publicKey;
    if (e.byteLength !== 32)
      throw new Error("byte string must be 32 bytes long for an address");
    return e;
  }
  decode(e) {
    if (e.byteLength !== 32)
      throw new Error("byte string must be 32 bytes long for an address");
    return Ue(e);
  }
}, Ci = class extends pr {
  toString() {
    return "bool";
  }
  equals(e) {
    return e instanceof Ci;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return o8;
  }
  encode(e) {
    if (typeof e != "boolean")
      throw new Error(`Cannot encode value as bool: ${e}`);
    return e ? new Uint8Array([128]) : new Uint8Array([0]);
  }
  decode(e) {
    if (e.byteLength !== 1)
      throw new Error("bool string must be 1 byte long");
    let r = e[0];
    if (r === 128)
      return true;
    if (r === 0)
      return false;
    throw new Error("boolean could not be decoded from the byte string");
  }
}, wf = class extends pr {
  toString() {
    return "byte";
  }
  equals(e) {
    return e instanceof wf;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return s8;
  }
  encode(e) {
    if (typeof e != "number" && typeof e != "bigint")
      throw new Error(`Cannot encode value as byte: ${e}`);
    if (typeof e == "bigint" && (e = Number(e)), e < 0 || e > 255)
      throw new Error(`${e} cannot be encoded into a byte`);
    return new Uint8Array([e]);
  }
  decode(e) {
    if (e.byteLength !== 1)
      throw new Error("byte string must be 1 byte long");
    return e[0];
  }
}, xf = class extends pr {
  toString() {
    return "string";
  }
  equals(e) {
    return e instanceof xf;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(e) {
    if (typeof e != "string" && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as string: ${e}`);
    let r = bf.Buffer.from(e), i = Tn(r.length, Or), n = new Uint8Array(r.length + Or);
    return n.set(i), n.set(r, Or), n;
  }
  decode(e) {
    if (e.length < Or)
      throw new Error(`byte string is too short to be decoded. Actual length is ${e.length}, but expected at least ${Or}`);
    let i = bf.Buffer.from(e).readUIntBE(0, Or), n = e.slice(Or, e.length);
    if (i !== n.length)
      throw new Error(`string length bytes do not match the actual length of string. Expected ${i}, got ${n.length}`);
    return bf.Buffer.from(n).toString("utf-8");
  }
}, _f2 = class extends pr {
  constructor(e, r) {
    if (super(), r < 0)
      throw new Error(`static array must have a non negative length: ${r}`);
    this.childType = e, this.staticLength = r;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(e) {
    return e instanceof _f2 && this.staticLength === e.staticLength && this.childType.equals(e.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    return this.childType.constructor === Ci ? Math.ceil(this.staticLength / 8) : this.staticLength * this.childType.byteLen();
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    if (e.length !== this.staticLength)
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${e.length}`);
    return this.toABITupleType().encode(e);
  }
  decode(e) {
    return this.toABITupleType().decode(e);
  }
  toABITupleType() {
    return new Yr(Array(this.staticLength).fill(this.childType));
  }
}, Af = class extends pr {
  constructor(e) {
    super(), this.childType = e;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(e) {
    return e instanceof Af && this.childType.equals(e.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    let r = this.toABITupleType(e.length), i = r.encode(e), n = Tn(r.childTypes.length, Or);
    return Jt(n, i);
  }
  decode(e) {
    let i = bf.Buffer.from(e).readUIntBE(0, Or);
    return this.toABITupleType(i).decode(e.slice(Or, e.length));
  }
  toABITupleType(e) {
    return new Yr(Array(e).fill(this.childType));
  }
}, Yr = class extends pr {
  constructor(e) {
    if (super(), e.length >= Ro)
      throw new Error("tuple type child type number larger than maximum uint16 error");
    this.childTypes = e;
  }
  toString() {
    let e = [];
    for (let r = 0; r < this.childTypes.length; r++)
      e[r] = this.childTypes[r].toString();
    return `(${e.join(",")})`;
  }
  equals(e) {
    return e instanceof Yr && this.childTypes.length === e.childTypes.length && this.childTypes.every((r, i) => r.equals(e.childTypes[i]));
  }
  isDynamic() {
    let e = (r) => r.isDynamic();
    return this.childTypes.some(e);
  }
  byteLen() {
    let e = 0;
    for (let r = 0; r < this.childTypes.length; r++)
      if (this.childTypes[r].constructor === Ci) {
        let i = bd(this.childTypes, r, 1), n = i + 1;
        r += i, e += Math.trunc((n + 7) / 8);
      } else
        e += this.childTypes[r].byteLen();
    return e;
  }
  encode(e) {
    if (!Array.isArray(e) && !(e instanceof Uint8Array))
      throw new Error(`Cannot encode value as ${this.toString()}: ${e}`);
    let r = Array.from(e);
    if (e.length > Ro)
      throw new Error("length of tuple array should not exceed a uint16");
    let i = this.childTypes, n = [], s2 = [], o = /* @__PURE__ */ new Map(), f = 0;
    for (; f < i.length; ) {
      let A2 = i[f];
      if (A2.isDynamic())
        o.set(n.length, true), n.push(new Uint8Array([0, 0])), s2.push(A2.encode(r[f]));
      else {
        if (A2.constructor === Ci) {
          let F3 = bd(i, f, -1), z3 = bd(i, f, 1);
          if (F3 % 8 !== 0)
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          z3 = Math.min(7, z3);
          let V = CR(r.slice(f, f + z3 + 1));
          n.push(Tn(V, 1)), f += z3;
        } else {
          let F3 = A2.encode(r[f]);
          n.push(F3);
        }
        o.set(f, false), s2.push(new Uint8Array());
      }
      f += 1;
    }
    let l = 0;
    for (let A2 of n)
      l += A2.length;
    let m3 = 0;
    for (let A2 = 0; A2 < n.length; A2++) {
      if (o.get(A2)) {
        let F3 = l + m3;
        if (F3 > Ro)
          throw new Error(`byte length of ${F3} should not exceed a uint16`);
        n[A2] = Tn(F3, Or);
      }
      m3 += s2[A2].length;
    }
    return Jt(...n, ...s2);
  }
  decode(e) {
    let r = this.childTypes, i = [], n = [], s2 = 0, o = 0, f = bf.Buffer.from(e);
    for (; s2 < r.length; ) {
      let A2 = r[s2];
      if (A2.isDynamic()) {
        if (e.slice(o, e.length).length < Or)
          throw new Error("dynamic type in tuple is too short to be decoded");
        let F3 = f.readUIntBE(o, Or);
        if (i.length > 0 && (i[i.length - 1].right = F3, F3 < i[i.length - 1].left))
          throw new Error("dynamic index segment miscalculation: left is greater than right index");
        let z3 = { left: F3, right: -1 };
        i.push(z3), n.push(null), o += Or;
      } else if (A2.constructor === Ci) {
        let F3 = bd(this.childTypes, s2, -1), z3 = bd(this.childTypes, s2, 1);
        if (F3 % 8 !== 0)
          throw new Error("expected before bool number mod 8 === 0");
        z3 = Math.min(7, z3);
        for (let V = 0; V <= z3; V++) {
          let $ = 128 >> V;
          (e[o] & $) > 0 ? n.push(new Uint8Array([128])) : n.push(new Uint8Array([0]));
        }
        s2 += z3, o += 1;
      } else {
        let F3 = A2.byteLen();
        n.push(e.slice(o, o + F3)), o += F3;
      }
      if (s2 !== r.length - 1 && o >= e.length)
        throw new Error("input byte not enough to decode");
      s2 += 1;
    }
    if (i.length > 0 && (i[i.length - 1].right = e.length, o = e.length), o < e.length)
      throw new Error("input byte not fully consumed");
    for (let A2 = 0; A2 < i.length; A2++) {
      let F3 = i[A2];
      if (F3.left > F3.right)
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      if (A2 !== i.length - 1 && F3.right !== i[A2 + 1].left)
        throw new Error("dynamic segment should be consecutive");
    }
    let l = 0;
    for (let A2 = 0; A2 < r.length; A2++)
      r[A2].isDynamic() && (n[A2] = e.slice(i[l].left, i[l].right), l += 1);
    let m3 = [];
    for (let A2 = 0; A2 < r.length; A2++) {
      let F3 = r[A2].decode(n[A2]);
      m3.push(F3);
    }
    return m3;
  }
  static parseTupleContent(e) {
    if (e.length === 0)
      return [];
    if (e.endsWith(",") || e.startsWith(","))
      throw new Error("tuple string should not start with comma");
    if (e.includes(",,"))
      throw new Error("tuple string should not have consecutive commas");
    let r = [], i = 0, n = "";
    for (let s2 of e)
      n += s2, s2 === "(" ? i += 1 : s2 === ")" ? i -= 1 : s2 === "," && i === 0 && (r.push(n.slice(0, n.length - 1)), n = "");
    if (n.length !== 0 && r.push(n), i !== 0)
      throw new Error("tuple string has mismatched parentheses");
    return r;
  }
};
function CR(t) {
  let e = 0;
  if (t.length > 8)
    throw new Error("value list passed in should be no greater than length 8");
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    if (typeof i != "boolean")
      throw new Error("non-boolean values cannot be compressed into a byte");
    i && (e |= 1 << 7 - r);
  }
  return e;
}
function bd(t, e, r) {
  let i = 0;
  for (; ; ) {
    let n = e + r * i;
    if (t[n].constructor === Ci)
      if (n !== t.length - 1 && r === 1)
        i += 1;
      else if (n > 0 && r === -1)
        i += 1;
      else
        break;
    else {
      i -= 1;
      break;
    }
  }
  return i;
}
U();
U();
U();
var Oi;
(function(t) {
  t.any = "txn", t.pay = "pay", t.keyreg = "keyreg", t.acfg = "acfg", t.axfer = "axfer", t.afrz = "afrz", t.appl = "appl";
})(Oi || (Oi = {}));
function Ef(t) {
  return t === Oi.any || t === Oi.pay || t === Oi.keyreg || t === Oi.acfg || t === Oi.axfer || t === Oi.afrz || t === Oi.appl;
}
function Yg(t, e) {
  return t === Oi.any ? true : e.type && e.type.toString() === t.toString();
}
U();
var Qi;
(function(t) {
  t.account = "account", t.application = "application", t.asset = "asset";
})(Qi || (Qi = {}));
function vd(t) {
  return t === Qi.account || t === Qi.application || t === Qi.asset;
}
function OR(t) {
  let e = t.indexOf("(");
  if (e === -1)
    throw new Error(`Invalid method signature: ${t}`);
  let r = -1, i = 0;
  for (let n = e; n < t.length; n++) {
    let s2 = t[n];
    if (s2 === "(")
      i += 1;
    else if (s2 === ")") {
      if (i === 0)
        break;
      if (i -= 1, i === 0) {
        r = n;
        break;
      }
    }
  }
  if (r === -1)
    throw new Error(`Invalid method signature: ${t}`);
  return { name: t.slice(0, e), args: Yr.parseTupleContent(t.slice(e + 1, r)), returns: t.slice(r + 1) };
}
var en = class {
  constructor(e) {
    if (typeof e.name != "string" || typeof e.returns != "object" || !Array.isArray(e.args))
      throw new Error("Invalid ABIMethod parameters");
    this.name = e.name, this.description = e.desc, this.args = e.args.map(({ type: r, name: i, desc: n }) => Ef(r) || vd(r) ? { type: r, name: i, description: n } : { type: pr.from(r), name: i, description: n }), this.returns = { type: e.returns.type === "void" ? e.returns.type : pr.from(e.returns.type), description: e.returns.desc };
  }
  getSignature() {
    let e = this.args.map((i) => i.type.toString()).join(","), r = this.returns.type.toString();
    return `${this.name}(${e})${r}`;
  }
  getSelector() {
    let e = Dr(this.getSignature());
    return new Uint8Array(e.slice(0, 4));
  }
  txnCount() {
    let e = 1;
    for (let r of this.args)
      typeof r.type == "string" && Ef(r.type) && (e += 1);
    return e;
  }
  toJSON() {
    return { name: this.name, desc: this.description, args: this.args.map(({ type: e, name: r, description: i }) => ({ type: e.toString(), name: r, desc: i })), returns: { type: this.returns.type.toString(), desc: this.returns.description } };
  }
  static fromSignature(e) {
    let { name: r, args: i, returns: n } = OR(e);
    return new en({ name: r, args: i.map((s2) => ({ type: s2 })), returns: { type: n } });
  }
};
function wd(t, e) {
  if (t === null || !Array.isArray(t) || !t.every((i) => i instanceof en))
    throw new Error("Methods list provided is null or not the correct type");
  let r = t.filter((i) => i.name === e);
  if (r.length > 1)
    throw new Error(`found ${r.length} methods with the same name ${r.map((i) => i.getSignature()).join(",")}`);
  if (r.length === 0)
    throw new Error(`found 0 methods with the name ${e}`);
  return r[0];
}
var Jg = class {
  constructor(e) {
    if (typeof e.name != "string" || !Array.isArray(e.methods) || e.networks && typeof e.networks != "object")
      throw new Error("Invalid ABIContract parameters");
    this.name = e.name, this.description = e.desc, this.networks = e.networks ? { ...e.networks } : {}, this.methods = e.methods.map((r) => new en(r));
  }
  toJSON() {
    return { name: this.name, desc: this.description, networks: this.networks, methods: this.methods.map((e) => e.toJSON()) };
  }
  getMethodByName(e) {
    return wd(this.methods, e);
  }
};
U();
var Zg = class {
  constructor(e) {
    if (typeof e.name != "string" || !Array.isArray(e.methods))
      throw new Error("Invalid ABIInterface parameters");
    this.name = e.name, this.description = e.desc, this.methods = e.methods.map((r) => new en(r));
  }
  toJSON() {
    return { name: this.name, desc: this.description, methods: this.methods.map((e) => e.toJSON()) };
  }
  getMethodByName(e) {
    return wd(this.methods, e);
  }
};
var jR = Qg.Buffer.from([21, 31, 124, 117]), xd = 16, Nr;
(function(t) {
  t[t.BUILDING = 0] = "BUILDING", t[t.BUILT = 1] = "BUILT", t[t.SIGNED = 2] = "SIGNED", t[t.SUBMITTED = 3] = "SUBMITTED", t[t.COMMITTED = 4] = "COMMITTED";
})(Nr || (Nr = {}));
function Xg(t, e, r) {
  if (r != null && t === r)
    return 0;
  let i = r == null ? 0 : 1;
  for (let n = 0; n < e.length; n++)
    if (t === e[n])
      return n + i;
  return e.push(t), e.length - 1 + i;
}
var mi = class {
  constructor() {
    this.status = Nr.BUILDING, this.transactions = [], this.methodCalls = /* @__PURE__ */ new Map(), this.signedTxns = [], this.txIDs = [];
  }
  getStatus() {
    return this.status;
  }
  count() {
    return this.transactions.length;
  }
  clone() {
    let e = new mi();
    return e.transactions = this.transactions.map(({ txn: r, signer: i }) => ({ txn: Ht.from_obj_for_encoding({ ...r.get_obj_for_encoding(), grp: void 0 }), signer: i })), e.methodCalls = new Map(this.methodCalls), e;
  }
  addTransaction(e) {
    if (this.status !== Nr.BUILDING)
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    if (this.transactions.length === mi.MAX_GROUP_SIZE)
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${mi.MAX_GROUP_SIZE}`);
    if (e.txn.group && e.txn.group.some((r) => r !== 0))
      throw new Error("Cannot add a transaction with nonzero group ID");
    this.transactions.push(e);
  }
  addMethodCall({ appID: e, method: r, methodArgs: i, sender: n, suggestedParams: s2, onComplete: o, approvalProgram: f, clearProgram: l, numGlobalInts: m3, numGlobalByteSlices: A2, numLocalInts: F3, numLocalByteSlices: z3, extraPages: V, appAccounts: $, appForeignApps: re, appForeignAssets: W2, boxes: Z2, note: ue, lease: ge, rekeyTo: Se, signer: pe2 }) {
    if (this.status !== Nr.BUILDING)
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    if (this.transactions.length + r.txnCount() > mi.MAX_GROUP_SIZE)
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${mi.MAX_GROUP_SIZE}`);
    if (e === 0) {
      if (f == null || l == null || m3 == null || A2 == null || F3 == null || z3 == null)
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
    } else if (o === hr.UpdateApplicationOC) {
      if (f == null || l == null)
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      if (m3 != null || A2 != null || F3 != null || z3 != null || V != null)
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    } else if (f != null || l != null || m3 != null || A2 != null || F3 != null || z3 != null || V != null)
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    if (i == null && (i = []), i.length !== r.args.length)
      throw new Error(`Incorrect number of method arguments. Expected ${r.args.length}, got ${i.length}`);
    let H2 = [], le = [], ie = [], se = [], N3 = [], c2 = /* @__PURE__ */ new Map(), p2 = Z2 || [];
    for (let u = 0; u < i.length; u++) {
      let E2 = r.args[u].type, B = i[u];
      if (Ef(E2)) {
        if (!c0(B) || !Yg(E2, B.txn))
          throw new Error(`Expected ${E2} TransactionWithSigner for argument at index ${u}`);
        if (B.txn.group && B.txn.group.some((y2) => y2 !== 0))
          throw new Error("Cannot add a transaction with nonzero group ID");
        ie.push(B);
        continue;
      }
      if (c0(B))
        throw new Error(`Expected non-transaction value for argument at index ${u}`);
      if (vd(E2) && (c2.set(se.length, H2.length), se.push(E2), N3.push(B), E2 = new Xi(8)), typeof E2 == "string")
        throw new Error(`Unknown ABI type: ${E2}`);
      H2.push(E2), le.push(B);
    }
    let h2 = [], a = $ == null ? [] : $.slice(), d2 = re == null ? [] : re.slice(), b2 = W2 == null ? [] : W2.slice();
    for (let u = 0; u < se.length; u++) {
      let E2 = se[u], B = N3[u], y2 = 0;
      switch (E2) {
        case Qi.account: {
          let M = new as(), de2 = M.decode(M.encode(B));
          y2 = Xg(de2, a, n);
          break;
        }
        case Qi.application: {
          let M = new Xi(64), de2 = M.decode(M.encode(B));
          if (de2 > Number.MAX_SAFE_INTEGER)
            throw new Error(`Expected safe integer for application value, got ${de2}`);
          y2 = Xg(Number(de2), d2, e);
          break;
        }
        case Qi.asset: {
          let M = new Xi(64), de2 = M.decode(M.encode(B));
          if (de2 > Number.MAX_SAFE_INTEGER)
            throw new Error(`Expected safe integer for asset value, got ${de2}`);
          y2 = Xg(Number(de2), b2);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${E2}`);
      }
      h2.push(y2);
    }
    for (let u = 0; u < h2.length; u++) {
      let E2 = c2.get(u);
      le[E2] = h2[u];
    }
    if (H2.length > xd - 1) {
      let u = H2.slice(xd - 2), E2 = le.slice(xd - 2);
      H2 = H2.slice(0, xd - 2), le = le.slice(0, xd - 2), H2.push(new Yr(u)), le.push(E2);
    }
    let _2 = [r.getSelector()];
    for (let u = 0; u < H2.length; u++)
      _2.push(H2[u].encode(le[u]));
    let v = { txn: Vg({ from: n, appIndex: e, appArgs: _2, accounts: a, foreignApps: d2, foreignAssets: b2, boxes: p2, onComplete: o ?? hr.NoOpOC, approvalProgram: f, clearProgram: l, numGlobalInts: m3, numGlobalByteSlices: A2, numLocalInts: F3, numLocalByteSlices: z3, extraPages: V, lease: ge, note: ue, rekeyTo: Se, suggestedParams: s2 }), signer: pe2 };
    this.transactions.push(...ie, v), this.methodCalls.set(this.transactions.length - 1, r);
  }
  buildGroup() {
    if (this.status === Nr.BUILDING) {
      if (this.transactions.length === 0)
        throw new Error("Cannot build a group with 0 transactions");
      this.transactions.length > 1 && Xh(this.transactions.map((e) => e.txn)), this.status = Nr.BUILT;
    }
    return this.transactions;
  }
  async gatherSignatures() {
    if (this.status >= Nr.SIGNED)
      return this.signedTxns;
    let e = this.buildGroup(), r = e.map((l) => l.txn), i = /* @__PURE__ */ new Map();
    for (let l = 0; l < e.length; l++) {
      let { signer: m3 } = e[l];
      i.has(m3) || i.set(m3, []), i.get(m3).push(l);
    }
    let n = Array.from(i), s2 = await Promise.all(n.map(([l, m3]) => l(r, m3))), o = e.map(() => null);
    for (let l = 0; l < n.length; l++) {
      let m3 = n[l][1], A2 = s2[l];
      for (let F3 = 0; F3 < m3.length; F3++)
        o[m3[F3]] = A2[F3];
    }
    if (!o.every((l) => l != null))
      throw new Error(`Missing signatures. Got ${o}`);
    let f = o.map((l, m3) => {
      try {
        return xn(l).txn.txID();
      } catch (A2) {
        throw new Error(`Cannot decode signed transaction at index ${m3}. ${A2}`);
      }
    });
    return this.signedTxns = o, this.txIDs = f, this.status = Nr.SIGNED, o;
  }
  async submit(e) {
    if (this.status > Nr.SUBMITTED)
      throw new Error("Transaction group cannot be resubmitted");
    let r = await this.gatherSignatures();
    return await e.sendRawTransaction(r).do(), this.status = Nr.SUBMITTED, this.txIDs;
  }
  async simulate(e, r) {
    if (this.status > Nr.SUBMITTED)
      throw new Error("Simulated Transaction group has already been submitted to the network");
    let n = (await this.gatherSignatures()).map((l) => Kt(l)), s2 = r ?? new Sn({ txnGroups: [] });
    s2.txnGroups = [new Ji({ txns: n })];
    let o = await e.simulateTransactions(s2).do(), f = [];
    for (let [l, m3] of this.methodCalls) {
      let A2 = this.txIDs[l], F3 = o.txnGroups[0].txnResults[l].txnResult, z3 = { txID: A2, rawReturnValue: new Uint8Array(), method: m3 };
      f.push(mi.parseMethodResponse(m3, z3, F3.get_obj_for_encoding()));
    }
    return { methodResults: f, simulateResponse: o };
  }
  async execute(e, r) {
    if (this.status === Nr.COMMITTED)
      throw new Error("Transaction group has already been executed successfully");
    let i = await this.submit(e);
    this.status = Nr.SUBMITTED;
    let n = this.transactions.findIndex((m3, A2) => this.methodCalls.has(A2)), o = await Wh(e, i[n === -1 ? 0 : n], r);
    this.status = Nr.COMMITTED;
    let f = o["confirmed-round"], l = [];
    for (let [m3, A2] of this.methodCalls) {
      let F3 = i[m3], z3 = { txID: F3, rawReturnValue: new Uint8Array(), method: A2 };
      try {
        let V = m3 === n ? o : await e.pendingTransactionInformation(F3).do();
        z3 = mi.parseMethodResponse(A2, z3, V);
      } catch (V) {
        z3.decodeError = V;
      }
      l.push(z3);
    }
    return { confirmedRound: f, txIDs: i, methodResults: l };
  }
  static parseMethodResponse(e, r, i) {
    let n = r;
    try {
      if (n.txInfo = i, e.returns.type !== "void") {
        let s2 = i.logs || [];
        if (s2.length === 0)
          throw new Error("App call transaction did not log a return value");
        let o = Qg.Buffer.from(s2[s2.length - 1], "base64");
        if (o.byteLength < 4 || !o.slice(0, 4).equals(jR))
          throw new Error("App call transaction did not log a return value");
        n.rawReturnValue = new Uint8Array(o.slice(4)), n.returnValue = e.returns.type.decode(r.rawReturnValue);
      }
    } catch (s2) {
      n.decodeError = s2;
    }
    return n;
  }
};
mi.MAX_GROUP_SIZE = 16;
U();
U();
U();
var a8 = u0.Buffer.from([77, 88]), f8 = "The transaction sender address and multisig preimage do not match.";
function LR(t, e) {
  if (typeof t.from > "u") {
    let i = bn(e);
    t.from = Ue(i.publicKey);
  }
  let r = hi(t);
  return { txID: r.txID().toString(), blob: r.signTxn(e) };
}
function qR(t, e) {
  return new Fc(t).signBid(e);
}
function PR(t, e) {
  let r = u0.Buffer.from(Jt(a8, t));
  return vn(r, e);
}
function UR(t, e, r) {
  let i = u0.Buffer.from(Jt(a8, t)), n = ut(r).publicKey;
  return Js(i, e, n);
}
function zR(t) {
  return new Uint8Array(tr(t));
}
function jr(t) {
  return Kt(t);
}
var HR = new Error(f8), $R = new Error(Rc);
var tm = em;
U();
U();
U();
U();
function rm(t, e) {
  let r = /* @__PURE__ */ Object.create(null), i = t.split(",");
  for (let n = 0; n < i.length; n++)
    r[i[n]] = true;
  return e ? (n) => !!r[n.toLowerCase()] : (n) => !!r[n];
}
W.default.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
W.default.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
var d0 = () => {
};
var im = Object.assign;
var GR = Object.prototype.hasOwnProperty, _d2 = (t, e) => GR.call(t, e), yi = Array.isArray, Sf = (t) => u8(t) === "[object Map]";
var Rn = (t) => typeof t == "function", KR = (t) => typeof t == "string", l0 = (t) => typeof t == "symbol", fs = (t) => t !== null && typeof t == "object", c8 = (t) => fs(t) && Rn(t.then) && Rn(t.catch), WR = Object.prototype.toString, u8 = (t) => WR.call(t), nm = (t) => u8(t).slice(8, -1);
var h0 = (t) => KR(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t;
var p0 = (t) => {
  let e = /* @__PURE__ */ Object.create(null);
  return (r) => e[r] || (e[r] = t(r));
}, sm = p0((t) => t.charAt(0).toUpperCase() + t.slice(1)), Mf = (t, e) => !Object.is(t, e);
var d8 = (t, e, r) => {
  Object.defineProperty(t, e, { configurable: true, enumerable: false, value: r });
};
var JR = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
rm(JR + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");
function l8(t, ...e) {
  console.warn(`[Vue warn] ${t}`, ...e);
}
var ZR;
function XR(t, e = ZR) {
  e && e.active && e.effects.push(t);
}
var Ed = (t) => {
  let e = new Set(t);
  return e.w = 0, e.n = 0, e;
}, w8 = (t) => (t.w & ds) > 0, x8 = (t) => (t.n & ds) > 0, QR = ({ deps: t }) => {
  if (t.length)
    for (let e = 0; e < t.length; e++)
      t[e].w |= ds;
}, ek = (t) => {
  let { deps: e } = t;
  if (e.length) {
    let r = 0;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      w8(n) && !x8(n) ? n.delete(t) : e[r++] = n, n.w &= ~ds, n.n &= ~ds;
    }
    e.length = r;
  }
}, om = /* @__PURE__ */ new WeakMap(), Ad = 0, ds = 1, am = 30, Lr, ko = Symbol(W.default.env.NODE_ENV !== "production" ? "iterate" : ""), fm = Symbol(W.default.env.NODE_ENV !== "production" ? "Map key iterate" : ""), Sd = class {
  constructor(e, r = null, i) {
    this.fn = e, this.scheduler = r, this.active = true, this.deps = [], this.parent = void 0, XR(this, i);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = Lr, r = us;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = Lr, Lr = this, us = true, ds = 1 << ++Ad, Ad <= am ? QR(this) : h8(this), this.fn();
    } finally {
      Ad <= am && ek(this), ds = 1 << --Ad, Lr = this.parent, us = r, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Lr === this ? this.deferStop = true : this.active && (h8(this), this.onStop && this.onStop(), this.active = false);
  }
};
function h8(t) {
  let { deps: e } = t;
  if (e.length) {
    for (let r = 0; r < e.length; r++)
      e[r].delete(t);
    e.length = 0;
  }
}
var us = true, _8 = [];
function tk() {
  _8.push(us), us = false;
}
function rk() {
  let t = _8.pop();
  us = t === void 0 ? true : t;
}
function bi(t, e, r) {
  if (us && Lr) {
    let i = om.get(t);
    i || om.set(t, i = /* @__PURE__ */ new Map());
    let n = i.get(r);
    n || i.set(r, n = Ed());
    let s2 = W.default.env.NODE_ENV !== "production" ? { effect: Lr, target: t, type: e, key: r } : void 0;
    cm(n, s2);
  }
}
function cm(t, e) {
  let r = false;
  Ad <= am ? x8(t) || (t.n |= ds, r = !w8(t)) : r = !t.has(Lr), r && (t.add(Lr), Lr.deps.push(t), W.default.env.NODE_ENV !== "production" && Lr.onTrack && Lr.onTrack(im({ effect: Lr }, e)));
}
function ls(t, e, r, i, n, s2) {
  let o = om.get(t);
  if (!o)
    return;
  let f = [];
  if (e === "clear")
    f = [...o.values()];
  else if (r === "length" && yi(t)) {
    let m3 = Number(i);
    o.forEach((A2, F3) => {
      (F3 === "length" || F3 >= m3) && f.push(A2);
    });
  } else
    switch (r !== void 0 && f.push(o.get(r)), e) {
      case "add":
        yi(t) ? h0(r) && f.push(o.get("length")) : (f.push(o.get(ko)), Sf(t) && f.push(o.get(fm)));
        break;
      case "delete":
        yi(t) || (f.push(o.get(ko)), Sf(t) && f.push(o.get(fm)));
        break;
      case "set":
        Sf(t) && f.push(o.get(ko));
        break;
    }
  let l = W.default.env.NODE_ENV !== "production" ? { target: t, type: e, key: r, newValue: i, oldValue: n, oldTarget: s2 } : void 0;
  if (f.length === 1)
    f[0] && (W.default.env.NODE_ENV !== "production" ? If(f[0], l) : If(f[0]));
  else {
    let m3 = [];
    for (let A2 of f)
      A2 && m3.push(...A2);
    W.default.env.NODE_ENV !== "production" ? If(Ed(m3), l) : If(Ed(m3));
  }
}
function If(t, e) {
  let r = yi(t) ? t : [...t];
  for (let i of r)
    i.computed && p8(i, e);
  for (let i of r)
    i.computed || p8(i, e);
}
function p8(t, e) {
  (t !== Lr || t.allowRecurse) && (W.default.env.NODE_ENV !== "production" && t.onTrigger && t.onTrigger(im({ effect: t }, e)), t.scheduler ? t.scheduler() : t.run());
}
var ik = rm("__proto__,__v_isRef,__isVue"), A8 = new Set(Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(l0)), nk = E8();
var sk = E8(true);
var g8 = ok();
function ok() {
  let t = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    t[e] = function(...r) {
      let i = $t(this);
      for (let s2 = 0, o = this.length; s2 < o; s2++)
        bi(i, "get", s2 + "");
      let n = i[e](...r);
      return n === -1 || n === false ? i[e](...r.map($t)) : n;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    t[e] = function(...r) {
      tk();
      let i = $t(this)[e].apply(this, r);
      return rk(), i;
    };
  }), t;
}
function ak(t) {
  let e = $t(this);
  return bi(e, "has", t), e.hasOwnProperty(t);
}
function E8(t = false, e = false) {
  return function(i, n, s2) {
    if (n === "__v_isReactive")
      return !t;
    if (n === "__v_isReadonly")
      return t;
    if (n === "__v_isShallow")
      return e;
    if (n === "__v_raw" && s2 === (t ? e ? Ak : T8 : e ? _k : I8).get(i))
      return i;
    let o = yi(i);
    if (!t) {
      if (o && _d2(g8, n))
        return Reflect.get(g8, n, s2);
      if (n === "hasOwnProperty")
        return ak;
    }
    let f = Reflect.get(i, n, s2);
    return (l0(n) ? A8.has(n) : ik(n)) || (t || bi(i, "get", n), e) ? f : tn(f) ? o && h0(n) ? f : f.value : fs(f) ? t ? Jr(f) : Tf(f) : f;
  };
}
var fk = ck();
function ck(t = false) {
  return function(r, i, n, s2) {
    let o = r[i];
    if (Md(o) && tn(o) && !tn(n))
      return false;
    if (!t && (!lm(n) && !Md(n) && (o = $t(o), n = $t(n)), !yi(r) && tn(o) && !tn(n)))
      return o.value = n, true;
    let f = yi(r) && h0(i) ? Number(i) < r.length : _d2(r, i), l = Reflect.set(r, i, n, s2);
    return r === $t(s2) && (f ? Mf(n, o) && ls(r, "set", i, n, o) : ls(r, "add", i, n)), l;
  };
}
function uk(t, e) {
  let r = _d2(t, e), i = t[e], n = Reflect.deleteProperty(t, e);
  return n && r && ls(t, "delete", e, void 0, i), n;
}
function dk(t, e) {
  let r = Reflect.has(t, e);
  return (!l0(e) || !A8.has(e)) && bi(t, "has", e), r;
}
function lk(t) {
  return bi(t, "iterate", yi(t) ? "length" : ko), Reflect.ownKeys(t);
}
var hk = { get: nk, set: fk, deleteProperty: uk, has: dk, ownKeys: lk }, pk = { get: sk, set(t, e) {
  return W.default.env.NODE_ENV !== "production" && l8(`Set operation on key "${String(e)}" failed: target is readonly.`, t), true;
}, deleteProperty(t, e) {
  return W.default.env.NODE_ENV !== "production" && l8(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), true;
} };
var dm = (t) => t, w0 = (t) => Reflect.getPrototypeOf(t);
function g0(t, e, r = false, i = false) {
  t = t.__v_raw;
  let n = $t(t), s2 = $t(e);
  r || (e !== s2 && bi(n, "get", e), bi(n, "get", s2));
  let { has: o } = w0(n), f = i ? dm : r ? pm : hm;
  if (o.call(n, e))
    return f(t.get(e));
  if (o.call(n, s2))
    return f(t.get(s2));
  t !== n && t.get(e);
}
function m0(t, e = false) {
  let r = this.__v_raw, i = $t(r), n = $t(t);
  return e || (t !== n && bi(i, "has", t), bi(i, "has", n)), t === n ? r.has(t) : r.has(t) || r.has(n);
}
function y0(t, e = false) {
  return t = t.__v_raw, !e && bi($t(t), "iterate", ko), Reflect.get(t, "size", t);
}
function m8(t) {
  t = $t(t);
  let e = $t(this);
  return w0(e).has.call(e, t) || (e.add(t), ls(e, "add", t, t)), this;
}
function y8(t, e) {
  e = $t(e);
  let r = $t(this), { has: i, get: n } = w0(r), s2 = i.call(r, t);
  s2 ? W.default.env.NODE_ENV !== "production" && M8(r, i, t) : (t = $t(t), s2 = i.call(r, t));
  let o = n.call(r, t);
  return r.set(t, e), s2 ? Mf(e, o) && ls(r, "set", t, e, o) : ls(r, "add", t, e), this;
}
function b8(t) {
  let e = $t(this), { has: r, get: i } = w0(e), n = r.call(e, t);
  n ? W.default.env.NODE_ENV !== "production" && M8(e, r, t) : (t = $t(t), n = r.call(e, t));
  let s2 = i ? i.call(e, t) : void 0, o = e.delete(t);
  return n && ls(e, "delete", t, void 0, s2), o;
}
function v8() {
  let t = $t(this), e = t.size !== 0, r = W.default.env.NODE_ENV !== "production" ? Sf(t) ? new Map(t) : new Set(t) : void 0, i = t.clear();
  return e && ls(t, "clear", void 0, void 0, r), i;
}
function b0(t, e) {
  return function(i, n) {
    let s2 = this, o = s2.__v_raw, f = $t(o), l = e ? dm : t ? pm : hm;
    return !t && bi(f, "iterate", ko), o.forEach((m3, A2) => i.call(n, l(m3), l(A2), s2));
  };
}
function v0(t, e, r) {
  return function(...i) {
    let n = this.__v_raw, s2 = $t(n), o = Sf(s2), f = t === "entries" || t === Symbol.iterator && o, l = t === "keys" && o, m3 = n[t](...i), A2 = r ? dm : e ? pm : hm;
    return !e && bi(s2, "iterate", l ? fm : ko), { next() {
      let { value: F3, done: z3 } = m3.next();
      return z3 ? { value: F3, done: z3 } : { value: f ? [A2(F3[0]), A2(F3[1])] : A2(F3), done: z3 };
    }, [Symbol.iterator]() {
      return this;
    } };
  };
}
function cs(t) {
  return function(...e) {
    if (W.default.env.NODE_ENV !== "production") {
      let r = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${sm(t)} operation ${r}failed: target is readonly.`, $t(this));
    }
    return t === "delete" ? false : this;
  };
}
function gk() {
  let t = { get(s2) {
    return g0(this, s2);
  }, get size() {
    return y0(this);
  }, has: m0, add: m8, set: y8, delete: b8, clear: v8, forEach: b0(false, false) }, e = { get(s2) {
    return g0(this, s2, false, true);
  }, get size() {
    return y0(this);
  }, has: m0, add: m8, set: y8, delete: b8, clear: v8, forEach: b0(false, true) }, r = { get(s2) {
    return g0(this, s2, true);
  }, get size() {
    return y0(this, true);
  }, has(s2) {
    return m0.call(this, s2, true);
  }, add: cs("add"), set: cs("set"), delete: cs("delete"), clear: cs("clear"), forEach: b0(true, false) }, i = { get(s2) {
    return g0(this, s2, true, true);
  }, get size() {
    return y0(this, true);
  }, has(s2) {
    return m0.call(this, s2, true);
  }, add: cs("add"), set: cs("set"), delete: cs("delete"), clear: cs("clear"), forEach: b0(true, true) };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s2) => {
    t[s2] = v0(s2, false, false), r[s2] = v0(s2, true, false), e[s2] = v0(s2, false, true), i[s2] = v0(s2, true, true);
  }), [t, r, e, i];
}
var [mk, yk, bk, vk] = gk();
function S8(t, e) {
  let r = e ? t ? vk : bk : t ? yk : mk;
  return (i, n, s2) => n === "__v_isReactive" ? !t : n === "__v_isReadonly" ? t : n === "__v_raw" ? i : Reflect.get(_d2(r, n) && n in i ? r : i, n, s2);
}
var wk = { get: S8(false, false) };
var xk = { get: S8(true, false) };
function M8(t, e, r) {
  let i = $t(r);
  if (i !== r && e.call(t, i)) {
    let n = nm(t);
    console.warn(`Reactive ${n} contains both the raw and reactive versions of the same object${n === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var I8 = /* @__PURE__ */ new WeakMap(), _k = /* @__PURE__ */ new WeakMap(), T8 = /* @__PURE__ */ new WeakMap(), Ak = /* @__PURE__ */ new WeakMap();
function Ek(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Sk(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : Ek(nm(t));
}
function Tf(t) {
  return Md(t) ? t : F8(t, false, hk, wk, I8);
}
function Jr(t) {
  return F8(t, true, pk, xk, T8);
}
function F8(t, e, r, i, n) {
  if (!fs(t))
    return W.default.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(t)}`), t;
  if (t.__v_raw && !(e && t.__v_isReactive))
    return t;
  let s2 = n.get(t);
  if (s2)
    return s2;
  let o = Sk(t);
  if (o === 0)
    return t;
  let f = new Proxy(t, o === 2 ? i : r);
  return n.set(t, f), f;
}
function hs(t) {
  return Md(t) ? hs(t.__v_raw) : !!(t && t.__v_isReactive);
}
function Md(t) {
  return !!(t && t.__v_isReadonly);
}
function lm(t) {
  return !!(t && t.__v_isShallow);
}
function R8(t) {
  return hs(t) || Md(t);
}
function $t(t) {
  let e = t && t.__v_raw;
  return e ? $t(e) : t;
}
function x0(t) {
  return d8(t, "__v_skip", true), t;
}
var hm = (t) => fs(t) ? Tf(t) : t, pm = (t) => fs(t) ? Jr(t) : t;
function Mk(t) {
  us && Lr && (t = $t(t), W.default.env.NODE_ENV !== "production" ? cm(t.dep || (t.dep = Ed()), { target: t, type: "get", key: "value" }) : cm(t.dep || (t.dep = Ed())));
}
function Ik(t, e) {
  t = $t(t);
  let r = t.dep;
  r && (W.default.env.NODE_ENV !== "production" ? If(r, { target: t, type: "set", key: "value", newValue: e }) : If(r));
}
function tn(t) {
  return !!(t && t.__v_isRef === true);
}
var um = class {
  constructor(e, r, i, n) {
    this._setter = r, this.dep = void 0, this.__v_isRef = true, this.__v_isReadonly = false, this._dirty = true, this.effect = new Sd(e, () => {
      this._dirty || (this._dirty = true, Ik(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !n, this.__v_isReadonly = i;
  }
  get value() {
    let e = $t(this);
    return Mk(e), (e._dirty || !e._cacheable) && (e._dirty = false, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
};
function vi(t, e, r = false) {
  let i, n, s2 = Rn(t);
  s2 ? (i = t, n = W.default.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : d0) : (i = t.get, n = t.set);
  let o = new um(i, n, s2 || !n, r);
  return W.default.env.NODE_ENV !== "production" && e && !r && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;
}
U();
function _0(t, e, r) {
  let i;
  try {
    i = r ? t(...r) : t();
  } catch (n) {
    D8(n, e);
  }
  return i;
}
function gm(t, e, r) {
  if (Rn(t)) {
    let n = _0(t, e, r);
    return n && c8(n) && n.catch((s2) => {
      D8(s2, e);
    }), n;
  }
  let i = [];
  for (let n = 0; n < t.length; n++)
    i.push(gm(t[n], e, r));
  return i;
}
function D8(t, e) {
  console.error(new Error(`[@vue-reactivity/watch]: ${e}`)), console.error(t);
}
function Tk(t) {
  console.warn(Fk(t));
}
function Fk(t) {
  return new Error(`[reactivue]: ${t}`);
}
var k8 = {};
function Id(t, e, r) {
  return Rk(t, e, r);
}
function Rk(t, e, { immediate: r, deep: i, flush: n } = {}) {
  let s2, o = false, f = false;
  if (tn(t) ? (s2 = () => t.value, o = lm(t)) : hs(t) ? (s2 = () => t, i = true) : yi(t) ? (f = true, o = t.some(hs), s2 = () => t.map(($) => tn($) ? $.value : hs($) ? Ff($) : Rn($) ? _0($, "watch getter") : Tk("invalid source"))) : Rn(t) ? e ? s2 = () => _0(t, "watch getter") : s2 = () => (l && l(), gm(t, "watch callback", [m3])) : s2 = d0, e && i) {
    let $ = s2;
    s2 = () => Ff($());
  }
  let l, m3 = ($) => {
    l = V.onStop = () => {
      _0($, "watch cleanup");
    };
  }, A2 = f ? [] : k8, F3 = () => {
    if (!!V.active)
      if (e) {
        let $ = V.run();
        (i || o || (f ? $.some((re, W2) => Mf(re, A2[W2])) : Mf($, A2))) && (l && l(), gm(e, "watch value", [$, A2 === k8 ? void 0 : A2, m3]), A2 = $);
      } else
        V.run();
  };
  F3.allowRecurse = !!e;
  let z3;
  n === "sync" ? z3 = F3 : z3 = () => {
    F3();
  };
  let V = new Sd(s2, z3);
  return e ? r ? F3() : A2 = V.run() : V.run(), () => V.stop();
}
function Ff(t, e = /* @__PURE__ */ new Set()) {
  if (!fs(t) || e.has(t))
    return t;
  if (e.add(t), yi(t))
    for (let r = 0; r < t.length; r++)
      Ff(t[r], e);
  else if (t instanceof Map)
    t.forEach((r, i) => {
      Ff(t.get(i), e);
    });
  else if (t instanceof Set)
    t.forEach((r) => {
      Ff(r, e);
    });
  else
    for (let r of Object.keys(t))
      Ff(t[r], e);
  return t;
}
var P8 = rr$1(or(), 1);
var N8 = Object.defineProperty, kk = (t, e, r) => e in t ? N8(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r, Ut = (t, e) => N8(t, "name", { value: e, configurable: true }), Dn = (t, e, r) => (kk(t, typeof e != "symbol" ? e + "" : e, r), r);
function Em() {
  let t = false;
  return typeof window !== void 0 && typeof window == "object" && "document" in window && typeof window.document == "object" && (t = true), t;
}
Ut(Em, "isBrowser");
var Dk = Ut((t) => {
  if (typeof window == null)
    throw new Error("Cannot access window for simple btoa conversion.");
  for (var e = "", r = new Uint8Array(t), i = r.byteLength, n = 0; n < i; n++)
    e += String.fromCharCode(r[n]);
  return window.btoa(e);
}, "arrayBufferToBase64"), Bn = { enabled: false, log(...t) {
  !this.enabled || console.log(...t);
}, warn(...t) {
  !this.enabled || console.warn(...t);
}, debug(...t) {
  !this.enabled || console.debug(...t);
} }, gs = { changedStateHandlers: [], changedAccountHandlers: [] }, C8 = "AW", Bk = Ut(() => {
  Bn.debug("startWatchers started"), Id(() => He.stored, () => {
    try {
      localStorage.setItem(C8, JSON.stringify(He.stored));
    } catch {
      Em() ? console.warn("could not save to localstorage") : Bn.log("no localstorage to save to in node env");
    }
  }, { deep: true }), Id(He, (t) => {
    gs.changedStateHandlers.forEach((e) => e(t));
  }, { deep: true }), Id(() => He.stored.activeAccount, (t) => {
    gs.changedAccountHandlers.forEach((e) => e(t));
  }, { deep: true });
}, "startWatchers");
Ut((t, e = { callOnSet: true }) => (gs.changedStateHandlers.push(t), e.callOnSet && t(He), Ut(() => {
  let r = gs.changedStateHandlers.indexOf(t);
  r !== -1 && gs.changedStateHandlers.splice(r, 1);
}, "unsubscribe")), "subscribeToStateChanges");
var O8 = Ut((t, e = { callOnSet: true }) => (gs.changedAccountHandlers.push(t), e.callOnSet && t(He.stored.activeAccount), Ut(() => {
  let r = gs.changedAccountHandlers.indexOf(t);
  r !== -1 && gs.changedAccountHandlers.splice(r, 1);
}, "unsubscribe")), "subscribeToAccountChanges"), rn = class {
  constructor(t) {
  }
};
Ut(rn, "BaseClient"), Dn(rn, "metadata"), Dn(rn, "init");
var Nk = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzcgMTg3Ij48cmVjdCB4PSItMTEuMzgiIHk9Ii0yNS45NyIgd2lkdGg9IjIwMC4wMiIgaGVpZ2h0PSIyMzEuNTMiIHN0eWxlPSJmaWxsOiNmZTU7Ii8+PHBhdGggZD0iTTk0LjA1LDU5LjYxYzIuMDUsOC40OCwxLjM2LDE1Ljk0LTEuNTUsMTYuNjYtMi45LC43Mi02LjkxLTUuNTctOC45Ni0xNC4wNS0yLjA1LTguNDgtMS4zNi0xNS45NCwxLjU1LTE2LjY2LDIuOS0uNzIsNi45MSw1LjU3LDguOTYsMTQuMDVaIiBzdHlsZT0iZmlsbDojMWMxYzFjOyIvPjxwYXRoIGQ9Ik0xMjcuODUsNjYuOWMtNC41My00LjgxLTEzLjU1LTMuNS0yMC4xNSwyLjkxLTYuNTksNi40MS04LjI2LDE1LjUtMy43MywyMC4zMSw0LjUzLDQuOCwxMy41NSwzLjUsMjAuMTUtMi45MXM4LjI2LTE1LjUsMy43My0yMC4zMVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTkxLjc5LDE0MC40N2MyLjktLjcyLDMuNDktOC42LDEuMzItMTcuNjEtMi4xNy05LTYuMjktMTUuNzEtOS4xOS0xNC45OS0yLjksLjcyLTMuNDksOC42LTEuMzIsMTcuNjEsMi4xNyw5LDYuMjksMTUuNzEsOS4xOSwxNC45OVoiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTYyLjIyLDcxLjNjOC4zNywyLjQ3LDE0LjQ4LDYuOCwxMy42Niw5LjY3LS44MywyLjg3LTguMjgsMy4yLTE2LjY1LC43My04LjM3LTIuNDctMTQuNDgtNi44LTEzLjY2LTkuNjcsLjgzLTIuODcsOC4yOC0zLjIsMTYuNjUtLjczWiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48cGF0aCBkPSJNMTE2LjU0LDEwMy43NGM4Ljg4LDIuNjIsMTUuNDEsNy4wNywxNC41OSw5Ljk0LS44MywyLjg3LTguNywzLjA4LTE3LjU4LC40Ni04Ljg4LTIuNjItMTUuNDEtNy4wNy0xNC41OS05Ljk0LC44My0yLjg3LDguNy0zLjA4LDE3LjU4LS40NloiIHN0eWxlPSJmaWxsOiMxYzFjMWM7Ii8+PHBhdGggZD0iTTcxLjY0LDk3LjcxYy0yLjA4LTIuMTUtOC44OCwuOTgtMTUuMiw2Ljk5LTYuMzIsNi4wMS05Ljc2LDEyLjYzLTcuNjksMTQuNzgsMi4wOCwyLjE1LDguODgtLjk4LDE1LjItNi45OSw2LjMyLTYuMDEsOS43Ni0xMi42Myw3LjY5LTE0Ljc4WiIgc3R5bGU9ImZpbGw6IzFjMWMxYzsiLz48L3N2Zz4=", kn = { id: "pera", chain: "algorand", name: "Pera Wallet", icon: Nk, pkg: "@perawallet/connect" }, j8 = class extends rn {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r, i = { shouldShowSignTxnToast: false };
        r = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./index-42620cff.js").then((n2) => n2.i), true ? ["./index-42620cff.js","./qr-code-styling-3c33b143.js","./algosdk.min-1c1c7044.js","./index-f3593f61.js"] : void 0, import.meta.url), s2 = n.PeraWalletConnect || n.default.PeraWalletConnect;
        e = new s2(r);
      }
      return e = x0(e), new j8({ sdk: e });
    } catch (e) {
      return console.error(`[${kn.id}] Error initializing...`, e), null;
    }
  }
  async connect(t) {
    var _a2;
    let e = await this.sdk.connect();
    if ((_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e.length === 0)
      throw new Error(`No accounts found for ${kn.id}`);
    let r = e.map((i, n) => ({ name: `Pera Account ${n + 1}`, address: i, walletId: kn.id, chain: kn.chain, active: false }));
    return { ...kn, accounts: r };
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? { ...kn, accounts: e.map((r, i) => ({ name: `Pera Account ${i + 1}`, address: r, walletId: kn.id, chain: kn.chain, active: false })) } : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let r = e.map((s2) => jr(s2)), i = r.reduce((s2, o, f) => {
      let l = t.map((m3) => m3.address);
      return !("txn" in o) && l.includes(Ue(o.snd)) ? s2.push({ txn: eo(e[f]) }) : s2.push({ txn: xn(e[f]).txn, signers: [] }), s2;
    }, []), n = await this.sdk.signTransaction([i]);
    return r.reduce((s2, o, f) => {
      if ("txn" in o)
        s2.push(e[f]);
      else {
        let l = n.shift();
        l && s2.push(l);
      }
      return s2;
    }, []);
  }
}, mm = j8;
Ut(mm, "PeraClient"), Dn(mm, "metadata", kn);
var Ck = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA2MDAgNjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6IzE5MTkxOTt9Cgkuc3Qxe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxnPgoJPHBhdGggY2xhc3M9InN0MCIgZD0iTTQ2MCwwSDE0MEM2Mi43LDAsMCw2Mi43LDAsMTQwdjMyMGMwLDc3LjMsNjIuNywxNDAsMTQwLDE0MGg0Ny45TDMwMCw0ODcuOUw0MTIuMSw2MDBINDYwCgkJYzc3LjMsMCwxNDAtNjIuNywxNDAtMTQwVjE0MEM2MDAsNjIuNyw1MzcuMywwLDQ2MCwweiIvPgo8L2c+CjxnPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTc3LjEsMjM0Ljl2MTE0LjZINDEuNlYyMzQuOUg3Ny4xeiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTIwNi4yLDIzNC45djExNC42aC0zOC45bC0zMS4zLTU2LjhsLTcuMy0xNS41aC0wLjNsMC43LDIyLjZ2NDkuN0g5OC4yVjIzNC45SDEzN2wzMS4zLDU2LjhsNy41LDE1LjVoMC4yCgkJbC0wLjctMjIuNnYtNDkuN0gyMDYuMnoiLz4KCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMjk5LDM0OS41IDMzOS4xLDM0OS41IDI5OS41LDI4MC45IDMzNi4zLDIzNC45IDI5Ny45LDIzNC45IDI2Mi44LDI4MS43IDI2Mi44LDIzNC45IDIyNy40LDIzNC45IAoJCTIyNy40LDM0OS41IDI2Mi44LDM0OS41IDI2Mi44LDMxOC42IDI3NC41LDMwMy41IAkiLz4KCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0zNTAsMzQ5LjVWMjM0LjloOTIuNHYyNi42aC01Ni45VjI4MGg0NS41djI0LjdoLTQ1LjV2MTguMmg1OS4ydjI2LjZIMzUweiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTU2NiwyMzQuOWwtNDAuMSw3NHY0MC42aC0zNS42di00MC42bC00MC4zLTc0SDQ4NmwxMy45LDI4LjZsOC41LDIwbDguMy0yMGwxNC4xLTI4LjZINTY2eiIvPgo8L2c+Cjwvc3ZnPgo=", Rf = { id: "inkey", chain: "algorand", name: "Inkey Microwallet", icon: Ck, pkg: "@thencc/inkey-client-js" }, L8 = class extends rn {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r, i = { src: "https://inkey.app", align: "center" };
        r = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./index.esm-2f1d95df.js"), true ? [] : void 0, import.meta.url);
        e = await (n.createClient || n.default.createClient)(r);
      }
      return await new Promise((r) => setTimeout(r, 600)), new L8({ sdk: e });
    } catch (e) {
      return console.warn(`[${Rf.id}] Error initializing...`, e), null;
    }
  }
  async connect(t) {
    let e = await this.sdk.connect(t);
    if (!e)
      throw new Error("no inkeyAccounts");
    if (e.length === 0)
      throw new Error(`No accounts found for ${Rf.id}`);
    let r = e.map((i) => ({ name: i.name, address: i.address, walletId: Rf.id, chain: Rf.chain, active: false }));
    return (t == null ? void 0 : t.onDisconnect) && this.sdk.frameBus.setOnDisconnect(t.onDisconnect), { ...Rf, accounts: r };
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let r = e.map((o) => jr(o)), i = r.reduce((o, f, l) => {
      let m3 = t.map((A2) => A2.address);
      return !("txn" in f) && m3.includes(Ue(f.snd)) && o.push(e[l]), o;
    }, []).map((o) => Dk(o)), n = await this.sdk.signTxns(i, t);
    if (!n.success)
      throw new Error("Error signing transactions");
    let s2 = n.signedTxns;
    return r.reduce((o, f, l) => {
      if ("txn" in f)
        o.push(e[l]);
      else {
        let m3 = s2.shift();
        m3 && o.push(m3);
      }
      return o;
    }, []);
  }
}, ym = L8;
Ut(ym, "InkeyClient"), Dn(ym, "metadata", Rf);
var Ok = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgPHBhdGggZmlsbD0iIzI0NUVDNiIgZD0iTTE2LDMyYy0zLjIsMC02LjItMC45LTguOS0yLjdjLTIuNi0xLjgtNC43LTQuMy01LjktNy4yQzAsMTkuMi0wLjMsMTYsMC4zLDEyLjlDMC45LDkuOCwyLjQsNyw0LjcsNC43IEM2LjIsMy4yLDcuOSwyLDkuOSwxLjJDMTEuOCwwLjQsMTMuOSwwLDE2LDBzNC4yLDAuNCw2LjEsMS4yYzEuOSwwLjgsMy43LDIsNS4yLDMuNXMyLjcsMy4zLDMuNSw1LjJjMC44LDEuOSwxLjIsNCwxLjIsNi4xIHMtMC40LDQuMi0xLjIsNi4xYy0wLjgsMS45LTIsMy43LTMuNSw1LjJjLTEuNSwxLjUtMy4yLDIuNy01LjIsMy41QzIwLjIsMzEuNiwxOC4xLDMyLDE2LDMyTDE2LDMyeiBNMjAuMiwxMS4ybDAuMSwwLjVsMi42LDkuNWgyLjEgTDIxLjUsOC45bC0wLjEtMC4zaC0xLjlsMCwwLjFsLTEuNywzLjFMMTYsMTQuOWwwLDAuMWwwLTAuMWwtMC4yLTAuOGwtMC42LTIuNGwtMC4xLTAuMmwtMC43LTIuNmwtMC4xLTAuM2gtMS45bDAsMC4xbC0xLjcsMy4xIGwtMS44LDMuMkw3LjEsMThsLTEuOCwzLjJoMi4xTDkuMiwxOGwxLjgtMy4ybDEuOC0zLjJsMC4zLTAuNWwwLjEsMC41bDAuNSwyLjFsMC43LDIuNmwwLjIsMC45TDE0LjIsMThsLTEuOCwzLjJoMi4xbDAuOC0xLjMgbDEuMy0yLjNsMS41LTIuN2wxLjgtMy4yTDIwLjIsMTEuMkwyMC4yLDExLjJ6Ii8+Cjwvc3ZnPgo=", kf = { id: "myalgo", chain: "algorand", name: "MyAlgo", icon: Ok, pkg: "@randlabs/myalgo-connect" }, q8 = class extends rn {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r, i = { disableLedgerNano: false };
        r = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./buffer-N4IG3DOH-c81e6b6e.js"), true ? [] : void 0, import.meta.url);
        window.Buffer || (window.Buffer = n.Buffer || n.default.Buffer);
        let s2 = (await __vitePreload(() => import("./index-26152857.js").then((n2) => n2.i), true ? [] : void 0, import.meta.url)).default;
        e = new s2(r);
      }
      return e = x0(e), new q8({ sdk: e });
    } catch (e) {
      return console.error(`[${kf.id}] Error initializing...`, e), null;
    }
  }
  async connect() {
    let t = await this.sdk.connect();
    if (t.length === 0)
      throw new Error(`No accounts found for ${kf.id}`);
    let e = t.map((r) => ({ ...r, walletId: kf.id, chain: kf.chain, active: false }));
    return { ...kf, accounts: e };
  }
  async reconnect() {
    return null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let r = e.map((s2) => jr(s2)), i = r.reduce((s2, o, f) => {
      let l = t.map((m3) => m3.address);
      return !("txn" in o) && l.includes(Ue(o.snd)) && s2.push(e[f]), s2;
    }, []), n = await this.sdk.signTransaction(i);
    return r.reduce((s2, o, f) => {
      var _a2;
      if ("txn" in o)
        s2.push(e[f]);
      else {
        let l = (_a2 = n.shift()) == null ? void 0 : _a2.blob;
        l && s2.push(l);
      }
      return s2;
    }, []);
  }
}, bm = q8;
Ut(bm, "MyAlgoClient"), Dn(bm, "metadata", kf);
var jk = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjM4IiBoZWlnaHQ9IjIzOCIgdmlld0JveD0iMCAwIDIzOCAyMzgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01MS43MDUgMTQ1LjA0MkgxMTYuNzA1TDEwNy43MDUgMTU1LjA0Mkg1MS43MDVWMTQ1LjA0MloiIGZpbGw9IiNENjQ1MDAiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNDcuNTE5IDE5MS41NTdMMTI5LjU3NyAxNDQuMzk0TDE0Mi40MDQgMTI3LjExMkwxNjcuODc1IDE5MS41NTdIMTQ3LjUxOVpNMTEwLjkzNiA5NS4zOTMyTDEyMC42MTMgMTIwLjgzMUwxMzMuMzU5IDEwNC4yMjhMMTE3LjQ3NSA2NC4wNDIyQzExNS45MjggNjAuMTI4IDExMi4xNDYgNTcuNTU2NSAxMDcuOTM4IDU3LjU1NjVDMTAzLjcyOSA1Ny41NTY1IDk5Ljk0NzQgNjAuMTI4IDk4LjQwMDMgNjQuMDQyMkw2Ny45NjU5IDE0MS4wNDJIODcuNzgwN0M5NS40MTUzIDEyMS4wMTEgMTAyLjg5MyAxMDEuMzk5IDEwNS4xOTggOTUuMzU0MUMxMDUuNjQxIDk0LjE5MTIgMTA2Ljc0MyA5My40NTk5IDEwNy45ODcgOTMuNDU5OUgxMDguMTMyQzEwOS4zNzggOTMuNDU5OSAxMTAuNDkzIDk0LjIyOTMgMTEwLjkzNiA5NS4zOTMyWk04MC45MjEgMTU5LjA0MkM3NC45Mjg5IDE3NC43NjggNjkuODY2MSAxODguMDYzIDY4LjU0NDcgMTkxLjU1N0g0OEw2MC44NTE0IDE1OS4wNDJIODAuOTIxWiIgZmlsbD0iIzIyMkI2MCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3Ni4wMjYgNTQuNzUwOUMxNzcuOTk3IDUyLjA4NzIgMTgxLjc1NCA1MS41MjU3IDE4NC40MTggNTMuNDk2N0MxODcuMDgyIDU1LjQ2NzggMTg3LjY0MyA1OS4yMjUxIDE4NS42NzIgNjEuODg4OEwxMzAuMDEzIDEzNy4xMDdDMTI5LjcxNCAxMzcuNTEyIDEyOS4zNDEgMTM3Ljg1NyAxMjguOTEzIDEzOC4xMjNMMTE3Ljg1NiAxNDUuMDEzQzExNy4wODcgMTQ1LjQ5MyAxMTYuMTI4IDE0NC43ODMgMTE2LjM2MSAxNDMuOTA3TDExOS43MTggMTMxLjMxOEMxMTkuODQ3IDEzMC44MzIgMTIwLjA2OCAxMzAuMzc0IDEyMC4zNjcgMTI5Ljk3TDE3MC42NyA2MS45ODlMMTY5LjkyOSA2MS40NDA1QzE2OS40ODUgNjEuMTEyIDE2OC44NTkgNjEuMjA1NiAxNjguNTMgNjEuNjQ5NkwxNTIuMzExIDgzLjU2ODhDMTUyLjU4NiA4NC4yMDIzIDE1Mi41MjQgODQuOTYxMiAxNTIuMDg0IDg1LjU1NjJMMTQ5LjExIDg5LjU3NTVDMTQ4LjQ1MyA5MC40NjM0IDE0Ny4yMDEgOTAuNjUwNiAxNDYuMzEzIDg5Ljk5MzZDMTQ1LjQyNSA4OS4zMzY2IDE0NS4yMzggODguMDg0MSAxNDUuODk1IDg3LjE5NjJMMTQ3LjY3OSA4NC43ODQ3TDE0OC44NjkgODMuMTc2OUwxNjcuMzA4IDU4LjI1NzRDMTY4LjYyMiA1Ni40ODE1IDE3MS4xMjcgNTYuMTA3MiAxNzIuOTAzIDU3LjQyMTJMMTczLjY0NCA1Ny45Njk3TDE3Ni4wMjYgNTQuNzUwOVoiIGZpbGw9IiNENjQ1MDAiLz4KPC9zdmc+Cg==", Df = { id: "algosigner", chain: "algorand", name: "AlgoSigner", icon: jk, pkg: "" }, Lk = Ut((t) => t === "betanet" ? "BetaNet" : t === "testnet" ? "TestNet" : t === "mainnet" ? "MainNet" : t, "getNetwork"), U8 = class extends rn {
  constructor({ sdk: t, network: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "network");
    this.sdk = t, this.network = e;
  }
  static async init(t) {
    var _a2;
    try {
      if (typeof window > "u" || window.AlgoSigner === void 0)
        throw new Error("AlgoSigner is not available.");
      let e = window.AlgoSigner, r = "mainnet";
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.network) && (t.config.network == "mainnet" || t.config.network == "testnet" || t.config.network == "betanet" ? r = t.config.network : console.warn(`invalid network in ${Df.id} config`)), new U8({ sdk: e, network: r });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    await this.sdk.connect();
    let t = await this.sdk.accounts({ ledger: Lk(this.network) });
    if (t.length === 0)
      throw new Error(`No accounts found for ${Df.id}`);
    let e = t.map(({ address: r }, i) => ({ name: `AlgoSigner Account ${i + 1}`, address: r, walletId: Df.id, chain: Df.chain, active: false }));
    return { ...Df, accounts: e };
  }
  async reconnect(t) {
    return (window === void 0 || window.AlgoSigner === void 0) && t(), null;
  }
  async disconnect() {
  }
  async signTransactions(t, e) {
    let r = e.map((i) => jr(i)).reduce((i, n, s2) => {
      let o = { txn: this.sdk.encoding.msgpackToBase64(e[s2]) }, f = t.map((l) => l.address);
      return ("txn" in n || !f.includes(Ue(n.snd))) && (o.txn = this.sdk.encoding.msgpackToBase64(xn(e[s2]).txn.toByte()), o.signers = []), i.push(o), i;
    }, []);
    return (await this.sdk.signTxn(r)).reduce((i, n, s2) => (n ? i.push(new Uint8Array(P8.Buffer.from(n.blob, "base64"))) : i.push(e[s2]), i), []);
  }
}, vm = U8;
Ut(vm, "AlgoSignerClient"), Dn(vm, "metadata", Df);
var qk = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMDAgMzAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMDAgMzAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6dXJsKCNTVkdJRF8xXyk7fQoJLnN0MXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNDM0MjYxNjcxNDAxMDY1ODIyNzAwMDAwMDIxMzA3Njg5MDYwNzMxMTM0ODRfKTt9Cgkuc3Qye2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEwMjUxOTMxNjAxNTI3NjU4MTY0MDAwMDAxNjI3NDExMjM4MzE3NTY0MTc1OV8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTt9Cgkuc3Qze2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDEzODU2MzM4MjQ2MjA4NjAyMDM1MDAwMDAxNDg3ODQ5MDI3MDc4MjA3MTIwN18pO30KCS5zdDR7bWFzazp1cmwoI21hc2swXzE2NjFfMjk1XzAwMDAwMDg4MTMyMjUxNTk3NDQxNTczNDkwMDAwMDExNjkzNjEyMDE4NTA2NjgxNDgxXyk7fQoJLnN0NXtmaWxsOnVybCgjU1ZHSURfMDAwMDAxMDYxMjA2MzI0NjE3OTI4NzExNjAwMDAwMDc0MzM5MTMwMzgzMzc3NjY1NzZfKTt9Cjwvc3R5bGU+CjxnPgoJCgkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDYuNjAzIiB5MT0iOS4yMjEyIiB4Mj0iMTc0LjE1OCIgeTI9IjMwOC41NDI2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xCgkJTDI3NC43LDkzLjl6Ii8+CgkKCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMjkuMzUxNiIgeTE9Ii0xOS4xNTczIiB4Mj0iNTYuOTA2NiIgeTI9IjI4MC4xNjQxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCQkZCRTAiLz4KCTwvbGluZWFyR3JhZGllbnQ+Cgk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDE4MjI4MjM3MTUxMjM5MTUxMzIwMDAwMDE3ODM4NjY0MjU5NzY2MjczOTI1Xyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCWw2OS4yLTQ1LjFWMjNMMjUuMyw5My45TDQzLDE1MC4xbC0xNy43LDU2LjJMMTMzLjcsMjc3di0zOS42bC02OS40LTQ1LjFMNzIuNSwxNjYuNHoiLz4KCTxkZWZzPgoJCTxmaWx0ZXIgaWQ9IkFkb2JlX09wYWNpdHlNYXNrRmlsdGVyIiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ij4KCQkJPGZlQ29sb3JNYXRyaXggIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIxIDAgMCAwIDAgIDAgMSAwIDAgMCAgMCAwIDEgMCAwICAwIDAgMCAxIDAiLz4KCQk8L2ZpbHRlcj4KCTwvZGVmcz4KCQoJCTxtYXNrIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjI1LjQiIHk9IjIzIiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0IiBpZD0ibWFzazBfMTY2MV8yOTVfMDAwMDAwODgxMzIyNTE1OTc0NDE1NzM0OTAwMDAwMTE2OTM2MTIwMTg1MDY2ODE0ODFfIj4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjQ2LjYwMzgiIHkxPSI5LjIyMTQiIHgyPSIxNzQuMTU4OCIgeTI9IjMwOC41NDI4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgMzAyKSI+CgkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwQjQ2RjkiLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JCRkJFMCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJPHBhdGggc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NTkyOTcyNDMwMzE2NDIwMzAwMDAwMDAwNzEwMTkwNDk4NDUxOTkxNTE2Ml8pO2ZpbHRlcjp1cmwoI0Fkb2JlX09wYWNpdHlNYXNrRmlsdGVyKTsiIGQ9IgoJCQlNMjc0LjcsOTMuOUwxNjYuNiwyM3YzOS42bDY5LjQsNDUuMWwtOC4yLDI1LjhoLTYxLjJ2MzIuOWg2MS4ybDguMiwyNS44bC02OS40LDQ1LjFWMjc3bDEwOC4yLTcwLjdMMjU3LDE1MC4xTDI3NC43LDkzLjl6Ii8+CgkJCgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMTk4MTE3MDc2MjE0NzI4MTQyNzAwMDAwMTA4Mjk2NTkzODM4NTEyMDI0OTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyOS4zNTIxIiB5MT0iLTE5LjE1NzEiIHgyPSI1Ni45MDcxIiB5Mj0iMjgwLjE2NDIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAzMDIpIj4KCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzBCNDZGOSIvPgoJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQkJGQkUwIi8+CgkJPC9saW5lYXJHcmFkaWVudD4KCQk8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTE5ODExNzA3NjIxNDcyODE0MjcwMDAwMDEwODI5NjU5MzgzODUxMjAyNDkxXyk7IiBkPSJNNzIuNSwxNjYuNGg2MXYtMzIuOUg3Mi4ybC03LjktMjUuOAoJCQlsNjkuMi00NS4xVjIzTDI1LjMsOTMuOUw0MywxNTAuMWwtMTcuNyw1Ni4yTDEzMy43LDI3N3YtMzkuNmwtNjkuNC00NS4xTDcyLjUsMTY2LjR6Ii8+Cgk8L21hc2s+Cgk8ZyBjbGFzcz0ic3Q0Ij4KCQkKCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDEwOTAxOTkxODU1Nzc3MzA1MzQyMDAwMDAxNzYwMjQwNTkwODA2NzEyMDMwMF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDYuNDY2MiIgeTE9IjIyOC43NTU0IiB4Mj0iMTcxLjg2MzgiIHkyPSIxMzUuMTAzOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDMwMikiPgoJCQk8c3RvcCAgb2Zmc2V0PSIwLjExOTgiIHN0eWxlPSJzdG9wLWNvbG9yOiM4OTUyRkY7c3RvcC1vcGFjaXR5OjAuODciLz4KCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0RBQkRGRjtzdG9wLW9wYWNpdHk6MCIvPgoJCTwvbGluZWFyR3JhZGllbnQ+CgkJCgkJCTxyZWN0IHg9IjI1LjQiIHk9IjIzIiBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTA5MDE5OTE4NTU3NzczMDUzNDIwMDAwMDE3NjAyNDA1OTA4MDY3MTIwMzAwXyk7IiB3aWR0aD0iMjQ3LjYiIGhlaWdodD0iMjU0Ii8+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", Td = { id: "exodus", chain: "algorand", name: "Exodus", icon: qk, pkg: "" }, z8 = class extends rn {
  constructor({ sdk: t, onlyIfTrusted: e }) {
    super();
    __publicField(this, "sdk");
    __publicField(this, "onlyIfTrusted");
    this.sdk = t, this.onlyIfTrusted = e;
  }
  static async init(t) {
    var _a2, _b2;
    try {
      if (typeof window > "u" || window.exodus === void 0)
        throw new Error("Exodus is not available. Do you have the browser extension installed?");
      let e = window.exodus.algorand, r = false;
      return ((_a2 = t == null ? void 0 : t.config) == null ? void 0 : _a2.onlyIfTrusted) && (r = (_b2 = t == null ? void 0 : t.config) == null ? void 0 : _b2.onlyIfTrusted), new z8({ sdk: e, onlyIfTrusted: r });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    let t = "";
    try {
      let { address: r } = await window.exodus.algorand.connect({ onlyIfTrusted: this.onlyIfTrusted });
      t = r;
    } catch (r) {
      throw console.warn("err w exodus connect"), r;
    }
    if (!t)
      throw new Error(`No accounts found for ${Td.id}`);
    let e = [{ name: `Exodus Account ${(/* @__PURE__ */ new Date()).getTime().toString()}`, address: t, walletId: Td.id, chain: Td.chain, active: false }];
    return { ...Td, accounts: e };
  }
  async reconnect(t) {
    return (window === void 0 || window.exodus === void 0 || window.exodus.algorand.isConnected !== true) && t(), null;
  }
  async disconnect() {
    window.exodus.algorand.disconnect();
  }
  async signTransactions(t, e, r, i = true) {
    let n = e.map((l) => jr(l)), s2 = [], o = n.reduce((l, m3, A2) => {
      let F3 = "txn" in m3, z3 = t.map((V) => V.address);
      return (r && r.length && r.includes(A2) || !F3 && z3.includes(Ue(m3.snd))) && (s2.push(A2), l.push(e[A2])), l;
    }, []), f = await window.exodus.algorand.signTransaction(o);
    return e.reduce((l, m3, A2) => {
      if (s2.includes(A2)) {
        let F3 = f.shift();
        F3 && l.push(F3);
      } else
        i && l.push(e[A2]);
      return l;
    }, []);
  }
}, wm = z8;
Ut(wm, "ExodusClient"), Dn(wm, "metadata", Td);
var Pk = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiLz4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEuNjgyMDksMCwwLDEuNjgyMDksMjI2LjM2OCwyMTIuODE4KSI+CiAgICAgICAgPHBhdGggZD0iTTMyNy4wNDksMjgwLjE5MkwxNjkuNTI0LDEzTDEyLDI4MC4xOTJMMTY5LjUyNCwxODkuMDg0TDMyNy4wNDksMjgwLjE5MloiIHN0eWxlPSJmaWxsOndoaXRlO2ZpbGwtcnVsZTpub256ZXJvOyIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMS42ODIwOSwwLDAsMS42ODIwOSwyMjYuMzY4LDIxMi44MTgpIj4KICAgICAgICA8cGF0aCBkPSJNMjk5LjU0NiwzMDdMMTY5LjUyNSwyMzguNDczTDM5LjUwNCwzMDdMMTY5LjUyNSwyNjQuNjdMMjk5LjU0NiwzMDdaIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybzsiLz4KICAgIDwvZz4KPC9zdmc+Cg==", ps = { id: "defly", chain: "algorand", name: "Defly", icon: Pk, pkg: "@blockshake/defly-connect" }, H8 = class extends rn {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      typeof window < "u" ? window.global = window : console.warn("Using a browser lib not in a browser...");
      let e;
      if (t && t.sdk)
        e = t.sdk;
      else {
        let r, i = { shouldShowSignTxnToast: false };
        r = (t == null ? void 0 : t.config) || i;
        let n = await __vitePreload(() => import("./index-4203e9fd.js").then((n2) => n2.i), true ? ["./index-4203e9fd.js","./qr-code-styling-3c33b143.js","./algosdk.min-1c1c7044.js","./lottie-f9918250.js"] : void 0, import.meta.url), s2 = n.DeflyWalletConnect || n.default.DeflyWalletConnect;
        e = new s2(r);
      }
      return new H8({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect(t) {
    let e = await this.sdk.connect().catch(console.info);
    if (this.sdk.connector.on("disconnect", t), !e || e.length === 0)
      throw new Error(`No accounts found for ${ps.id}`);
    let r = e.map((i, n) => ({ name: `Defly Account ${n + 1}`, address: i, walletId: ps.id, chain: ps.chain, active: false }));
    return { ...ps, accounts: r };
  }
  async reconnect(t) {
    var _a2;
    let e = await this.sdk.reconnectSession().catch(console.info);
    return (_a2 = this.sdk.connector) == null ? void 0 : _a2.on("disconnect", t), e ? { ...ps, accounts: e.map((r, i) => ({ name: `Defly Account ${i + 1}`, address: r, walletId: ps.id, chain: ps.chain, active: false })) } : null;
  }
  async disconnect() {
    await this.sdk.disconnect();
  }
  async signTransactions(t, e) {
    let r = e.map((s2) => jr(s2)), i = r.reduce((s2, o, f) => {
      let l = t.map((m3) => m3.address);
      return !("txn" in o) && l.includes(Ue(o.snd)) ? s2.push({ txn: eo(e[f]) }) : s2.push({ txn: xn(e[f]).txn, signers: [] }), s2;
    }, []), n = await this.sdk.signTransaction([i]);
    return r.reduce((s2, o, f) => {
      if ("txn" in o)
        s2.push(e[f]);
      else {
        let l = n.shift();
        l && s2.push(l);
      }
      return s2;
    }, []);
  }
}, xm = H8;
Ut(xm, "DeflyClient"), Dn(xm, "metadata", ps);
var Uk = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e %3c!-- Generated by Pixelmator Pro 3.2.2 --%3e %3csvg width='409' height='210' viewBox='0 0 409 210' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctext id='MNEMONIC' xml:space='preserve' x='0' y='129' font-family='Helvetica' font-size='72' fill='black'%3eMNEMONIC%3c/text%3e%3c/svg%3e", A0 = { id: "mnemonic", name: "Mnemonic", icon: Uk, chain: "algorand", pkg: "" }, $8 = class extends rn {
  constructor({ sdk: t }) {
    super();
    __publicField(this, "sdk");
    this.sdk = t;
  }
  static async init(t) {
    try {
      let e;
      if (t)
        if (typeof t == "string")
          e = To(t);
        else if (typeof t == "object") {
          if (t.sdk)
            e = t.sdk;
          else if (t.config && t.config.mnemonic) {
            let r = t.config.mnemonic;
            e = To(r);
          }
        } else
          throw new Error("bad initParams for mnemonic client");
      else
        console.error("mnemonic wallet needs to be inited w a mnemonic - none provided.");
      return new $8({ sdk: e });
    } catch (e) {
      return console.error("Error initializing...", e), null;
    }
  }
  async connect() {
    var _a2;
    return this.sdk == null && console.warn("mnemonic client wasnt initialized properly... no mnemonic passed in so cannot connect."), { ...A0, accounts: [{ name: `Mnemonic Account ${(/* @__PURE__ */ new Date()).getTime().toString()}`, address: ((_a2 = this.sdk) == null ? void 0 : _a2.addr) || "", walletId: A0.id, chain: A0.chain, active: false }] };
  }
  async disconnect() {
    this.sdk = void 0;
  }
  async reconnect() {
    return null;
  }
  async signTransactions(t, e, r, i = true) {
    if (this.sdk || await this.connect(), !this.sdk)
      throw new Error("Client could not init");
    let n = e.map((m3) => jr(m3)), s2 = [], o = [];
    for (let m3 in n) {
      let A2 = n[m3], F3 = "txn" in A2, z3 = t.map(($) => $.address);
      if (s2.push(e[m3]), F3 || r && r.length && !r.includes(Number(m3)) || !z3.includes(Ue(A2.snd)))
        continue;
      s2[m3] = new Uint8Array();
      let V = Ht.from_obj_for_encoding(A2).signTxn(this.sdk.sk);
      o.push(V);
    }
    let f = 0, l = s2.reduce((m3, A2, F3) => (A2.length === 0 ? (m3.push(o[f]), f += 1) : i && m3.push(A2), m3), []);
    return Promise.resolve(l);
  }
}, _m = $8;
Ut(_m, "MnemonicClient"), Dn(_m, "metadata", A0);
var Bo = { pera: { client: mm }, inkey: { client: ym }, myalgo: { client: bm }, algosigner: { client: vm }, exodus: { client: wm }, defly: { client: xm }, mnemonic: { client: _m } };
Object.values(Bo).map((t) => t.client.metadata.id);
Object.values(Bo).map((t) => t.client.metadata.pkg).filter((t) => t !== "");
Ut((t) => {
  let e = [];
  for (let r of t)
    e.push(Bo[r].client.metadata.pkg);
  return e;
}, "excludeClients");
function Am(t) {
  let e = Ut((r) => Array.isArray(r) ? r.map((i) => e(i)) : tn(r) || hs(r) || R8(r) ? e($t(r)) : r && typeof r == "object" ? Object.keys(r).reduce((i, n) => (i[n] = e(r[n]), i), {}) : r, "objectIterator");
  return e(t);
}
Ut(Am, "deepToRaw");
var Do = Ut((t, e = true) => {
  let r = Tf({ id: t, metadata: Bo[t].client.metadata, client: null, initParams: e, inited: false, initing: false, signing: false, connecting: false, loadClient: async () => (Bn.debug("loadClient:", t), r.inited ? (Bn.log("aw already inited client"), true) : (r.initing = true, typeof r.initParams == "string" ? r.client = await Bo[t].client.init(r.initParams) : typeof r.initParams == "object" && (r.initParams.config || r.initParams.sdk) ? r.client = await Bo[t].client.init(r.initParams) : e == true ? r.client = await Bo[t].client.init() : console.warn("Bad/incomplete init params for wallet:", t), r.initing = false, r.inited = true, true)), connect: async (i) => {
    r.connecting = true;
    try {
      if (await r.loadClient(), r.accounts) {
        i == null && (i = {});
        let s2 = Am(r.accounts);
        i.connectedAccounts = [...s2];
      }
      let { accounts: n } = await r.client.connect(i);
      return $k(n), Gk(n[0]), n;
    } catch (n) {
      throw n;
    } finally {
      r.connecting = false;
    }
  }, disconnect: async () => {
    He.stored.activeAccount && He.stored.activeAccount.walletId == r.id && Hk(He.stored.activeAccount), await r.loadClient();
    try {
      await r.client.disconnect();
    } catch (i) {
      console.warn(i);
    }
  }, reconnect: async () => {
    await r.loadClient(), await r.client.reconnect(() => {
    });
  }, setAsActiveWallet: () => {
    let i = B8(t);
    if (i)
      He.stored.activeAccount = i[0];
    else
      throw new Error("No accounts for this provider to set as active");
  }, removeAccounts: () => {
    zk(t);
  }, signTransactions: async (i) => {
    await r.loadClient();
    let n = Am(r.accounts);
    n.length || (n = await r.connect(), await new Promise((s2) => setTimeout(s2, 1e3))), r.signing = true;
    try {
      return await r.client.signTransactions(n, i);
    } catch (s2) {
      throw s2;
    } finally {
      r.signing = false;
    }
  }, get accounts() {
    return Jr(vi(() => B8(t)));
  }, get isConnected() {
    return Jr(vi(() => He.stored.connectedAccounts.some((i) => i.walletId === t)));
  }, get isActive() {
    return vi(() => {
      var _a2;
      return ((_a2 = He.stored.activeAccount) == null ? void 0 : _a2.walletId) === t;
    });
  }, get activeAccount() {
    return Jr(vi(() => {
      let i;
      return this.isConnected && He.stored.activeAccount && (i = He.stored.activeAccount), i;
    }));
  } });
  return r;
}, "createWallet"), Sm = Ut((t = Kk) => {
  Bn.log("enableWallets started", t), He.enabledWallets == null && (He.enabledWallets = {});
  for (let [e, r] of Object.entries(t)) {
    let i = e;
    He.allWallets[i].initParams = r, He.enabledWallets[i] = He.allWallets[i];
  }
  return He.enabledWallets;
}, "enableWallets");
Ut((t) => {
  if (!He.enabledWallets) {
    console.warn("no wallets enabled to disable");
    return;
  }
  for (let e of t) {
    let r = He.enabledWallets[e];
    r && (r.disconnect(), delete He.enabledWallets[e]);
  }
}, "disableWallets");
var B8 = Ut((t) => He.stored.connectedAccounts.filter((e) => e.walletId === t), "getAccountsByWalletId"), zk = Ut((t) => {
  if (He.stored.activeAccount) {
    let r = He.stored.connectedAccounts.filter((i) => i.walletId == t);
    for (let i of r)
      if (i.address == He.stored.activeAccount.address && i.walletId == He.stored.activeAccount.walletId) {
        He.stored.activeAccount = null;
        break;
      }
  }
  let e = He.stored.connectedAccounts.filter((r) => r.walletId !== t);
  He.stored.connectedAccounts = e;
}, "removeAccountsByWalletId"), Hk = Ut((t) => {
  if (He.stored.activeAccount) {
    let i = He.stored.connectedAccounts.filter((n) => n.walletId == t.walletId && n.name == t.name && n.address == t.address);
    for (let n of i)
      if (n.address == He.stored.activeAccount.address && n.walletId == He.stored.activeAccount.walletId) {
        He.stored.activeAccount = null;
        break;
      }
  }
  let e = He.stored.connectedAccounts, r = e.findIndex((i) => i.walletId == t.walletId && i.address == t.address && i.name == t.name);
  e.splice(r, 1), He.stored.connectedAccounts = e;
}, "removeAccount"), G8 = Ut(() => {
  He.stored.activeAccount = null, He.stored.connectedAccounts = [];
}, "removeAllAccounts"), $k = Ut((t) => {
  for (let e of t) {
    let r = false;
    for (let i of He.stored.connectedAccounts)
      e.walletId == i.walletId && e.address == i.address && (r = true);
    r || He.stored.connectedAccounts.push(e);
  }
}, "addConnectedAccounts"), Gk = Ut((t) => {
  Bn.debug("setAsActiveAccount", t), He.stored.activeAccount = t, He.stored.connectedAccounts.forEach((e) => {
    e.walletId == t.walletId && e.address == t.address && e.name == t.name ? e.active = true : e.active = false;
  }), He.stored.activeAccount.active = true;
}, "setAsActiveAccount"), K8 = Ut(async (t) => {
  if (!He.enabledWallets)
    throw new Error("No wallets enabled, call enableWallets() first");
  let e = Object.keys(He.enabledWallets), r = He.activeWalletId;
  if (e.length == 1 && (r = e[0]), !r)
    throw new Error("No active wallet id");
  let i = He.enabledWallets[r];
  if (!i)
    throw new Error("No active wallet... how'd you get here.");
  return await i.signTransactions(t);
}, "signTransactions"), W8 = Ut((t) => {
  Bn.enabled = t;
}, "setLogsEnabled"), Mm = ((t) => (t.PERA = "pera", t.INKEY = "inkey", t.MYALGO = "myalgo", t.ALGOSIGNER = "algosigner", t.EXODUS = "exodus", t.DEFLY = "defly", t.MNEMONIC = "mnemonic", t))(Mm || {}), Kk = {}, Wk = { pera: Do("pera"), inkey: Do("inkey"), myalgo: Do("myalgo"), algosigner: Do("algosigner"), exodus: Do("exodus"), defly: Do("defly"), mnemonic: Do("mnemonic") }, He = Tf({ allWallets: Wk, enabledWallets: null, stored: { version: 0, connectedAccounts: [], activeAccount: null }, activeAddress: Jr(vi(() => {
  let t = "";
  return He.stored.activeAccount && (t = He.stored.activeAccount.address), t;
})), activeAccount: Jr(vi(() => {
  let t = null;
  return He.stored.activeAccount && (t = He.stored.activeAccount), t;
})), connectedAccounts: Jr(vi(() => {
  let t = [];
  return He.stored.connectedAccounts && (t = He.stored.connectedAccounts), t;
})), activeWalletId: Jr(vi(() => {
  let t = null;
  return He.stored.activeAccount && (t = He.stored.activeAccount.walletId), t;
})), activeWallet: Jr(vi(() => {
  let t;
  return He.activeWalletId !== null && He.enabledWallets !== null && (t = He.enabledWallets[He.activeWalletId]), t;
})), isSigning: Jr(vi(() => {
  let t = false;
  if (He.enabledWallets) {
    for (let [e, r] of Object.entries(He.enabledWallets))
      if (r.signing) {
        t = true;
        break;
      }
  }
  return t;
})) }), V8 = Ut(() => {
  Bn.log("recallState"), Em() && Ut(() => {
    Bn.log("initLocalStorage");
    try {
      let t = localStorage.getItem(C8);
      if (t)
        try {
          let e = JSON.parse(t);
          He.stored = e;
        } catch {
          console.warn("bad sLocalStorage parse");
        }
    } catch {
      console.warn("could not access localstorage");
    }
  }, "initLocalStorage")();
}, "recallState");
Bk();
U();
var Im = { LEDGER: "testnet", BASE_SERVER: "https://testnet-api.algonode.cloud", INDEX_SERVER: "https://testnet-idx.algonode.cloud", API_TOKEN: "", PORT: "" }, Y8 = { LEDGER: "mainnet", BASE_SERVER: "https://mainnet-api.algonode.cloud", INDEX_SERVER: "https://mainnet-idx.algonode.cloud", API_TOKEN: "", PORT: "" }, Tm = Im;
U();
var Fm = { disableLogs: true };
U();
var Wt = { enabled: false, log(...t) {
  !this.enabled || console.log(...t);
}, debug(...t) {
  !this.enabled || console.debug(...t);
} };
var Rm = null, km = class {
  constructor(e) {
    __publicField(this, "algodClient");
    __publicField(this, "indexerClient");
    __publicField(this, "nodeConfig", Tm);
    __publicField(this, "libConfig", Fm);
    __publicField(this, "sdk", tm);
    __publicField(this, "walletState", He);
    __publicField(this, "inkeyClientSdk", null);
    __publicField(this, "inkeyLoading", false);
    __publicField(this, "inkeyLoaded", false);
    __publicField(this, "account", null);
    this.setNodeConfig(e == null ? void 0 : e.nodeConfig), this.enableWallets(e == null ? void 0 : e.initWallets), this.setLibConfig(e == null ? void 0 : e.libConfig), this.initAcctSync();
  }
  get connectedAccounts() {
    return He.connectedAccounts;
  }
  setLibConfig(e) {
    e == null && (e = Fm), e !== void 0 && "disableLogs" in e && typeof e.disableLogs == "boolean" && (Wt.enabled = !e.disableLogs, W8(!e.disableLogs));
  }
  isValidNodeConfig(e) {
    let r = true;
    return (e == null || !e.BASE_SERVER) && (r = false), r;
  }
  setNodeConfig(e) {
    if (Wt.log("setNodeConfig", e), e == null && (e = Tm), typeof e == "string")
      if (e == "mainnet")
        e = Y8;
      else if (e == "testnet")
        e = Im;
      else
        throw new Error("bad node config string.");
    if (!this.isValidNodeConfig(e))
      throw new Error("bad node config!");
    if (typeof e > "u")
      throw new Error("node config undefined");
    this.nodeConfig = e, this.algodClient = new mo(e.API_TOKEN, e.BASE_SERVER, e.PORT), e.INDEX_SERVER ? this.indexerClient = new Io(e.API_TOKEN, e.INDEX_SERVER, e.PORT) : console.warn("No indexer configured because INDEX_SERVER was not provided.");
  }
  getNodeConfig() {
    return this.nodeConfig ? this.nodeConfig : false;
  }
  async checkStatus() {
    if (!this.getNodeConfig())
      throw new Error("No node configuration set.");
    let e = await this.algodClient.status().do();
    return Wt.log("Algorand network status: %o", e), e;
  }
  initAcctSync() {
    Rm = O8((e) => {
      Wt.log("acct changed", e), this.account = e;
    });
  }
  stopAcctSync() {
    Rm && Rm();
  }
  enableWallets(e) {
    e == null && Wt.debug(".enableWallets called without any init params."), Sm(e || {});
  }
  async mnemonicConnect(e) {
    if (!e)
      throw new Error("algonaut.mnemonicConnect: No mnemonic provided.");
    return await this.connect({ mnemonic: e });
  }
  async inkeyConnect() {
    return console.warn(".inkeyConnect is deprecated. please use .connect"), await this.connect({ inkey: true });
  }
  async inkeyDisconnect() {
    return console.warn(".inkeyDisconnect is deprecated. please use .disconnect"), await this.disconnect([Mm.INKEY]);
  }
  async inkeyShow(e) {
    (await this.getInkeyClientSdk()).show(e);
  }
  async inkeyHide() {
    (await this.getInkeyClientSdk()).hide();
  }
  async getInkeyClientSdk() {
    var _a2;
    if (Wt.log("getInkeyClientSdk"), this.inkeyClientSdk !== null)
      return this.inkeyLoaded = true, this.inkeyClientSdk;
    {
      let e = (_a2 = this.walletState.enabledWallets) == null ? void 0 : _a2.inkey;
      if (!e)
        throw console.warn("Inkey wallet not enabled by dev"), new Error("Inkey wallet not enabled by dev");
      this.inkeyLoading = true, await e.loadClient(), this.inkeyLoading = false;
      let r = e.client.sdk;
      return r.frameBus.ready == false && (Wt.debug("inkeySdk FrameBus not yet ready..."), await r.frameBus.isReady(), Wt.debug("inkeySdk FrameBus IS ready.")), this.inkeyLoaded = true, this.inkeyClientSdk = r, this.inkeyClientSdk;
    }
  }
  async connect(e) {
    if (e !== void 0) {
      let r = Object.entries(e);
      if (r.length == 1) {
        let i = r[0][0], n = r[0][1], s2 = He.allWallets[i];
        if (Wt.debug("connect: ", i, n), s2 !== void 0)
          return (He.enabledWallets == null || !He.enabledWallets[i]) && Sm(e), s2.initParams = n, await s2.connect();
        throw new Error("Could not find wallet to enable");
      } else
        throw new Error("Cannot init multiple wallets at once using .connect(). To enable multiple wallets at once define initWallets params in Algonaut class instantiation.");
    } else if (He.enabledWallets) {
      let r = Object.entries(He.enabledWallets);
      if (r.length == 1) {
        let i = r[0][1];
        if (i)
          return await i.connect();
        throw new Error("Wallet wasnt initialized correctly.");
      } else
        throw new Error("Too many wallets enabled to know which to connect.");
    } else
      throw new Error("No enabled wallets to connect.");
  }
  async disconnect(e) {
    if (typeof e == null)
      if (He.enabledWallets) {
        let r = Object.entries(He.enabledWallets);
        if (r.length == 1) {
          let i = r[0][1];
          if (i) {
            if (i.isConnected)
              return Wt.log("disconnecting active wallet:", i.id), await i.disconnect();
            throw new Error("Wallet already disconnected.");
          } else
            throw new Error("Wallet wasnt initialized correctly.");
        } else
          throw new Error("Too many wallets enabled to know which to connect.");
      } else
        throw new Error("No enabled wallets to disconnect.");
    else if (typeof e == "boolean") {
      if (e == true) {
        Wt.log("disconnecting all wallets from dapp");
        for (let r of Object.keys(He.allWallets)) {
          let i = He.allWallets[r];
          if (i) {
            if (i.isConnected)
              return Wt.log("disconnecting wallet:", r), await i.disconnect();
            throw new Error("Wallet already disconnected.");
          } else
            throw new Error("Could not find wallet by id to disconnect... (shouldnt happen)");
        }
      }
    } else if (Array.isArray(e)) {
      Wt.log("disconnecting these wallets:", e);
      for (let r of e) {
        let i = He.allWallets[r];
        if (i) {
          if (i.isConnected)
            return Wt.log("disconnecting wallet:", r), await i.disconnect();
          throw new Error("Wallet already disconnected.");
        } else
          throw new Error("Could not find wallet by id to disconnect... (shouldnt happen)");
      }
    } else
      Wt.debug("this shouldnt happen... passed in a bad arg to .disconnect() ");
  }
  disconnectAll() {
    G8();
  }
  reconnect() {
    V8();
  }
  async waitForConfirmation(e, r, i = false) {
    var _a2;
    if (!e)
      throw new Error("waitForConfirmation: No transaction ID provided.");
    let n = (await this.algodClient.status().do())["last-round"], s2 = n + (r || 50), o = { status: "fail", message: "" };
    for (; n < s2; ) {
      let f = "";
      try {
        f = await this.algodClient.pendingTransactionInformation(e).do(), i && Wt.log("waiting for confirmation");
      } catch (l) {
        console.error((_a2 = l.response) == null ? void 0 : _a2.text);
      }
      if (f["confirmed-round"] !== null && f["confirmed-round"] > 0) {
        i && Wt.log("Transaction confirmed in round " + f["confirmed-round"]), o.txId = e, o.status = "success", o.message = "Transaction confirmed in round " + f["confirmed-round"];
        break;
      }
      n = (await this.algodClient.status().do())["last-round"];
    }
    return o;
  }
  generateLogicSig(e) {
    if (!e)
      throw new Error("No program string provided.");
    let r = new Uint8Array($r.Buffer.from(e, "base64"));
    return new Zi(r);
  }
  async atomicOptInAsset(e, r) {
    if (!this.walletState.activeAddress)
      throw new Error("No account set in Algonaut.");
    if (!e)
      throw new Error("No asset index provided.");
    let i = (r == null ? void 0 : r.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: md({ from: this.walletState.activeAddress, to: this.walletState.activeAddress, assetIndex: e, amount: 0, suggestedParams: i }), transactionSigner: void 0, isLogigSig: false };
  }
  async optInAsset(e, r, i) {
    if (!this.walletState.activeAddress)
      throw new Error("There was no account!");
    if (!e)
      throw new Error("No asset index provided.");
    let { transaction: n } = await this.atomicOptInAsset(e, i);
    return await this.sendTransaction(n, r);
  }
  async isOptedIntoAsset(e) {
    if (!e.account)
      throw new Error("No account provided.");
    if (!e.assetId)
      throw new Error("No asset ID provided.");
    let r = false;
    return (await this.getAccountInfo(e.account)).assets.forEach((n) => {
      n["asset-id"] == e.assetId && (r = true);
    }), r;
  }
  encodeArguments(e) {
    let r = [];
    return e.forEach((i) => {
      typeof i == "number" ? r.push(Xs(i)) : typeof i == "bigint" ? r.push(Xs(i)) : typeof i == "string" && r.push(new Uint8Array($r.Buffer.from(i)));
    }), r;
  }
  async atomicCreateAsset(e) {
    var _a2;
    if (!e.assetName)
      throw new Error("args.assetName not provided.");
    if (!e.symbol)
      throw new Error("args.symbol not provided");
    if (typeof e.decimals > "u")
      throw new Error("args.decimals not provided.");
    if (!e.amount)
      throw new Error("args.amount not provided.");
    let r = e.from || this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    e.metaBlock || (e.metaBlock = " "), e.defaultFrozen || (e.defaultFrozen = false), e.assetURL || (e.assetURL = void 0);
    let i = e.metaBlock.length;
    if (i > 1023)
      throw console.error("meta block is " + i), new Error("drat! this meta block is too long!");
    let s2 = new TextEncoder().encode(e.metaBlock), o = e.amount, f = e.manager && e.manager.length > 0 ? e.manager : r, l = e.reserve && e.reserve.length > 0 ? e.reserve : r, m3 = e.freeze && e.freeze.length > 0 ? e.freeze : r, A2 = e.clawback && e.clawback.length > 0 ? e.clawback : r, F3 = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: n0(r, s2, o, e.decimals, e.defaultFrozen, f, l, m3, A2, e.symbol, e.assetName, e.assetURL, e.assetMetadataHash, F3), transactionSigner: void 0, isLogigSig: false };
  }
  async createAsset(e, r) {
    let n = (await this.atomicCreateAsset(e)).transaction;
    try {
      let o = await this.sendTransaction(n, r), f = await this.algodClient.pendingTransactionInformation(n.txID().toString()).do();
      return o.createdIndex = f["asset-index"], o;
    } catch (s2) {
      throw Wt.log("transaction error"), Wt.log(s2), new Error(s2);
    }
  }
  async atomicDeleteAsset(e, r) {
    if (!this.walletState.activeAddress)
      throw new Error("there was no account!");
    if (!e)
      throw new Error("No assetId provided!");
    let i = new TextEncoder(), n = (r == null ? void 0 : r.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: s0(this.walletState.activeAddress, i.encode("doh!"), e, n), transactionSigner: void 0, isLogigSig: false };
  }
  async deleteAsset(e, r, i) {
    if (!e)
      throw new Error("No asset ID provided!");
    let { transaction: n } = await this.atomicDeleteAsset(e, i);
    return await this.sendTransaction(n, r);
  }
  async atomicSendAsset(e) {
    var _a2;
    if (!e.to)
      throw new Error("No to address provided");
    if (!Zn(e.to))
      throw new Error("Invalid to address");
    if (!e.assetIndex)
      throw new Error("No asset index provided");
    if (!(typeof e.amount == "bigint" || typeof e.amount == "number"))
      throw new Error("Amount has to be a number.");
    let r = e.from || this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: md({ from: r, to: e.to, amount: e.amount, assetIndex: e.assetIndex, suggestedParams: i }), transactionSigner: void 0, isLogigSig: false };
  }
  async sendAsset(e, r) {
    if (!(e.from || this.walletState.activeAddress))
      throw new Error("there is no fromAddr");
    let { transaction: n } = await this.atomicSendAsset(e);
    return await this.sendTransaction(n, r);
  }
  async getAssetInfo(e) {
    if (!e)
      throw new Error("No asset ID provided");
    return await this.algodClient.getAssetByID(e).do();
  }
  async atomicOptInApp(e) {
    var _a2, _b2, _c2, _d3, _e2, _f3, _g3;
    if (!e.appIndex)
      throw new Error("No app ID provided");
    let r = this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: Kg({ from: r, appIndex: e.appIndex, suggestedParams: i, appArgs: e.appArgs ? this.encodeArguments(e.appArgs) : void 0, accounts: ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) ? (_c2 = e.optionalFields) == null ? void 0 : _c2.accounts : void 0, foreignApps: ((_d3 = e.optionalFields) == null ? void 0 : _d3.applications) ? (_e2 = e.optionalFields) == null ? void 0 : _e2.applications : void 0, foreignAssets: ((_f3 = e.optionalFields) == null ? void 0 : _f3.assets) ? (_g3 = e.optionalFields) == null ? void 0 : _g3.assets : void 0 }), transactionSigner: void 0, isLogigSig: false };
  }
  async optInApp(e, r) {
    let { transaction: i } = await this.atomicOptInApp(e);
    return await this.sendTransaction(i, r);
  }
  async atomicDeleteApp(e, r) {
    if (!e)
      throw new Error("No app ID provided");
    let i = this.walletState.activeAddress;
    if (!i)
      throw new Error("there is no fromAddr");
    let n = (r == null ? void 0 : r.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: a0(i, n, e), transactionSigner: void 0, isLogigSig: false };
  }
  async deleteApp(e, r, i) {
    var _a2;
    try {
      let { transaction: n } = await this.atomicDeleteApp(e, i), s2 = n.txID().toString(), o = await this.sendTransaction(n, r), l = (await this.algodClient.pendingTransactionInformation(s2).do()).txn.txn.apid;
      return { status: "success", message: "deleted app index " + l, txId: s2 };
    } catch (n) {
      throw Wt.log(n), new Error((_a2 = n.response) == null ? void 0 : _a2.text);
    }
  }
  async atomicCallApp(e) {
    var _a2, _b2, _c2, _d3, _e2;
    let r = (e == null ? void 0 : e.from) || this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    if (!e.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    let i = this.encodeArguments(e.appArgs), n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: f0({ from: r, suggestedParams: n, appIndex: e.appIndex, appArgs: i, accounts: ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) || void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) || void 0, foreignAssets: ((_d3 = e.optionalFields) == null ? void 0 : _d3.assets) || void 0, note: ((_e2 = e.optionalFields) == null ? void 0 : _e2.note) ? this.toUint8Array(e.optionalFields.note) : void 0 }), transactionSigner: void 0, isLogigSig: false };
  }
  async callApp(e, r) {
    let { transaction: i } = await this.atomicCallApp(e);
    return await this.sendTransaction(i, r);
  }
  async atomicCallAppWithLSig(e) {
    var _a2, _b2, _c2, _d3;
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    if (!e.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    let r = this.encodeArguments(e.appArgs), i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
    return { transaction: f0({ from: e.lsig.address(), suggestedParams: i, appIndex: e.appIndex, appArgs: r, accounts: ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) || void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) || void 0, foreignAssets: ((_d3 = e.optionalFields) == null ? void 0 : _d3.assets) || void 0 }), transactionSigner: e.lsig, isLogigSig: true };
  }
  async atomicCloseOutApp(e) {
    var _a2, _b2, _c2, _d3;
    let r = (e == null ? void 0 : e.from) || this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    if (!e.appIndex)
      throw new Error("Must provide appIndex");
    try {
      let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), n = this.encodeArguments(e.appArgs);
      return { transaction: Wg({ from: r, suggestedParams: i, appIndex: e.appIndex, appArgs: n, accounts: ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) || void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) || void 0, foreignAssets: ((_d3 = e.optionalFields) == null ? void 0 : _d3.assets) || void 0 }), transactionSigner: void 0, isLogigSig: false };
    } catch (i) {
      throw new Error(i);
    }
  }
  async closeOutApp(e, r) {
    let { transaction: i } = await this.atomicCloseOutApp(e);
    return await this.sendTransaction(i, r);
  }
  getAppEscrowAccount(e) {
    if (!e)
      throw new Error("No appId provided");
    return Qs(e);
  }
  async getAppInfo(e) {
    if (!e)
      throw new Error("No appId provided");
    let r = [this.algodClient.getApplicationByID(e).do()];
    this.walletState.activeAddress && r.push(this.getAppLocalState(e));
    let n = await Promise.all(r), s2 = n[0], o = n[1], f = { hasState: true, globals: [], locals: (o == null ? void 0 : o.locals) || [], creatorAddress: s2.params.creator, index: e };
    return s2.params["global-state"] && (f.globals = this.decodeStateArray(s2.params["global-state"])), f;
  }
  async createApp(e, r) {
    var _a2, _b2, _c2, _d3, _e2;
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw console.warn("drat! your note is too long!"), new Error("Your note is too long");
    let i = this.walletState.activeAddress;
    if (!i)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (!e.schema)
      throw new Error("No schema provided");
    try {
      let n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), s2 = new Uint8Array(), o = new Uint8Array();
      if (s2 = await this.compileProgram(e.tealApprovalCode), o = await this.compileProgram(e.tealClearCode), s2 && o) {
        let f = Gg({ from: i, suggestedParams: n, onComplete: hr.NoOpOC, approvalProgram: s2, clearProgram: o, numLocalInts: e.schema.localInts, numLocalByteSlices: e.schema.localBytes, numGlobalInts: e.schema.globalInts, numGlobalByteSlices: e.schema.globalBytes, appArgs: this.encodeArguments(e.appArgs), accounts: ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) ? e.optionalFields.accounts : void 0, foreignApps: ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) ? e.optionalFields.applications : void 0, foreignAssets: ((_d3 = e.optionalFields) == null ? void 0 : _d3.assets) ? e.optionalFields.assets : void 0, note: ((_e2 = e.optionalFields) == null ? void 0 : _e2.note) ? this.toUint8Array(e.optionalFields.note) : void 0 }), l = f.txID().toString(), m3 = await this.sendTransaction(f, r), A2 = await this.algodClient.pendingTransactionInformation(l).do();
        return m3.message = "Created App ID: " + A2["application-index"], m3.createdIndex = A2["application-index"], m3.meta = A2, m3.txId = l, m3;
      } else
        throw new Error("could not compile teal code");
    } catch (n) {
      throw new Error(n.message);
    }
  }
  async atomicCreateApp(e) {
    var _a2, _b2, _c2, _d3, _e2;
    let r = this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (!e.schema)
      throw new Error("No schema provided");
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    if (r)
      try {
        let i = hr.NoOpOC, n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), s2 = new Uint8Array(), o = new Uint8Array();
        if (s2 = await this.compileProgram(e.tealApprovalCode), o = await this.compileProgram(e.tealClearCode), !s2 || !o)
          throw new Error("Error: you must provide an approval program and a clear state program.");
        return { transaction: yd(r, n, i, s2, o, e.schema.localInts, e.schema.localBytes, e.schema.globalInts, e.schema.globalBytes, this.encodeArguments(e.appArgs), ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) ? e.optionalFields.accounts : void 0, ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) ? e.optionalFields.applications : void 0, ((_d3 = e.optionalFields) == null ? void 0 : _d3.assets) ? e.optionalFields.assets : void 0, ((_e2 = e.optionalFields) == null ? void 0 : _e2.note) ? this.toUint8Array(e.optionalFields.note) : void 0), transactionSigner: void 0, isLogigSig: false };
      } catch {
        throw new Error("There was an error creating the transaction");
      }
    else
      throw new Error("Algonaut.js has no account loaded!");
  }
  async deployTealWithLSig(e) {
    var _a2, _b2;
    if (e.noteText && e.noteText.length > 511)
      throw new Error("Your note is too long");
    let r = [];
    e.appArgs && e.appArgs.length && (r = this.encodeArguments(e.appArgs));
    let i = e.lsig.address(), n = hr.NoOpOC, s2 = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), o = new Uint8Array(), f = new Uint8Array();
    try {
      if (o = await this.compileProgram(e.tealApprovalCode), f = await this.compileProgram(e.tealClearCode), o && f) {
        let l = yd(i, s2, n, o, f, e.schema.localInts, e.schema.localBytes, e.schema.globalInts, e.schema.globalBytes, r, ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) || void 0), m3 = l.txID().toString(), A2 = Fo(l, e.lsig);
        await this.algodClient.sendRawTransaction(A2.blob).do();
        let F3 = await this.waitForConfirmation(m3), V = (await this.algodClient.pendingTransactionInformation(m3).do())["application-index"];
        return { status: "success", message: "created new app with id: " + V, txId: m3 };
      } else
        throw new Error("Error compiling programs.");
    } catch (l) {
      throw console.error("Error deploying contract:"), new Error(l);
    }
  }
  async atomicUpdateApp(e) {
    var _a2, _b2, _c2, _d3, _e2;
    let r = this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    if (!e.tealApprovalCode)
      throw new Error("No approval program provided");
    if (!e.tealClearCode)
      throw new Error("No clear program provided");
    if (e.optionalFields && e.optionalFields.note && e.optionalFields.note.length > 1023)
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    try {
      let i = hr.NoOpOC, n = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do(), s2 = new Uint8Array(), o = new Uint8Array();
      if (s2 = await this.compileProgram(e.tealApprovalCode), o = await this.compileProgram(e.tealClearCode), !s2 || !o)
        throw new Error("Error: you must provide an approval program and a clear state program.");
      return { transaction: o0(r, n, e.appIndex, s2, o, this.encodeArguments(e.appArgs), ((_b2 = e.optionalFields) == null ? void 0 : _b2.accounts) ? e.optionalFields.accounts : void 0, ((_c2 = e.optionalFields) == null ? void 0 : _c2.applications) ? e.optionalFields.applications : void 0, ((_d3 = e.optionalFields) == null ? void 0 : _d3.assets) ? e.optionalFields.assets : void 0, ((_e2 = e.optionalFields) == null ? void 0 : _e2.note) ? this.toUint8Array(e.optionalFields.note) : void 0), transactionSigner: void 0, isLogigSig: false };
    } catch {
      throw new Error("There was an error creating the transaction");
    }
  }
  async updateApp(e, r) {
    let { transaction: i } = await this.atomicUpdateApp(e);
    return await this.sendTransaction(i, r);
  }
  async compileProgram(e) {
    let i = new TextEncoder().encode(e), n = await this.algodClient.compile(i).do();
    return new Uint8Array($r.Buffer.from(n.result, "base64"));
  }
  async atomicSendAlgo(e) {
    var _a2, _b2;
    if (!(typeof e.amount == "bigint" || typeof e.amount == "number"))
      throw new Error("Amount has to be a number.");
    if (!e.to)
      throw new Error("You did not specify a to address");
    if (!Zn(e.to))
      throw new Error("Invalid to address");
    let r = e.from || this.walletState.activeAddress;
    if (!r)
      throw new Error("there is no fromAddr");
    if (r) {
      let i = ((_a2 = e.optionalFields) == null ? void 0 : _a2.note) ? this.toUint8Array(e.optionalFields.note) : new Uint8Array(), n = ((_b2 = e.optionalFields) == null ? void 0 : _b2.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: i0({ from: r, to: e.to, amount: e.amount, note: i, suggestedParams: n }), transactionSigner: void 0, isLogigSig: false };
    } else
      throw new Error("there is no fromAddr");
  }
  async sendAlgo(e, r) {
    let { transaction: i } = await this.atomicSendAlgo(e);
    return await this.sendTransaction(i, r);
  }
  async getAccountInfo(e) {
    if (!e)
      throw new Error("No address provided");
    return await this.algodClient.accountInformation(e).do();
  }
  async getAlgoBalance(e) {
    if (!e)
      throw new Error("No address provided");
    return (await this.algodClient.accountInformation(e).do()).amount;
  }
  async getTokenBalance(e, r) {
    if (!e)
      throw new Error("No address provided");
    if (!r)
      throw new Error("No asset index provided");
    let i = await this.algodClient.accountInformation(e).do(), n = 0;
    return i.assets.forEach((s2) => {
      s2["asset-id"] == r && (n = s2.amount);
    }), n;
  }
  async accountHasTokens(e, r) {
    return await this.getTokenBalance(e, r) > 0;
  }
  async getAppGlobalState(e) {
    if (!e)
      throw new Error("No application ID provided");
    let r = await this.getAppInfo(e);
    return r.hasState ? this.stateArrayToObject(r.globals) : {};
  }
  async getAppLocalState(e, r) {
    if (!e)
      throw new Error("No application ID provided");
    let i = { hasState: false, globals: [], locals: [], creatorAddress: "", index: e };
    if (this.walletState.activeAddress && !r && (r = this.walletState.activeAddress), r) {
      let n = await this.algodClient.accountInformation(r).do();
      for (let s2 = 0; s2 < n["apps-local-state"].length; s2++)
        if (n["apps-local-state"][s2].id == e) {
          i.hasState = true;
          for (let o = 0; o < n["apps-local-state"][s2]["key-value"].length; o++) {
            let f = n["apps-local-state"][s2]["key-value"][o], l = $r.Buffer.from(f.key, "base64").toString(), m3 = f.value.type, A2, F3 = "";
            m3 == 1 ? (A2 = $r.Buffer.from(f.value.bytes, "base64").toString(), F3 = Ue($r.Buffer.from(f.value.bytes, "base64"))) : f.value.type == 2 && (A2 = f.value.uint), i.locals.push({ key: l, value: A2 || "", address: F3 });
          }
        }
      return i;
    } else
      console.warn("Algonaut used in non-authd state, not getting local vars");
  }
  async atomicAssetTransferWithLSig(e) {
    var _a2;
    if (e.lsig) {
      let r = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: md({ from: e.lsig.address(), to: e.to, amount: e.amount, assetIndex: e.assetIndex, suggestedParams: r }), transactionSigner: e.lsig, isLogigSig: true };
    } else
      throw new Error("there is no logic sig object!");
  }
  async atomicPaymentWithLSig(e) {
    var _a2;
    if (e.lsig) {
      let r = ((_a2 = e.optionalFields) == null ? void 0 : _a2.suggestedParams) || await this.algodClient.getTransactionParams().do();
      return { transaction: i0({ from: e.lsig.address(), to: e.to, amount: e.amount, suggestedParams: r }), transactionSigner: e.lsig, isLogigSig: true };
    } else
      throw new Error("there is no account!");
  }
  normalizeTxns(e) {
    Wt.log("normalizeTxns", e);
    let r = [];
    Array.isArray(e) ? r = e : r = [e];
    let i = [];
    if (i = r.map((s2) => {
      let o = s2.transaction;
      return o == null && (o = s2), o;
    }), Wt.log("algoTxnArr", [...i]), i.length > 1 && (i = tm.assignGroupID(i), Wt.log("added group id to txn array"), i[0].group)) {
      let s2 = this.txnBuffToB64(i[0].group);
      Wt.log("gId", s2);
    }
    let n = i.map((s2) => s2.toByte());
    return Wt.log("txnBuffArr", n), n;
  }
  async signTransaction(e) {
    let r = this.normalizeTxns(e);
    Wt.log("awTxnsToSign", r);
    let i;
    try {
      i = await K8(r), Wt.log("awTxnsSigned", i);
    } catch (n) {
      throw console.warn("err signing txns..."), Wt.log(n), new Error("Error signing transactions");
    }
    return i;
  }
  async sendTransaction(e, r) {
    let i = await this.signTransaction(e);
    (r == null ? void 0 : r.onSign) && r.onSign(i);
    let n = await this.algodClient.sendRawTransaction(i).do();
    (r == null ? void 0 : r.onSend) && r.onSend(n);
    let s2 = await this.waitForConfirmation(n.txId), o = await this.algodClient.pendingTransactionInformation(n.txId).do();
    return s2.meta = o, (r == null ? void 0 : r.onConfirm) && r.onConfirm(s2), s2;
  }
  toUint8Array(e, r = "utf8") {
    return new Uint8Array($r.Buffer.from(e, r));
  }
  to8Arr(e, r = "utf8") {
    return this.toUint8Array(e, r);
  }
  stateArrayToObject(e) {
    let r = {};
    return e.forEach((i) => {
      i.key && (r[i.key] = i.value || null);
    }), r;
  }
  b64StrToHumanStr(e) {
    return $r.Buffer.from(e, "base64").toString();
  }
  fromBase64(e) {
    return this.b64StrToHumanStr(e);
  }
  valueAsAddr(e) {
    return Ue($r.Buffer.from(e, "base64"));
  }
  decodeStateArray(e) {
    let r = [];
    for (let i = 0; i < e.length; i++) {
      let n = e[i], s2 = this.b64StrToHumanStr(n.key), o = n.value.type, f, l = "";
      o == 1 ? (f = this.b64StrToHumanStr(n.value.bytes), l = this.valueAsAddr(n.value.bytes)) : n.value.type == 2 && (f = n.value.uint), r.push({ key: s2, value: f || "", address: l });
    }
    return r;
  }
  decodeBase64UnsignedTransaction(e) {
    return eo($r.Buffer.from(e, "base64"));
  }
  txnSummary(e) {
    if (e.type) {
      let r = e.to ? Ue(e.to.publicKey) : "", i = e.from ? Ue(e.from.publicKey) : "";
      if (e.type === "pay")
        return e.amount ? `Send ${Uh(e.amount)} ALGO to ${r}` : `Send 0 ALGO to ${r}`;
      if (e.type === "axfer")
        return !e.amount && r === i ? `Opt-in to asset ID ${e.assetIndex}` : `Transfer ${e.amount ? e.amount : 0} of asset ID ${e.assetIndex} to ${r}`;
      if (e.type === "acfg")
        return e.assetUnitName ? `Create asset ${e.assetName}, symbol ${e.assetUnitName}` : `Configure asset ${e.assetIndex}`;
      if (e.type === "afrz")
        return `Freeze asset ${e.assetIndex}`;
      if (e.type === "appl")
        switch (e.appOnComplete) {
          case 0:
            return `Call to application ID ${e.appIndex}`;
          case 1:
            return `Opt-in to application ID ${e.appIndex}`;
          case 2:
            return `Close out application ID ${e.appIndex}`;
          case 3:
            return `Execute clear state program of application ID ${e.appIndex}`;
          case 4:
            return `Update application ID ${e.appIndex}`;
          case 5:
            return `Delete application ID ${e.appIndex}`;
          default:
            return `Call to application ID ${e.appIndex}`;
        }
      else
        return `Transaction of type ${e.type} to ${r}`;
    } else
      return e.toString();
  }
  createWallet() {
    let e = gd();
    if (e) {
      let r = Zh(e.sk);
      return { address: e.addr, mnemonic: r };
    } else
      throw new Error("There was no account: could not create algonaut wallet!");
  }
  recoverAccount(e) {
    if (!e)
      throw new Error("No mnemonic provided.");
    try {
      let r = To(e);
      if (Zn(r == null ? void 0 : r.addr))
        return r;
      throw new Error("Not a valid mnemonic.");
    } catch (r) {
      throw console.error(r), new Error("Could not recover account from mnemonic.");
    }
  }
  txnB64ToTxnBuff(e) {
    return $r.Buffer.from(e, "base64");
  }
  txnBuffToB64(e) {
    return $r.Buffer.from(e).toString("base64");
  }
  txnToStr(e) {
    let r = e.toByte();
    return this.txnBuffToB64(r);
  }
};
$r.Buffer;
/*
* [hi-base32]{@link https://github.com/emn178/hi-base32}
*
* @version 0.5.0
* @author Chen, Yi-Cyuan [emn178@gmail.com]
* @copyright Chen, Yi-Cyuan 2015-2018
* @license MIT
*/
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const algonaut = new km();
const unsubAcctChange1 = He$1(
  (acct) => {
    console.log("outside acct changed", acct);
  }
);
const _sfc_main$1 = defineComponent({
  data() {
    return {
      walletListOpen: false,
      AnyWalletState: s,
      selectedAddrFromDropdown: s.stored.activeAccount
    };
  },
  mounted() {
    He$1(
      (acct) => {
        this.selectedAddrFromDropdown = acct;
        this.$forceUpdate();
      }
    );
    Re$1(
      () => this.$forceUpdate()
    );
    Jn();
  },
  methods: {
    getAddrFromAccount(a) {
      return a.address;
    },
    activeAddrChanged(x) {
      s.stored.activeAccount = x;
    },
    async connectInkey() {
      let accts = await En$1("inkey");
      return accts;
    },
    async connectMnemonic() {
      return await En$1("mnemonic", "123 456 789 ...");
    },
    async doTxnSimpleAlgJs() {
      console.log("doTxnSimpleAlgJs");
      let addr = s.activeAddress;
      if (!addr) {
        alert("no .to address provided");
        return;
      }
      const txn = await algonaut.atomicSendAlgo({
        amount: 1e3,
        to: addr,
        from: addr
        // .from needed IF algonaut doesnt have this.account populated
      });
      console.log("txn", txn);
      const txnArr = txn.transaction.toByte();
      try {
        let res = await bn$1([txnArr]);
        console.log("res", res);
      } catch (e) {
        console.warn(e);
      }
    },
    doUnsub() {
      console.log("doUnsub");
      unsubAcctChange1();
    }
  }
});
const Demo_vue_vue_type_style_index_0_scoped_8437e3b6_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _withScopeId = (n) => (pushScopeId("data-v-8437e3b6"), n = n(), popScopeId(), n);
const _hoisted_1 = { class: "auth-test-container" };
const _hoisted_2 = { style: { "color": "red" } };
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { key: 1 };
const _hoisted_5 = {
  key: 0,
  class: "wallet-list"
};
const _hoisted_6 = {
  key: 0,
  class: "active-account-details"
};
const _hoisted_7 = { style: { "font-weight": "bold" } };
const _hoisted_8 = { style: { "font-family": "monospace", "word-break": "break-all" } };
const _hoisted_9 = { class: "wallet-list-item" };
const _hoisted_10 = ["src"];
const _hoisted_11 = { style: { "padding": "0 1em" } };
const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { style: { "flex-grow": "1" } }, null, -1));
const _hoisted_13 = ["name"];
const _hoisted_14 = ["value"];
const _hoisted_15 = ["onClick", "disabled"];
const _hoisted_16 = ["onClick", "disabled"];
const _hoisted_17 = ["onClick"];
const _hoisted_18 = ["disabled"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createBaseVNode("header", null, [
      createBaseVNode("span", _hoisted_2, toDisplayString(_ctx.AnyWalletState.isSigning ? "(signing)" : ""), 1),
      createBaseVNode("button", {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.walletListOpen = !_ctx.walletListOpen)
      }, [
        _ctx.AnyWalletState.activeAddress ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(`${_ctx.AnyWalletState.activeAddress.substring(0, 6)}...${_ctx.AnyWalletState.activeAddress.substring(_ctx.AnyWalletState.activeAddress.length - 3)}`) + " (" + toDisplayString(_ctx.AnyWalletState.activeWalletId) + ") ", 1)) : (openBlock(), createElementBlock("span", _hoisted_4, " Connect Wallet "))
      ])
    ]),
    _ctx.walletListOpen ? (openBlock(), createElementBlock("div", _hoisted_5, [
      _ctx.AnyWalletState.stored.activeAccount ? (openBlock(), createElementBlock("div", _hoisted_6, [
        createBaseVNode("span", _hoisted_7, toDisplayString(_ctx.AnyWalletState.stored.activeAccount.name), 1),
        createBaseVNode("span", null, "(" + toDisplayString(_ctx.AnyWalletState.stored.activeAccount.walletId) + ")", 1),
        createBaseVNode("div", _hoisted_8, toDisplayString(_ctx.AnyWalletState.activeAddress), 1)
      ])) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.AnyWalletState.allWallets, (p2, key) => {
        return openBlock(), createElementBlock("div", _hoisted_9, [
          p2 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("img", {
              src: p2.metadata.icon,
              alt: "",
              style: { "width": "40px", "height": "40px" }
            }, null, 8, _hoisted_10),
            createBaseVNode("span", _hoisted_11, toDisplayString(p2.metadata.name), 1),
            _hoisted_12,
            createBaseVNode("span", null, toDisplayString(p2.initing ? "(loading)" : ""), 1),
            createBaseVNode("span", null, toDisplayString(p2.connecting ? "(connecting)" : ""), 1),
            createBaseVNode("span", null, toDisplayString(p2.signing ? "(signing)" : ""), 1),
            p2.isActive ? withDirectives((openBlock(), createElementBlock("select", {
              key: 0,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedAddrFromDropdown = $event),
              style: { "width": "100px" },
              name: `w_${key}_select`,
              id: "",
              onChange: _cache[2] || (_cache[2] = ($event) => _ctx.activeAddrChanged(_ctx.selectedAddrFromDropdown))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(p2.accounts, (a) => {
                return openBlock(), createElementBlock("option", { value: a }, toDisplayString(_ctx.getAddrFromAccount(a)) + " (" + toDisplayString(a.name) + ") ", 9, _hoisted_14);
              }), 256))
            ], 40, _hoisted_13)), [
              [vModelSelect, _ctx.selectedAddrFromDropdown]
            ]) : createCommentVNode("", true),
            p2.isConnected && !p2.isActive ? (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: ($event) => p2.setAsActiveWallet(),
              disabled: !(p2.isConnected && !p2.isActive)
            }, "set as active", 8, _hoisted_15)) : p2.isConnected ? (openBlock(), createElementBlock("button", {
              key: 2,
              onClick: ($event) => p2.disconnect(),
              disabled: !p2.isConnected
            }, "disconnect", 8, _hoisted_16)) : createCommentVNode("", true),
            createBaseVNode("button", {
              onClick: ($event) => p2.connect()
            }, "connect", 8, _hoisted_17)
          ], 64)) : createCommentVNode("", true)
        ]);
      }), 256))
    ])) : createCommentVNode("", true),
    _ctx.AnyWalletState.activeWallet !== null ? (openBlock(), createElementBlock("button", {
      key: 1,
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.doTxnSimpleAlgJs && _ctx.doTxnSimpleAlgJs(...args)),
      disabled: !(_ctx.AnyWalletState.activeWallet !== null)
    }, " sign transaction test ", 8, _hoisted_18)) : createCommentVNode("", true)
  ]);
}
const Demo = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-8437e3b6"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Demo);
    };
  }
});
const App_vue_vue_type_style_index_0_scoped_872f38e6_lang = "";
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-872f38e6"]]);
const style = "";
const app = createApp(App);
app.mount("#app");
export {
  commonjsGlobal as a,
  buffer as b,
  commonjsRequire as c,
  getAugmentedNamespace as d,
  getDefaultExportFromCjs as g,
  or as o,
  require$$0 as r
};
